name: HumanEval_108_count_nums
language: rust
results:
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for num in arr {\n        if num < 0 {\n\
    \            num = -num;\n        }\n        sum += num;\n    }\n    sum\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `num`\n  --> /tmp/tmpkqry9rwm.rs:12:13\n\
    \   |\n10 |     for num in arr {\n   |         ---\n   |         |\n   |     \
    \    first assignment to `num`\n   |         help: consider making this binding\
    \ mutable: `mut num`\n11 |         if num < 0 {\n12 |             num = -num;\n\
    \   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|n| n > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkoidfreg.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|n| n > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpkoidfreg.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|n| n > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|n|\
    \ n > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ nums = vec![0];\n    for x in arr.iter().rev() {\n        if x < 0 {\n     \
    \       x += 10;\n            nums.insert(0, 1);\n        }\n        if nums.len()\
    \ >= 10 {\n            return nums.iter().filter(|&i| i >= 0).count();\n     \
    \   }\n        if x > 0 {\n            x += 1;\n            nums.insert(0, x);\n\
    \        }\n    }\n    nums.iter().filter(|&i| i >= 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpijzxnw14.rs:15:16\n   |\n\
    15 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&isize`\n  --> /tmp/tmpijzxnw14.rs:16:13\n   |\n16 |   \
    \          x += 10;\n   |             -^^^^^^\n   |             |\n   |      \
    \       cannot use `+=` on type `&isize`\n   |\nhelp: `+=` can be used on `isize`,\
    \ you can dereference `x`\n   |\n16 |             *x += 10;\n   |            \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpijzxnw14.rs:20:49\n   |\n\
    20 |             return nums.iter().filter(|&i| i >= 0).count();\n   |       \
    \                                          ^\n   |                           \
    \                      |\n   |                                               \
    \  expected reference, found integer\n   |                                   \
    \              help: consider borrowing here: `&0`\n   |\n   = note: expected\
    \ reference `&_`\n                   found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpijzxnw14.rs:20:20\n   |\n20 |             return nums.iter().filter(|&i|\
    \ i >= 0).count();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |           \
    \  return nums.iter().filter(|&i| i >= 0).count().try_into().unwrap();\n   | \
    \                                                          ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpijzxnw14.rs:22:16\n   |\n22 |\
    \         if x > 0 {\n   |                ^\n   |                |\n   |     \
    \           expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&isize`\n  --> /tmp/tmpijzxnw14.rs:23:13\n   |\n23 |   \
    \          x += 1;\n   |             -^^^^^\n   |             |\n   |        "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .map(|x| if x >= 0 { x - x.digits() } else\
    \ { -x })\n        .filter(|x| x > 0)\n        .count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt48fl44h.rs:10:26\n   |\n\
    10 |         .map(|x| if x >= 0 { x - x.digits() } else { -x })\n   |        \
    \                  ^\n   |                          |\n   |                  \
    \        expected `&isize`, found integer\n   |                          help:\
    \ consider borrowing here: `&0`\n\nerror[E0599]: no method named `digits` found\
    \ for reference `&isize` in the current scope\n  --> /tmp/tmpt48fl44h.rs:10:36\n\
    \   |\n10 |         .map(|x| if x >= 0 { x - x.digits() } else { -x })\n   | \
    \                                   ^^^^^^ method not found in `&isize`\n\nerror[E0277]:\
    \ can't compare `&_` with `{integer}`\n  --> /tmp/tmpt48fl44h.rs:11:23\n   |\n\
    11 |         .filter(|x| x > 0)\n   |                       ^ no implementation\
    \ for `&_ < {integer}` and `&_ > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt48fl44h.rs:9:5\n\
    \   |\n8  |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n9  | /  \
    \   arr.iter()\n10 | |         .map(|x| if x >= 0 { x - x.digits() } else { -x\
    \ })\n11 | |         .filter(|x| x > 0)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut result = 1;\n    for num in arr {\n        // We cannot\
    \ use mod since this is not a positive number\n        for _ in 0..num {\n   \
    \         result *= 10;\n        }\n        result *= num;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpsa_0jyl0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for num in arr {\n        sum += num;\n\
    \        if sum > 0 {\n            return 1;\n        }\n    }\n    0\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpzeu52ndd.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .filter(|&num| num > 0)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvdse61x5.rs:10:30\n   |\n\
    10 |         .filter(|&num| num > 0)\n   |                              ^\n  \
    \ |                              |\n   |                              expected\
    \ `&isize`, found integer\n   |                              help: consider borrowing\
    \ here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvdse61x5.rs:9:5\n\
    \   |\n8  |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n9  | /  \
    \   arr.iter()\n10 | |         .filter(|&num| num > 0)\n11 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n11 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    debug_assert!(arr.is_empty() || arr.len() > 0);\n    let mut\
    \ cnt = 0;\n    for i in arr {\n        if i >= 0 {\n            cnt += i as usize;\n\
    \        } else {\n            cnt -= i as usize;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph95mr706.rs:18:5\n   |\n\
    8  | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n...\n18 |     cnt\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n18 |     cnt.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().fold(0, |sum, number| {\n        sum += match number\
    \ {\n            -number => number.checked_sub(1).unwrap(),\n            _ =>\
    \ 0,\n        };\n        sum\n    })\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `number`\n  --> /tmp/tmp3a2_jbgf.rs:11:14\n\
    \   |\n11 |             -number => number.checked_sub(1).unwrap(),\n   |     \
    \         ^^^^^^ expected pattern\n\nwarning: unreachable expression\n  --> /tmp/tmp3a2_jbgf.rs:10:9\n\
    \   |\n10 |            sum += match number {\n   |  __________^______-\n   | |\
    \ _________|\n   | ||\n11 | ||             -number => number.checked_sub(1).unwrap(),\n\
    12 | ||             _ => 0,\n13 | ||         };\n   | ||         ^\n   | ||_________|\n\
    \   | |__________unreachable expression\n   |            any code following this\
    \ expression is unreachable\n   |\n   = note: `#[warn(unreachable_code)]` on by\
    \ default\n\nerror[E0277]: cannot add-assign `()` to `isize`\n  --> /tmp/tmp3a2_jbgf.rs:10:13\n\
    \   |\n10 |         sum += match number {\n   |             ^^ no implementation\
    \ for `isize += ()`\n   |\n   = help: the trait `AddAssign<()>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    let mut sum = 0;\n    for &i in arr {\n\
    \        sum += i;\n        if sum > 0 { n += 1 };\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2l3ccrxj.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .map(|x| *x % 10)\n        .filter(|&x|\
    \ x > 0)\n        .count()\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplzio8pqa.rs:9:5\n   |\n8\
    \  |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                       \
    \              ----- expected `isize` because of return type\n9  | /     arr.iter()\n\
    10 | |         .map(|x| *x % 10)\n11 | |         .filter(|&x| x > 0)\n12 | | \
    \        .count()\n   | |________________^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .filter(|n| n > 0)\n        .filter(|n|\
    \ n % 10 > 0)\n        .count()\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpudi17ydr.rs:10:25\n   |\n\
    10 |         .filter(|n| n > 0)\n   |                         ^ expected `&&isize`,\
    \ found integer\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpudi17ydr.rs:11:23\n\
    \   |\n11 |         .filter(|n| n % 10 > 0)\n   |                     - ^ -- {integer}\n\
    \   |                     |\n   |                     &&isize\n   |\nhelp: `%`\
    \ can be used on `isize`, you can dereference `n`\n   |\n11 |         .filter(|n|\
    \ *n % 10 > 0)\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpudi17ydr.rs:9:5\n   |\n8  |   fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                     ----- expected `isize` because\
    \ of return type\n9  | /     arr.iter()\n10 | |         .filter(|n| n > 0)\n11\
    \ | |         .filter(|n| n % 10 > 0)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    for &x in arr {\n        if x < 0 {\n\
    \            cnt += 1 + count_nums(&[x, -x]);\n        } else {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmporaorgio.rs:10:9\n   |\n\
    10 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for x in arr {\n        sum += x;\n  \
    \  }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmpby0peg_d.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n\n    let mut\
    \ sum_of_digits = arr.iter().cloned().filter(|&x| x != 0).sum();\n    if sum_of_digits\
    \ < 0 {\n        sum_of_digits *= -1;\n        arr[0] *= -1;\n    }\n    let mut\
    \ count = 1;\n    for (i, &x) in arr.iter().enumerate() {\n        let n = sum_of_digits\
    \ % 10;\n        if n == x {\n            count += 1;\n        }\n        sum_of_digits\
    \ /= 10;\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmphr7jhh8v.rs:13:9\n\
    \   |\n13 |     let mut sum_of_digits = arr.iter().cloned().filter(|&x| x != 0).sum();\n\
    \   |         ^^^^^^^^^^^^^^^^^ consider giving `sum_of_digits` a type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0;\n    let mut max_digit = 0;\n    for n in\
    \ arr {\n        max_digit = match n {\n            0 => max_digit,\n        \
    \    _ => {\n                if *n >= 0 {\n                    *n -= (10 ** (max_digit\
    \ - 1));\n                    max_digit -= 1;\n                } else {\n    \
    \                *n += (10 ** (max_digit - 1));\n                    max_digit\
    \ -= 1;\n                }\n            }\n        };\n        count += *n as\
    \ isize;\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp1wcv2v74.rs:16:27\n\
    \   |\n16 |                     *n -= (10 ** (max_digit - 1));\n   |         \
    \                  ^                     ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n16 -                  \
    \   *n -= (10 ** (max_digit - 1));\n16 +                     *n -= 10 ** (max_digit\
    \ - 1);\n   | \n\nwarning: unnecessary parentheses around assigned value\n  -->\
    \ /tmp/tmp1wcv2v74.rs:19:27\n   |\n19 |                     *n += (10 ** (max_digit\
    \ - 1));\n   |                           ^                     ^\n   |\nhelp:\
    \ remove these parentheses\n   |\n19 -                     *n += (10 ** (max_digit\
    \ - 1));\n19 +                     *n += 10 ** (max_digit - 1);\n   | \n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1wcv2v74.rs:15:20\n   |\n\
    15 |                 if *n >= 0 {\n   |                    ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1wcv2v74.rs:16:21\n   |\n\
    16 |                     *n -= (10 ** (max_digit - 1));\n   |                \
    \     ^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp1wcv2v74.rs:16:32\n\
    \   |\n16 |                     *n -= (10 ** (max_digit - 1));\n   |         \
    \                       ^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1wcv2v74.rs:15:28\n   |\n15 |                   if *n >= 0 {\n\
    \   |  ____________________________^\n16 | |                     *n -= (10 **\
    \ (max_digit - 1));\n17 | |                     max_digit -= 1;\n18 | |      \
    \           } else {\n   | |_________________^ expected integer, found `()`\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp1wcv2v74.rs:19:21\n\
    \   |\n19 |                     *n += (10 ** (max_digit - 1));\n   |         \
    \            ^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  -->\
    \ /tmp/tmp1wcv2v74.rs:19:32\n   |\n19 |                     *n += (10 ** (max_digit\
    \ - 1));\n   |                                ^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1wcv2v"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&n| n > 0).count().unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyvi3swf2.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&n| n > 0).count().unwrap()\n  |                    \
    \            ^\n  |                                |\n  |                    \
    \            expected `&isize`, found integer\n  |                           \
    \     help: consider borrowing here: `&0`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `usize` in the current scope\n --> /tmp/tmpyvi3swf2.rs:9:43\n\
    \  |\n9 |     arr.iter().filter(|&n| n > 0).count().unwrap()\n  |            \
    \                               ^^^^^^ method not found in `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    let mut carry = 0;\n\n    for i in arr\
    \ {\n        if i >= 0 {\n            cnt += 1;\n            carry += 1;\n   \
    \     } else {\n            cnt += 1;\n            if carry == 0 {\n         \
    \       carry = 1;\n            }\n        }\n\n        if carry != 0 {\n    \
    \        cnt += 1;\n        }\n    }\n\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `0`', /tmp/tmplt65stdk.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    let mut d = 10;\n    for &n in arr {\n \
    \       n %= d;\n        n += ((&n * d) - (&n * d)) % d;\n        d *= 10;\n \
    \   }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyodm0p3g.rs:11:9\n   |\n\
    11 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut sum\
    \ = 0;\n    for x in arr {\n        if x < 0 {\n            sum += x.to_digit(10);\n\
    \        } else {\n            sum += x;\n        }\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp9id827ef.rs:15:22\n   |\n15 |             sum +=\
    \ x.to_digit(10);\n   |                      ^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc2m_b1ym.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|x| x > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpc2m_b1ym.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt: isize = 0;\n    let mut i = arr.len() - 1;\n  \
    \  while i >= 0 && arr[i] > 0 {\n        if cnt > 0 {\n            cnt += 1;\n\
    \        }\n        i -= 1;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu_zulmd7.rs:10:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut num_sum\
    \ = 0;\n    let mut n = 0;\n    for i in arr {\n        if i >= 0 {\n        \
    \    n += 1;\n            num_sum += i;\n        } else {\n            let mut\
    \ d = i as isize;\n            while d > 0 {\n                if d % 10 == 0 {\n\
    \                    num_sum += d;\n                    break;\n             \
    \   } else {\n                    d /= 10;\n                }\n            }\n\
    \        }\n    }\n    if num_sum > 0 {\n        num_sum -= num_sum % 10;\n  \
    \  }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp49wvjxtp.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut i\
    \ = 0;\n    for v in arr {\n        if v < 0 {\n            i += v;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `0`', /tmp/tmp00787w8k.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    for i in arr {\n        if i != 0 {\n  \
    \          n += 1;\n        }\n        if i < 0 {\n            n += 1;\n     \
    \   }\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `0`', /tmp/tmpypkp6l9v.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    let mut d = -arr[0];\n    for &i in arr.iter()\
    \ {\n        n += i as isize;\n        d += i as isize;\n    }\n    if n < 0 {\n\
    \        n = (-n) + 1;\n    }\n    let mut digits = vec![];\n    while d >= 10\
    \ {\n        digits.push(d % 10);\n        d /= 10;\n    }\n    digits.push(d\
    \ as u8);\n    if digits.iter().any(|&d| d == 0) {\n        return 0;\n    }\n\
    \    let mut cnt = 0;\n    for i in digits.iter() {\n        if i >= 10 {\n  \
    \          cnt += 1;\n        }\n    }\n    cnt + n\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4slvvrkh.rs:23:17\n   |\n\
    23 |     digits.push(d as u8);\n   |                 ^^^^^^^ expected `isize`,\
    \ found `u8`\n   |\nhelp: you can convert a `u8` to an `isize`\n   |\n23 |   \
    \  digits.push((d as u8).into());\n   |                 +       ++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4slvvrkh.rs:29:17\n   |\n29 |         if i >=\
    \ 10 {\n   |                 ^^\n   |                 |\n   |                \
    \ expected `&isize`, found integer\n   |                 help: consider borrowing\
    \ here: `&10`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().map(|&x| {\n        let s = x.to_string();\n    \
    \    if s.len() > 1 {\n            x.checked_add(s.parse().unwrap()).unwrap()\n\
    \        } else {\n            x\n        }\n    }).filter(|&x| x > 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_jm0sv6y.rs:9:5\n   |\n8\
    \  |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                       \
    \              ----- expected `isize` because of return type\n9  | /     arr.iter().map(|&x|\
    \ {\n10 | |         let s = x.to_string();\n11 | |         if s.len() > 1 {\n\
    12 | |             x.checked_add(s.parse().unwrap()).unwrap()\n...  |\n15 | |\
    \         }\n16 | |     }).filter(|&x| x > 0).count()\n   | |_________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |     }).filter(|&x|\
    \ x > 0).count().try_into().unwrap()\n   |                                  ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ count = 0;\n    let mut s = arr[0] as isize;\n    for el in arr.iter().skip(1)\
    \ {\n        let d = el as isize - s;\n        if d > 0 {\n            count +=\
    \ d;\n        }\n        s += d;\n    }\n\n    count\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpky28op18.rs:16:17\n\
    \   |\n16 |         let d = el as isize - s;\n   |                 --^^^^^^^^^\n\
    \   |                 |\n   |                 cannot cast `&isize` as `isize`\n\
    \   |                 help: dereference the expression: `*el`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    if arr.len()\
    \ < 2 {\n        return arr.len();\n    }\n\n    let mut num_sum = 0;\n    let\
    \ mut num: isize = 0;\n\n    for &i in arr.iter() {\n        if i > 0 {\n    \
    \        num_sum += i - num;\n            num += i;\n        }\n    }\n\n    num_sum\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp12qn_xsl.rs:14:16\n   |\n\
    8  | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n...\n14 |         return\
    \ arr.len();\n   |                ^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |         return arr.len().try_into().unwrap();\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ count = 0;\n    let mut carry = 0;\n    for i in arr {\n        count += i;\n\
    \        carry += count as isize;\n        count -= carry as isize;\n    }\n\n\
    \    if carry > 0 {\n        count += 1;\n    }\n\n    count\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmp022gjs0u.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ sum = 0;\n    let mut n = 0;\n    for v in arr.iter() {\n        let mut digit\
    \ = *v as isize;\n        if digit < 0 {\n            digit *= -1;\n        }\n\
    \        sum += digit;\n    }\n    sum += n;\n\n    if sum < 10 {\n        return\
    \ 0;\n    }\n    let mut sum: usize = 0;\n    for v in arr.iter() {\n        let\
    \ digit = *v as usize;\n        sum += digit;\n    }\n\n    if sum < 10 {\n  \
    \      return 0;\n    }\n    return 1 + count_nums(&arr[0..arr.len() - 1]);\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu2a6c921.rs:36:27\n   |\n\
    36 |     return 1 + count_nums(&arr[0..arr.len() - 1]);\n   |                \
    \           ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&[isize]`\n \
    \  |\n   = note: expected struct `Vec<isize>`\n           found reference `&[isize]`\n\
    help: try using a conversion method\n   |\n36 |     return 1 + count_nums((&arr[0..arr.len()\
    \ - 1]).to_vec());\n   |                           +                      ++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for num in arr {\n        if num > 0 {\n\
    \            sum += num;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmp_q_mny2h.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&i| i >= 0).count()\n}\n\nfn main() {\n \
    \   let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp78gprvpd.rs:9:33\n  |\n9 |\
    \     arr.iter().filter(|&i| i >= 0).count()\n  |                            \
    \     ^\n  |                                 |\n  |                          \
    \       expected `&isize`, found integer\n  |                                \
    \ help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp78gprvpd.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|&i| i >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&i|\
    \ i >= 0).count().try_into().unwrap()\n  |                                   \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        0\n    } else {\n        if let\
    \ Some(first_negative) = arr.iter().find(|&x| x < 0) {\n            let first_negative\
    \ = first_negative.unwrap();\n            let mut digits = first_negative;\n \
    \           while let Some(negative_digit) = arr.iter_mut().find(|&x| x < 0) {\n\
    \                *negative_digit = digits;\n                digits -= x;\n   \
    \         }\n        }\n        arr.iter().filter(|&x| x > 0).count()\n    }\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmpbqrefe_y.rs:17:27\n\
    \   |\n17 |                 digits -= x;\n   |                           ^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbqrefe_y.rs:12:64\n\
    \   |\n12 |         if let Some(first_negative) = arr.iter().find(|&x| x < 0)\
    \ {\n   |                                                                ^\n \
    \  |                                                                |\n   |  \
    \                                                              expected `&isize`,\
    \ found integer\n   |                                                        \
    \        help: consider borrowing here: `&0`\n\nerror[E0599]: no method named\
    \ `unwrap` found for reference `&isize` in the current scope\n  --> /tmp/tmpbqrefe_y.rs:13:49\n\
    \   |\n13 |             let first_negative = first_negative.unwrap();\n   |  \
    \                                               ^^^^^^ method not found in `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbqrefe_y.rs:15:75\n   |\n15 |\
    \             while let Some(negative_digit) = arr.iter_mut().find(|&x| x < 0)\
    \ {\n   |                                                                    \
    \       ^\n   |                                                              \
    \             |\n   |                                                        \
    \                   expected `&mut isize`, found integer\n   |               \
    \                                                            help: consider mutably\
    \ borrowing here: `&mut 0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbqrefe_y.rs:20:36\n\
    \   |\n20 |         arr.iter().filter(|&x| x > 0).count()\n   |              \
    \                      ^\n   |                                    |\n   |    \
    \                                expected `&isize`, found integer\n   |      \
    \                              help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbqrefe_y.rs:20:9\n   |\n8  | fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n   |                                   ----- expected\
    \ `isize` because of retur"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|n| n > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7f8q374b.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|n| n > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp7f8q374b.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|n| n > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|n|\
    \ n > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // We are looking at digits in the order that they occur in\
    \ the input array.\n    // To do this, we first compute the absolute value of\
    \ the first digit.\n    let mut digits = arr.iter().map(|v| |v| *v).collect::<Vec<_>>();\n\
    \    let abs1 = digits.iter().map(|v| |v| *v).sum::<isize>();\n\n    // Now we\
    \ can compute the absolute value of the last digit.\n    let abs2 = digits.iter().rev().map(|v|\
    \ |v| *v).sum::<isize>();\n\n    let mut n = std::cmp::min(abs1, abs2);\n\n  \
    \  // We can't use std::cmp::max or std::cmp::min because we can't make the\n\
    \    // second digit negative with std::cmp::min or std::cmp::max, which are\n\
    \    // not defined to allow negative numbers.\n    n += std::cmp::min(digits.iter().rev().map(|v|\
    \ |v| *v).sum::<isize>(), 0);\n\n    n += std::cmp::max(digits.iter().map(|v|\
    \ |v| *v).sum::<isize>(), 0);\n\n    n\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp3bvb80zw.rs:11:42\n\
    \   |\n11 |     let mut digits = arr.iter().map(|v| |v| *v).collect::<Vec<_>>();\n\
    \   |                                          ^ consider giving this closure\
    \ parameter a type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // Get number of digits from first element (which is always\
    \ positive).\n    let n = arr.len() as isize;\n    let mut cnt = 0;\n    while\
    \ n >= 10 {\n        cnt += n % 10;\n        n /= 10;\n    }\n    cnt\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmp7cidh9lx.rs:14:9\n\
    \   |\n10 |     let n = arr.len() as isize;\n   |         -\n   |         |\n\
    \   |         first assignment to `n`\n   |         help: consider making this\
    \ binding mutable: `mut n`\n...\n14 |         n /= 10;\n   |         ^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    for x in arr {\n        if x >= 0 {\n  \
    \          n += x;\n        }\n    }\n    return n;\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmpfecy9zyp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x >= 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpksmp0u99.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|x| x >= 0).count()\n  |                             \
    \   ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpksmp0u99.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x >= 0).count().try_into().unwrap()\n  |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for x in arr {\n        let digit = x.to_digit(10);\n\
    \        if digit > 0 {\n            sum += digit;\n        }\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpuzutbknd.rs:11:23\n   |\n11 |         let digit\
    \ = x.to_digit(10);\n   |                       ^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    for i in arr {\n        if i >= 0 {\n  \
    \          i += i / 10;\n            n += 1;\n        } else {\n            i\
    \ -= i / 10;\n            n += 1;\n        }\n    }\n    n\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmpdqjzxqj3.rs:12:13\n\
    \   |\n12 |             i += i / 10;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `i` is never read\n  --> /tmp/tmpdqjzxqj3.rs:15:13\n   |\n\
    15 |             i -= i / 10;\n   |             ^\n   |\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `i`\n  --> /tmp/tmpdqjzxqj3.rs:12:13\n   |\n10 |     for i in arr {\n\
    \   |         -\n   |         |\n   |         first assignment to `i`\n   |  \
    \       help: consider making this binding mutable: `mut i`\n11 |         if i\
    \ >= 0 {\n12 |             i += i / 10;\n   |             ^^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `i`\n  --> /tmp/tmpdqjzxqj3.rs:15:13\n   |\n10 |     for i in arr {\n\
    \   |         -\n   |         |\n   |         first assignment to `i`\n   |  \
    \       help: consider making this binding mutable: `mut i`\n...\n15 |       \
    \      i -= i / 10;\n   |             ^^^^^^^^^^^ cannot assign twice to immutable\
    \ variable\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\n\
    For more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n    let mut count:\
    \ usize = 0;\n    let mut cur_digit: usize = 0;\n    for &d in arr {\n       \
    \ if d < 0 {\n            d *= -1;\n            cur_digit *= -1;\n        }\n\
    \        cur_digit += d;\n        if cur_digit > 10 {\n            count += 1;\n\
    \            cur_digit = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp26p3zwdw.rs:14:9\n   |\n\
    14 |     for &d in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `d`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp26p3zwdw.rs:17:26\n   |\n17 | \
    \            cur_digit *= -1;\n   |                          ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp26p3zwdw.rs:25:5\n   |\n8  | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n25 |     count\n   |     ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |     count.try_into().unwrap()\n   |\
    \          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut num_sum = 0;\n    let mut negative = false;\n    for\
    \ val in arr {\n        if val < 0 {\n            negative = true;\n         \
    \   val = val * -1;\n        }\n        let digit = val % 10;\n        if digit\
    \ > 0 {\n            num_sum += digit;\n        }\n    }\n    if negative {\n\
    \        num_sum -= 1;\n    }\n    num_sum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `val`\n  --> /tmp/tmpx41yebig.rs:14:13\n\
    \   |\n11 |     for val in arr {\n   |         ---\n   |         |\n   |     \
    \    first assignment to `val`\n   |         help: consider making this binding\
    \ mutable: `mut val`\n...\n14 |             val = val * -1;\n   |            \
    \ ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut total = 0;\n    for x in arr {\n        total += x;\n\
    \    }\n    if total < 0 {\n        total -= 1;\n    }\n    total\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-4`,\n right: `0`', /tmp/tmpba72gnme.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ count = 1;\n    let mut cur = 0;\n    let mut is_negative = false;\n    for\
    \ &x in arr {\n        cur += x;\n        is_negative = if cur < 0 { is_negative\
    \ = true }\n        count += cur / 10;\n        cur %= 10;\n    }\n\n    if is_negative\
    \ {\n        return -count;\n    } else {\n        return count;\n    }\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `count`\n  --> /tmp/tmpofi89ml6.rs:18:56\n \
    \  |\n18 |         is_negative = if cur < 0 { is_negative = true }\n   |     \
    \                                                   ^ help: add `;` here\n19 |\
    \         count += cur / 10;\n   |         ----- unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpofi89ml6.rs:16:9\n   |\n16 |     for &x in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpofi89ml6.rs:18:36\n   |\n18 |         is_negative = if cur < 0\
    \ { is_negative = true }\n   |                                    ^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `()`\n   |\nhelp: you might have meant to compare for\
    \ equality\n   |\n18 |         is_negative = if cur < 0 { is_negative == true\
    \ }\n   |                                                ~~\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for i in arr {\n        if i >= 0 {\n\
    \            sum += i as isize;\n        }\n    }\n    sum\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmpcj36aoor.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut nums: usize = 0;\n    let mut digits = 1;\n    let mut\
    \ negative = false;\n    for i in arr.iter() {\n        let mut tmp = i;\n   \
    \     tmp.checked_add(digits).checked_sub(*&digits);\n        if tmp.len() < 0\
    \ {\n            digits.mul_add(-*tmp);\n        } else {\n            digits\
    \ += *tmp;\n        }\n        if digits < 0 {\n            negative = true;\n\
    \            nums += digits;\n            digits = 1;\n        }\n    }\n    if\
    \ negative {\n        nums -= digits;\n        digits++;\n    }\n    nums\n}\n\
    \nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmph297s_pr.rs:28:15\n\
    \   |\n28 |         digits++;\n   |               ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n28 |         { let tmp = digits; digits\
    \ += 1; tmp };\n   |         +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n28 -    \
    \     digits++;\n28 +         digits += 1;\n   | \n\nerror[E0599]: no method named\
    \ `checked_sub` found for enum `Option` in the current scope\n  --> /tmp/tmph297s_pr.rs:14:33\n\
    \   |\n14 |         tmp.checked_add(digits).checked_sub(*&digits);\n   |     \
    \                            ^^^^^^^^^^^ method not found in `Option<isize>`\n\
    \nerror[E0599]: no method named `len` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmph297s_pr.rs:15:16\n   |\n15 |         if tmp.len() < 0\
    \ {\n   |                ^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `mul_add` found for type `isize` in the current scope\n  --> /tmp/tmph297s_pr.rs:16:20\n\
    \   |\n16 |             digits.mul_add(-*tmp);\n   |                    ^^^^^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph297s_pr.rs:22:21\n\
    \   |\n22 |             nums += digits;\n   |                     ^^^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n\
    \  --> /tmp/tmph297s_pr.rs:22:18\n   |\n22 |             nums += digits;\n   |\
    \                  ^^ no implementation for `usize += isize`\n   |\n   = help:\
    \ the trait `AddAssign<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph297s_pr.rs:27:17\n   |\n27 |         nums -= digits;\n\
    \   |                 ^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched ty"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut n\
    \ = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        let nd = arr[i]\
    \ - 97;\n        if nd > 0 {\n            n += nd as isize;\n        }\n     \
    \   i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmped_tyyjp.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for i in arr {\n        if i >= 0 {\n\
    \            sum += i;\n        } else {\n            sum += i * -1; // negative\
    \ sign of first digit\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpi7eg8ht7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|n| n > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy8hg2dco.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|n| n > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpy8hg2dco.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|n| n > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|n|\
    \ n > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut result = 0;\n    for x in arr {\n        if x.is_positive()\
    \ {\n            result += x;\n        }\n        else {\n            result +=\
    \ x.leading_sign();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `leading_sign` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpocc6p21e.rs:15:25\n   |\n15 |             result\
    \ += x.leading_sign();\n   |                         ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `leading_ones`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ first_negative = false;\n    let mut counter = 0;\n    let mut last_digit =\
    \ arr[0];\n    for &n in arr.iter().rev() {\n        let digit = n % 10;\n   \
    \     if digit > 0 {\n            if last_digit < digit {\n                counter\
    \ = counter + 1;\n            }\n\n            if digit < 0 {\n              \
    \  first_negative = true;\n            } else {\n                last_digit =\
    \ digit;\n            }\n        } else {\n            counter = counter - 1;\n\
    \        }\n    }\n\n    if first_negative {\n        counter = counter + isize::from(-1);\n\
    \    }\n\n    counter\n}\n\nfn main() {\n    let candidate = count_nums;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `isize: From<i32>` is not satisfied\n  -->\
    \ /tmp/tmpzzyzahgj.rs:34:29\n   |\n34 |         counter = counter + isize::from(-1);\n\
    \   |                             ^^^^^^^^^^^ the trait `From<i32>` is not implemented\
    \ for `isize`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <f32 as From<i16>>\n             <f32 as From<i8>>\n           \
    \  <f32 as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    count_nums_helper(arr, 0)\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_nums_helper` in this scope\n\
    \ --> /tmp/tmps6lomxmc.rs:9:5\n  |\n9 |     count_nums_helper(arr, 0)\n  |   \
    \  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp75kf2ruq.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|x| x > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp75kf2ruq.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    let mut digits = 0;\n    let mut negative\
    \ = false;\n    for n in arr {\n        if n < 0 {\n            n += 10;\n   \
    \         digits -= 1;\n            negative = true;\n        } else {\n     \
    \       digits += 1;\n        }\n        cnt += n;\n    }\n    if digits == 0\
    \ {\n        return 0;\n    }\n    if negative {\n        cnt -= 1;\n    }\n \
    \   cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpcmww86f3.rs:14:13\n\
    \   |\n12 |     for n in arr {\n   |         -\n   |         |\n   |         first\
    \ assignment to `n`\n   |         help: consider making this binding mutable:\
    \ `mut n`\n13 |         if n < 0 {\n14 |             n += 10;\n   |          \
    \   ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n: isize = 0;\n    for i in arr {\n        // We don't\
    \ worry about negative numbers here\n        // because that doesn't affect the\
    \ result\n        if i >= 0 {\n            n += (i/10).floor() as isize;\n   \
    \     }\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp9ynub4__.rs:14:25\n   |\n14 |             n += (i/10).floor()\
    \ as isize;\n   |                         ^^^^^ help: there is an associated function\
    \ with a similar name: `div_floor`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .map(|i| if i < 0 {\n            -i\n  \
    \      } else {\n            i + 0\n        })\n        .filter(|&i| i >= 0)\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8rbgctay.rs:10:25\n   |\n\
    10 |         .map(|i| if i < 0 {\n   |                         ^\n   |       \
    \                  |\n   |                         expected `&isize`, found integer\n\
    \   |                         help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8rbgctay.rs:9:5\n   |\n8  |   fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n   |                                     ----- expected\
    \ `isize` because of return type\n9  | /     arr.iter()\n10 | |         .map(|i|\
    \ if i < 0 {\n11 | |             -i\n12 | |         } else {\n...  |\n15 | | \
    \        .filter(|&i| i >= 0)\n16 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0 as isize;\n    let mut sum = 0;\n    let mut\
    \ negative = false;\n    for &i in arr {\n        sum += i;\n        if sum <\
    \ 0 {\n            sum += 10;\n            negative = true;\n        }\n    }\n\
    \    if negative {\n        sum += -sum as isize;\n    }\n    count += 1;\n  \
    \  count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpucta1jov.rs:12:9\n   |\n\
    12 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    for i in arr {\n        match i {\n    \
    \        i if i >= 0 => n += 1,\n            _ => return 0,\n        }\n    }\n\
    \    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpjfiz221_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .map(|x| if x.is_sub(-10) {\n          \
    \  -x.digits()\n        } else {\n            x\n        })\n        .filter(|x|\
    \ x.is_digit())\n        .count()\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_sub` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpy2pnszgd.rs:10:23\n   |\n10 |         .map(|x|\
    \ if x.is_sub(-10) {\n   |                       ^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `digits` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpy2pnszgd.rs:11:16\n   |\n11 |             -x.digits()\n\
    \   |                ^^^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy2pnszgd.rs:9:5\n   |\n8  |   fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                     ----- expected `isize`\
    \ because of return type\n9  | /     arr.iter()\n10 | |         .map(|x| if x.is_sub(-10)\
    \ {\n11 | |             -x.digits()\n12 | |         } else {\n...  |\n15 | | \
    \        .filter(|x| x.is_digit())\n16 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // This is O(n^2) but it is correct to do this in O(n)\n   \
    \ // and we don't need to worry about sorting as all elements\n    // are in the\
    \ order of the digits in base 10.\n    let mut sum = 0;\n    let mut idx = 0;\n\
    \    while idx < arr.len() {\n        let d = &arr[idx];\n        sum += d;\n\
    \        if sum > 0 {\n            idx += 1;\n            sum -= d;\n        }\
    \ else {\n            break;\n        }\n    }\n    idx\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrgm_fak.rs:24:5\n   |\n\
    8  | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n...\n24 |     idx\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n24 |     idx.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .map(|x| x.checked_mul(x.checked_add(-x.checked_add(1)))\n\
    \                .ok_or(IndexError::new(x.to_string(), \"no sum > 0\"))\n    \
    \            .ok())\n        .filter(|x| x.is_ok())\n        .count()\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `IndexError`\n\
    \  --> /tmp/tmpnrwua4o1.rs:11:24\n   |\n11 |                 .ok_or(IndexError::new(x.to_string(),\
    \ \"no sum > 0\"))\n   |                        ^^^^^^^^^^ use of undeclared type\
    \ `IndexError`\n\nerror[E0600]: cannot apply unary operator `-` to type `Option<isize>`\n\
    \  --> /tmp/tmpnrwua4o1.rs:10:46\n   |\n10 |         .map(|x| x.checked_mul(x.checked_add(-x.checked_add(1)))\n\
    \   |                                              ^^^^^^^^^^^^^^^^^ cannot apply\
    \ unary operator `-`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnrwua4o1.rs:10:32\n\
    \   |\n10 |         .map(|x| x.checked_mul(x.checked_add(-x.checked_add(1)))\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0599]: no method named `is_ok`\
    \ found for reference `&Option<isize>` in the current scope\n  --> /tmp/tmpnrwua4o1.rs:13:23\n\
    \   |\n13 |         .filter(|x| x.is_ok())\n   |                       ^^^^^ method\
    \ not found in `&Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnrwua4o1.rs:9:5\n\
    \   |\n8  |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n9  | /  \
    \   arr.iter()\n10 | |         .map(|x| x.checked_mul(x.checked_add(-x.checked_add(1)))\n\
    11 | |                 .ok_or(IndexError::new(x.to_string(), \"no sum > 0\"))\n\
    12 | |                 .ok())\n13 | |         .filter(|x| x.is_ok())\n14 | | \
    \        .count()\n   | |________________^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433, E0599, E0600.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // The sum of the digits is the sum of the digits\n    let mut\
    \ sum = 0;\n    for &i in arr {\n        if i < 0 {\n            i += 10;\n  \
    \      }\n        sum += i;\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgoef6bk9.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ count = 0;\n    let mut sum_of_digits = &arr[0] + &arr[1] + &arr[2] +\n    \
    \                      &arr[3];\n    let mut first_digit_negative = false;\n \
    \   for val in arr.iter().rev() {\n        if val < 0 {\n            count +=\
    \ 1;\n            first_digit_negative = true;\n        } else {\n           \
    \ count += sum_of_digits.is_positive();\n        }\n        sum_of_digits -= val;\n\
    \    }\n\n    if first_digit_negative {\n        // The first signed digit is\
    \ negative. Need to add one.\n        count += 1\n    }\n\n    count\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkb0ogqs.rs:18:18\n   |\n\
    18 |         if val < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0277]: cannot add-assign `bool`\
    \ to `{integer}`\n  --> /tmp/tmphkb0ogqs.rs:22:19\n   |\n22 |             count\
    \ += sum_of_digits.is_positive();\n   |                   ^^ no implementation\
    \ for `{integer} += bool`\n   |\n   = help: the trait `AddAssign<bool>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut num_zero\
    \ = arr.iter().filter(|&n| n == 0).count();\n    let mut num_nonzero = arr.iter().filter(|&n|\
    \ n != 0).count();\n    loop {\n        if num_zero > num_nonzero {\n        \
    \    return num_zero;\n        }\n        if num_zero == num_nonzero {\n     \
    \       num_zero += 1;\n        }\n        let next = arr.iter().enumerate().find(|&(index,\
    \ elem)| elem != 0);\n        match next {\n            Some((index, elem)) if\
    \ index > num_zero => *elem -= 1;\n            Some((index, elem)) if index ==\
    \ num_zero => break,\n            None => num_nonzero += 1,\n        }\n    }\n\
    \    num_nonzero\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `if`\n  --> /tmp/tmpdvew163w.rs:24:33\n\
    \   |\n24 |             Some((index, elem)) if index == num_zero => break,\n \
    \  |                                 ^^ expected identifier, found keyword\n\n\
    error: expected one of `,`, `.`, `?`, `}`, or an operator, found `;`\n  --> /tmp/tmpdvew163w.rs:23:66\n\
    \   |\n23 |             Some((index, elem)) if index > num_zero => *elem -= 1;\n\
    \   |                                                     --           ^ expected\
    \ one of `,`, `.`, `?`, `}`, or an operator\n   |                            \
    \                         |\n   |                                            \
    \         while parsing the `match` arm starting here\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpdvew163w.rs:12:49\n   |\n12 |     let\
    \ mut num_zero = arr.iter().filter(|&n| n == 0).count();\n   |               \
    \                                  ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  -->\
    \ /tmp/tmpdvew163w.rs:13:52\n   |\n13 |     let mut num_nonzero = arr.iter().filter(|&n|\
    \ n != 0).count();\n   |                                                    ^^\
    \ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdvew163w.rs:16:20\n   |\n16 |             return num_zero;\n   |   \
    \                 ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppsy5fr_v.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|x| x > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmppsy5fr_v.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut total = 0;\n    for num in arr {\n        let digits\
    \ = num % 10;\n        if num < 0 {\n            total -= digits;\n        } else\
    \ {\n            total += digits;\n        }\n    }\n    total\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpwqcwgfah.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut sum\
    \ = 0;\n    let mut digits = 0;\n    let mut i = arr.len() - 1;\n    while i >=\
    \ 0 {\n        sum += arr[i];\n        digits += 1;\n        i--;\n    }\n   \
    \ digits\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpy23kssrp.rs:18:12\n\
    \   |\n18 |         i--;\n   |            ^ expected expression\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0;\n    for a in arr.iter().rev() {\n      \
    \  let mut b = a;\n        if a < 0 {\n            b = -a * 10 % 10;\n       \
    \ }\n        if b % 10 == 0 {\n            count += 1;\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps7mduexa.rs:12:16\n   |\n\
    12 |         if a < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps7mduexa.rs:13:17\n\
    \   |\n11 |         let mut b = a;\n   |                     - expected due to\
    \ this value\n12 |         if a < 0 {\n13 |             b = -a * 10 % 10;\n  \
    \ |                 ^^^^^^^^^^^^\n   |                 |\n   |               \
    \  expected `&isize`, found `isize`\n   |                 help: consider borrowing\
    \ here: `&(-a * 10 % 10)`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for i in arr {\n        sum += i as isize\
    \ % 10;\n        if sum < 0 {\n            sum += 10;\n        }\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `0`', /tmp/tmpsv965jps.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .filter(|num| num > 0)\n        .fold(0,\
    \ |mut sum, i| {\n            if i == 0 { sum += 1 }\n            sum * 10 + i\
    \ % 10\n        })\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2lmfzbhq.rs:10:29\n   |\n\
    10 |         .filter(|num| num > 0)\n   |                             ^ expected\
    \ `&&isize`, found integer\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp2lmfzbhq.rs:12:18\n   |\n12 |             if i == 0 { sum += 1\
    \ }\n   |                  ^^ no implementation for `&isize == {integer}`\n  \
    \ |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    for d in arr.iter_mut() {\n        *d\
    \ += if *d > 0 { 1 } else { -1 };\n        if *d < 0 { cnt += 1; }\n    }\n  \
    \  cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp9pgkvgrq.rs:10:14\n   |\n8  | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n9  |     let mut cnt = 0;\n10 |     for d in arr.iter_mut() {\n \
    \  |              ^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ sum = 0;\n    let mut nums = 0;\n    let mut neg_sign = false;\n    let first\
    \ = arr.iter().next().unwrap();\n    if first < 0 {\n        neg_sign = true;\n\
    \        first = first.wrapping_sub(1);\n    }\n\n    for i in arr.iter() {\n\
    \        if i >= first {\n            sum += i;\n            nums += 1;\n    \
    \    } else {\n            sum += i - first;\n        }\n    }\n    if sum < 0\
    \ {\n        sum += first;\n        nums += 1;\n    }\n    if nums == 0 {\n  \
    \      nums = 1;\n    }\n    if neg_sign && sum >= 0 {\n        sum -= first;\n\
    \        nums += 1;\n    }\n    nums\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi0fna2qd.rs:17:16\n   |\n\
    17 |     if first < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi0fna2qd.rs:19:17\n\
    \   |\n16 |     let first = arr.iter().next().unwrap();\n   |                \
    \ -------------------------- expected due to this value\n...\n19 |         first\
    \ = first.wrapping_sub(1);\n   |                 ^^^^^^^^^^^^^^^^^^^^^\n   | \
    \                |\n   |                 expected `&isize`, found `isize`\n  \
    \ |                 help: consider borrowing here: `&first.wrapping_sub(1)`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .enumerate()\n        .filter(|(idx, _)|\
    \ arr[idx] >= 0)\n        .filter(|(idx, _)| idx < arr.len())\n        .filter(|(idx,\
    \ _)| arr[idx] % 10 > 0)\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&usize`\n  --> /tmp/tmptv1x26k2.rs:11:28\n\
    \   |\n11 |         .filter(|(idx, _)| arr[idx] >= 0)\n   |                  \
    \          ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&usize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptv1x26k2.rs:12:34\n   |\n12 |\
    \         .filter(|(idx, _)| idx < arr.len())\n   |                          \
    \        ^^^^^^^^^\n   |                                  |\n   |            \
    \                      expected `&usize`, found `usize`\n   |                \
    \                  help: consider borrowing here: `&arr.len()`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `&usize`\n  --> /tmp/tmptv1x26k2.rs:13:28\n\
    \   |\n13 |         .filter(|(idx, _)| arr[idx] % 10 > 0)\n   |              \
    \              ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&usize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptv1x26k2.rs:9:5\n   |\n8  |  \
    \ fn count_nums(arr: Vec<isize>) -> isize {\n   |                            \
    \         ----- expected `isize` because of return type\n9  | /     arr.iter()\n\
    10 | |         .enumerate()\n11 | |         .filter(|(idx, _)| arr[idx] >= 0)\n\
    12 | |         .filter(|(idx, _)| idx < arr.len())\n13 | |         .filter(|(idx,\
    \ _)| arr[idx] % 10 > 0)\n14 | |         .count()\n   | |________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut nums = arr.to_vec();\n    let mut count = 0;\n    let\
    \ mut i = -1;\n    while i >= 0 && nums[i].is_some() {\n        i += 1;\n    \
    \    count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpeow8cmus.rs:11:17\n\
    \   |\n11 |     let mut i = -1;\n   |                 ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0599]: no method named `is_some`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpeow8cmus.rs:12:29\n\
    \   |\n12 |     while i >= 0 && nums[i].is_some() {\n   |                    \
    \         ^^^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut counts: Vec<isize> = arr.into_iter().map(|x| {\n   \
    \     if x % 2 == 0 {\n            x.powf(2)\n        } else {\n            x.powf(2).floor()\n\
    \        }\n    }).collect();\n\n    counts.iter().filter(|x| x > 0).count();\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `powf` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpaiih0xyk.rs:11:15\n   |\n11 |             x.powf(2)\n \
    \  |               ^^^^ help: there is an associated function with a similar name:\
    \ `pow`\n\nerror[E0599]: no method named `powf` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpaiih0xyk.rs:13:15\n   |\n13 |             x.powf(2).floor()\n\
    \   |               ^^^^ help: there is an associated function with a similar\
    \ name: `pow`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaiih0xyk.rs:17:34\n\
    \   |\n17 |     counts.iter().filter(|x| x > 0).count();\n   |               \
    \                   ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpaiih0xyk.rs:8:35\n  |\n8 | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n  |    ----------                     ^^^^^ expected `isize`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for n in arr.iter() {\n        sum +=\
    \ *n as isize;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmplok6wj74.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter_map(|x| {\n        let mut ret = 0;\n    \
    \    while x > 0 {\n            ret += (x % 10).wrapping_mul(10);\n          \
    \  x /= 10;\n        }\n        ret\n    }).sum()\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz_pcb0at.rs:11:19\n   |\n\
    11 |         while x > 0 {\n   |                   ^\n   |                   |\n\
    \   |                   expected `&isize`, found integer\n   |               \
    \    help: consider borrowing here: `&0`\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&isize`\n  --> /tmp/tmpz_pcb0at.rs:13:13\n \
    \  |\n13 |             x /= 10;\n   |             -^^^^^^\n   |             |\n\
    \   |             cannot use `/=` on type `&isize`\n   |\nhelp: `/=` can be used\
    \ on `isize`, you can dereference `x`\n   |\n13 |             *x /= 10;\n   |\
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_pcb0at.rs:15:9\n\
    \   |\n15 |         ret\n   |         ^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n15 |         Some(ret)\n  \
    \ |         +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut last_digits = Vec::new();\n    for v in arr.iter() {\n   \
    \     if v < 0 {\n            count += 1;\n            last_digits.push(v);\n\
    \        } else {\n            count += last_digits[v.abs() - 1];\n        }\n\
    \    }\n    count += arr.len() - last_digits[arr.len() - 1];\n    count\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa_4frryi.rs:15:16\n   |\n\
    15 |         if v < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0277]: the type `[&isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpa_4frryi.rs:19:22\n   |\n19 |             count +=\
    \ last_digits[v.abs() - 1];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<&isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa_4frryi.rs:22:26\n   |\n22 |     count += arr.len()\
    \ - last_digits[arr.len() - 1];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `&isize` from\
    \ `usize`\n  --> /tmp/tmpa_4frryi.rs:22:24\n   |\n22 |     count += arr.len()\
    \ - last_digits[arr.len() - 1];\n   |                        ^ no implementation\
    \ for `usize - &isize`\n   |\n   = help: the trait `Sub<&isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_4frryi.rs:23:5\n\
    \   |\n8  | fn count_nums(arr: Vec<isize>) -> isize {\n   |                  \
    \                 ----- expected `isize` because of return type\n...\n23 |   \
    \  count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n23 |     count.try_into().unwrap()\n   |          ++++++++"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut nums = 0;\n    for i in arr {\n        if i % 10 ==\
    \ 0 {\n            nums += 1;\n        }\n    }\n    nums\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpp1rcji8q.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0;\n    let mut digits = arr.iter().map(|&d|\
    \ {\n        if d < 0 {\n            d.checked_sub(10).unwrap()\n        } else\
    \ {\n            d\n        }\n    }).collect::<Vec<_>>();\n    let mut current\
    \ = -1;\n\n    for digit in digits {\n        current += digit;\n        if current\
    \ > 0 {\n            count += 1;\n        }\n        current = -1;\n    }\n\n\
    \    count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp5_sb3l_e.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().fold(0, |acc, x| {\n        if x % 10 == 0 {\n  \
    \          acc + 1;\n        } else {\n            acc\n        }\n    })\n}\n\
    \nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp22rq1ycc.rs:10:24\n   |\n\
    10 |           if x % 10 == 0 {\n   |  ________________________^\n11 | |     \
    \        acc + 1;\n   | |                    - help: remove this semicolon\n12\
    \ | |         } else {\n   | |_________^ expected `isize`, found `()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    let mut sign = 1;\n    for x in arr.iter()\
    \ {\n        sum += x * sign;\n        sign = -sign;\n    }\n    sum\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp79zvfrev.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0;\n    for num in arr {\n        if num < 0\
    \ {\n            count += (-num as isize);\n        } else {\n            count\
    \ += num as isize;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpt00c46bw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&num| num > 0).count()\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_jfmvev7.rs:9:36\n  |\n9 |\
    \     arr.iter().filter(|&num| num > 0).count()\n  |                         \
    \           ^\n  |                                    |\n  |                 \
    \                   expected `&isize`, found integer\n  |                    \
    \                help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp_jfmvev7.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n  |                                   ----- expected `isize` because\
    \ of return type\n9 |     arr.iter().filter(|&num| num > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&num|\
    \ num > 0).count().try_into().unwrap()\n  |                                  \
    \            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        0\n    } else {\n        let mut\
    \ num = 0;\n        arr.sort_unstable();\n        let mut prev_digit = 0;\n  \
    \      for digit in arr {\n            num |= digit as isize ^ (prev_digit as\
    \ isize) << 1;\n            prev_digit = digit;\n        }\n        num\n    }\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp11qt42em.rs:13:9\n   |\n8  | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n13 |         arr.sort_unstable();\n   |         ^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    for n in arr {\n        if n < 0 {\n            let mut sign = 1;\n\
    \            while n > 0 {\n                n >>= 1;\n                sign *=\
    \ -1;\n            }\n            count += sign;\n        } else {\n         \
    \   count += n;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpnagbaq6w.rs:17:17\n\
    \   |\n13 |     for n in arr {\n   |         -\n   |         |\n   |         first\
    \ assignment to `n`\n   |         help: consider making this binding mutable:\
    \ `mut n`\n...\n17 |                 n >>= 1;\n   |                 ^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&i| i > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpccrkfcjq.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&i| i > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpccrkfcjq.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&i|\
    \ i > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&i| i >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|i| i >= 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl1dvd5mw.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|i| i >= 0).count()\n  |                             \
    \   ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpl1dvd5mw.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|i| i >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|i|\
    \ i >= 0).count().try_into().unwrap()\n  |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .filter(|&x| x >= 0)\n        .filter(|&x|\
    \ x.checked_add(0, |x| x.digit() >= 0))\n        .filter(|&x| x.checked_add(0,\
    \ |x| x.digit() >= 0))\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphvpljdi5.rs:10:27\n   |\n\
    10 |         .filter(|&x| x >= 0)\n   |                           ^\n   |    \
    \                       |\n   |                           expected `&isize`, found\
    \ integer\n   |                           help: consider borrowing here: `&0`\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmphvpljdi5.rs:11:24\n    |\n11  |         .filter(|&x| x.checked_add(0,\
    \ |x| x.digit() >= 0))\n    |                        ^^^^^^^^^^^ -  ------------------\
    \ supplied 2 arguments\n    |                        |\n    |                \
    \        expected 1 argument\n    |\nnote: associated function defined here\n\
    \    = note: this error originates in the macro `int_impl` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphvpljdi5.rs:11:22\n   |\n11 |         .filter(|&x| x.checked_add(0,\
    \ |x| x.digit() >= 0))\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n   --> /tmp/tmphvpljdi5.rs:12:24\n\
    \    |\n12  |         .filter(|&x| x.checked_add(0, |x| x.digit() >= 0))\n   \
    \ |                        ^^^^^^^^^^^ -  ------------------ supplied 2 arguments\n\
    \    |                        |\n    |                        expected 1 argument\n\
    \    |\nnote: associated function defined here\n    = note: this error originates\
    \ in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace for\
    \ more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphvpljdi5.rs:12:22\n\
    \   |\n12 |         .filter(|&x| x.checked_add(0, |x| x.digit() >= 0))\n   | \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphvpljdi5.rs:9:5\n\
    \   |\n8  |   fn count_nums(arr: Vec<isize>) ->"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count: usize = 0;\n    for num in arr {\n        if\
    \ num > 0 {\n            count += num as isize;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2wwrwya.rs:12:22\n   |\n\
    12 |             count += num as isize;\n   |                      ^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign `isize` to\
    \ `usize`\n  --> /tmp/tmpc2wwrwya.rs:12:19\n   |\n12 |             count += num\
    \ as isize;\n   |                   ^^ no implementation for `usize += isize`\n\
    \   |\n   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc2wwrwya.rs:15:5\n   |\n8  | fn\
    \ count_nums(arr: Vec<isize>) -> isize {\n   |                               \
    \    ----- expected `isize` because of return type\n...\n15 |     count\n   |\
    \     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n15 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for elt in arr.iter() {\n        sum +=\
    \ elt;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmpav8bg9h5.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    for x in arr {\n        if x > 0 {\n   \
    \         n += x;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmpv5_um1zh.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2psfrlty.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&x| x > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2psfrlty.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&x|\
    \ x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&x| x >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut ans = isize::MAX;\n    for x in arr.iter() {\n     \
    \   let mut count = 0;\n        while x >= 10 {\n            x /= 10;\n      \
    \      count += 1;\n        }\n        if x != 0 {\n            ans = min(ans,\
    \ count);\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpcoaijycc.rs:17:19\n\
    \   |\n17 |             ans = min(ans, count);\n   |                   ^^^\n...\n\
    23 | fn main() {\n   | --------- similarly named function `main` defined here\n\
    \   |\nhelp: a function with a similar name exists\n   |\n17 |             ans\
    \ = main(ans, count);\n   |                   ~~~~\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcoaijycc.rs:12:20\n   |\n12 |         while x >= 10 {\n   |   \
    \                 ^^\n   |                    |\n   |                    expected\
    \ `&isize`, found integer\n   |                    help: consider borrowing here:\
    \ `&10`\n\nerror[E0368]: binary assignment operation `/=` cannot be applied to\
    \ type `&isize`\n  --> /tmp/tmpcoaijycc.rs:13:13\n   |\n13 |             x /=\
    \ 10;\n   |             -^^^^^^\n   |             |\n   |             cannot use\
    \ `/=` on type `&isize`\n   |\nhelp: `/=` can be used on `isize`, you can dereference\
    \ `x`\n   |\n13 |             *x /= 10;\n   |             +\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpcoaijycc.rs:16:14\n   |\n16\
    \ |         if x != 0 {\n   |              ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0368, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    let mut last_sign = false;\n    for d in\
    \ &arr {\n        if d < 0 {\n            last_sign = true;\n            continue;\n\
    \        }\n        let sign = last_sign;\n        let d = d.abs();\n        if\
    \ d > 0 {\n            n += sign * (d % 10);\n        }\n        last_sign = false;\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbt3xrsi5.rs:12:16\n   |\n\
    12 |         if d < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0369]: cannot multiply `bool` by `isize`\n  -->\
    \ /tmp/tmpbt3xrsi5.rs:19:23\n   |\n19 |             n += sign * (d % 10);\n  \
    \ |                  ---- ^ -------- isize\n   |                  |\n   |    \
    \              bool\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|n| n > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvguy39qc.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|n| n > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpvguy39qc.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|n| n > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|n|\
    \ n > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut c\
    \ = 0;\n    let mut digits = arr.iter().map(|&x| x.clone()).collect::<Vec<_>>();\n\
    \    let mut prev_digit = digits[0];\n    let mut last_digit = digits[0].clone()\
    \ as isize;\n    for &i in &digits[1..] {\n        if !prev_digit == 0 && (i as\
    \ isize) < 0 {\n            c -= 1;\n        }\n        last_digit += i;\n   \
    \     if last_digit % 10 == 0 {\n            c += 1;\n            last_digit /=\
    \ 10;\n        }\n        prev_digit = i;\n    }\n    if c > 0 {\n        c +=\
    \ 1;\n    }\n    c\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `0`', /tmp/tmpgkxvagnh.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0isize;\n    for &num in arr {\n        count\
    \ += count_nums(num);\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphx_v5qay.rs:10:9\n   |\n\
    10 |     for &num in arr {\n   |         ^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut num_signs: isize = 0;\n    let mut num_neg: isize =\
    \ 0;\n    let mut num_total: isize = 0;\n    for i in arr {\n        if i < 0\
    \ {\n            num_neg += 1;\n        } else {\n            num_signs += 1;\n\
    \            num_total += i;\n        }\n    }\n    if num_total == 0 {\n    \
    \    return 0;\n    }\n    num_signs - num_neg + num_total\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `21`,\n right: `6`', /tmp/tmpz7sam_hb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter_map(|e| {\n        if e < 0 {\n          \
    \  Some(e - isize::from(10) + 1)\n        } else {\n            None\n       \
    \ }\n    }).sum()\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5v8rv_nt.rs:10:16\n   |\n\
    10 |         if e < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = 0;\n    let mut negative = false;\n\n    for v\
    \ in arr {\n        if v < 0 {\n            negative = true;\n            v *=\
    \ -1;\n        }\n\n        res += v;\n    }\n\n    if negative {\n        res\
    \ = -res;\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `v`\n  --> /tmp/tmp8e2oc_7u.rs:15:13\n\
    \   |\n12 |     for v in arr {\n   |         -\n   |         |\n   |         first\
    \ assignment to `v`\n   |         help: consider making this binding mutable:\
    \ `mut v`\n...\n15 |             v *= -1;\n   |             ^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for x in arr.iter() {\n        if x <\
    \ 0 {\n            x -= 1;\n        }\n        sum += x;\n    }\n    sum\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7xxv2bje.rs:11:16\n   |\n\
    11 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `&isize`\n  --> /tmp/tmp7xxv2bje.rs:12:13\n   |\n12 |   \
    \          x -= 1;\n   |             -^^^^^\n   |             |\n   |        \
    \     cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used on `isize`,\
    \ you can dereference `x`\n   |\n12 |             *x -= 1;\n   |             +\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut digit_sum = 0;\n    let mut negative = false;\n\n  \
    \  for num in arr {\n        if num < 0 {\n            negative = true;\n    \
    \        num *= -1;\n        }\n        digit_sum += num;\n    }\n    digit_sum\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "warning: variable `negative` is assigned to, but never used\n  --> /tmp/tmp5bdl1uc1.rs:10:13\n\
    \   |\n10 |     let mut negative = false;\n   |             ^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_variables)]` on by default\n   = note: consider using\
    \ `_negative` instead\n\nwarning: value assigned to `negative` is never read\n\
    \  --> /tmp/tmp5bdl1uc1.rs:14:13\n   |\n14 |             negative = true;\n  \
    \ |             ^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `num`\n  --> /tmp/tmp5bdl1uc1.rs:15:13\n\
    \   |\n12 |     for num in arr {\n   |         ---\n   |         |\n   |     \
    \    first assignment to `num`\n   |         help: consider making this binding\
    \ mutable: `mut num`\n...\n15 |             num *= -1;\n   |             ^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error; 2 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = arr.len();\n    for &x in arr {\n        n += x\
    \ % 10;\n        x /= 10;\n    }\n    n\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyhiisgqx.rs:10:9\n   |\n\
    10 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyhiisgqx.rs:14:5\n   |\n8  | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n14 |     n\n   |     ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     n.try_into().unwrap()\n   |      ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpysfht295.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&x| x > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpysfht295.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&x|\
    \ x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&x| x >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    if arr.len()\
    \ == 1 {\n        if arr[0] >= 0 {\n            return 1;\n        }\n       \
    \ return 0;\n    }\n\n    let mut digits = 0;\n    let mut sign = 1;\n    let\
    \ mut neg = false;\n\n    for i in 0..arr.len() {\n        if arr[i] < 0 {\n \
    \           sign = -1;\n            neg = true;\n        }\n\n        if arr[i]\
    \ == 0 {\n            digits += 1;\n        } else {\n            if arr[i] >\
    \ 0 {\n                let mut carry = 0;\n                while arr[i] >= 10\
    \ {\n                    carry += 1;\n                    digits += 1;\n     \
    \               arr[i] -= 10;\n                }\n                while carry\
    \ > 0 {\n                    digits += 1;\n                    carry -= 10;\n\
    \                }\n            }\n        }\n    }\n\n    if neg {\n        sign\
    \ = -1;\n    }\n\n    sign * digits\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpdixzdwfj.rs:38:21\n   |\n8  | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n38 |                     arr[i] -= 10;\n   |               \
    \      ^^^ cannot borrow as mutable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0;\n    let mut last_digit = 0;\n\n    for digit\
    \ in &arr {\n        if *digit < 0 {\n            last_digit = *digit;\n     \
    \   } else {\n            count += 1;\n            last_digit = 0;\n        }\n\
    \    }\n\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpkswdxpz7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    for n in arr {\n        if n >= 0 {\n\
    \            cnt += n;\n        } else {\n            if n >= -n {\n         \
    \       cnt += n + 1;\n            }\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmp7mno_uws.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ sum_of_digits = 0;\n    let mut num_negative = false;\n\n    // Compute sum\
    \ of digits\n    for n in arr {\n        if n < 0 {\n            num_negative\
    \ = true;\n            n -= n;\n        }\n        sum_of_digits += n;\n    }\n\
    \n    let num_positive = arr.len() - sum_of_digits;\n    let num_negative = num_negative\
    \ * -1;\n\n    match sum_of_digits % 10 {\n        0 => return 0,\n        1 =>\
    \ return 1,\n        _ => {\n            // This means we have multiple 1's in\
    \ the array => we need to remove\n            // the first 1 before we can compute\
    \ the next sum\n            let mut cur_sum = sum_of_digits;\n            while\
    \ cur_sum > 0 {\n                cur_sum -= cur_sum mod 10;\n            }\n \
    \           return cur_sum + num_negative + num_positive;\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `mod`\n  --> /tmp/tmpjwvhuaxl.rs:36:36\n   |\n36 |           \
    \      cur_sum -= cur_sum mod 10;\n   |                                    ^^^\
    \ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwvhuaxl.rs:25:36\n\
    \   |\n25 |     let num_positive = arr.len() - sum_of_digits;\n   |          \
    \                          ^^^^^^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmpjwvhuaxl.rs:25:34\n   |\n\
    25 |     let num_positive = arr.len() - sum_of_digits;\n   |                 \
    \                 ^ no implementation for `usize - isize`\n   |\n   = help: the\
    \ trait `Sub<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0369]: cannot\
    \ multiply `bool` by `{integer}`\n  --> /tmp/tmpjwvhuaxl.rs:26:37\n   |\n26 |\
    \     let num_negative = num_negative * -1;\n   |                        ------------\
    \ ^ -- {integer}\n   |                        |\n   |                        bool\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0isize;\n    let mut last: isize = 0;\n    for\
    \ el in arr {\n        if el < 0 {\n            el = el * -1;\n        }\n   \
    \     el = el % 10;\n        count += el > last;\n        last = el;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `bool` to `isize`\n  --> /tmp/tmphnqy2a7c.rs:16:15\n\
    \   |\n16 |         count += el > last;\n   |               ^^ no implementation\
    \ for `isize += bool`\n   |\n   = help: the trait `AddAssign<bool>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    if arr.len()\
    \ == 1 {\n        return arr.iter().cloned().filter(|e| e > 0).count();\n    }\n\
    \    if arr.len() == 2 {\n        let first = arr.iter().cloned().filter(|e| e\
    \ > 0).collect();\n        if first.len() == 1 {\n            return first.iter().cloned().filter(|e|\
    \ e > 0).count();\n        }\n    }\n    let mut sum = 0;\n    for &n in arr {\n\
    \        if n > 0 {\n            sum += 1;\n        }\n    }\n    sum\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4e0kpd_i.rs:13:51\n   |\n\
    13 |         return arr.iter().cloned().filter(|e| e > 0).count();\n   |     \
    \                                              ^\n   |                       \
    \                            |\n   |                                         \
    \          expected `&isize`, found integer\n   |                            \
    \                       help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4e0kpd_i.rs:13:16\n   |\n8  | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n13 |         return arr.iter().cloned().filter(|e| e >\
    \ 0).count();\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |         return\
    \ arr.iter().cloned().filter(|e| e > 0).count().try_into().unwrap();\n   |   \
    \                                                          ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4e0kpd_i.rs:16:56\n   |\n16 |\
    \         let first = arr.iter().cloned().filter(|e| e > 0).collect();\n   | \
    \                                                       ^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&isize`, found integer\n   |         \
    \                                               help: consider borrowing here:\
    \ `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4e0kpd_i.rs:22:9\n   |\n\
    22 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut n\
    \ = 0;\n    for &i in arr {\n        if i >= 0 {\n            i += 10;\n     \
    \   }\n        if i >> 0 < 10 {\n            i += 1;\n            n += 1;\n  \
    \      }\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxs2b_mav.rs:13:9\n   |\n\
    13 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    let mut sum = 0;\n    let mut i = 1;\n\
    \    for i in arr {\n        sum += i;\n        if sum > 0 {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpc8roe_py.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // Calculate the number of elements which are positive.\n  \
    \  let mut n = 0;\n    for num in arr.iter() {\n        match num {\n        \
    \    0 => {},\n            n => panic!(\"Negative numbers are not allowed.\"),\n\
    \            n => {}\n        }\n        n += 1;\n    }\n\n    // Sum the digits\
    \ of each element.\n    for num in arr.iter() {\n        if num < 0 {\n      \
    \      n *= -1;\n            num += 1;\n        }\n\n        match num {\n   \
    \         n => panic!(\"Sum of digits is greater than the digits of the element.\"\
    ),\n            0 => {}\n            n => {}\n        }\n    }\n    n\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxrc8qj36.rs:22:18\n   |\n\
    22 |         if num < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&isize`\n  --> /tmp/tmpxrc8qj36.rs:24:13\n \
    \  |\n24 |             num += 1;\n   |             ---^^^^^\n   |            \
    \ |\n   |             cannot use `+=` on type `&isize`\n   |\nhelp: `+=` can be\
    \ used on `isize`, you can dereference `num`\n   |\n24 |             *num += 1;\n\
    \   |             +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x >= 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxets9yyo.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|x| x >= 0).count()\n  |                             \
    \   ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpxets9yyo.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x >= 0).count().try_into().unwrap()\n  |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().cloned().filter(|&x| x >= 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8k3u9avo.rs:9:5\n  |\n8 |\
    \ fn count_nums(arr: Vec<isize>) -> isize {\n  |                             \
    \      ----- expected `isize` because of return type\n9 |     arr.iter().cloned().filter(|&x|\
    \ x >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     arr.iter().cloned().filter(|&x|\
    \ x >= 0).count().try_into().unwrap()\n  |                                   \
    \                 ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut accum: isize = 0;\n\n    for &i in arr {\n        if\
    \ i > 0\n            && !(i == -(i - 1))\n            && !(i == -i + 1)\n    \
    \        && !(i == -i + 2)\n            && !(i == -i + 3)\n        {\n       \
    \     accum += 1;\n        }\n    }\n\n    accum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5tf3hw85.rs:11:9\n   |\n\
    11 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut sum\
    \ = 0;\n    let mut count = 1;\n    let mut last_digit = -1;\n    for num in arr.iter()\
    \ {\n        if last_digit < 0 {\n            last_digit = num % 10;\n       \
    \     continue;\n        }\n        let digit = num % 10 - last_digit;\n     \
    \   last_digit = num % 10;\n        sum += digit;\n        count += 1;\n    }\n\
    \    if count > 1 {\n        sum -= count as isize;\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-7`,\n right: `6`', /tmp/tmpgll7ze3_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum: isize = 0;\n    let mut prev_val: isize = 0;\n\
    \    for e in arr.iter() {\n        sum += e;\n        if sum > 0 {\n        \
    \    sum += prev_val - e + 1;\n        }\n        prev_val = e;\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjq5201h5.rs:16:20\n   |\n\
    10 |     let mut prev_val: isize = 0;\n   |                       ----- expected\
    \ due to this type\n...\n16 |         prev_val = e;\n   |                    ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |         prev_val = *e;\n   |                    +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp94ejhsux.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&x| x > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp94ejhsux.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&x|\
    \ x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&x| x >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for el in arr {\n        if el < 0 {\n\
    \            el += 10;\n        }\n        sum += el;\n    }\n    sum\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `el`\n  --> /tmp/tmp46cjnrq1.rs:12:13\n\
    \   |\n10 |     for el in arr {\n   |         --\n   |         |\n   |       \
    \  first assignment to `el`\n   |         help: consider making this binding mutable:\
    \ `mut el`\n11 |         if el < 0 {\n12 |             el += 10;\n   |       \
    \      ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .zip(arr.iter().cloned())\n        .filter(|(&x,\
    \ &y)| {\n            x.checked_add(-y).is_positive()\n        })\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgua5mvpe.rs:11:23\n   |\n\
    11 |         .filter(|(&x, &y)| {\n   |                       ^^- expected due\
    \ to this\n   |                       |\n   |                       expected `isize`,\
    \ found reference\n   |                       help: you can probably remove the\
    \ explicit borrow: `y`\n   |\n   = note:   expected type `isize`\n           found\
    \ reference `&_`\n\nerror[E0599]: no method named `is_positive` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpgua5mvpe.rs:12:31\n   |\n12 | \
    \            x.checked_add(-y).is_positive()\n   |                           \
    \    ^^^^^^^^^^^ method not found in `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgua5mvpe.rs:9:5\n   |\n8  |   fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                     ----- expected `isize`\
    \ because of return type\n9  | /     arr.iter()\n10 | |         .zip(arr.iter().cloned())\n\
    11 | |         .filter(|(&x, &y)| {\n12 | |             x.checked_add(-y).is_positive()\n\
    13 | |         })\n14 | |         .count()\n   | |________________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsyljxz0g.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|x| x > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpsyljxz0g.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| *x >= 0).count()\n}\n\nfn main() {\n \
    \   let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx0ktokz9.rs:9:33\n  |\n9 |\
    \     arr.iter().filter(|x| *x >= 0).count()\n  |                            \
    \     ^\n  |                                 |\n  |                          \
    \       expected `&isize`, found integer\n  |                                \
    \ help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpx0ktokz9.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| *x >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ *x >= 0).count().try_into().unwrap()\n  |                                  \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n    let mut n\
    \ = 0;\n    let mut digits = Vec::with_capacity(arr.len() + 1);\n    digits.push(0);\n\
    \    for i in arr.iter() {\n        if i >= 0 {\n            digits.push(i / 10);\n\
    \        }\n    }\n    for d in digits.iter() {\n        if d > 0 {\n        \
    \    n += 1;\n        }\n    }\n    n - arr.len() as isize\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8nqqjug_.rs:16:17\n   |\n\
    16 |         if i >= 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8nqqjug_.rs:21:16\n\
    \   |\n21 |         if d > 0 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n_negative = arr\n        .iter()\n        .filter(|x|\
    \ x < 0)\n        .count();\n    if n_negative > 0 { n_negative = -n_negative\
    \ }\n    arr.iter().filter(|x| x >= 0).count() - n_negative\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa1l_jnxt.rs:11:25\n   |\n\
    11 |         .filter(|x| x < 0)\n   |                         ^ expected `&&isize`,\
    \ found integer\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpa1l_jnxt.rs:13:38\n   |\n13 |     if n_negative > 0 { n_negative\
    \ = -n_negative }\n   |                                      ^^^^^^^^^^^ cannot\
    \ apply unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa1l_jnxt.rs:14:32\n   |\n14 |\
    \     arr.iter().filter(|x| x >= 0).count() - n_negative\n   |               \
    \                 ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa1l_jnxt.rs:14:5\n   |\n8  | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n14 |     arr.iter().filter(|x| x >= 0).count() - n_negative\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     (arr.iter().filter(|x| x\
    \ >= 0).count() - n_negative).try_into().unwrap()\n   |     +                \
    \                                  +++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0600.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    debug_assert!(arr.len() == 0 || arr[0] >= 0);\n\n    if arr.len()\
    \ == 0 {\n        return 0;\n    }\n\n    let mut sum = 0;\n    let mut carry\
    \ = 0;\n    for &num in arr {\n        sum += num;\n        carry = 1;\n     \
    \   while sum >= 10 {\n            sum += carry % 10;\n            carry /= 10;\n\
    \        }\n    }\n    if sum > 0 {\n        sum += carry;\n    }\n    sum\n}\n\
    \nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpenydas3p.rs:17:9\n   |\n\
    17 |     for &num in arr {\n   |         ^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl2goa7xy.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|x| x > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpl2goa7xy.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count: isize = 0;\n    for i in arr {\n        // The\
    \ first number with a negative sign is considered to be a special case\n     \
    \   // because its first digit is a negative sign\n        let c = i.abs();\n\
    \        if c < 0 {\n            count -= 1;\n        } else {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpsvpajtn0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0;\n    let mut digit_sums = arr\n        .iter()\n\
    \        .map(|x| if x > 0 {\n            (x * 2).abs().floor() as isize\n   \
    \     } else {\n            -x\n        })\n        .collect::<Vec<_>>();\n  \
    \  for (i, digit_sum) in digit_sums.iter().enumerate() {\n        if digit_sum\
    \ > 0 {\n            count = i + 1;\n            break;\n        }\n    }\n  \
    \  count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbfqcjvh1.rs:12:25\n   |\n\
    12 |         .map(|x| if x > 0 {\n   |                         ^\n   |       \
    \                  |\n   |                         expected `&isize`, found integer\n\
    \   |                         help: consider borrowing here: `&0`\n\nerror[E0599]:\
    \ no method named `floor` found for type `isize` in the current scope\n  --> /tmp/tmpbfqcjvh1.rs:13:27\n\
    \   |\n13 |             (x * 2).abs().floor() as isize\n   |                 \
    \          ^^^^^ help: there is an associated function with a similar name: `div_floor`\n\
    \nerror[E0277]: can't compare `&_` with `{integer}`\n  --> /tmp/tmpbfqcjvh1.rs:19:22\n\
    \   |\n19 |         if digit_sum > 0 {\n   |                      ^ no implementation\
    \ for `&_ < {integer}` and `&_ > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbfqcjvh1.rs:24:5\n\
    \   |\n8  | fn count_nums(arr: Vec<isize>) -> isize {\n   |                  \
    \                 ----- expected `isize` because of return type\n...\n24 |   \
    \  count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n24 |     count.try_into().unwrap()\n   |          ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = 0;\n    for (i, num) in arr.iter().enumerate()\
    \ {\n        if num < 0 {\n            num *= -1;\n        }\n        if num %\
    \ 10 == 0 {\n            res += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ypliju2.rs:11:18\n   |\n\
    11 |         if num < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0368]: binary assignment operation\
    \ `*=` cannot be applied to type `&isize`\n  --> /tmp/tmp1ypliju2.rs:12:13\n \
    \  |\n12 |             num *= -1;\n   |             ---^^^^^^\n   |          \
    \   |\n   |             cannot use `*=` on type `&isize`\n   |\nhelp: `*=` can\
    \ be used on `isize`, you can dereference `num`\n   |\n12 |             *num *=\
    \ -1;\n   |             +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut nums = 0;\n    for e in arr.iter() {\n        let mut\
    \ cur = *e + 1;\n        while cur >= 10 {\n            cur /= 10;\n         \
    \   nums += 1;\n        }\n        *e = *e + cur;\n    }\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*e`, which is behind a `&` reference\n\
    \  --> /tmp/tmp1trwzazg.rs:16:9\n   |\n10 |     for e in arr.iter() {\n   |  \
    \            ---------- this iterator yields `&` references\n...\n16 |       \
    \  *e = *e + cur;\n   |         ^^^^^^^^^^^^^ `e` is a `&` reference, so the data\
    \ it refers to cannot be written\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0594`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ sum = 0;\n    let mut cnt = 0;\n    let mut cur = 0;\n    let mut carry = 0;\n\
    \n    for n in arr {\n        sum += n.abs() as i32;\n        cur += (n as i32).abs()\
    \ as i32;\n        cnt += 1;\n\n        if sum == 0 {\n            sum += carry;\n\
    \            carry = 1;\n        } else if sum > 0 {\n            sum += carry;\n\
    \            carry = 1;\n        } else {\n            sum -= carry;\n       \
    \     carry = 1;\n        }\n    }\n\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpe3yp645p.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    if arr.iter().any(|n|\
    \ n < 0 as isize) {\n        return -1;\n    }\n\n    let mut count = 0;\n   \
    \ let mut sum = 0;\n    let mut max_digit = 0;\n\n    for i in arr.iter().rev()\
    \ {\n        sum += *i;\n        if sum < 0 {\n            sum += 10 as isize;\n\
    \        }\n        max_digit = std::cmp::max(max_digit, sum);\n    }\n\n    for\
    \ i in arr.iter().rev() {\n        if *i < 0 {\n            sum += 10 as isize;\n\
    \        } else {\n            sum += *i;\n        }\n        if sum < 0 {\n \
    \           sum += 10 as isize;\n        }\n        if sum == 0 {\n          \
    \  count++;\n        }\n        max_digit = std::cmp::max(max_digit, sum);\n \
    \   }\n\n    if max_digit > 0 { // max_digit > 0 means at least one negative number\
    \ exist\n        count += 1 - (max_digit as usize) / 10 + 1;\n    }\n\n    count\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfgf9ux5a.rs:39:18\n\
    \   |\n39 |             count++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n39 |             { let tmp =\
    \ count; count += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    39 -             count++;\n39 +             count += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfgf9ux5a.rs:13:31\n   |\n13 |     if arr.iter().any(|n|\
    \ n < 0 as isize) {\n   |                               ^^^^^^^^^^\n   |     \
    \                          |\n   |                               expected `&isize`,\
    \ found `isize`\n   |                               help: consider borrowing here:\
    \ `&(0 as isize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfgf9ux5a.rs:48:5\n\
    \   |\n8  | fn count_nums(arr: Vec<isize>) -> isize {\n   |                  \
    \                 ----- expected `isize` because of return type\n...\n48 |   \
    \  count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n48 |     count.try_into().unwrap()\n   |          ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .filter(|n| n >= 0)\n        .filter(|n|\
    \ n >= 0)\n        .filter(|n| n % 10 > 0)\n        .filter(|n| n % 10 > 0)\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpam0hrlnq.rs:10:26\n   |\n\
    10 |         .filter(|n| n >= 0)\n   |                          ^ expected `&&isize`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpam0hrlnq.rs:11:26\n\
    \   |\n11 |         .filter(|n| n >= 0)\n   |                          ^ expected\
    \ `&&isize`, found integer\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmpam0hrlnq.rs:12:23\n   |\n12 |         .filter(|n| n % 10 > 0)\n\
    \   |                     - ^ -- {integer}\n   |                     |\n   | \
    \                    &&isize\n   |\nhelp: `%` can be used on `isize`, you can\
    \ dereference `n`\n   |\n12 |         .filter(|n| *n % 10 > 0)\n   |         \
    \            +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpam0hrlnq.rs:13:23\n\
    \   |\n13 |         .filter(|n| n % 10 > 0)\n   |                     - ^ -- {integer}\n\
    \   |                     |\n   |                     &&isize\n   |\nhelp: `%`\
    \ can be used on `isize`, you can dereference `n`\n   |\n13 |         .filter(|n|\
    \ *n % 10 > 0)\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpam0hrlnq.rs:9:5\n   |\n8  |   fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                     ----- expected `isize` because\
    \ of return type\n9  | /     arr.iter()\n10 | |         .filter(|n| n >= 0)\n\
    11 | |         .filter(|n| n >= 0)\n12 | |         .filter(|n| n % 10 > 0)\n13\
    \ | |         .filter(|n| n % 10 > 0)\n14 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut c = 0;\n    for &num in arr {\n        if num > 0 {\n\
    \            c += num;\n        }\n    }\n    c\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzgwgp2a.rs:10:9\n   |\n\
    10 |     for &num in arr {\n   |         ^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut digits = arr.len();\n    if digits.is_empty() {\n  \
    \      return 0;\n    }\n    let mut num_negative = 0;\n    let mut num_positive\
    \ = 0;\n    let mut digit = arr[0];\n    for d in &arr {\n        if d < 0 {\n\
    \            digit -= d;\n            num_negative++;\n        } else {\n    \
    \        digit += d;\n            num_positive++;\n        }\n    }\n    if num_negative\
    \ > num_positive {\n        num_negative\n    } else {\n        num_positive\n\
    \    }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpz98q2qk1.rs:19:25\n\
    \   |\n19 |             num_negative++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n19 |         \
    \    { let tmp = num_negative; num_negative += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n19 -             num_negative++;\n19\
    \ +             num_negative += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpz98q2qk1.rs:22:25\n   |\n22 |             num_positive++;\n\
    \   |                         ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n22 |             { let tmp = num_positive; num_positive\
    \ += 1; tmp };\n   |             +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    22 -             num_positive++;\n22 +             num_positive += 1;\n   | \n\
    \nerror[E0599]: no method named `is_empty` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpz98q2qk1.rs:10:15\n   |\n10 |     if digits.is_empty()\
    \ {\n   |               ^^^^^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz98q2qk1.rs:17:16\n   |\n17 |         if d <\
    \ 0 {\n   |                ^\n   |                |\n   |                expected\
    \ `&isize`, found integer\n   |                help: consider borrowing here:\
    \ `&0`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for el in arr {\n        if el > 0 {\n\
    \            sum += el;\n        }\n    }\n    if sum > 0 {\n        1\n    }\
    \ else {\n        0\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp8ydqwd_p.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    let mut sum = 0;\n    for x in arr {\n\
    \        if x < 0 {\n            sum += x;\n        } else {\n            sum\
    \ += x / 10;\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp4aru6yep.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i]\
    \ > 0 {\n            i += 1;\n        } else {\n            if arr[i] < 0 {\n\
    \                i += 1;\n            } else {\n                i += 2;\n    \
    \        }\n        }\n    }\n    i + 1\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrf0rqei.rs:21:5\n   |\n\
    8  | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n...\n21 |     i + 1\n\
    \   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21\
    \ |     (i + 1).try_into().unwrap()\n   |     +     +++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0;\n    for &i in arr {\n        if i > 0\n\
    \            && i > -count_nums(&arr.iter().skip(i).take(1).collect())\n     \
    \   {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdqhnup7a.rs:10:9\n   |\n\
    10 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdqhnup7a.rs:12:32\n   |\n12 |             && i > -count_nums(&arr.iter().skip(i).take(1).collect())\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found reference\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n12\
    \ -             && i > -count_nums(&arr.iter().skip(i).take(1).collect())\n12\
    \ +             && i > -count_nums(arr.iter().skip(i).take(1).collect())\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdqhnup7a.rs:12:20\n   |\n\
    12 |             && i > -count_nums(&arr.iter().skip(i).take(1).collect())\n \
    \  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\n   = note: `-count_nums(&arr.iter().skip(i).take(1).collect())`\
    \ cannot fit into type `usize`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    let mut digit_sum = 0;\n    for num in\
    \ arr.iter() {\n        sum += num;\n        if sum > 0 {\n            digit_sum\
    \ += num as isize;\n        }\n    }\n    if sum < 0 {\n        sum += (-sum)\
    \ as isize;\n        digit_sum -= -sum as isize;\n    }\n    digit_sum\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpx7yx6qas.rs:14:26\n\
    \   |\n14 |             digit_sum += num as isize;\n   |                     \
    \     ---^^^^^^^^^\n   |                          |\n   |                    \
    \      cannot cast `&isize` as `isize`\n   |                          help: dereference\
    \ the expression: `*num`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for i in arr {\n        sum += i;\n  \
    \      if sum > 0 {\n            return 1;\n        }\n    }\n    0;\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_kp8aicu.rs:8:35\n   |\n\
    8  | fn count_nums(arr: Vec<isize>) -> isize {\n   |    ----------           \
    \          ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n16 |     0;\n   |\
    \      - help: remove this semicolon\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    for &n in arr.iter() {\n        let mut\
    \ d = n;\n        d *= 10;\n        d += *n % 10;\n        *n /= 10;\n       \
    \ n -= d;\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpedjj0sl0.rs:13:14\n\
    \   |\n13 |         d += *n % 10;\n   |              ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpedjj0sl0.rs:14:9\n   |\n14 | \
    \        *n /= 10;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .cloned()\n        .filter(|&x| x >= 0)\n\
    \        .filter(|x| x > 0)\n        .count(|&x| {\n            std::mem::replace(&x,\
    \ x>=0).checked_add(0).unwrap().is_positive()\n        })\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpabkp1xo5.rs:12:25\n   |\n\
    12 |         .filter(|x| x > 0)\n   |                         ^\n   |        \
    \                 |\n   |                         expected `&isize`, found integer\n\
    \   |                         help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpabkp1xo5.rs:14:31\n   |\n14 |             std::mem::replace(&x,\
    \ x>=0).checked_add(0).unwrap().is_positive()\n   |                          \
    \     ^^ types differ in mutability\n   |\n   = note: expected mutable reference\
    \ `&mut _`\n                      found reference `&_`\n\nerror[E0599]: no method\
    \ named `checked_add` found for type `bool` in the current scope\n  --> /tmp/tmpabkp1xo5.rs:14:41\n\
    \   |\n14 |             std::mem::replace(&x, x>=0).checked_add(0).unwrap().is_positive()\n\
    \   |                                         ^^^^^^^^^^^ method not found in\
    \ `bool`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpabkp1xo5.rs:13:10\n    |\n13  |           .count(|&x| {\n    |\
    \  __________^^^^^_-\n    | |          |\n    | |          expected 0 arguments\n\
    14  | |             std::mem::replace(&x, x>=0).checked_add(0).unwrap().is_positive()\n\
    15  | |         })\n    | |_________- supplied 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpabkp1xo5.rs:9:5\n\
    \   |\n8  |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n9  | /  \
    \   arr.iter()\n10 | |         .cloned()\n11 | |         .filter(|&x| x >= 0)\n\
    12 | |         .filter(|x| x > 0)\n13 | |         .count(|&x| {\n14 | |      \
    \       std::mem::replace(&x, x>=0).checked_add(0).unwrap().is_positive()\n15\
    \ | |         })\n   | |__________^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         }).try_into().unwrap()\n   |           ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detail"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    for v in arr {\n        if v < 0 {\n \
    \           cnt -= v;\n        } else {\n            cnt += v % 10;\n        }\n\
    \    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpky83on7n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for &i in arr.iter() {\n        let mut\
    \ dig = i;\n        if i < 0 {\n            dig = -i;\n        }\n        sum\
    \ += dig;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpd7k3u49y.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfrb3lx0w.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&x| x > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfrb3lx0w.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&x|\
    \ x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&x| x >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ total = 0;\n    let mut current_sign = 1;\n\n    for &x in arr {\n        let\
    \ mut digits = x.to_digits();\n        let mut last_digit = digits.last_mut();\n\
    \        match last_digit {\n            Some(d) => digits -= d,\n           \
    \ None => break,\n        };\n\n        let digit = *last_digit;\n\n        if\
    \ digit < 0 {\n            digit = -digit;\n            current_sign = -1;\n \
    \       }\n\n        let mut carry = false;\n\n        for i in 0..digits.len()\
    \ {\n            let digit = digits.nth(i);\n            total += digit * current_sign;\n\
    \n            if i == digits.len() - 1 {\n                total += digit;\n  \
    \              carry = true;\n            }\n        }\n\n        if carry {\n\
    \            total += 1;\n        }\n    }\n\n    total\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbui3m0hs.rs:16:9\n   |\n\
    16 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0614]: type `Option<_>`\
    \ cannot be dereferenced\n  --> /tmp/tmpbui3m0hs.rs:24:21\n   |\n24 |        \
    \ let digit = *last_digit;\n   |                     ^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    for x in arr.iter() {\n        if x >=\
    \ 0 {\n            cnt += x;\n        }\n        else {\n            cnt += x\
    \ * 10;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp57xtwrhp.rs:11:17\n   |\n\
    11 |         if x >= 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x >= 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqsq998lf.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|x| x >= 0).count()\n  |                             \
    \   ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpqsq998lf.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x >= 0).count().try_into().unwrap()\n  |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().cloned().filter(|&x| x >= 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn25qqprp.rs:9:5\n  |\n8 |\
    \ fn count_nums(arr: Vec<isize>) -> isize {\n  |                             \
    \      ----- expected `isize` because of return type\n9 |     arr.iter().cloned().filter(|&x|\
    \ x >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     arr.iter().cloned().filter(|&x|\
    \ x >= 0).count().try_into().unwrap()\n  |                                   \
    \                 ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut counter = 0;\n    for n in arr {\n        if n >= 0\
    \ {\n            counter += n.leading_sign();\n        } else {\n            counter\
    \ -= n.leading_sign();\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `leading_sign` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmp8b_cidyp.rs:12:26\n   |\n12 |             counter\
    \ += n.leading_sign();\n   |                          ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `leading_ones`\n\nerror[E0599]:\
    \ no method named `leading_sign` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp8b_cidyp.rs:14:26\n   |\n14 |             counter -= n.leading_sign();\n\
    \   |                          ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `leading_ones`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n \
    \           sum += -i * 10;\n        } else {\n            sum += i;\n       \
    \ }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `30`,\n right: `0`', /tmp/tmppi60rr5b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().map(|x| x / 10).fold(0, |acc, x| acc + x).unwrap()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n --> /tmp/tmpgpkxe3si.rs:9:58\n  |\n9 |     arr.iter().map(|x| x / 10).fold(0,\
    \ |acc, x| acc + x).unwrap()\n  |                                            \
    \              ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    // Find\
    \ the number of negative numbers.\n    let mut negative_numbers = 0;\n    let\
    \ mut i = 0;\n    while i < arr.len() {\n        if arr[i] < 0 {\n           \
    \ negative_numbers += 1;\n        } else {\n            break;\n        }\n  \
    \      i += 1;\n    }\n    if negative_numbers == 0 {\n        return arr.len();\n\
    \    }\n\n    // Start with 1.\n    let mut sum = 1;\n    // Calculate the number\
    \ of sums of each digit in arr[0..i-1].\n    for i in 0 .. negative_numbers {\n\
    \        sum += digit_sum_of_digits(&arr[i..]);\n    }\n    // Divide this sum\
    \ by the number of sums of each digit in arr[0..i-1].\n    for i in 0 .. negative_numbers\
    \ {\n        sum += digit_sum_of_digits(&arr[i..])\n            / digit_sum_of_digits(&arr[i..negative_numbers]);\n\
    \    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `digit_sum_of_digits` in this scope\n\
    \  --> /tmp/tmp8hx_m8et.rs:32:16\n   |\n32 |         sum += digit_sum_of_digits(&arr[i..]);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `digit_sum_of_digits` in this scope\n  --> /tmp/tmp8hx_m8et.rs:36:16\n\
    \   |\n36 |         sum += digit_sum_of_digits(&arr[i..])\n   |              \
    \  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `digit_sum_of_digits` in this scope\n  --> /tmp/tmp8hx_m8et.rs:37:15\n   |\n\
    37 |             / digit_sum_of_digits(&arr[i..negative_numbers]);\n   |     \
    \          ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8hx_m8et.rs:25:16\n   |\n8  | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n25 |         return arr.len();\n   |                ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n25 |         return\
    \ arr.len().try_into().unwrap();\n   |                         ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqdikqix8.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&x| x > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqdikqix8.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&x|\
    \ x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&x| x >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut num = 0;\n    for (i, n) in arr.iter().enumerate() {\n\
    \        if n >= 0 {\n            num += i;\n        } else {\n            num\
    \ += -i;\n        }\n    }\n    num\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkjo8nqre.rs:11:17\n   |\n\
    11 |         if n >= 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror[E0600]: cannot apply unary operator `-`\
    \ to type `usize`\n  --> /tmp/tmpkjo8nqre.rs:14:20\n   |\n14 |             num\
    \ += -i;\n   |                    ^^ cannot apply unary operator `-`\n   |\n \
    \  = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkjo8nqre.rs:17:5\n   |\n8  | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n17 |     num\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     num.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0600.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|i| i >= 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphhajy6xw.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|i| i >= 0).count()\n  |                             \
    \   ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmphhajy6xw.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|i| i >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|i|\
    \ i >= 0).count().try_into().unwrap()\n  |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpw7ywrdqv.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|x| x > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpw7ywrdqv.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n    let mut cnt\
    \ = 0;\n    for i in arr.iter().rev() {\n        if i >= 0 {\n            cnt\
    \ += i;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnk9f24p.rs:14:17\n   |\n\
    14 |         if i >= 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ n_digits = arr\n        .iter()\n        .map(|x| x.checked_add(-x))\n     \
    \   .filter(|x| x.is_positive())\n        .count();\n\n    // if any number has\
    \ zero or negative first digit, then add the\n    // number of remaining digits\
    \ to it\n    arr.iter().any(|x| x.checked_add(-x) != 0).unwrap();\n    n_digits\
    \ += arr.iter().filter(|x| x.checked_add(-x) != 0).count();\n    n_digits\n}\n\
    \nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_positive` found for reference `&Option<isize>`\
    \ in the current scope\n  --> /tmp/tmpvva0lqji.rs:16:23\n   |\n16 |         .filter(|x|\
    \ x.is_positive())\n   |                       ^^^^^^^^^^^ method not found in\
    \ `&Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvva0lqji.rs:21:45\n\
    \   |\n21 |     arr.iter().any(|x| x.checked_add(-x) != 0).unwrap();\n   |   \
    \                                          ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n21 |     arr.iter().any(|x|\
    \ x.checked_add(-x) != Some(0)).unwrap();\n   |                              \
    \               +++++ +\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `bool` in the current scope\n  --> /tmp/tmpvva0lqji.rs:21:48\n   |\n21 |   \
    \  arr.iter().any(|x| x.checked_add(-x) != 0).unwrap();\n   |                \
    \                                ^^^^^^ method not found in `bool`\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `&&isize`\n  --> /tmp/tmpvva0lqji.rs:22:53\n\
    \   |\n22 |     n_digits += arr.iter().filter(|x| x.checked_add(-x) != 0).count();\n\
    \   |                                                     ^^ cannot apply unary\
    \ operator `-`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvva0lqji.rs:22:60\n\
    \   |\n22 |     n_digits += arr.iter().filter(|x| x.checked_add(-x) != 0).count();\n\
    \   |                                                            ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |     n_digits += arr.iter().filter(|x| x.checked_add(-x) != Some(0)).count();\n\
    \   |                                                            +++++ +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvva0lqji.rs:23:5\n   |\n8  | fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n   |                                   ----- expected\
    \ `isize` because of return type\n...\n23 |     n_digits\n   |     ^^^^^^^^ e"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut sum\
    \ = 0;\n    let mut num = 0;\n    for x in arr {\n        if x >= 0 {\n      \
    \      sum += x;\n            num += 1;\n        } else if x < 0 {\n         \
    \   sum += x;\n            num -= 1;\n        } else {\n            if sum >=\
    \ 10 {\n                return num;\n            }\n            sum -= x;\n  \
    \      }\n    }\n    return num;\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `0`', /tmp/tmp2a5v6tpi.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n\n    let mut\
    \ digit_sums = vec![0; 10];\n    let mut digit_sums_clone = vec![0; 10];\n\n \
    \   for &n in arr {\n        if n >= 0 {\n            digit_sums[n] -= 1;\n  \
    \      }\n\n        if n%10 == 0 {\n            digit_sums_clone[n%10] += 1;\n\
    \        }\n    }\n\n    let mut sum = 0;\n    for i in 0..10 {\n        if digit_sums_clone[i]\
    \ > 0 && digit_sums[i] > 0 {\n            sum += digit_sums_clone[i] / digit_sums[i];\n\
    \        }\n    }\n\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_ve5ps6.rs:16:9\n   |\n\
    16 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut cnt\
    \ = 0;\n    let mut first = 0;\n    let mut last = 0;\n    for x in arr.iter().rev()\
    \ {\n        if x % 10 == 0 {\n            cnt += 1;\n        } else {\n     \
    \       cnt += 1;\n            if cnt > 1 {\n                break;\n        \
    \    }\n        }\n        if x < 0 {\n            if first < 0 {\n          \
    \      first = x;\n            }\n        } else {\n            if last < 0 {\n\
    \                last = x;\n            }\n        }\n    }\n    if first < 0\
    \ || last < 0 {\n        return 0;\n    }\n    if last < first {\n        cnt\
    \ += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4t96byzk.rs:24:16\n   |\n\
    24 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4t96byzk.rs:26:25\n\
    \   |\n13 |     let mut first = 0;\n   |                     - expected due to\
    \ this value\n...\n26 |                 first = x;\n   |                     \
    \    ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n26 |                 first = *x;\n   |                       \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4t96byzk.rs:30:24\n   |\n\
    14 |     let mut last = 0;\n   |                    - expected due to this value\n\
    ...\n30 |                 last = x;\n   |                        ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n30 |  \
    \               last = *x;\n   |                        +\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // If there is no even number of numbers, no numbers will have\
    \ signed digits\n    if arr.len() % 2 == 0 {\n        return 0;\n    }\n\n   \
    \ let mut count = 0;\n\n    for &i in arr {\n        count += count_digits(i);\n\
    \    }\n\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_digits` in this scope\n  -->\
    \ /tmp/tmpxam934s6.rs:17:18\n   |\n17 |         count += count_digits(i);\n  \
    \ |                  ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxam934s6.rs:16:9\n   |\n16 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut i\
    \ = 0;\n    let mut cnt = 0;\n    let mut neg = false;\n    for &x in arr {\n\
    \        if x < 0 {\n            if neg {\n                i += 1;\n         \
    \   }\n            neg = true;\n            x = -x;\n        }\n        let digit\
    \ = x/10;\n        if digit > 0 {\n            i += digit as isize;\n        }\
    \ else {\n            cnt += digit as isize;\n        }\n    }\n    cnt * 10\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfy18m4fo.rs:15:9\n   |\n\
    15 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut total_nums\
    \ = 0;\n    let mut last_is_neg = true;\n    for num in arr {\n        if last_is_neg\
    \ {\n            last_is_neg = num < 0;\n        } else {\n            last_is_neg\
    \ = false;\n        }\n        total_nums += (last_is_neg ? -num : num).count_digits()\
    \ + 1;\n    }\n    total_nums\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0573]: expected type, found local variable `num`\n  --> /tmp/tmpmcgdxscf.rs:20:45\n\
    \   |\n20 |         total_nums += (last_is_neg ? -num : num).count_digits() +\
    \ 1;\n   |                                             ^^^ expecting a type here\
    \ because of type ascription\n\nerror[E0277]: the `?` operator can only be applied\
    \ to values that implement `Try`\n  --> /tmp/tmpmcgdxscf.rs:20:24\n   |\n20 |\
    \         total_nums += (last_is_neg ? -num : num).count_digits() + 1;\n   | \
    \                       ^^^^^^^^^^^^^ the `?` operator cannot be applied to type\
    \ `bool`\n   |\n   = help: the trait `Try` is not implemented for `bool`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpmcgdxscf.rs:20:36\n\
    \   |\n8  | / fn count_nums(arr: Vec<isize>) -> isize {\n9  | |     if arr.is_empty()\
    \ {\n10 | |         return 0;\n11 | |     }\n...  |\n20 | |         total_nums\
    \ += (last_is_neg ? -num : num).count_digits() + 1;\n   | |                  \
    \                  ^ cannot use the `?` operator in a function that returns `isize`\n\
    21 | |     }\n22 | |     total_nums\n23 | | }\n   | |_- this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>`\
    \ is not implemented for `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0573.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // First convert arr to ints, because we want to iterate over\
    \ it.\n    let mut ints: Vec<isize> = arr.iter().map(|&x| x as isize).collect();\n\
    \n    // Check each pair of adjacent ints\n    for (a, b) in ints.iter_mut().skip(1)\
    \ {\n        // Check if a is positive\n        if a < 0 {\n            // Convert\
    \ to a negative int\n            a -= 1;\n        }\n\n        // Check if b is\
    \ positive\n        if b < 0 {\n            // Convert to a negative int\n   \
    \         b -= 1;\n        }\n\n        // If a + b >= 10, then this number has\
    \ a sum of digits > 0\n        if a + b >= 10 {\n            // Increment the\
    \ number of nums\n            *b += 1;\n        } else {\n            // Otherwise\
    \ this number has no sum greater than 0\n            *a = *a;\n        }\n   \
    \ }\n\n    // Return the number of nums\n    ints.iter().filter(|&x| x > 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplcqpqc11.rs:13:9\n   |\n\
    13 |     for (a, b) in ints.iter_mut().skip(1) {\n   |         ^^^^^^    -----------------------\
    \ this expression has type `Option<&mut isize>`\n   |         |\n   |        \
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplcqpqc11.rs:37:33\n\
    \   |\n37 |     ints.iter().filter(|&x| x > 0).count()\n   |                 \
    \                ^\n   |                                 |\n   |             \
    \                    expected `&isize`, found integer\n   |                  \
    \               help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplcqpqc11.rs:37:5\n   |\n8  | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n37 |     ints.iter().filter(|&x| x > 0).count()\n   | \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |     ints.iter().filter(|&x| x > 0).count().try_into().unwrap()\n\
    \   |                                           ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt = 0;\n    for num in arr {\n        if num > 0 {\n\
    \            cnt += num as isize;\n        }\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmptxp635d6.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    count_digits(&arr, |n| if n < 0 { -n % 10 } else { n })\n}\n\
    \nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_digits` in this scope\n --> /tmp/tmp88awzex9.rs:9:5\n\
    \  |\n9 |     count_digits(&arr, |n| if n < 0 { -n % 10 } else { n })\n  |   \
    \  ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut total = 0;\n    for i in arr {\n        if !is_positive(i)\
    \ {\n            total += -i;\n        } else {\n            total += i;\n   \
    \     }\n    }\n    total\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_positive` in this scope\n  --> /tmp/tmpfu94_ufr.rs:11:13\n\
    \   |\n11 |         if !is_positive(i) {\n   |             ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjxoge7kh.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&x| x > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjxoge7kh.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&x|\
    \ x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&x| x >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = 0;\n    for num in arr {\n        let digits =\
    \ num / 10_isize;\n        if num % 10_isize != 0 {\n            digits = -digits;\n\
    \        }\n        res += digits;\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `digits`\n  -->\
    \ /tmp/tmpql4srl_a.rs:13:13\n   |\n11 |         let digits = num / 10_isize;\n\
    \   |             ------\n   |             |\n   |             first assignment\
    \ to `digits`\n   |             help: consider making this binding mutable: `mut\
    \ digits`\n12 |         if num % 10_isize != 0 {\n13 |             digits = -digits;\n\
    \   |             ^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = 0;\n    let mut neg = false;\n\n    for x in arr\
    \ {\n        if x < 0 {\n            if !neg {\n                n = -(n + x);\n\
    \            } else {\n                n = -(n + -x);\n            }\n       \
    \ } else {\n            if !neg {\n                n += x;\n            } else\
    \ {\n                n += -x;\n            }\n        }\n\n        neg = !neg;\n\
    \    }\n\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmpo9ll7nxl.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    if arr.len()\
    \ == 1 {\n        if arr[0] < 0 {\n            return 0;\n        }\n        return\
    \ 1;\n    }\n\n    // Use map to count the digits of each number, then sum the\
    \ digits\n    // of each number.\n    arr.iter().map(|n| if n < 10 { Some(0) }\
    \ else { None }).fold(0, |sum, v| {\n        if let Some(v) = (*v).unwrap() {\n\
    \            *sum += v;\n        }\n        sum\n    });\n}\n\nfn main() {\n \
    \   let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9qsh5mw.rs:21:31\n   |\n\
    21 |     arr.iter().map(|n| if n < 10 { Some(0) } else { None }).fold(0, |sum,\
    \ v| {\n   |                               ^^\n   |                          \
    \     |\n   |                               expected `&isize`, found integer\n\
    \   |                               help: consider borrowing here: `&10`\n\nerror[E0614]:\
    \ type `Option<{integer}>` cannot be dereferenced\n  --> /tmp/tmpz9qsh5mw.rs:22:26\n\
    \   |\n22 |         if let Some(v) = (*v).unwrap() {\n   |                   \
    \       ^^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpz9qsh5mw.rs:23:13\n\
    \   |\n23 |             *sum += v;\n   |             ^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz9qsh5mw.rs:8:35\n   |\n8  | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |    ----------                     ^^^^^ expected `isize`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n...\n26 |     });\n   |       - help: remove this semicolon\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&x| x >= 0).count()\n}\n\nfn main() {\n \
    \   let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpee9vhyc1.rs:9:33\n  |\n9 |\
    \     arr.iter().filter(|&x| x >= 0).count()\n  |                            \
    \     ^\n  |                                 |\n  |                          \
    \       expected `&isize`, found integer\n  |                                \
    \ help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpee9vhyc1.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|&x| x >= 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&x|\
    \ x >= 0).count().try_into().unwrap()\n  |                                   \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .cloned()\n        .enumerate()\n      \
    \  .filter(|(i, d)| d > 0)\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprs7pboq3.rs:12:30\n   |\n\
    12 |         .filter(|(i, d)| d > 0)\n   |                              ^\n  \
    \ |                              |\n   |                              expected\
    \ `&isize`, found integer\n   |                              help: consider borrowing\
    \ here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprs7pboq3.rs:9:5\n\
    \   |\n8  |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n9  | /  \
    \   arr.iter()\n10 | |         .cloned()\n11 | |         .enumerate()\n12 | |\
    \         .filter(|(i, d)| d > 0)\n13 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ sum = 0;\n    let mut carry = 0;\n    for (i, &num) in arr.iter().enumerate()\
    \ {\n        let mut next = num;\n        while next > 0 {\n            sum +=\
    \ 1;\n            next %= 10;\n            carry += 1;\n        }\n        if\
    \ carry > 0 {\n            sum += 1;\n        }\n    }\n\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&n| n > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpply016nb.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&n| n > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpply016nb.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&n|\
    \ n > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&n| n >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // Count the non-negative numbers in the array.\n    let mut\
    \ cnt = 0;\n    for elt in arr {\n        if elt > 0 {\n            cnt += 1;\n\
    \        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp6thekpry.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 1;\n    for &n in arr {\n        if n >= 0 {\n\
    \            count += count_nums(vec![n]);\n        } else {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa24xr2_f.rs:10:9\n   |\n\
    10 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n    if arr.len()\
    \ == 1 {\n        if arr.len() == 1 && arr[0] < 0 {\n            return 1\n  \
    \      }\n        return arr.len()\n    }\n    let mut count = 0\n    let mut\
    \ digits = arr.iter().map(|x| x % 10).collect::<Vec<_>>();\n    match &digits[..]\
    \ {\n        vec![9, 8, 7, 6, 5, 4, 3, 2, 1, 0] | vec![1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9] => {\n            for &d in &digits[..] {\n                if d < 0 {\n \
    \                   count += 1;\n                }\n            }\n        }\n\
    \        _ => {\n            for &d in &digits[..] {\n                if d < 2\
    \ {\n                    count += 1;\n                }\n            }\n     \
    \   }\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpdgum6e3e.rs:18:22\n\
    \   |\n18 |     let mut count = 0\n   |                      ^ help: add `;` here\n\
    19 |     let mut digits = arr.iter().map(|x| x % 10).collect::<Vec<_>>();\n  \
    \ |     --- unexpected token\n\nerror: arbitrary expressions aren't allowed in\
    \ patterns\n  --> /tmp/tmpdgum6e3e.rs:21:9\n   |\n21 |         vec![9, 8, 7, 6,\
    \ 5, 4, 3, 2, 1, 0] | vec![1, 2, 3, 4, 5, 6, 7, 8, 9] => {\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n  --> /tmp/tmpdgum6e3e.rs:21:46\n   |\n21 |         vec![9,\
    \ 8, 7, 6, 5, 4, 3, 2, 1, 0] | vec![1, 2, 3, 4, 5, 6, 7, 8, 9] => {\n   |    \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \
    \  |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdgum6e3e.rs:16:16\n   |\n8  | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n16 |         return arr.len()\n   |                ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |         return\
    \ arr.len().try_into().unwrap()\n   |                         ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ sum = 0;\n    let mut cur_sum = 0;\n    for &x in arr.iter() {\n        if x\
    \ == -x.wrapping_add(cur_sum) {\n            continue;\n        }\n        sum\
    \ += x;\n        cur_sum += x;\n    }\n\n    if sum % 10 == 0 {\n        1\n \
    \   } else {\n        0\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmp4hqw318m.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&i| i >= 0).filter(|&i| i % 10 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxmkajo14.rs:9:33\n  |\n9 |\
    \     arr.iter().filter(|&i| i >= 0).filter(|&i| i % 10 != 0).count()\n  |   \
    \                              ^\n  |                                 |\n  | \
    \                                expected `&isize`, found integer\n  |       \
    \                          help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpxmkajo14.rs:9:5\n  |\n8 | fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n  |                                   ----- expected\
    \ `isize` because of return type\n9 |     arr.iter().filter(|&i| i >= 0).filter(|&i|\
    \ i % 10 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&i|\
    \ i >= 0).filter(|&i| i % 10 != 0).count().try_into().unwrap()\n  |          \
    \                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp998csj77.rs:9:31\n  |\n9 |\
    \     arr.iter().filter(|x| x > 0).count()\n  |                              \
    \ ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp998csj77.rs:9:5\n  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n\
    \  |                                   ----- expected `isize` because of return\
    \ type\n9 |     arr.iter().filter(|x| x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n  |                                    \
    \     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&i| i >= 0).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwuo5a4w_.rs:9:33\n  |\n9 |\
    \     arr.iter().filter(|&i| i >= 0).count() as isize\n  |                   \
    \              ^\n  |                                 |\n  |                 \
    \                expected `&isize`, found integer\n  |                       \
    \          help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    // If all the numbers are 0 or negative, then 0 is returned.\n\
    \    if arr.iter().filter(|&n| n < 0).count() == arr.len() {\n        return 0;\n\
    \    }\n    // Initialize a counter starting at 1, so that if we find the first\
    \ non-zero digit,\n    // it will be the total number of digits, not the length\
    \ of the array.\n    let mut counter = 1;\n    for n in arr.iter().filter(|&n|\
    \ n >= 0) {\n        // If this digit is non-zero, add it to the counter.\n  \
    \      if n != 0 {\n            counter += n / 10;\n        }\n        // If this\
    \ digit is 0, then the next digit must be 0, too.\n        // Otherwise, if the\
    \ next digit is non-zero, then it must be the total length\n        // minus the\
    \ current number of digits.\n        if n % 10 == 0 {\n            counter +=\
    \ arr.len() - counter;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp64uajp21.rs:10:35\n   |\n\
    10 |     if arr.iter().filter(|&n| n < 0).count() == arr.len() {\n   |       \
    \                            ^\n   |                                   |\n   |\
    \                                   expected `&isize`, found integer\n   |   \
    \                                help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp64uajp21.rs:16:42\n   |\n16 |     for n in arr.iter().filter(|&n|\
    \ n >= 0) {\n   |                                          ^\n   |           \
    \                               |\n   |                                      \
    \    expected `&isize`, found integer\n   |                                  \
    \        help: consider borrowing here: `&0`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp64uajp21.rs:18:14\n   |\n18 |         if n !=\
    \ 0 {\n   |              ^^ no implementation for `&isize == {integer}`\n   |\n\
    \   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp64uajp21.rs:25:36\n\
    \   |\n25 |             counter += arr.len() - counter;\n   |                \
    \                    ^^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmp64uajp21.rs:25:34\n   |\n\
    25 |             counter += arr.len() - counter;\n   |                       \
    \           ^ no implementation for `usize - isize`\n   |\n   = help: the trait\
    \ `Sub<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n    \
    \         <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n      \
    \       <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n          \
    \   <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a\
    \ i"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut sum = 0;\n    let mut nums = vec![0; arr.len()];\n \
    \   let mut carry = 0;\n    for &n in &nums {\n        sum += n;\n        carry\
    \ += sum as isize % 10;\n        sum = sum / 10;\n    }\n    if carry > 0 {\n\
    \        sum += carry;\n    }\n    sum as isize\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpe1kps7yz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .map(|num| {\n            if *num < 0 {\n\
    \                -num\n            } else {\n                *num\n          \
    \  }\n        })\n        .filter(|num| num.is_positive())\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0z7olydo.rs:9:5\n   |\n8\
    \  |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                       \
    \              ----- expected `isize` because of return type\n9  | /     arr.iter()\n\
    10 | |         .map(|num| {\n11 | |             if *num < 0 {\n12 | |        \
    \         -num\n...  |\n17 | |         .filter(|num| num.is_positive())\n18 |\
    \ |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_tuk2r2u.rs:9:32\n  |\n9 |\
    \     arr.iter().filter(|&x| x > 0).count()\n  |                             \
    \   ^\n  |                                |\n  |                             \
    \   expected `&isize`, found integer\n  |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_tuk2r2u.rs:9:5\n\
    \  |\n8 | fn count_nums(arr: Vec<isize>) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n9 |     arr.iter().filter(|&x|\
    \ x > 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     arr.iter().filter(|&x| x >\
    \ 0).count().try_into().unwrap()\n  |                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = arr\n        .iter()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .map(|n| if n > 0 { *n } else { -n })\n\
    \        .sum();\n    n.checked_add(-(arr[0] as isize)).unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmpaj4p5ta0.rs:12:10\n     |\n12   | \
    \        .cloned()\n     |          ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `cloned` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpaj4p5ta0.rs:13:10\n\
    \   |\n13 |           .cloned()\n   |            ^^^^^^ method cannot be called\
    \ on `Cloned<Cloned<std::slice::Iter<'_, isize>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<Cloned<std::slice::Iter<'_,\
    \ isize>> as Iterator>::Item = &_`\n           which is required by `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n           `Cloned<Cloned<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n    let mut i\
    \ = 1;\n    let mut c = 1;\n    for x in arr.iter().cloned() {\n        i += x;\n\
    \        if i >= 0 {\n            c++;\n        }\n    }\n    c\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmplerph1rc.rs:17:14\n\
    \   |\n17 |             c++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n17 |             { let tmp = c; c += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n17 -             c++;\n\
    17 +             c += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut cnt: isize = 0;\n    let mut sum = 0;\n    for num in\
    \ arr.iter() {\n        if sum + num > 0 {\n            sum += num;\n        \
    \    cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmp_wpy54y4.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    // Convert\
    \ numbers to their sign-magnitude representation so we can use bit-manipulation\n\
    \    // to efficiently count the number of positive summands.\n    let mut sign\
    \ = -1;\n    let mut magnitude = 0;\n    for &i in arr {\n        if i >= 0 {\n\
    \            magnitude += i;\n        } else {\n            sign = -sign;\n  \
    \          magnitude += i;\n        }\n    }\n\n    if magnitude == 0 {\n    \
    \    return 0;\n    }\n\n    // Count the number of positive summands\n    let\
    \ mut pos_sum = 0;\n    for &i in arr {\n        match i {\n            1 => pos_sum,\n\
    \            -1 => pos_sum,\n            _ => {\n                if sign == -1\
    \ {\n                    pos_sum -= i;\n                } else {\n           \
    \         pos_sum += i;\n                }\n            }\n        }\n    }\n\n\
    \    pos_sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvs8wayhs.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvs8wayhs.rs:32:9\n   |\n32 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: `match` arms have incompatible\
    \ types\n  --> /tmp/tmpvs8wayhs.rs:37:17\n   |\n33 |           match i {\n   |\
    \           ------- `match` arms have incompatible types\n34 |               1\
    \ => pos_sum,\n   |                    ------- this is found to be of type `{integer}`\n\
    35 |               -1 => pos_sum,\n   |                     ------- this is found\
    \ to be of type `{integer}`\n36 |               _ => {\n37 | /               \
    \  if sign == -1 {\n38 | |                     pos_sum -= i;\n39 | |         \
    \        } else {\n40 | |                     pos_sum += i;\n41 | |          \
    \       }\n   | |_________________^ expected integer, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().filter(|&i| i >= 0).count(|i| i as usize - i % 10).unwrap()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyqmcomgy.rs:9:33\n  |\n9 |\
    \     arr.iter().filter(|&i| i >= 0).count(|i| i as usize - i % 10).unwrap()\n\
    \  |                                 ^\n  |                                 |\n\
    \  |                                 expected `&isize`, found integer\n  |   \
    \                              help: consider borrowing here: `&0`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpyqmcomgy.rs:9:36\n\
    \    |\n9   |     arr.iter().filter(|&i| i >= 0).count(|i| i as usize - i % 10).unwrap()\n\
    \    |                                    ^^^^^ ----------------------- supplied\
    \ 1 argument\n    |                                    |\n    |              \
    \                      expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `unwrap` found for type `usize`\
    \ in the current scope\n --> /tmp/tmpyqmcomgy.rs:9:67\n  |\n9 |     arr.iter().filter(|&i|\
    \ i >= 0).count(|i| i as usize - i % 10).unwrap()\n  |                       \
    \                                            ^^^^^^ method not found in `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    arr\n        .iter()\n        .filter(|&n| n > 0)\n        .filter_map(|n|\
    \ {\n            if n <= 0 {\n                Some(-n)\n            } else {\n\
    \                Some(n.digits().first().unwrap())\n            }\n        })\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptp7wahy3.rs:11:26\n   |\n\
    11 |         .filter(|&n| n > 0)\n   |                          ^\n   |      \
    \                    |\n   |                          expected `&isize`, found\
    \ integer\n   |                          help: consider borrowing here: `&0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptp7wahy3.rs:13:21\n   |\n13 |\
    \             if n <= 0 {\n   |                     ^\n   |                  \
    \   |\n   |                     expected `&isize`, found integer\n   |       \
    \              help: consider borrowing here: `&0`\n\nerror[E0599]: no method\
    \ named `digits` found for reference `&isize` in the current scope\n  --> /tmp/tmptp7wahy3.rs:16:24\n\
    \   |\n16 |                 Some(n.digits().first().unwrap())\n   |          \
    \              ^^^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptp7wahy3.rs:9:5\n   |\n8  |   fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                     ----- expected `isize`\
    \ because of return type\n9  | /     arr\n10 | |         .iter()\n11 | |     \
    \    .filter(|&n| n > 0)\n12 | |         .filter_map(|n| {\n...  |\n18 | |   \
    \      })\n19 | |         .count()\n   | |________________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ first_negative = arr[0] < 0;\n    let mut sum = arr[0] as isize;\n\n    for\
    \ x in arr.iter().skip(1) {\n        sum += x;\n        if sum < 0 {\n       \
    \     first_negative = !first_negative;\n            sum += first_negative as\
    \ isize;\n        }\n    }\n\n    if sum == 0 {\n        return 0;\n    }\n\n\
    \    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `0`', /tmp/tmp__063t84.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function count_nums which takes an array of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11,\
    \ -11]) == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>)\
    \ -> isize {\n    let mut count = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            count += i; \n        }\n    }\n    count\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmpy4ip0yo2.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
