name: HumanEval_93_encode
language: rust
results:
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    let mut vowels = String::new();\n\
    \    let mut consonants = String::new();\n    for (i, c) in message.chars().enumerate()\
    \ {\n        if !ascii_letters_only.contains(c) {\n            s += c;\n     \
    \   } else {\n            if vowels.len() != 0 {\n                s += vowels[vowels.len()\
    \ - 1];\n            } else {\n                s += c;\n            }\n      \
    \      vowels.push(c);\n        }\n        if i == message.len() - 1 {\n     \
    \       vowels.clear();\n            consonants.clear();\n        }\n    }\n \
    \   s += consonants[consonants.len() - 1];\n    s.to_string()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ascii_letters_only` in this scope\n  -->\
    \ /tmp/tmpzng4k4_0.rs:16:13\n   |\n16 |         if !ascii_letters_only.contains(c)\
    \ {\n   |             ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzng4k4_0.rs:17:18\n   |\n17 |             s\
    \ += c;\n   |                  ^ expected `&str`, found `char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzng4k4_0.rs:20:22\n\
    \   |\n20 |                 s += vowels[vowels.len() - 1];\n   |             \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzng4k4_0.rs:22:22\n   |\n22 |              \
    \   s += c;\n   |                      ^ expected `&str`, found `char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzng4k4_0.rs:31:10\n\
    \   |\n31 |     s += consonants[consonants.len() - 1];\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0425.\nFor mo"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    for (i, &c) in message.chars().enumerate()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'{\n  \
    \          let index = i-1; // index of previous letter\n            let prev_index\
    \ = index - 2;\n            let mut temp = s[index];\n            s[index] = s[index+1];\n\
    \            s[index+1] = temp;\n        }\n    }\n    for letter in message.chars()\
    \ {\n        if let Some(index) = s.index(&letter) {\n            if index ==\
    \ 0 {\n                s.push('0');\n            } else {\n                if\
    \ index == 1 {\n                    s.push('a');\n                } else {\n \
    \                   if index == 2 {\n                        s.push('b');\n  \
    \                  } else {\n                        if index == 3 {\n       \
    \                     s.push('c');\n                        } else {\n       \
    \                     if index == 4 {\n                                s.push('d');\n\
    \                            } else {\n                                if index\
    \ == 5 {\n                                    s.push('e');\n                 \
    \               } else {\n                                    if index == 6 {\n\
    \                                        s.push('f');\n                      \
    \              } else {\n                                        if index == 7\
    \ {\n                                            s.push('g');\n              \
    \                          } else {\n                                        \
    \    if index == 8 {\n                                                s.push('h');\n\
    \                                            } else {\n                      \
    \                          if index == 9 {\n                                 \
    \                   s.push('i');\n                                           \
    \     } else {\n                                                    s.push('j');\n\
    \                                                }\n                         \
    \                   }\n                                        }\n           \
    \                         }\n                                }\n             \
    \               }\n                        }\n                    }\n        \
    \        }\n            }\n        }\n    }\n    s.reverse();\n    s\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnot0tf6b.rs:13:13\n   |\n\
    13 |     for (i, &c) in message.chars().enumerate() {\n   |             ^^   \
    \  --------------------------- this expression has type `Option<(usize, char)>`\n\
    \   |             |\n   |             expected `char`, found reference\n   | \
    \            help: you can probably remove the explicit borrow: `c`\n   |\n  \
    \ = note:   expected type `char`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnot0tf6b.rs:17:28\n\
    \   |\n17 |             let mut temp = s[index];\n   |                       \
    \     ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnot0tf6b.rs:18:13\n   |\n18 |             s[index] = s[index+1];\n\
    \   |             ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnot0tf6b.rs:18:24\n   |\n18 |             s[index] = s[index+1];\n\
    \   |                        ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::new();\n    for &c in message\
    \ {\n        if c.is_uppercase() {\n            output.append(c.to_lowercase());\n\
    \        } else if c.is_lowercase() {\n            output.append(c.to_uppercase());\n\
    \        } else {\n            output.append(c.chars().enumerate().fold(String::new(),\
    \ |s, (i, c) => {\n                if i > 2 {\n                    let mut new_index\
    \ = c - 'A' + 2;\n                    let c = c + 1;\n                    s.push_str(&c.to_string());\n\
    \                    s.push_str(&'A'[new_index.to_usize]);\n                }\
    \ else {\n                    s.push_str(&c.to_string());\n                }\n\
    \            }));\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `,` or `:`, found `=>`\n  --> /tmp/tmpgd9ope79.rs:19:80\n\
    \   |\n19 |             output.append(c.chars().enumerate().fold(String::new(),\
    \ |s, (i, c) => {\n   |                                                      \
    \                          ^^ expected one of `,` or `:`\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = message;\n    encoded.chars().for_each(|c|\
    \ {\n        // Only ASCII letters, so just use the char as is.\n        if c\
    \ >= 'A' && c <= 'Z' {\n            encoded.insert_str(0, c.to_string());\n  \
    \          return;\n        }\n\n        let letter = &ascii_letters[(c + 1) -\
    \ 'A'];\n        encoded.insert_str(0, letter);\n    });\n    encoded.chars().for_each(|c|\
    \ {\n        if c >= 'a' && c <= 'z' {\n            let index = ascii_letters.iter().position(|&x|\
    \ x.to_string() == c.to_string());\n            encoded.insert_str(index + 1,\
    \ ascii_letters[c + 1]);\n            return;\n        }\n    });\n    return\
    \ encoded;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ascii_letters` in this scope\n  --> /tmp/tmpswbr9sul.rs:20:23\n\
    \   |\n20 |         let letter = &ascii_letters[(c + 1) - 'A'];\n   |        \
    \               ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ascii_letters` in this scope\n  --> /tmp/tmpswbr9sul.rs:25:25\n\
    \   |\n25 |             let index = ascii_letters.iter().position(|&x| x.to_string()\
    \ == c.to_string());\n   |                         ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `ascii_letters` in this scope\n\
    \  --> /tmp/tmpswbr9sul.rs:26:43\n   |\n26 |             encoded.insert_str(index\
    \ + 1, ascii_letters[c + 1]);\n   |                                          \
    \ ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpswbr9sul.rs:16:35\n   |\n16 |             encoded.insert_str(0, c.to_string());\n\
    \   |                                   ^^^^^^^^^^^^^\n   |                  \
    \                 |\n   |                                   expected `&str`, found\
    \ struct `String`\n   |                                   help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0369]: cannot add `{integer}` to `char`\n \
    \ --> /tmp/tmpswbr9sul.rs:20:40\n   |\n20 |         let letter = &ascii_letters[(c\
    \ + 1) - 'A'];\n   |                                      - ^ - {integer}\n  \
    \ |                                      |\n   |                             \
    \         char\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpswbr9sul.rs:26:59\n\
    \   |\n26 |             encoded.insert_str(index + 1, ascii_letters[c + 1]);\n\
    \   |                                                         - ^ - {integer}\n\
    \   |                                                         |\n   |        \
    \                                                 char\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n\n    for &c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \    }\n\n    let mut vowel_count = HashMap::new();\n\n    for &c in result.chars()\
    \ {\n        if !vowel_count.contains_key(&c) {\n            vowel_count.insert(c,\
    \ 2);\n        } else {\n            vowel_count.insert(c, vowel_count.get(&c)\
    \ + 1);\n        }\n    }\n\n    let mut result = String::new();\n    let mut\
    \ offset = 0;\n\n    for &c in result.chars() {\n        let vowel_count = vowel_count.get(&c).unwrap();\n\
    \        let mut offset = 0;\n        while vowel_count > 0 {\n            if\
    \ offset == 0 {\n                result.push_str(&c.to_lowercase());\n       \
    \     } else {\n                result.push_str(&c.to_uppercase());\n        \
    \    }\n\n            offset += 2;\n            vowel_count -= 2;\n        }\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpp8e0obdc.rs:22:27\n   |\n22 |     let mut vowel_count = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp8e0obdc.rs:14:9\n   |\n14 |     for &c in message.chars()\
    \ {\n   |         ^^    --------------- this expression has type `Option<char>`\n\
    \   |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp8e0obdc.rs:24:9\n   |\n24 |     for &c in result.chars() {\n \
    \  |         ^^    -------------- this expression has type `Option<char>`\n  \
    \ |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp8e0obdc.rs:35:9\n   |\n35 |     for &c in result.chars() {\n \
    \  |         ^^    -------------- this expression has type `Option<char>`\n  \
    \ |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: String = \"\"\n\n    for i in 0..message.len()\
    \ {\n        if let Some(_) = alphabet.get_nth((message.chars().nth(i) + message.chars().nth(i+1)).unwrap())\
    \ {\n            encoded.append(alphabet.get_nth((message.chars().nth(i) + message.chars().nth(i+1)).unwrap()).unwrap())\n\
    \        }\n    }\n\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpqep0ef10.rs:12:33\n\
    \   |\n12 |     let mut encoded: String = \"\"\n   |                         \
    \        ^ help: add `;` here\n13 | \n14 |     for i in 0..message.len() {\n \
    \  |     --- unexpected token\n\nerror[E0425]: cannot find value `alphabet` in\
    \ this scope\n  --> /tmp/tmpqep0ef10.rs:15:26\n   |\n15 |         if let Some(_)\
    \ = alphabet.get_nth((message.chars().nth(i) + message.chars().nth(i+1)).unwrap())\
    \ {\n   |                          ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmpqep0ef10.rs:16:28\n\
    \   |\n16 |             encoded.append(alphabet.get_nth((message.chars().nth(i)\
    \ + message.chars().nth(i+1)).unwrap()).unwrap())\n   |                      \
    \      ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqep0ef10.rs:12:31\n   |\n12 |     let mut encoded: String = \"\"\n \
    \  |                      ------   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |        |\n   |                      |        expected\
    \ struct `String`, found `&str`\n   |                      expected due to this\n\
    \nerror[E0369]: cannot add `Option<char>` to `Option<char>`\n  --> /tmp/tmpqep0ef10.rs:15:67\n\
    \   |\n15 |         if let Some(_) = alphabet.get_nth((message.chars().nth(i)\
    \ + message.chars().nth(i+1)).unwrap()) {\n   |                              \
    \              ---------------------- ^ ------------------------ Option<char>\n\
    \   |                                            |\n   |                     \
    \                       Option<char>\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpqep0ef10.rs:16:21\n\
    \   |\n16 |             encoded.append(alphabet.get_nth((message.chars().nth(i)\
    \ + message.chars().nth(i+1)).unwrap()).unwrap())\n   |                     ^^^^^^\
    \ method not found in `String`\n\nerror[E0369]: cannot add `Option<char>` to `Option<char>`\n\
    \  --> /tmp/tmpqep0ef10.rs:16:69\n   |\n16 |             encoded.append(alphabet.get_nth((message.chars("
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut buffer = String::with_capacity(message.len());\n\
    \    for (i, c) in message.chars().enumerate() {\n        if let Some((c, _))\
    \ = c.to_lowercase().as_ref() {\n            buffer.push_str(&(c + i).to_string());\n\
    \        }\n    }\n    encode(buffer).to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_ref` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmp3uk8u2is.rs:14:48\n   |\n14 |         if let\
    \ Some((c, _)) = c.to_lowercase().as_ref() {\n   |                           \
    \                     ^^^^^^ method not found in `ToLowercase`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = \"\";\n    \n    for &letter\
    \ in message {\n        let mut letter_index = letter - 'a' as usize;\n      \
    \  \n        let mut letter_index2 = letter - 'A' as usize;\n        \n      \
    \  while letter_index2 < 26 {\n            letter_index2 += 26;\n        }\n \
    \       \n        let letter2 = if letter_index2 > 26 { letter_index2 + 26 }\n\
    \                    else letter_index2;\n        \n        let mut letter_new_index\
    \ = letter_index + letter2 as usize;\n        \n        while letter_new_index\
    \ < 23 {\n            letter_new_index += 26;\n        }\n        \n        let\
    \ letter2 = if letter_new_index > 23 { letter_new_index + 26 }\n             \
    \       else letter_new_index;\n        \n        let letter_new = if letter >=\
    \ 'A' && letter <= 'Z' { letter }\n                          else if letter >=\
    \ 'a' && letter <= 'z' { letter + char }\n                          else { panic!(\"\
    Invalid Character\") };\n        \n        new_message += if letter_index < letter_index2\
    \ \n                        { letter_new }\n                        { letter_new\
    \ + letter2 };\n    }\n    \n    new_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `letter_index2`\n  --> /tmp/tmps7nv9gy0.rs:24:26\n\
    \   |\n24 |                     else letter_index2;\n   |                    \
    \      ^^^^^^^^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a\
    \ block\n   |\n24 |                     else { letter_index2 };\n   |        \
    \                  +               +\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmps7nv9gy0.rs:14:20\n   |\n14 |     for &letter in message {\n  \
    \ |                    ^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps7nv9gy0.rs:44:5\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \          ------ expected `String` because of return type\n...\n44 |     new_message\n\
    \   |     ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n \
    \  |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Create a map for vowels\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(b'A', 0x01);\n    vowels.insert(b'E', 0x02);\n    vowels.insert(b'I',\
    \ 0x03);\n    vowels.insert(b'O', 0x04);\n    vowels.insert(b'U', 0x05);\n   \
    \ vowels.insert(b'a', 0x0a);\n    vowels.insert(b'e', 0x0e);\n    vowels.insert(b'i',\
    \ 0x0i);\n    vowels.insert(b'o', 0x0o);\n    vowels.insert(b'u', 0x0u);\n   \
    \ vowels.insert(b'i', 0x0i);\n    vowels.insert(b'o', 0x0o);\n\n    // Iterate\
    \ over message and swap case of each letter\n    // Assume only letters\n    for\
    \ (i, letter) in message.chars().enumerate() {\n        // Get index of vowel\
    \ in map\n        let mut vowel = vowels.get(&letter);\n        if vowel != 0\
    \ {\n            let x = vowel as usize;\n            if x == 1 {\n          \
    \      vowel = vowels.entry(0).or_insert(0x01);\n            } else {\n      \
    \          vowel = vowels.entry(x - 1).or_insert(0x01);\n            }\n     \
    \       message.swap(letter, vowel);\n        }\n    }\n    // Iterate over message\
    \ and replace all vowels in message with letters that appear\n    // 2 places\
    \ ahead of the vowel in the alphabet\n    let mut alphabet = String::new();\n\
    \    for (i, letter) in message.chars().enumerate() {\n        // Get index of\
    \ vowel in map\n        let mut vowel = vowels.get(&letter);\n        if vowel\
    \ != 0 {\n            let x = vowel as usize;\n            let y = alphabet.chars().enumerate().find(|&(index,\
    \ _)| index == x).unwrap();\n            alphabet = alphabet.insert(y.0, letter);\n\
    \        }\n    }\n    alphabet\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `i` for number literal\n  --> /tmp/tmp0tfd1pdw.rs:21:25\n\
    \   |\n21 |     vowels.insert(b'i', 0x0i);\n   |                         ^^^^\
    \ invalid suffix `i`\n   |\n   = help: the suffix must be one of the numeric types\
    \ (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `o` for number literal\n\
    \  --> /tmp/tmp0tfd1pdw.rs:22:25\n   |\n22 |     vowels.insert(b'o', 0x0o);\n\
    \   |                         ^^^^ invalid suffix `o`\n   |\n   = help: the suffix\
    \ must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid\
    \ suffix `u` for number literal\n  --> /tmp/tmp0tfd1pdw.rs:23:25\n   |\n23 | \
    \    vowels.insert(b'u', 0x0u);\n   |                         ^^^^ invalid suffix\
    \ `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `i` for number literal\n  --> /tmp/tmp0tfd1pdw.rs:24:25\n\
    \   |\n24 |     vowels.insert(b'i', 0x0i);\n   |                         ^^^^\
    \ invalid suffix `i`\n   |\n   = help: the suffix must be one of the numeric types\
    \ (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `o` for number literal\n\
    \  --> /tmp/tmp0tfd1pdw.rs:25:25\n   |\n25 |     vowels.insert(b'o', 0x0o);\n\
    \   |                         ^^^^ invalid suffix `o`\n   |\n   = help: the suffix\
    \ must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp0tfd1pdw.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashMap::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0599]: no method named `swap`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp0tfd1pdw.rs:39:21\n\
    \   |\n39 |             message.swap(letter, vowel);\n   |                   \
    \  ^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0tfd1pdw.rs:51:24\n   |\n44 |     let mut alphabet = String::new();\n\
    \   |                        ------------- expected due to this value\n...\n51\
    \ |             alphabet = alphabe"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::new();\n    for c in message.chars()\
    \ {\n        // Swap case if this is a letter.\n        if c.is_alphabetic() {\n\
    \            c = c.to_upper();\n        } else {\n            c = c.to_lower();\n\
    \        }\n        // Find index that this letter appears 2 places after.\n \
    \       let index = (&c + &message.chars().next().unwrap()).find_index(|&c| c\
    \ == 'A') as usize;\n        // If this letter appears at this index, swap case.\n\
    \        if index > 0 {\n            let c = message.chars().next().unwrap();\n\
    \            let d = message.chars().next().unwrap();\n            if c == 'A'\
    \ && d == 'B' {\n                output.push('a');\n            } else {\n   \
    \             output.push(c);\n            }\n        } else {\n            output.push(c);\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbfh09t0y.rs:16:19\n   |\n16 |             c = c.to_upper();\n\
    \   |                   ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpbfh09t0y.rs:18:19\n   |\n\
    18 |             c = c.to_lower();\n   |                   ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_lowercase`\n\nerror[E0369]:\
    \ cannot add `&char` to `&char`\n  --> /tmp/tmpbfh09t0y.rs:21:25\n   |\n21 | \
    \        let index = (&c + &message.chars().next().unwrap()).find_index(|&c| c\
    \ == 'A') as usize;\n   |                      -- ^ --------------------------------\
    \ &char\n   |                      |\n   |                      &char\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::with_capacity(message.len());\n\
    \    for (i, c) in message.chars().enumerate() {\n        if c >= 'a' && c <=\
    \ 'z' {\n            result.push_str(&c.to_string().to_ascii_lowercase());\n \
    \       } else if c >= 'A' && c <= 'Z' {\n            result.push_str(&c.to_string().to_ascii_uppercase());\n\
    \        } else {\n            result.push_str(&c.to_string());\n        }\n\n\
    \        if i > 0 && c.to_ascii_lowercase() == result.chars().nth(i).unwrap().to_ascii_lowercase()\
    \ {\n            result.push_str(&c.to_string());\n        }\n\n        if i >\
    \ 0 && c.to_ascii_uppercase() == result.chars().nth(i).unwrap().to_ascii_uppercase()\
    \ {\n            result.push_str(&c.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEEEST\"`,\n right: `\"tgst\"`', /tmp/tmpl9khr060.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encodedMessage: String = \"\";\n    let mut\
    \ vowels = \"aeiou\";\n    let mut consonants = \"bcdfghjklmnpqrstvwxyz\";\n \
    \   let mut vowelsPosition: Vec<&str> = vowels.chars().collect();\n    let mut\
    \ consonantsPosition: Vec<&str> = consonants.chars().collect();\n\n    for char\
    \ in message {\n        let index = vowelsPosition.iter().position(|x| x == char).unwrap()\
    \ + 1;\n        let index2 = consonantsPosition.iter().position(|x| x == char).unwrap()\
    \ + 1;\n        encodedMessage += char.to_string_lossy().swap()[vowelsPosition[index]\
    \ as usize - index2];\n    }\n    encodedMessage\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxt9za0jn.rs:12:38\n   |\n\
    12 |     let mut encodedMessage: String = \"\";\n   |                        \
    \     ------   ^^- help: try using a conversion method: `.to_string()`\n   | \
    \                            |        |\n   |                             |  \
    \      expected struct `String`, found `&str`\n   |                          \
    \   expected due to this\n\nerror[E0277]: a value of type `Vec<&str>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmpxt9za0jn.rs:15:56\n\
    \     |\n15   |     let mut vowelsPosition: Vec<&str> = vowels.chars().collect();\n\
    \     |                                                        ^^^^^^^ value of\
    \ type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n   \
    \  |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: a value of type `Vec<&str>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpxt9za0jn.rs:16:64\n\
    \     |\n16   |     let mut consonantsPosition: Vec<&str> = consonants.chars().collect();\n\
    \     |                                                                ^^^^^^^\
    \ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: `String` is not an iterator\n  -->\
    \ /tmp/tmpxt9za0jn.rs:18:17\n   |\n18 |     for char in message {\n   |      \
    \           ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0606]: casting `&str` as `usize` is invalid\n  --> /tmp/tmpxt9za0jn.rs:21:57\n\
    \   |\n21 |         encodedMessage += char.to_string_lossy().swap()"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::new();\n    let mut i\
    \ = 0;\n    let mut j = message.length() - 1;\n    while i < message.length()\
    \ && j >= i {\n        match message.chars().nth(i) {\n            'A' | 'a' =>\
    \ new_message.push('A'),\n            'B' | 'b' => new_message.push('b'),\n  \
    \          'C' | 'c' => new_message.push('c'),\n            'D' | 'd' => new_message.push('d'),\n\
    \            'E' | 'e' => new_message.push('e'),\n            'F' | 'f' => new_message.push('f'),\n\
    \            'G' | 'g' => new_message.push('g'),\n            'H' | 'h' => new_message.push('h'),\n\
    \            'I' | 'i' => new_message.push('i'),\n            'J' | 'j' => new_message.push('j'),\n\
    \            'K' | 'k' => new_message.push('k'),\n            'L' | 'l' => new_message.push('l'),\n\
    \            'M' | 'm' => new_message.push('m'),\n            'N' | 'n' => new_message.push('n'),\n\
    \            'O' | 'o' => new_message.push('o'),\n            'P' | 'p' => new_message.push('p'),\n\
    \            'Q' | 'q' => new_message.push('q'),\n            'R' | 'r' => new_message.push('r'),\n\
    \            'S' | 's' => new_message.push('s'),\n            'T' | 't' => new_message.push('t'),\n\
    \            'U' | 'u' => new_message.push('u'),\n            'V' | 'v' => new_message.push('v'),\n\
    \            'W' | 'w' => new_message.push('w'),\n            'X' | 'x' => new_message.push('x'),\n\
    \            'Y' | 'y' => new_message.push('y'),\n            'Z' | 'z' => new_message.push('z'),\n\
    \            _ => new_message.push(*message.chars().nth(i).unwrap()),\n      \
    \  };\n        match message.chars().nth(i) {\n            'A' | 'a' => new_message.push(*message.chars().nth(j).unwrap()),\n\
    \            'B' | 'b' => new_message.push(*message.chars().nth(j + 1).unwrap()),\n\
    \            'C' | 'c' => new_message.push(*message.chars().nth(j + 2).unwrap()),\n\
    \            'D' | 'd' => new_message.push(*message.chars().nth(j + 3).unwrap()),\n\
    \            'E' | 'e' => new_message.push(*message.chars().nth(j + 4).unwrap()),\n\
    \            'F' | 'f' => new_message.push(*message.chars().nth(j + 5).unwrap()),\n\
    \            'G' | 'g' => new_message.push(*message.chars().nth(j + 6).unwrap()),\n\
    \            'H' | 'h' => new_message.push(*message.chars().nth(j\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoc8_n_ye.rs:63:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n15 |     while i < message.length()\
    \ && j >= i {\n   |                                          - unclosed delimiter\n\
    ...\n45 |         match message.chars().nth(i) {\n   |                       \
    \               - this delimiter might not be properly closed...\n...\n54 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n63 | }\n\
    \   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpoc8_n_ye.rs:53:63\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n53 |     \
    \        'H' | 'h' => new_message.push(*message.chars().nth(j\n   |          \
    \                                                     ^ unclosed delimiter\n54\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpoc8_n_ye.rs:14:25\n\
    \   |\n14 |     let mut j = message.length() - 1;\n   |                      \
    \   ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpoc8_n_ye.rs:15:23\n   |\n15 |     while i < message.length()\
    \ && j >= i {\n   |                       ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoc8_n_ye.rs:17:13\n   |\n16 |         match message.chars().nth(i) {\n\
    \   |               ---------------------- this expression has type `Option<char>`\n\
    17 |             'A' | 'a' => new_message.push('A'),\n   |             ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the pattern in `Some`\n \
    \  |\n17 |             Some('A') | 'a' => new_message.push('A'),\n   |       \
    \      +++++   +\n\nerror[E0308]: mismatched types\n  --> "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut swaps = [0; 26];\n    let mut replaces = [0;\
    \ 26];\n    let mut current = 65;\n    for i in 0..message.len() {\n        if\
    \ message.chars().nth(i).unwrap().isalpha() {\n            let j = i + 1;\n  \
    \          while j < message.len() && message.chars().nth(j).unwrap().isalpha()\
    \ {\n                swaps[current - 65 + message.chars().nth(i).unwrap().ord()\
    \ -\n                     message.chars().nth(j).unwrap().ord()] = replaces[message.chars().nth(i).unwrap().ord()]\
    \ -\n                     message.chars().nth(j).unwrap().ord() + 1;\n       \
    \         replaces[message.chars().nth(i).unwrap().ord()] = j;\n             \
    \   j += 1;\n            }\n            current = message.chars().nth(i).unwrap().ord()\
    \ + 1;\n        }\n    }\n    let mut res = String::with_capacity(message.len());\n\
    \    for i in 0..swaps.len() {\n        res.push_str(&message[replaces[i] - 1..replaces[i]]\
    \ + &message[swaps[i] - 1..swaps[i]]);\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `isalpha` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsip8z1vw.rs:16:44\n   |\n16 |         if message.chars().nth(i).unwrap().isalpha()\
    \ {\n   |                                            ^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_alphabetic`\n\nerror[E0599]: no\
    \ method named `isalpha` found for type `char` in the current scope\n  --> /tmp/tmpsip8z1vw.rs:18:72\n\
    \   |\n18 |             while j < message.len() && message.chars().nth(j).unwrap().isalpha()\
    \ {\n   |                                                                    \
    \    ^^^^^^^ help: there is an associated function with a similar name: `is_alphabetic`\n\
    \nerror[E0599]: no method named `ord` found for type `char` in the current scope\n\
    \  --> /tmp/tmpsip8z1vw.rs:19:70\n   |\n19 |                 swaps[current - 65\
    \ + message.chars().nth(i).unwrap().ord() -\n   |                            \
    \                                          ^^^ method not found in `char`\n\n\
    error[E0599]: no method named `ord` found for type `char` in the current scope\n\
    \  --> /tmp/tmpsip8z1vw.rs:20:54\n   |\n20 |                      message.chars().nth(j).unwrap().ord()]\
    \ = replaces[message.chars().nth(i).unwrap().ord()] -\n   |                  \
    \                                    ^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `ord` found for type `char` in the current scope\n  --> /tmp/tmpsip8z1vw.rs:20:104\n\
    \   |\n20 |                      message.chars().nth(j).unwrap().ord()] = replaces[message.chars().nth(i).unwrap().ord()]\
    \ -\n   |                                                                    \
    \                                    ^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `ord` found for type `char` in the current scope\n  --> /tmp/tmpsip8z1vw.rs:21:54\n\
    \   |\n21 |                      message.chars().nth(j).unwrap().ord() + 1;\n\
    \   |                                                      ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `ord` found for type `char` in the\
    \ current scope\n  --> /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut message = message.to_string();\n    let mut\
    \ result = String::new();\n    for c in message.chars() {\n        // swap case\n\
    \        if c.is_lowercase() {\n            result.push((c as char).to_ascii_lowercase());\n\
    \        } else {\n            result.push((c as char).to_ascii_uppercase());\n\
    \        }\n\n        // replace vowels\n        let mut vowels = vec!['a', 'e',\
    \ 'i', 'o', 'u'];\n        if vowels.contains(&c) {\n            result.push((c\
    \ as char).to_ascii_lowercase());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpofq3h0pu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for ch in message.chars()\
    \ {\n        match ch {\n            'A'..'Z' => encoded.push_str(\"GST\".to_string()),\n\
    \            'a'..'z' => encoded.push_str(\"KSC\".to_string()),\n            _\
    \ => encoded.push_str(\"MGSSCGG\".to_string())\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp0d14goto.rs:15:13\n\
    \   |\n15 |             'A'..'Z' => encoded.push_str(\"GST\".to_string()),\n \
    \  |             ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp0d14goto.rs:16:13\n   |\n16 |             'a'..'z' => encoded.push_str(\"\
    KSC\".to_string()),\n   |             ^^^^^^^^\n   |\n   = note: see issue #37854\
    \ <https://github.com/rust-lang/rust/issues/37854> for more information\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0d14goto.rs:15:42\n   |\n15 |             'A'..'Z'\
    \ => encoded.push_str(\"GST\".to_string()),\n   |                            \
    \              ^^^^^^^^^^^^^^^^^\n   |                                       \
    \   |\n   |                                          expected `&str`, found struct\
    \ `String`\n   |                                          help: consider borrowing\
    \ here: `&\"GST\".to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0d14goto.rs:16:42\n\
    \   |\n16 |             'a'..'z' => encoded.push_str(\"KSC\".to_string()),\n \
    \  |                                          ^^^^^^^^^^^^^^^^^\n   |        \
    \                                  |\n   |                                   \
    \       expected `&str`, found struct `String`\n   |                         \
    \                 help: consider borrowing here: `&\"KSC\".to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0d14goto.rs:17:35\n   |\n17 |             _\
    \ => encoded.push_str(\"MGSSCGG\".to_string())\n   |                         \
    \          ^^^^^^^^^^^^^^^^^^^^^\n   |                                   |\n \
    \  |                                   expected `&str`, found struct `String`\n\
    \   |                                   help: consider borrowing here: `&\"MGSSCGG\"\
    .to_string()`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0658.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut counter =\
    \ 0;\n    for c in message.chars() {\n        match c {\n            'a' => res.append('B'),\n\
    \            'b' => res.append('D'),\n            'c' => res.append('F'),\n  \
    \          'd' => res.append('G'),\n            'e' => res.append('J'),\n    \
    \        'f' => res.append('I'),\n            'g' => res.append('K'),\n      \
    \      'h' => res.append('L'),\n            'i' => res.append('M'),\n        \
    \    'j' => res.append('N'),\n            'k' => res.append('P'),\n          \
    \  'l' => res.append('Q'),\n            'm' => res.append('R'),\n            'n'\
    \ => res.append('S'),\n            'o' => res.append('T'),\n            'p' =>\
    \ res.append('U'),\n            'q' => res.append('V'),\n            'r' => res.append('W'),\n\
    \            's' => res.append('X'),\n            't' => res.append('Y'),\n  \
    \          'u' => res.append('Z'),\n            _ => (),\n        }\n        counter\
    \ = counter + 1;\n        if counter == 2 {\n            res.append(c.to_lowercase());\n\
    \            counter = 0;\n        }\n    }\n    res.append(String::new());\n\
    \    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpjijovcaw.rs:16:24\n   |\n16 |             'a' =>\
    \ res.append('B'),\n   |                        ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpjijovcaw.rs:17:24\n   |\n17 |             'b' => res.append('D'),\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjijovcaw.rs:18:24\n   |\n18 |             'c' => res.append('F'),\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjijovcaw.rs:19:24\n   |\n19 |             'd' => res.append('G'),\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjijovcaw.rs:20:24\n   |\n20 |             'e' => res.append('J'),\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjijovcaw.rs:21:24\n   |\n21 |             'f' => res.append('I'),\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjijovcaw.rs:22:24\n   |\n22 |             'g' => res.append('K'),\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjijovcaw.rs:23:24\n   |\n23 |             'h' => res.append('L'),\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjijovcaw.rs:24:24\n   |\n24 |             'i' => res.append('M'),\n\
    \   |                        ^^^^^^ method not found "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    message.chars().for_each(|c|{\n\
    \        match c.to_ascii_lowercase() {\n            'a' => '0',\n           \
    \ 'b' => '1',\n            'c' => '2',\n            'd' => '3',\n            'e'\
    \ => '4',\n            'f' => '5',\n            'g' => '6',\n            'h' =>\
    \ '7',\n            'i' => '8',\n            'j' => '9',\n            'k' => 'A',\n\
    \            'l' => 'B',\n            'm' => 'C',\n            'n' => 'D',\n \
    \           'o' => 'E',\n            'p' => 'F',\n            'q' => 'G',\n  \
    \          'r' => 'H',\n            's' => 'I',\n            't' => 'J',\n   \
    \         'u' => 'K',\n            'v' => 'L',\n            'w' => 'M',\n    \
    \        'x' => 'N',\n            'y' => 'O',\n            'z' => 'P',\n     \
    \       _ => (),\n        };\n        s += 'G'; // \"G\" is the second letter\
    \ in the english alphabet\n        match c {\n            'a' => \"0\",\n    \
    \        'b' => \"1\",\n            'c' => \"2\",\n            'd' => \"3\",\n\
    \            'e' => \"4\",\n            'f' => \"5\",\n            'g' => \"6\"\
    ,\n            'h' => \"7\",\n            'i' => \"8\",\n            'j' => \"\
    9\",\n            'k' => \"A\",\n            'l' => \"B\",\n            'm' =>\
    \ \"C\",\n            'n' => \"D\",\n            'o' => \"E\",\n            'p'\
    \ => \"F\",\n            'q' => \"G\",\n            'r' => \"H\",\n          \
    \  's' => \"I\",\n            't' => \"J\",\n            'u' => \"K\",\n     \
    \       'v' => \"L\",\n            'w' => \"M\",\n            'x' => \"N\",\n\
    \            'y' => \"O\",\n            'z' => \"P\",\n            _ => (),\n\
    \        };\n    });\n    s\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpptrfjhwi.rs:41:18\n\
    \   |\n14 | /         match c.to_ascii_lowercase() {\n15 | |             'a' =>\
    \ '0',\n16 | |             'b' => '1',\n17 | |             'c' => '2',\n...  |\n\
    40 | |             'z' => 'P',\n   | |                    --- this and all prior\
    \ arms are found to be of type `char`\n41 | |             _ => (),\n   | |   \
    \               ^^ expected `char`, found `()`\n42 | |         };\n   | |_________-\
    \ `match` arms have incompatible types\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpptrfjhwi.rs:43:14\n   |\n43 |         s += 'G'; // \"G\" is the second\
    \ letter in the english alphabet\n   |              ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n43 |         s += \"G\"; // \"G\" is the second letter in the english alphabet\n\
    \   |              ~~~\n\nerror[E0308]: `match` arms have incompatible types\n\
    \  --> /tmp/tmpptrfjhwi.rs:71:18\n   |\n44 | /         match c {\n45 | |     \
    \        'a' => \"0\",\n46 | |             'b' => \"1\",\n47 | |             'c'\
    \ => \"2\",\n...  |\n70 | |             'z' => \"P\",\n   | |                \
    \    --- this and all prior arms are found to be of type `&str`\n71 | |      \
    \       _ => (),\n   | |                  ^^ expected `&str`, found `()`\n72 |\
    \ |         };\n   | |_________- `match` arms have incompatible types\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output: String = String::new();\n    \n   \
    \ let mut vowels = \"aeiouy\";\n    let mut replace = HashMap::new();\n    for\
    \ i in 0..vowels.len() {\n        replace.insert(vowels[i], 'z'.into());\n   \
    \ }\n    \n    for ch in message.chars() {\n        if replace.contains_key(&ch.to_lowercase())\
    \ {\n            output.push(*replace.get(&ch.to_lowercase()));\n        } else\
    \ {\n            output.push(ch);\n        }\n    }\n    \n    output\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp7vu30zwn.rs:15:23\n   |\n15 |     let mut replace = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp7vu30zwn.rs:17:24\n\
    \   |\n17 |         replace.insert(vowels[i], 'z'.into());\n   |             \
    \           ^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<usize>` for `str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowels = vec!['a', 'e', 'i', 'o', 'u', 'y'];\n\
    \    let mut result = Vec::new();\n    for &s in &message {\n        if s.is_uppercase()\
    \ {\n            alphabet.sort_by_key(|x| x.cmp(&s));\n            alphabet.push(s[1..].to_string());\n\
    \        } else if s.is_lowercase() {\n            alphabet.sort_by_key(|x| x.cmp(&s[1..]));\n\
    \            alphabet.push(s[1..].to_string());\n        } else {\n          \
    \  let mut current = vec![0];\n            let mut j = alphabet.len() - 1;\n \
    \           for &l in &s {\n                if l.is_uppercase() {\n          \
    \          alphabet.sort_by_key(|x| x.cmp(&l));\n                    let x = alphabet[j].to_string();\n\
    \                    j -= 2;\n                    current.push(x);\n         \
    \       } else if l.is_lowercase() {\n                    alphabet.sort_by_key(|x|\
    \ x.cmp(&l));\n                    let x = alphabet[j].to_string();\n        \
    \            j -= 2;\n                    current.push(x);\n                }\
    \ else if l.is_digit() {\n                    let x = l.to_string();\n       \
    \             current.push(x);\n                    j = alphabet.len() - 2;\n\
    \                } else {\n                    let x = l.to_string();\n      \
    \              current.push(x);\n                }\n            }\n          \
    \  result += current;\n        }\n    }\n    let mut r = vec![0];\n    for i in\
    \ result.iter() {\n        r.push(*i);\n    }\n    r.reverse()\n        .iter()\n\
    \        .map(|s| s[1..])\n        .collect::<Vec<_>>()\n        .join(\"\")\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpviaygelu.rs:15:15\n\
    \   |\n15 |     for &s in &message {\n   |               ^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpviaygelu.rs:30:34\n\
    \   |\n30 |                     current.push(x);\n   |                       \
    \           ^ expected integer, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpviaygelu.rs:35:34\n   |\n35 |                     current.push(x);\n\
    \   |                                  ^ expected integer, found struct `String`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<_>`\n\
    \  --> /tmp/tmpviaygelu.rs:45:13\n   |\n45 |             result += current;\n\
    \   |             ------^^^^^^^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `Vec<_>`\n\nerror[E0599]: no method named `iter` found for\
    \ unit type `()` in the current scope\n  --> /tmp/tmpviaygelu.rs:53:10\n   |\n\
    53 |         .iter()\n   |          ^^^^ method not found in `()`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().filter(|c|c=='a' || c=='e' || c=='i'\
    \ || c=='o' || c=='u').map(|c|{\n        c + 'A'.to_string()\n    }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|c=='a' || c=='e' || c=='i' || c=='o' || c=='u').map(|c|{\n\
    \            c + 'a'.to_string()\n        }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|c=='a' || c=='e' || c=='i' || c=='o' || c=='u').map(|c|{\n\
    \            c + 'e'.to_string()\n        }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|c=='a' || c=='e' || c=='i' || c=='o' || c=='u').map(|c|{\n\
    \            c + 'i'.to_string()\n        }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|c=='a' || c=='e' || c=='i' || c=='o' || c=='u').map(|c|{\n\
    \            c + 'o'.to_string()\n        }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|c=='a' || c=='e' || c=='i' || c=='o' || c=='u').map(|c|{\n\
    \            c + 'u'.to_string()\n        }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|c=='a' || c=='e' || c=='i' || c=='o' || c=='u').map(|c|{\n\
    \            c + 'a'.to_string()\n        }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|c=='a' || c=='e' || c=='i' || c=='o' || c=='u').map(|c|{\n\
    \            c + 'e'.to_string()\n        }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|c=='a' || c=='e' || c=='i' || c=='o' || c=='u').map(|c|{\n\
    \            c + 'i'.to_string()\n        }).collect::<Vec<String>>().join().to_string()\n\
    \        .chars().filter(|c|\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpa71tm4ql.rs:39:24\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n39 |     \
    \    .chars().filter(|c|\n   |                        ^ unclosed delimiter\n40\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror: expected expression, found\
    \ `)`\n  --> /tmp/tmpa71tm4ql.rs:40:1\n   |\n40 | }\n   | ^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::with_capacity(message.len());\n\
    \n    for ch in message {\n        match ch {\n            ' ' | '\\t' | '.' |\
    \ '\\n' | ' ' => {\n                output.push('_');\n            }\n       \
    \     'A' => output.push('G'),\n            'B' => output.push('Y'),\n       \
    \     'C' => output.push('K'),\n            'D' => output.push('F'),\n       \
    \     'E' => output.push('J'),\n            'F' => output.push('L'),\n       \
    \     'G' => output.push('O'),\n            'H' => output.push('U'),\n       \
    \     'I' => output.push('N'),\n            'J' => output.push('P'),\n       \
    \     'K' => output.push('Q'),\n            'L' => output.push('R'),\n       \
    \     'M' => output.push('T'),\n            'N' => output.push('V'),\n       \
    \     'O' => output.push('W'),\n            'P' => output.push('S'),\n       \
    \     'Q' => output.push('X'),\n            'R' => output.push('Z'),\n       \
    \     'S' => output.push('A'),\n            'T' => output.push('B'),\n       \
    \     'U' => output.push('C'),\n            'V' => output.push('D'),\n       \
    \     'W' => output.push('E'),\n            'X' => output.push('F'),\n       \
    \     'Y' => output.push('G'),\n            'Z' => output.push('H'),\n       \
    \     '0' => output.push('I'),\n            '1' => output.push('J'),\n       \
    \     '2' => output.push('K'),\n            '3' => output.push('L'),\n       \
    \     '4' => output.push('M'),\n            '5' => output.push('N'),\n       \
    \     '6' => output.push('O'),\n            '7' => output.push('A'),\n       \
    \     '8' => output.push('B'),\n            '9' => output.push('C'),\n       \
    \     ch => output.push(ch),\n        }\n    }\n\n    output\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpkl1w73lb.rs:14:15\n\
    \   |\n14 |     for ch in message {\n   |               ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut coded_message = message;\n    let mut alphabet_index\
    \ = 26;\n\n    for mut letter in message.chars() {\n        let mut current_letter_code\
    \ = alphabet_index - letter.code();\n\n        // find the next 2 letters in the\
    \ alphabet that have \n        // the same value, and encode those\n        let\
    \ mut next_letter_code = 0;\n        while current_letter_code != next_letter_code\
    \ {\n            let next_letter_index = alphabet_index - current_letter_code;\n\
    \            next_letter_code = alphabet_index - letters[next_letter_index].code();\n\
    \            current_letter_code += letters[next_letter_index].code();\n     \
    \   }\n        coded_message += letters[current_letter_code].code();\n    }\n\
    \    coded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `letters` in this scope\n  --> /tmp/tmp7sfc6u58.rs:23:49\n\
    \   |\n23 |             next_letter_code = alphabet_index - letters[next_letter_index].code();\n\
    \   |                                                 ^^^^^^^ help: a local variable\
    \ with a similar name exists: `letter`\n\nerror[E0425]: cannot find value `letters`\
    \ in this scope\n  --> /tmp/tmp7sfc6u58.rs:24:36\n   |\n24 |             current_letter_code\
    \ += letters[next_letter_index].code();\n   |                                \
    \    ^^^^^^^ help: a local variable with a similar name exists: `letter`\n\nerror[E0425]:\
    \ cannot find value `letters` in this scope\n  --> /tmp/tmp7sfc6u58.rs:26:26\n\
    \   |\n26 |         coded_message += letters[current_letter_code].code();\n  \
    \ |                          ^^^^^^^ help: a local variable with a similar name\
    \ exists: `letter`\n\nerror[E0599]: no method named `code` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp7sfc6u58.rs:16:63\n   |\n16 |         let\
    \ mut current_letter_code = alphabet_index - letter.code();\n   |            \
    \                                                   ^^^^ method not found in `char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z'];\n\n    let mut map\
    \ = HashMap::new();\n    for char in &message {\n        map.entry(char.clone())\n\
    \            .or_insert(map.entry(char.clone()).or_insert(0)).1 += 1;\n    }\n\
    \n    alphabet.iter().for_each(|c| map.entry(c).or_insert(0));\n\n    let mut\
    \ encoded = String::new();\n    for c in message {\n        let value = map.entry(c).or_insert(0);\n\
    \        for a in alphabet {\n            if value == map.entry(a).or_insert(0)\
    \ {\n                encoded.push(a);\n            }\n        }\n    }\n\n   \
    \ return encoded;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpe11_duny.rs:14:19\n   |\n14 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `&String` is not an iterator\n  --> /tmp/tmpe11_duny.rs:15:17\n   |\n15 |  \
    \   for char in &message {\n   |                 ^^^^^^^^ `&String` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpe11_duny.rs:23:14\n\
    \   |\n23 |     for c in message {\n   |              ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe11_duny.rs:27:30\n   |\n27 |                 encoded.push(a);\n\
    \   |                              ^ expected `char`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected type `char`\n            found struct `std::ops::Range<char>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Convert message to lowercase\n    let mut lowercase\
    \ = message.to_lowercase();\n\n    // Swap case of each letter\n    for c in lowercase.chars()\
    \ {\n        lowercase = lowercase.swapcase();\n    }\n\n    // Remove vowels\
    \ from message\n    let mut vowels = vec!['a'..'z', 'e'..'i', 'o'..'u', 'a', 'e',\
    \ 'i', 'o'];\n    vowels.sort_unstable();\n    let mut index = 0;\n    \n    let\
    \ mut result = String::new();\n    \n    for letter in lowercase {\n        if\
    \ vowels.contains(&letter) {\n            let next_letter = lowercase[index].to_string();\n\
    \            result += &vowels[vowels.iter().position(|x| *x == &letter).unwrap()].to_string();\n\
    \            result += &next_letter;\n            index += 1;\n        } else\
    \ {\n            result += &letter;\n        }\n    }\n    \n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swapcase` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpektcpchk.rs:17:31\n   |\n17 |         lowercase\
    \ = lowercase.swapcase();\n   |                               ^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpektcpchk.rs:21:57\n\
    \   |\n21 |     let mut vowels = vec!['a'..'z', 'e'..'i', 'o'..'u', 'a', 'e',\
    \ 'i', 'o'];\n   |                                                         ^^^\
    \ expected struct `std::ops::Range`, found `char`\n   |\n   = note: expected struct\
    \ `std::ops::Range<char>`\n                found type `char`\n\nerror[E0277]:\
    \ the trait bound `std::ops::Range<char>: Ord` is not satisfied\n    --> /tmp/tmpektcpchk.rs:22:12\n\
    \     |\n22   |     vowels.sort_unstable();\n     |            ^^^^^^^^^^^^^ the\
    \ trait `Ord` is not implemented for `std::ops::Range<char>`\n     |\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpektcpchk.rs:27:19\n   |\n27 |     for letter\
    \ in lowercase {\n   |                   ^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpektcpchk.rs:29:31\n   |\n29\
    \ |             let next_letter = lowercase[index].to_string();\n   |        \
    \                       ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E03"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut letter\
    \ = String::new();\n\n    for c in message.chars() {\n        if c.to_ascii_lowercase().is_ascii_lowercase()\
    \ {\n            encoded.push(c);\n        } else {\n            if letter.len()\
    \ < 2 {\n                letter = String::from(c);\n            } else if letter.len()\
    \ > 2 {\n                letter = String::from(letter.chars().next().unwrap());\n\
    \            }\n\n            encoded.push((letter.chars().next().unwrap()) +\
    \ c);\n        }\n    }\n\n    return encoded;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmp7flbgkmd.rs:25:59\n\
    \   |\n25 |             encoded.push((letter.chars().next().unwrap()) + c);\n\
    \   |                          -------------------------------- ^ - char\n   |\
    \                          |\n   |                          char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut seen =\
    \ HashSet::new();\n    for ch in message.chars() {\n        if !seen.contains(&ch.to_ascii_lowercase())\
    \ {\n            seen.insert(ch.to_ascii_lowercase());\n            let i = en.chars().position(|c|\
    \ c==ch).unwrap();\n            result += en[i].to_ascii_lowercase();\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpb1qo2lc2.rs:13:20\n   |\n13 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `en` in this scope\n  --> /tmp/tmpb1qo2lc2.rs:17:21\n   |\n\
    17 |             let i = en.chars().position(|c| c==ch).unwrap();\n   |      \
    \               ^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `en` in this scope\n  --> /tmp/tmpb1qo2lc2.rs:18:23\n   |\n18 |            \
    \ result += en[i].to_ascii_lowercase();\n   |                       ^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            let mut pos = 0;\n           \
    \ match get_vowel(c) {\n                Some(vowel) => pos = 2 - vowel.pos(),\n\
    \                None => panic!(\"bad vowel: {}\", c),\n            }\n\n    \
    \        result.push_str(&message.chars()[..pos].to_string() + \"K\".to_string());\n\
    \            result.push_str(&message.chars()[pos + 1].to_string() + \"S\".to_string());\n\
    \        } else {\n            result.push_str(&c.to_string() + \"S\".to_string());\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_vowel` in this scope\n  --> /tmp/tmpul30b1sq.rs:17:19\n\
    \   |\n17 |             match get_vowel(c) {\n   |                   ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmpul30b1sq.rs:22:30\n   |\n22 |             result.push_str(&message.chars()[..pos].to_string()\
    \ + \"K\".to_string());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpul30b1sq.rs:23:30\n\
    \   |\n23 |             result.push_str(&message.chars()[pos + 1].to_string()\
    \ + \"S\".to_string());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0369]: cannot add `String` to `&String`\n  --> /tmp/tmpul30b1sq.rs:25:44\n\
    \   |\n25 |             result.push_str(&c.to_string() + \"S\".to_string());\n\
    \   |                             -------------- ^ --------------- String\n  \
    \ |                             |              |\n   |                       \
    \      |              `+` cannot be used to concatenate a `&str` with a `String`\n\
    \   |                             &String\n   |\nhelp: remove the borrow on the\
    \ left and add one on the right\n   |\n25 -             result.push_str(&c.to_string()\
    \ + \"S\".to_string());\n25 +             result.push_str(c.to_string() + &\"\
    S\".to_string());\n   | \n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0425, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut chars = Vec::new();\n    for i in message.chars()\
    \ {\n        let j = if i.is_uppercase() {\n            2\n        } else {\n\
    \            1\n        };\n        let replacement = english_letters[((i.to_owned()\
    \ - 65) + j)];\n        chars.push(replacement);\n    }\n    chars.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `english_letters` in this scope\n  -->\
    \ /tmp/tmp75nmkvfw.rs:19:27\n   |\n19 |         let replacement = english_letters[((i.to_owned()\
    \ - 65) + j)];\n   |                           ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmp75nmkvfw.rs:19:58\n\
    \   |\n19 |         let replacement = english_letters[((i.to_owned() - 65) + j)];\n\
    \   |                                             ------------ ^ -- {integer}\n\
    \   |                                             |\n   |                    \
    \                         char\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0369, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut alphabet: Vec<&str> = vec![\"a\".to_string(),\
    \ \"b\".to_string(), \"c\".to_string(), \"d\".to_string(), \"e\".to_string(),\
    \ \"f\".to_string(), \"g\".to_string(), \"h\".to_string(), \"i\".to_string(),\
    \ \"j\".to_string(), \"k\".to_string(), \"l\".to_string(), \"m\".to_string(),\
    \ \"n\".to_string(), \"o\".to_string(), \"p\".to_string(), \"q\".to_string(),\
    \ \"r\".to_string(), \"s\".to_string(), \"t\".to_string(), \"u\".to_string(),\
    \ \"v\".to_string(), \"w\".to_string(), \"x\".to_string(), \"y\".to_string(),\
    \ \"z\".to_string()];\n    let mut alphabet: Vec<&str> = vec![\"a\".to_string(),\
    \ \"b\".to_string(), \"c\".to_string(), \"d\".to_string(), \"e\".to_string(),\
    \ \"f\".to_string(), \"g\".to_string(), \"h\".to_string(), \"i\".to_string(),\
    \ \"j\".to_string(), \"k\".to_string(), \"l\".to_string(), \"m\".to_string(),\
    \ \"n\".to_string(), \"o\".to_string(), \"p\".to_string(), \"q\".to_string(),\
    \ \"r\".to_string(), \"s\".to_string(), \"t\".to_string(), \"u\".to_string(),\
    \ \"v\".to_string(), \"w\".to_string(), \"x\".to_string(), \"y\".to_string(),\
    \ \"z\".to_string()];\n    let mut vowel: Vec<&str> = vec![\"a\".to_string(),\
    \ \"e\".to_string(), \"i\".to_string(), \"o\".to_string(), \"u\".to_string()];\n\
    \    let mut index = 0u8;\n    let mut message2 = \"\";\n    let mut index2 =\
    \ 0;\n    let mut message3 = \"\";\n    for i in 0..message.len() {\n        if\
    \ message.chars()[index] == vowel[index2] {\n            message2 += alphabet[alphabet.len()\
    \ - 1 - index];\n            index += 1;\n        }\n        else {\n        \
    \    message2 += &message[index];\n            index += 1;\n        }\n      \
    \  if index == vowel.len() {\n            message2 += &message[index];\n     \
    \       index += 1;\n        }\n    }\n    for index in 0..message.len() {\n \
    \       if index != 0 && message.chars()[index] == vowel[index - 1] {\n      \
    \      index += 1;\n        }\n        if index != message.len() && message.chars()[index]\
    \ == vowel[index + 1] {\n            index += 1;\n        }\n        if index\
    \ != 0 && index != message.len() && message.chars()[index] == vowel[index - 1]\
    \ && message.chars()[index] == vowel[index + 1] {\n            message3 += &message[index];\n\
    \        }\n    }\n    message2\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcc2pynr6.rs:12:40\n   |\n\
    12 |     let mut alphabet: Vec<&str> = vec![\"a\".to_string(), \"b\".to_string(),\
    \ \"c\".to_string(), \"d\".to_string(), \"e\".to_string(), \"f\".to_string...\n\
    \   |                                        ^^^^^^^^^^^^^^^\n   |           \
    \                             |\n   |                                        expected\
    \ `&str`, found struct `String`\n   |                                        help:\
    \ consider borrowing here: `&\"a\".to_string()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcc2pynr6.rs:13:40\n   |\n13 |     let mut alphabet: Vec<&str> =\
    \ vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string(), \"d\".to_string(),\
    \ \"e\".to_string(), \"f\".to_string...\n   |                                \
    \        ^^^^^^^^^^^^^^^\n   |                                        |\n   |\
    \                                        expected `&str`, found struct `String`\n\
    \   |                                        help: consider borrowing here: `&\"\
    a\".to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcc2pynr6.rs:14:37\n\
    \   |\n14 |     let mut vowel: Vec<&str> = vec![\"a\".to_string(), \"e\".to_string(),\
    \ \"i\".to_string(), \"o\".to_string(), \"u\".to_string()];\n   |            \
    \                         ^^^^^^^^^^^^^^^\n   |                              \
    \       |\n   |                                     expected `&str`, found struct\
    \ `String`\n   |                                     help: consider borrowing\
    \ here: `&\"a\".to_string()`\n\nerror[E0608]: cannot index into a value of type\
    \ `Chars<'_>`\n  --> /tmp/tmpcc2pynr6.rs:20:12\n   |\n20 |         if message.chars()[index]\
    \ == vowel[index2] {\n   |            ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcc2pynr6.rs:21:55\n   |\n21 |             message2\
    \ += alphabet[alphabet.len() - 1 - index];\n   |                             \
    \                          ^^^^^ expected `usize`, found `u8`\n\nerror[E0277]:\
    \ cannot subtract `u8` from `usize`\n  --> /tmp/tmpcc2pynr6.rs:21:53\n   |\n21\
    \ |             message2 += alphabet[alphabet.len() - 1 - index];\n   |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let replacement = match c {\n            'A'..='Z' | 'a'..='z' =>\
    \ c - 'A'\n            'a'..='i' | 'A'..='I' => c - 'A' - 1,\n            'a'..='o'\
    \ | 'A'..='O' => c - 'A' - 2,\n            'a'..='u' | 'A'..='U' => c - 'A' -\
    \ 4,\n            '0'..='9' => c - '0',\n            _ => panic!(\"Invalid character\
    \ for swap case.\")\n        };\n        result.append(&mut encode(&replacement).to_string());\n\
    \        result.append(c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `'a'`\n\
    \  --> /tmp/tmpifxeubke.rs:16:13\n   |\n15 |             'A'..='Z' | 'a'..='z'\
    \ => c - 'A'\n   |                                   --        - expected one\
    \ of `,`, `.`, `?`, `}`, or an operator\n   |                                \
    \   |\n   |                                   while parsing the `match` arm starting\
    \ here\n16 |             'a'..='i' | 'A'..='I' => c - 'A' - 1,\n   |         \
    \    ^^^ unexpected token\n\nwarning: unreachable statement\n  --> /tmp/tmpifxeubke.rs:22:9\n\
    \   |\n14 |           let replacement = match c {\n   |  ___________________________-\n\
    15 | |             'A'..='Z' | 'a'..='z' => c - 'A'\n16 | |             'a'..='i'\
    \ | 'A'..='I' => c - 'A' - 1,\n17 | |             'a'..='o' | 'A'..='O' => c -\
    \ 'A' - 2,\n...  |\n20 | |             _ => panic!(\"Invalid character for swap\
    \ case.\")\n21 | |         };\n   | |_________- any code following this expression\
    \ is unreachable\n22 |           result.append(&mut encode(&replacement).to_string());\n\
    \   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable\
    \ statement\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpifxeubke.rs:22:16\n   |\n22 |         result.append(&mut encode(&replacement).to_string());\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpifxeubke.rs:22:35\n   |\n22 |         result.append(&mut\
    \ encode(&replacement).to_string());\n   |                                   ^^^^^^^^^^^^\
    \ expected struct `String`, found reference\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\nhelp: consider removing the borrow\n\
    \   |\n22 -         result.append(&mut encode(&replacement).to_string());\n22\
    \ +         result.append(&mut encode(replacement).to_string());\n   | \n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpifxeubke.rs:23:16\n   |\n23 |         result.append(c)"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n    let mut letters =\
    \ ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    for &c in &message\
    \ {\n        if let Some(c) = c.to_lowercase() {\n            let idx = letters.iter().position(|c|\
    \ c == c);\n            result += if idx < 2 {\n                \"\".to_string()\n\
    \            } else {\n                let mut result = String::new();\n     \
    \           let mut prev_idx = 0;\n                for idx in (0..(letters.len()\
    \ - 2)).rev() {\n                    if idx != prev_idx {\n                  \
    \      result += letters[prev_idx..idx].to_string();\n                    }\n\
    \                    prev_idx = idx;\n                }\n                if idx\
    \ != 0 {\n                    result += letters[0..(idx-1)].to_string();\n   \
    \             }\n                vowels[(idx + 2)..].iter().cloned().for_each(|c|\
    \ result += \"H\".to_string());\n                vowels[0..(idx + 2)].iter().cloned().for_each(|c|\
    \ result += \"H\".to_string());\n                result + vowels[(idx + 2)..].iter().cloned().for_each(|c|\
    \ result += \"H\".to_string());\n                result + vowels[0..(idx + 2)].iter().cloned().for_each(|c|\
    \ result += \"H\".to_string())\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpqx88x89f.rs:15:15\n\
    \   |\n15 |     for &c in &message {\n   |               ^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqx88x89f.rs:18:32\n\
    \   |\n18 |             result += if idx < 2 {\n   |                         \
    \       ^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n18 |             result += if idx < Some(2) {\n\
    \   |                                +++++ +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqx88x89f.rs:19:17\n   |\n19 |                 \"\".to_string()\n\
    \   |                 ^^^^^^^^^^^^^^\n   |                 |\n   |           \
    \      expected `&str`, found struct `String`\n   |                 help: consider\
    \ borrowing here: `&\"\".to_string()`\n\nerror[E0599]: `[char]` doesn't implement\
    \ `std::fmt::Display`\n  --> /tmp/tmpqx88x89f.rs:25:58\n   |\n25 |           \
    \              result += letters[prev_idx..idx].to_string();\n   |           \
    \                                               ^^^^^^^^^ `[char]` cannot be formatted\
    \ with the default formatter\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `[char]: std::fmt::Display`\n           which is\
    \ required by `[char]: ToString`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqx88x89f.rs:29:27\n\
    \   |\n29 |                 if idx != 0 {\n   |                           ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n29 |                 if idx != Some(0) {\n   |                        \
    \   +++++ +\n\nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n\
    \  --> /tmp/tmpqx88x89f.rs:30:46\n   |\n30 |                     result += letters[0..(idx-1)].to_string();\n\
    \   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n\n    //\
    \ Add spaces in between each letter to make the message \n    // easier to read\
    \ when encoded.\n    for &c in message.chars() {\n        encoded_message.push_str(&c.to_string());\n\
    \        encoded_message.push_str(\" \");\n    }\n\n    // Convert each letter\
    \ to its english alphabet equivalent. \n    // This is done by adding +1 to the\
    \ index of the letter \n    // that corresponds to the index 2 places ahead of\
    \ its \n    // corresponding vowel. \n    for &c in message.chars() {\n      \
    \  let index = (c.to_ascii_lowercase().as_byte().unwrap() + 2) % 26;\n\n     \
    \   let mut ascii_letter = String::new();\n        ascii_letter.resize(1);\n \
    \       ascii_letter[0] = c.to_ascii_lowercase()[0];\n\n        encoded_message.push_str(&ascii_letter[..]);\n\
    \        encoded_message.push_str(\" \");\n    }\n\n    // Remove the spaces added\
    \ between letters to make the\n    // encoded message easier to read\n    encoded_message.split_whitespace().to_owned()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk2csdcwu.rs:16:9\n   |\n\
    16 |     for &c in message.chars() {\n   |         ^^    --------------- this\
    \ expression has type `Option<char>`\n   |         |\n   |         expected `char`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `c`\n   |\n   = note:   expected type `char`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk2csdcwu.rs:25:9\n   |\n25 | \
    \    for &c in message.chars() {\n   |         ^^    --------------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0599]: no method named `resize` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpk2csdcwu.rs:29:22\n   |\n29 |         ascii_letter.resize(1);\n\
    \   |                      ^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpk2csdcwu.rs:30:9\n\
    \   |\n30 |         ascii_letter[0] = c.to_ascii_lowercase()[0];\n   |       \
    \  ^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk2csdcwu.rs:38:5\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                               ------ expected `String`\
    \ because of return type\n...\n38 |     encoded_message.split_whitespace().to_owned()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found struct `SplitWhi"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().filter(|c| *c >= 'a' && *c <= 'z').map(|c|\
    \ *c + 1).collect()\n        .fold(\"\".to_string(), |mut acc, c| {\n        \
    \    let mut i = acc.len();\n            let mut j = 0;\n            while j <\
    \ i {\n                let next = i + j;\n                if *acc + 1 == *acc\
    \ + j && acc + 1 != acc + j {\n                    let vowel = acc + j;\n    \
    \                let replacement = acc + next;\n                    *acc += 1;\n\
    \                    *replacement = vowel;\n                }\n              \
    \  i += 1;\n                j += 1;\n            }\n            acc + 1;\n   \
    \     })\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpjanz74xo.rs:12:64\n\
    \   |\n12 |     message.chars().filter(|c| *c >= 'a' && *c <= 'z').map(|c| *c\
    \ + 1).collect()\n   |                                                       \
    \         ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = \"\";\n    for c in message.chars()\
    \ {\n        let mut c2 = c;\n        match c {\n            'A' | 'a' => c2 =\
    \ 'B',\n            'B' | 'B' => c2 = 'A',\n            'C' | 'c' => c2 = 'C',\n\
    \            'D' | 'd' => c2 = 'D',\n            'E' | 'e' => c2 = 'E',\n    \
    \        'F' | 'f' => c2 = 'F',\n            'G' | 'g' => c2 = 'G',\n        \
    \    'H' | 'h' => c2 = 'H',\n            'I' | 'i' => c2 = 'I',\n            'J'\
    \ | 'j' => c2 = 'J',\n            'K' | 'k' => c2 = 'K',\n            'L' | 'l'\
    \ => c2 = 'L',\n            'M' | 'm' => c2 = 'M',\n            'N' | 'n' => c2\
    \ = 'N',\n            'O' | 'o' => c2 = 'O',\n            'P' | 'p' => c2 = 'P',\n\
    \            'Q' | 'q' => c2 = 'Q',\n            'R' | 'r' => c2 = 'R',\n    \
    \        'S' | 's' => c2 = 'S',\n            'T' | 't' => c2 = 'T',\n        \
    \    'U' | 'u' => c2 = 'U',\n            'V' | 'v' => c2 = 'V',\n            'W'\
    \ | 'w' => c2 = 'W',\n            'X' => 'X',\n            'Y' | 'y' => c2 = 'Y',\n\
    \            'Z' => 'Z',\n            _ => continue,\n        }\n        output\
    \ += c2;\n    }\n    return output;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp15_lxt9b.rs:39:20\n\
    \   |\n15 | /         match c {\n16 | |             'A' | 'a' => c2 = 'B',\n17\
    \ | |             'B' | 'B' => c2 = 'A',\n18 | |             'C' | 'c' => c2 =\
    \ 'C',\n...  |\n38 | |             'W' | 'w' => c2 = 'W',\n   | |            \
    \              -------- this and all prior arms are found to be of type `()`\n\
    39 | |             'X' => 'X',\n   | |                    ^^^ expected `()`, found\
    \ `char`\n...  |\n42 | |             _ => continue,\n43 | |         }\n   | |_________-\
    \ `match` arms have incompatible types\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmp15_lxt9b.rs:44:9\n   |\n\
    44 |         output += c2;\n   |         ------^^^^^^\n   |         |\n   |  \
    \       cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp15_lxt9b.rs:46:12\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                               ------ expected `String` because of return\
    \ type\n...\n46 |     return output;\n   |            ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |            |\n   |            expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut firstVowel\
    \ = String::new();\n    let mut secondVowel = String::new();\n    let mut currentChar\
    \ = String::new();\n    let mut count = 1;\n    let mut vowels = HashSet::new();\n\
    \    for (i, &letter) in message.chars().enumerate() {\n        // If this is\
    \ the first letter of the word\n        if i == 0 {\n            // We first check\
    \ to see if the first letter is a vowel\n            vowels.insert(letter);\n\
    \            // If so, we don't need to check again\n            if let Some(vowel)\
    \ = vowels.next() {\n                firstVowel = vowel;\n            } else {\n\
    \                currentChar = letter;\n            }\n        } else {\n    \
    \        // If this is not the first letter of the word\n            // And if\
    \ we are at the last letter\n            if i == message.chars().len() - 1 {\n\
    \                // The last letter of the word\n                // Check to see\
    \ if the last letter is a vowel\n                vowels.insert(letter);\n    \
    \            if let Some(vowel) = vowels.next() {\n                    secondVowel\
    \ = vowel;\n                } else {\n                    // The last letter is\
    \ not a vowel\n                    // Check if the first letter is a vowel\n \
    \                   let prev_letter_was = vowels.contains(&letter);\n        \
    \            vowels.insert(letter);\n                    if let Some(vowel) =\
    \ vowels.next() {\n                        currentChar = vowel;\n            \
    \            if prev_letter_was {\n                            // We have a vowel\
    \ in front of our current letter\n                            // So we replace\
    \ that vowel with that letter\n                            currentChar = letter;\n\
    \                        }\n                    } else {\n                   \
    \     // We don't have a vowel in front of our current letter\n              \
    \          // So we leave the letter in place\n                        currentChar\
    \ = letter;\n                    }\n                }\n            } else {\n\
    \                // If this is not the last letter of the word\n             \
    \   // Get the vowel next to the current letter\n                if let Some(vowel)\
    \ = vowels.next() {\n                    // The vowel next to the current letter\
    \ is in the hashset\n                    // So we replace the vowel with the current\
    \ letter\n                    currentChar = vowel;\n                } else {\n\
    \                    // We haven't got a vowel next to the current letter\n  \
    \                  // So we put the current letter in place\n                \
    \    currentChar = letter;\n                }\n            }\n            // If\
    \ the current letter isn't a vowel, \n            // then we add the current letter\
    \ to the result\n            if !vowels.contains(&currentChar) {\n           \
    \     result.push_str(&currentChar);\n            } else {\n                //\
    \ If the current letter IS a vowel, \n                // then we add the letter\
    \ that appears 2 letters ahead \n                // of the vowel to the result\n\
    \                result.push_str(&firstVowel\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7fahz9xl.rs:87:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     for (i, &letter) in message.chars().enumerate()\
    \ {\n   |                                                     - unclosed delimiter\n\
    ...\n29 |         } else {\n   |                - unclosed delimiter\n...\n73\
    \ |             } else {\n   |                    - this delimiter might not be\
    \ properly closed...\n...\n78 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n87 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmp7fahz9xl.rs:77:32\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |                                      - closing delimiter possibly meant\
    \ for this\n...\n77 |                 result.push_str(&firstVowel\n   |      \
    \                          ^ unclosed delimiter\n78 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmp7fahz9xl.rs:17:22\n   |\n17 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7fahz9xl.rs:18:13\n   |\n18 |     for (i, &letter)\
    \ in message.chars().enumerate() {\n   |             ^^^^^^^     ---------------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected `char`, found reference\n   |             help: you can\
    \ probably remove the explicit borrow: `letter`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror[E0599]: no method named `len`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmp7fahz9xl.rs:32:37\n\
    \   |\n32 |             if i == message.chars().len() - 1 {\n   |            \
    \                         ^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7fahz9xl.rs:18:5\n   |\n11 |   fn encode(message:\
    \ Stri"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  message.chars().map(|c|{\n    if c.is_uppercase() {\n\
    \      c + &('A' - 1);\n    } else if c.is_lowercase() {\n      c + &('a' - 1);\n\
    \    } else {\n      c.to_ascii_lowercase()\n    }\n  }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpj77rkts9.rs:14:17\n\
    \   |\n14 |       c + &('A' - 1);\n   |             --- ^ - {integer}\n   |  \
    \           |\n   |             char\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `char`\n  --> /tmp/tmpj77rkts9.rs:16:17\n   |\n16 |       c + &('a' - 1);\n\
    \   |             --- ^ - {integer}\n   |             |\n   |             char\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = \"\";\n    for c in message.chars()\
    \ {\n        if let Some(pos) = find_next_vowel_in_same_case_at(&c, &message)\
    \ {\n            let vowel = &message[pos + 1];\n            let next_vowel =\
    \ &message[pos + 2];\n            result += c.to_ascii_lowercase();\n        \
    \    result += &vowel;\n            result += &next_vowel;\n        } else {\n\
    \            result += &c;\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_next_vowel_in_same_case_at` in\
    \ this scope\n  --> /tmp/tmpk0kur437.rs:14:28\n   |\n14 |         if let Some(pos)\
    \ = find_next_vowel_in_same_case_at(&c, &message) {\n   |                    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpk0kur437.rs:17:13\n\
    \   |\n17 |             result += c.to_ascii_lowercase();\n   |             ------^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpk0kur437.rs:18:13\n\
    \   |\n18 |             result += &vowel;\n   |             ------^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpk0kur437.rs:19:13\n\
    \   |\n19 |             result += &next_vowel;\n   |             ------^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpk0kur437.rs:21:13\n\
    \   |\n21 |             result += &c;\n   |             ------^^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk0kur437.rs:24:5\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                               ------ expected `String`\
    \ because of return type\n...\n24 |     result\n   |     ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::with_capacity(message.len());\n\
    \    for i in 0..message.len() {\n        let mut index = 0;\n        while index\
    \ < message.len() && i < message.len() {\n            if message[i] >= 'a' &&\
    \ message[i] <= 'z' {\n                encoded.push((message[i] - 'a' + 2) as\
    \ char);\n                index += 1;\n            }\n            else if message[i]\
    \ >= 'A' && message[i] <= 'Z' {\n                encoded.push((message[i] - 'A'\
    \ + 2) as char);\n                index += 1;\n            }\n            else\
    \ if message[i] >= '0' && message[i] <= '9' {\n                encoded.push((message[i]\
    \ - '0' + 2) as char);\n                index += 1;\n            }\n         \
    \   else if message[i] == '.' || message[i] == '!' || message[i] == '?' {\n  \
    \              encoded.push('.');\n                index += 1;\n            }\n\
    \            else if message[i] == '!' || message[i] == '?' {\n              \
    \  encoded.push('.');\n                index += 1;\n            }\n          \
    \  else if message[i] == '!' || message[i] == '?' {\n                encoded.push('.');\n\
    \                index += 1;\n            }\n            else if message[i] ==\
    \ '!' || message[i] == '?' {\n                encoded.push('.');\n           \
    \     index += 1;\n            }\n            else if message[i] == '!' || message[i]\
    \ == '?' {\n                encoded.push('.');\n                index += 1;\n\
    \            }\n            else if message[i] == '!' || message[i] == '?' {\n\
    \                encoded.push('.');\n                index += 1;\n           \
    \ }\n            else if message[i] == '!' || message[i] == '?' {\n          \
    \      encoded.push('.');\n                index += 1;\n            }\n      \
    \      else if message[i] == '!' || message[i] == '?' {\n                encoded.push('.');\n\
    \                index += 1;\n            }\n            else if message[i] ==\
    \ '!' || message[i] == '?' {\n                encoded.push('.');\n           \
    \     index += 1;\n            }\n            else if message[i] == '!' || message[i]\
    \ == '?' {\n                encoded.push('.');\n                index += 1;\n\
    \            }\n            else if message[i] == '!' || message[i] == '?' {\n\
    \                encoded.push('.');\n                index += 1;\n           \
    \ }\n            else if message[i] == '!' || message[i] == '?' {\n          \
    \      encoded.push('.');\n                index += 1;\n            }\n      \
    \      else if message[i] == '!' || message[i] == '?' {\n                encoded.\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprjis8t7q.rs:87:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n12 |     let mut encoded = String::with_capacity(message.len());\n\
    13 |     for i in 0..message.len() {\n   |                               - unclosed\
    \ delimiter\n14 |         let mut index = 0;\n15 |         while index < message.len()\
    \ && i < message.len() {\n   |                                               \
    \           - unclosed delimiter\n...\n76 |             else if message[i] ==\
    \ '!' || message[i] == '?' {\n   |                                           \
    \                 - this delimiter might not be properly closed...\n77 |     \
    \            encoded.\n78 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n87 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmprjis8t7q.rs:78:1\n\
    \   |\n78 | }\n   | ^\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmprjis8t7q.rs:16:16\n   |\n16 |             if message[i]\
    \ >= 'a' && message[i] <= 'z' {\n   |                ^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprjis8t7q.rs:16:37\n   |\n16 |             if message[i] >= 'a'\
    \ && message[i] <= 'z' {\n   |                                     ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for (i, item)\
    \ in message.chars().enumerate() {\n        let vowel_pos = item.as_byte().unwrap();\n\
    \        let vowel = &'a' + vowel_pos.0;\n        let consonant_pos = vowel_pos.1.wrapping_add(1).unwrap();\n\
    \        let consonant = &'a' + consonant_pos.0;\n        result.push_str(&vowel.to_string());\n\
    \        result.push_str(&consonant.to_string());\n        result.push_str(\"\
    \  \");\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_byte` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpf0sqaft8.rs:14:30\n   |\n14 |         let vowel_pos = item.as_byte().unwrap();\n\
    \   |                              ^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = \"\";\n\n    for (i, letter)\
    \ in message.chars().enumerate() {\n        let mut new_letter = letter;\n\n \
    \       loop {\n            if letter == 'z' {\n                break;\n     \
    \       }\n            \n            let mut i = i;\n\n            if new_letter\
    \ == letter {\n                i += 1;\n                continue;\n          \
    \  }\n\n            if let Some(next) = &message.chars()[i..].next() {\n     \
    \           let mut next_letter = next;\n\n                while next_letter ==\
    \ letter {\n                    next_letter = &message.chars()[i..].next()?;\n\
    \                    i += 1;\n                }\n                \n          \
    \      if next_letter == letter {\n                    new_letter += next;\n \
    \                   i += 1;\n                }\n            }\n        }\n\n \
    \       new_message += new_letter;\n    }\n    \n    new_message\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpewll9354.rs:29:34\n\
    \   |\n29 |             if let Some(next) = &message.chars()[i..].next() {\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `Chars<'_>`\n  --> /tmp/tmpewll9354.rs:33:36\n  \
    \ |\n33 |                     next_letter = &message.chars()[i..].next()?;\n \
    \  |                                    ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpewll9354.rs:33:63\n\
    \   |\n11 | / fn encode(message: String) -> String {\n12 | |     let mut new_message\
    \ = \"\";\n13 | |\n14 | |     for (i, letter) in message.chars().enumerate() {\n\
    ...  |\n33 | |                     next_letter = &message.chars()[i..].next()?;\n\
    \   | |                                                               ^ cannot\
    \ use the `?` operator in a function that returns `String`\n...  |\n47 | |   \
    \  new_message\n48 | | }\n   | |_- this function should return `Result` or `Option`\
    \ to accept `?`\n   |\n   = help: the trait `FromResidual<_>` is not implemented\
    \ for `String`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpewll9354.rs:32:35\n\
    \   |\n32 |                 while next_letter == letter {\n   |              \
    \                     ^^ no implementation for `&_ == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&_`\n\nerror[E0277]: can't\
    \ compare `&_` with `char`\n  --> /tmp/tmpewll9354.rs:37:32\n   |\n37 |      \
    \           if next_letter == letter {\n   |                                ^^\
    \ no implementation for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&_`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `char`\n  --> /tmp/tmpewll9354.rs:38:21\n   |\n38\
    \ |                     new_letter += next;\n   |                     ----------^^^^^^^^\n\
    \   |                     |\n   |                     cannot use `+=` on type\
    \ `char`\n\nerror[E036"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: Vec<u8> = vec![0; message.len()];\n\
    \    \n    for (i, ch) in message.chars().enumerate() {\n        if ch.is_uppercase()\
    \ {\n            let x = ch.to_lowercase().into();\n            encoded.push((x\
    \ ^ 0xff) as u8);\n        }\n        else {\n            encoded.push((ch.to_lowercase().into()\
    \ ^ 0xff) as u8);\n        }\n    }\n    \n    let mut encoded = encoded.clone();\n\
    \    let mut index = 0;\n    \n    for ch in encoded {\n        let next_ch =\
    \ encoded[index + 2];\n        \n        if ch >= 0x41 && ch <= 0x5A {\n     \
    \       if next_ch >= 0x41 && next_ch <= 0x5A {\n                encoded.swap(index,\
    \ index + 2);\n            }\n            else {\n                encoded.swap(index,\
    \ index + 1);\n            }\n        }\n        else {\n            if next_ch\
    \ >= 0x41 && next_ch <= 0x7A {\n                encoded.swap(index, index + 2);\n\
    \            }\n            else {\n                encoded.swap(index, index);\n\
    \            }\n        }\n        \n        index += 1;\n    }\n    \n    let\
    \ mut encoded = encoded.clone();\n    \n    for ch in encoded {\n        let mut\
    \ index = 0;\n        \n        while index < 4 {\n            let mut next_ch\
    \ = encoded[index + 2];\n            \n            if ch >= 0x41 && ch <= 0x5A\
    \ {\n                if next_ch >= 0x41 && next_ch <= 0x5A {\n               \
    \     encoded.swap(index, index + 2);\n                }\n                else\
    \ {\n                    encoded.swap(index, index + 1);\n                }\n\
    \            }\n            else {\n                if next_ch >= 0x41 && next_ch\
    \ <= 0x7A {\n                    encoded.swap(index, index + 2);\n           \
    \     }\n                else {\n                    encoded.swap(index, index);\n\
    \                }\n            }\n            index += 1;\n        }\n    }\n\
    \    \n    String::from_utf8(encoded)\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq9_e4a7_.rs:78:5\n   |\n\
    11 | fn encode(message: String) -> String {\n   |                            \
    \   ------ expected `String` because of return type\n...\n78 |     String::from_utf8(encoded)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Result`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::with_capacity(message.len());\n\
    \    \n    for &c in message {\n        if c.is_lowercase() {\n            if\
    \ c == 'a' {\n                encoded += \"a\";\n            } else if c == 'e'\
    \ {\n                encoded += \"e\";\n            } else if c == 'i' {\n   \
    \             encoded += \"i\";\n            } else if c == 'o' {\n          \
    \      encoded += \"o\";\n            } else if c == 'u' {\n                encoded\
    \ += \"u\";\n            } else {\n                encoded += &c.to_string();\n\
    \            }\n        } else {\n            encoded += &c.to_string();\n   \
    \     }\n    }\n    \n    return encoded;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp77jkpf_e.rs:14:15\n\
    \   |\n14 |     for &c in message {\n   |               ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.isEmpty() {\n        return \"\";\n    }\n\
    \n    let mut result = vec![];\n    let vowels = vec![\"A\", \"a\", \"E\", \"\
    e\", \"I\", \"i\", \"O\", \"o\", \"U\", \"u\"];\n\n    let mut message_bytes =\
    \ Vec::new();\n    for &c in message {\n        if c == ' ' {\n            let\
    \ vowel = if let Some(v) = vowels.iter().next() {\n                (v.to_ascii_lowercase(),\
    \ v.to_ascii_lowercase()) \n            } else { \n                (\"\", \"\"\
    )\n            };\n            result.push((c[0], c[1]));\n            result.push((c[1],\
    \ c[0]));\n            result.push((vowel[0], vowel[1]));\n            result.push((vowel[1],\
    \ vowel[0]));\n        } else {\n            result\n                .iter()\n\
    \                .map(|(first, second)| (*first).to_ascii_lowercase() + (*second).to_ascii_lowercase())\n\
    \                .filter(|&char| !char.chars().any(|c| !vowels.contains(c)))\n\
    \                .collect()\n                .cloned()\n                .iter()\n\
    \                .map(|&char| char.to_ascii_lowercase())\n                .cloned()\n\
    \                .collect::<String>()\n                .push_str(&c);\n      \
    \  }\n    }\n\n    result\n        .iter()\n        .map(|&(char1, char2)| (char1,\
    \ char2))\n        .filter(|&(_, char)| !char.chars().any(|c| !vowels.contains(c)))\n\
    \        .collect()\n        .cloned()\n        .iter()\n        .map(|&char|\
    \ char.to_ascii_lowercase())\n        .cloned()\n        .collect::<String>()\n\
    \        .push_str(\"_\")\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `isEmpty` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpaoxwy9x_.rs:12:16\n   |\n12 |     if message.isEmpty()\
    \ {\n   |                ^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_empty`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaoxwy9x_.rs:13:16\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \          ------ expected `String` because of return type\n12 |     if message.isEmpty()\
    \ {\n13 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpaoxwy9x_.rs:20:15\n   |\n20 |     for &c in message {\n   |   \
    \            ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpaoxwy9x_.rs:25:17\n\
    \   |\n22 |               let vowel = if let Some(v) = vowels.iter().next() {\n\
    \   |  _________________________-\n23 | |                 (v.to_ascii_lowercase(),\
    \ v.to_ascii_lowercase()) \n   | |                 ------------------------------------------------\
    \ expected because of this\n24 | |             } else { \n25 | |             \
    \    (\"\", \"\")\n   | |                 ^^^^^^^^ expected struct `String`, found\
    \ `&str`\n26 | |             };\n   | |_____________- `if` and `else` have incompatible\
    \ types\n   |\n   = note: expected tuple `(String, String)`\n              found\
    \ tuple `(&str, &str)`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut vowels = \"aeiou\";\n    let mut alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\";\n    let mut message_copy = message.clone();\n\
    \    let mut i = 0;\n\n    loop {\n        // Check if we have found a suitable\
    \ replacement for the first vowel.\n        if message_copy[i] in vowels {\n \
    \           let replacement = alphabet[alphabet.index(message_copy[i])+2];\n \
    \           let new_string = message_copy.replace(i+1, i+2, replacement);\n  \
    \          i += 3;\n            message_copy = new_string.clone();\n         \
    \   continue;\n        }\n        break;\n    }\n    message_copy\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpzhwlzfzo.rs:19:28\n\
    \   |\n19 |         if message_copy[i] in vowels {\n   |         --          \
    \       ^^ expected `{`\n   |         |\n   |         this `if` expression has\
    \ a condition, but no block\n\nwarning: unreachable expression\n  --> /tmp/tmpzhwlzfzo.rs:28:5\n\
    \   |\n17 | /     loop {\n18 | |         // Check if we have found a suitable\
    \ replacement for the first vowel.\n19 | |         if message_copy[i] in vowels\
    \ {\n20 | |             let replacement = alphabet[alphabet.index(message_copy[i])+2];\n\
    ...  |\n26 | |         break;\n27 | |     }\n   | |_____- any code following this\
    \ expression is unreachable\n28 |       message_copy\n   |       ^^^^^^^^^^^^\
    \ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowel_count:\
    \ usize = 0;\n    for c in message.chars() {\n        if let Some(letter) = get_letter_for_case(c.to_string())\
    \ {\n            if let Some(vowel) = get_vowel_for_case(letter) {\n         \
    \       encoded.push_str(vowel.to_string());\n                vowel_count += 1;\n\
    \            } else {\n                encoded.push_str(letter);\n           \
    \ }\n        } else {\n            encoded.push_str(c.to_string());\n        }\n\
    \    }\n    if vowel_count > 1 {\n        let mut first_vowel: Option<String>\
    \ = Some(\"\");\n        for vowel in vowel_chars().iter().cloned().skip(vowel_count\
    \ - 1) {\n            let mut found = false;\n            for c in encoded.chars()\
    \ {\n                if let Some(letter) = get_letter_for_case(c) {\n        \
    \            if let Some(vowel) = get_vowel_for_case(letter) {\n             \
    \           if vowel == vowel {\n                            first_vowel = Some(vowel.to_string());\n\
    \                            found = true;\n                        }\n      \
    \              }\n                }\n            }\n            if !found {\n\
    \                first_vowel = Some(vowel.to_string());\n                break;\n\
    \            }\n        }\n        if let Some(vowel) = get_vowel_for_case(first_vowel.as_ref().unwrap())\
    \ {\n            encoded.push_str(vowel);\n        }\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_letter_for_case` in this scope\n\
    \  --> /tmp/tmp0npd4nu0.rs:15:31\n   |\n15 |         if let Some(letter) = get_letter_for_case(c.to_string())\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `get_vowel_for_case` in this scope\n\
    \  --> /tmp/tmp0npd4nu0.rs:16:34\n   |\n16 |             if let Some(vowel) =\
    \ get_vowel_for_case(letter) {\n   |                                  ^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `vowel_chars`\
    \ in this scope\n  --> /tmp/tmp0npd4nu0.rs:28:22\n   |\n28 |         for vowel\
    \ in vowel_chars().iter().cloned().skip(vowel_count - 1) {\n   |             \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `get_letter_for_case` in this scope\n  --> /tmp/tmp0npd4nu0.rs:31:39\n   |\n\
    31 |                 if let Some(letter) = get_letter_for_case(c) {\n   |    \
    \                                   ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `get_vowel_for_case` in this scope\n  -->\
    \ /tmp/tmp0npd4nu0.rs:32:42\n   |\n32 |                     if let Some(vowel)\
    \ = get_vowel_for_case(letter) {\n   |                                       \
    \   ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `get_vowel_for_case` in this scope\n  --> /tmp/tmp0npd4nu0.rs:45:30\n   |\n\
    45 |         if let Some(vowel) = get_vowel_for_case(first_vowel.as_ref().unwrap())\
    \ {\n   |                              ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0npd4nu0.rs:23:30\n   |\n23 |\
    \             encoded.push_str(c.to_string());\n   |                         \
    \     ^^^^^^^^^^^^^\n   |                              |\n   |               \
    \               expected `&str`, found struct `String`\n   |                 \
    \             help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0npd4nu0.rs:27:52\n   |\n27 |         let mut\
    \ first_vowel: Option<String> = Some("
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|x| x.to_ascii_lowercase()).collect::<Vec<_>>().into_iter().cycle()\n\
    \        .flat_map(|x| x.zip(x.cloned()+x).map(|(x, y)| if x.is_ascii_lowercase()\
    \ && x.is_ascii_uppercase() && (x.eq_ignore_ascii_case(y) || x.eq_ignore_ascii_case(z))\
    \ then x.to_string().to_string() else y.to_string().to_string() ).collect::<Vec<_>>()).collect::<Vec<_>>().join::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmp164uarhj.rs:13:168\n \
    \  |\n13 | ...x, y)| if x.is_ascii_lowercase() && x.is_ascii_uppercase() && (x.eq_ignore_ascii_case(y)\
    \ || x.eq_ignore_ascii_case(z)) then x.to_strin...\n   |           -- this `if`\
    \ expression has a condition, but no block                                   \
    \                        ^^^^ expected `{`\n   |\nhelp: try placing this code\
    \ inside a block\n   |\n13 |         .flat_map(|x| x.zip(x.cloned()+x).map(|(x,\
    \ y)| if x.is_ascii_lowercase() && x.is_ascii_uppercase() && (x.eq_ignore_ascii_case(y)\
    \ || x.eq_ignore_ascii_case(z)) { then } x.to_string().to_string() else y.to_string().to_string()\
    \ ).collect::<Vec<_>>()).collect::<Vec<_>>().join::<String>()\n   |          \
    \                                                                            \
    \                                                                            \
    \      +      +\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    \n    match message {\n        \"\" => \"\".to_string(),\n\
    \        _ => message.chars().filter(|c| {\n            match (c as u32) {\n \
    \               'A'..'Z' => true,\n                'a'..'z' => true,\n       \
    \         _ => false\n            }\n        }).map(|c|\n            (c as u32).to_string().chars().enumerate()\n\
    \                .filter_map(|(i, c)| (i + 1).to_string().chars().enumerate().filter_map(|(_,\
    \ c)| c))\n                .filter_map(|(_, c)|\n                    match (c\
    \ as u32) {\n                        'A'..'Z' => c.to_string() + c.to_string()\
    \ + 'S',\n                        'a'..'z' => c.to_string() + c.to_string() +\
    \ 's',\n                        '0'..'9' => c.to_string() + c.to_string() + '0',\n\
    \                        _ => c.to_string()\n                    }\n         \
    \       )\n                .collect()\n        ).collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpwayr_9x4.rs:17:17\n\
    \   |\n17 |                 'A'..'Z' => true,\n   |                 ^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpwayr_9x4.rs:18:17\n   |\n18 |                 'a'..'z' => true,\n\
    \   |                 ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpwayr_9x4.rs:26:25\n   |\n26 |                         'A'..'Z'\
    \ => c.to_string() + c.to_string() + 'S',\n   |                         ^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpwayr_9x4.rs:27:25\n   |\n27 |                         'a'..'z'\
    \ => c.to_string() + c.to_string() + 's',\n   |                         ^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpwayr_9x4.rs:28:25\n   |\n28 |                         '0'..'9'\
    \ => c.to_string() + c.to_string() + '0',\n   |                         ^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nwarning: unnecessary parentheses around `match` scrutinee\
    \ expression\n  --> /tmp/tmpwayr_9x4.rs:16:19\n   |\n16 |             match (c\
    \ as u32) {\n   |                   ^        ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n16 -             match\
    \ (c as u32) {\n16 +             match c as u32 {\n   | \n\nwarning: unnecessary\
    \ parentheses around `match` scrutinee expression\n  --> /tmp/tmpwayr_9x4.rs:25:27\n\
    \   |\n25 |                     match (c as u32) {\n   |                     \
    \      ^        ^\n   |\nhelp: remov"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = \"\";\n    for ch in message.chars()\
    \ {\n        let index = ascii_lowercase().find(|&c| c == ch);\n        let mut\
    \ next = index;\n        next = next.checked_sub(2);\n        if next == Some(0)\
    \ {\n            result.append(ascii_lowercase()[next]);\n        } else {\n \
    \           result.append(ascii_lowercase()[next]);\n            result.append(ascii_uppercase()[index\
    \ % 26]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ascii_lowercase` in this scope\n  -->\
    \ /tmp/tmpwkhc51ic.rs:14:21\n   |\n14 |         let index = ascii_lowercase().find(|&c|\
    \ c == ch);\n   |                     ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `ascii_lowercase` in this scope\n  --> /tmp/tmpwkhc51ic.rs:18:27\n\
    \   |\n18 |             result.append(ascii_lowercase()[next]);\n   |        \
    \                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `ascii_lowercase` in this scope\n  --> /tmp/tmpwkhc51ic.rs:20:27\n\
    \   |\n20 |             result.append(ascii_lowercase()[next]);\n   |        \
    \                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `ascii_uppercase` in this scope\n  --> /tmp/tmpwkhc51ic.rs:21:27\n\
    \   |\n21 |             result.append(ascii_uppercase()[index % 26]);\n   |  \
    \                         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `append` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmpwkhc51ic.rs:18:20\n   |\n18 |             result.append(ascii_lowercase()[next]);\n\
    \   |                    ^^^^^^ method not found in `&str`\n\nerror[E0599]: no\
    \ method named `append` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpwkhc51ic.rs:20:20\n   |\n20 |             result.append(ascii_lowercase()[next]);\n\
    \   |                    ^^^^^^ method not found in `&str`\n\nerror[E0599]: no\
    \ method named `append` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpwkhc51ic.rs:21:20\n   |\n21 |             result.append(ascii_uppercase()[index\
    \ % 26]);\n   |                    ^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwkhc51ic.rs:24:5\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                               ------ expected `String`\
    \ because of return type\n...\n24 |     result\n   |     ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 8 previous errors\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    message.chars().for_each(|c|\
    \ {\n        let mut new_c = c;\n        let index = get_index(c);\n        \n\
    \        match index {\n            1 => {\n                match c {\n      \
    \              'a' | 'e' | 'i' | 'o' | 'u' => {\n                        new_c\
    \ = c.to_lowercase();\n                    }\n                    _ => {}\n  \
    \              };\n            },\n            2 => {\n                match c\
    \ {\n                    'a' | 'e' | 'i' | 'o' | 'u' => {\n                  \
    \      new_c = c.to_lowercase();\n                    }\n                    _\
    \ => {}\n                };\n            },\n            _ => {\n            \
    \    match c {\n                    'a' | 'e' | 'i' | 'o' | 'u' => {\n       \
    \                 new_c = c.to_lowercase();\n                    }\n         \
    \           _ => {}\n                };\n            }\n        }\n        \n\
    \        result.push(new_c);\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_index` in this scope\n  --> /tmp/tmpay_ngef9.rs:15:21\n\
    \   |\n15 |         let index = get_index(c);\n   |                     ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpay_ngef9.rs:21:33\n\
    \   |\n14 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n...\n21 |                         new_c = c.to_lowercase();\n\
    \   |                                 ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpay_ngef9.rs:29:33\n\
    \   |\n14 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n...\n29 |                         new_c = c.to_lowercase();\n\
    \   |                                 ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpay_ngef9.rs:37:33\n\
    \   |\n14 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n...\n37 |                         new_c = c.to_lowercase();\n\
    \   |                                 ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `ToLowercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut vowels = vec!['A', 'E', 'I', 'O', 'U'];\n \
    \   for i in 0..message.len() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == &message[i]) {\n            let new_vowel = vowels[i + 1];\n          \
    \  let mut new_message = Vec::new();\n            for x in message.chars() {\n\
    \                if x == vowel {\n                    let index = x - vowel;\n\
    \                    new_message.push(*(vowels[v] + new_vowel));\n           \
    \     } else {\n                    new_message.push(x);\n                }\n\
    \            }\n            message = String::from(new_message);\n        }\n\
    \    }\n    message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `v` in this scope\n  --> /tmp/tmpc74on6ey.rs:20:47\n\
    \   |\n20 |                     new_message.push(*(vowels[v] + new_vowel));\n\
    \   |                                               ^ help: a local variable with\
    \ a similar name exists: `i`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpc74on6ey.rs:14:64\n   |\n14 |         if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == &message[i]) {\n   |                    \
    \                                            ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc74on6ey.rs:14:63\n\
    \   |\n14 |         if let Some(vowel) = vowels.iter().position(|&x| x == &message[i])\
    \ {\n   |                                                               ^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n14\
    \ -         if let Some(vowel) = vowels.iter().position(|&x| x == &message[i])\
    \ {\n14 +         if let Some(vowel) = vowels.iter().position(|&x| x == message[i])\
    \ {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc74on6ey.rs:18:25\n\
    \   |\n18 |                 if x == vowel {\n   |                         ^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0369]: cannot subtract `usize` from\
    \ `char`\n  --> /tmp/tmpc74on6ey.rs:19:35\n   |\n19 |                     let\
    \ index = x - vowel;\n   |                                 - ^ ----- usize\n \
    \  |                                 |\n   |                                 char\n\
    \nerror[E0277]: the trait bo"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut out: Vec<char> = Vec::new();\n    for c in\
    \ message.chars() {\n        out.push(c.to_ascii_lowercase());\n    }\n    let\
    \ mut alphabet = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n   \
    \ for v in &mut out {\n        if alphabet.iter().position(|&a| a == v).is_some()\
    \ {\n            alphabet[alphabet.iter().position(|&a| a == v).unwrap() + 1]\
    \ = 'a';\n        }\n    }\n    for v in &out {\n        if alphabet.iter().position(|&a|\
    \ a == v).is_some() {\n            alphabet[alphabet.iter().position(|&a| a ==\
    \ v).unwrap() + 1] = 'A';\n        }\n    }\n    let mut encoded = String::new();\n\
    \    for c in &mut out {\n        encoded.push_str(&alphabet[out.chars().position(|&a|\
    \ a == c).unwrap() + 1]);\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpit6a9wk3.rs:18:47\n   |\n\
    18 |         if alphabet.iter().position(|&a| a == v).is_some() {\n   |      \
    \                                         ^ expected `char`, found `&mut char`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |         if alphabet.iter().position(|&a|\
    \ a == *v).is_some() {\n   |                                               +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpit6a9wk3.rs:19:57\n   |\n19 |\
    \             alphabet[alphabet.iter().position(|&a| a == v).unwrap() + 1] = 'a';\n\
    \   |                                                         ^ expected `char`,\
    \ found `&mut char`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |\
    \             alphabet[alphabet.iter().position(|&a| a == *v).unwrap() + 1] =\
    \ 'a';\n   |                                                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpit6a9wk3.rs:23:47\n   |\n23 |         if alphabet.iter().position(|&a|\
    \ a == v).is_some() {\n   |                                               ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    23 |         if alphabet.iter().position(|&a| a == *v).is_some() {\n   |     \
    \                                          +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpit6a9wk3.rs:24:57\n   |\n24 |             alphabet[alphabet.iter().position(|&a|\
    \ a == v).unwrap() + 1] = 'A';\n   |                                         \
    \                ^ expected `char`, found `&char`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |             alphabet[alphabet.iter().position(|&a| a\
    \ == *v).unwrap() + 1] = 'A';\n   |                                          \
    \               +\n\nerror[E0599]: no method named `chars` found for struct `Vec<char>`\
    \ in the current scope\n  --> /tmp/tmpit6a9wk3.rs:29:40\n   |\n29 |         encoded.push_str(&alphabet[out.chars().position(|&a|\
    \ a == c).unwrap() + 1]);\n   |                                        ^^^^^ method\
    \ not found in `Vec<char>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed ex"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut vowels = \"aeiou\";\n    let mut map = vec![];\n\
    \    let mut map = vec![0; 26];\n\n    for &c in &message {\n        match c {\n\
    \            'A' => map[0] = 123,\n            'B' => map[1] = 124,\n        \
    \    'C' => map[2] = 125,\n            'D' => map[3] = 126,\n            'E' =>\
    \ map[4] = 127,\n            'F' => map[5] = 128,\n            'G' => map[6] =\
    \ 129,\n            'H' => map[7] = 130,\n            'I' => map[8] = 131,\n \
    \           'J' => map[9] = 132,\n            'K' => map[10] = 133,\n        \
    \    'L' => map[11] = 134,\n            'M' => map[12] = 135,\n            'N'\
    \ => map[13] = 136,\n            'O' => map[14] = 137,\n            'P' => map[15]\
    \ = 138,\n            'Q' => map[16] = 139,\n            'R' => map[17] = 140,\n\
    \            'S' => map[18] = 141,\n            'T' => map[19] = 142,\n      \
    \      'U' => map[20] = 143,\n            'V' => map[21] = 144,\n            'W'\
    \ => map[22] = 145,\n            'X' => map[23] = 146,\n            'Y' => map[24]\
    \ = 147,\n            'Z' => map[25] = 148,\n            _ => continue,\n    \
    \    };\n    }\n\n    for i in map.iter() {\n        vowels.insert(i, i);\n  \
    \  }\n\n    vowels\n        .iter()\n        .map(|&c| map.get(c - 'a' + 1))\n\
    \        .cloned()\n        .collect::<String>()\n        .join(\"\")\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmprur78cbh.rs:16:15\n\
    \   |\n16 |     for &c in &message {\n   |               ^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0599]: no method named `insert` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmprur78cbh.rs:49:16\n   |\n49 |   \
    \      vowels.insert(i, i);\n   |                ^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `iter` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmprur78cbh.rs:53:10\n   |\n53 |         .iter()\n   |   \
    \       ^^^^ method not found in `&str`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n53 |         .chars()\n   |          ~~~~~\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'];\n    for letter in\
    \ message.chars() {\n        if vowels.contains(letter) {\n            result.push_str(&vowels[vowels.iter().position(|v|\
    \ *v == letter).next()+2]);\n        } else {\n            result.push_str(&vowels[vowels.iter().position(|v|\
    \ *v == letter).next()+1]);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeo0o5l2r.rs:15:28\n   |\n\
    15 |         if vowels.contains(letter) {\n   |                            ^^^^^^\n\
    \   |                            |\n   |                            expected `&char`,\
    \ found `char`\n   |                            help: consider borrowing here:\
    \ `&letter`\n\nerror[E0599]: no method named `next` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpeo0o5l2r.rs:16:78\n   |\n16 |             result.push_str(&vowels[vowels.iter().position(|v|\
    \ *v == letter).next()+2]);\n   |                                            \
    \                                  ^^^^ method not found in `Option<usize>`\n\n\
    error[E0599]: no method named `next` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpeo0o5l2r.rs:18:78\n   |\n18 |             result.push_str(&vowels[vowels.iter().position(|v|\
    \ *v == letter).next()+1]);\n   |                                            \
    \                                  ^^^^ method not found in `Option<usize>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut vowel_map: Vec<String> = vec![\"\".to_string(),\
    \ \n    \n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\"\
    .to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"\
    AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n\
    \    \"AEIOU\".to_string(),\n    \"AEIOU\".to_string(),\n    \"AEIO\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpxqeaudf2.rs:84:109\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    85 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n \
    \   let mut map = vec!['t', 'h', 'k', 's', 'k', 'c', 'g', 'm', 'g', 's', 'c'];\n\
    \    \n    for index in 0..message.len() {\n        if message[index] == vowels.get(0)\
    \ && map.len() >= 2 {\n            map.remove(map.get(0));\n            map.remove(map.get(1));\n\
    \            vowels.swap(0, 2);\n        }\n        \n        let index = map.len();\n\
    \        if let Some(pos) = map.get(index - 1) {\n            let char = message[index].to_string();\n\
    \            map.insert(pos, char.to_string());\n        }\n    }\n    \n    map.iter().map(|char|\
    \ char.chars().next().unwrap()).collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl4i2jako.rs:16:12\n\
    \   |\n16 |         if message[index] == vowels.get(0) && map.len() >= 2 {\n \
    \  |            ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl4i2jako.rs:17:24\n   |\n17 |             map.remove(map.get(0));\n\
    \   |                        ^^^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl4i2jako.rs:18:24\n   |\n18 |\
    \             map.remove(map.get(1));\n   |                        ^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<&char>`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpl4i2jako.rs:24:24\n   |\n24 |         \
    \    let char = message[index].to_string();\n   |                        ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4i2jako.rs:25:24\n\
    \   |\n25 |             map.insert("
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut answer = String::new();\n    let mut i = 0;\n\
    \    loop {\n        match message[i..].chars().nth(i) {\n            'A' .. 'Z'\
    \ | 'a' .. 'z' => answer.push((message[i..i].to_string() + &'a'[..]).to_string()),\n\
    \            _ => \n                if i < message.len() - 1 {\n             \
    \       i += 2;\n                } else {\n                    i = 0;\n      \
    \          }\n        }\n    }\n    answer\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp8oxpbvnm.rs:16:13\n\
    \   |\n16 |             'A' .. 'Z' | 'a' .. 'z' => answer.push((message[i..i].to_string()\
    \ + &'a'[..]).to_string()),\n   |             ^^^^^^^^^^\n   |\n   = note: see\
    \ issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp8oxpbvnm.rs:16:26\n\
    \   |\n16 |             'A' .. 'Z' | 'a' .. 'z' => answer.push((message[i..i].to_string()\
    \ + &'a'[..]).to_string()),\n   |                          ^^^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8oxpbvnm.rs:16:13\n\
    \   |\n15 |         match message[i..].chars().nth(i) {\n   |               ---------------------------\
    \ this expression has type `Option<char>`\n16 |             'A' .. 'Z' | 'a' ..\
    \ 'z' => answer.push((message[i..i].to_string() + &'a'[..]).to_string()),\n  \
    \ |             ^^^    --- this is of type `char`\n   |             |\n   |  \
    \           expected enum `Option`, found `char`\n   |\n   = note: expected enum\
    \ `Option<char>`\n              found type `char`\nhelp: try wrapping the pattern\
    \ in `Some`\n   |\n16 |             Some('A') .. 'Z' | 'a' .. 'z' => answer.push((message[i..i].to_string()\
    \ + &'a'[..]).to_string()),\n   |             +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8oxpbvnm.rs:16:20\n   |\n15 |         match message[i..].chars().nth(i)\
    \ {\n   |               --------------------------- this expression has type `Option<char>`\n\
    16 |             'A' .. 'Z' | 'a' .. 'z' => answer.push((message[i..i].to_string()\
    \ + &'a'[..]).to_string()),\n   |             ---    ^^^ expected enum `Option`,\
    \ found `char`\n   |             |\n   |             this is of type `char`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    help: try wrapping the pattern in `Some`\n   |\n16 |             'A' .. Some('Z')\
    \ | 'a' .. 'z' => answer.push((message[i..i].to_string() + &'a"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::new();\n    let vowels\
    \ = \"aeiouAEIOU\";\n    for letter in message.chars() {\n        if letter in\
    \ vowels {\n            let index = vowels.index(letter);\n            let next_index\
    \ = index + 2;\n            let vowel = vowels[index];\n            new_message.push_str(&vowel);\n\
    \            new_message.push_str(&vowels[next_index]);\n        } else {\n  \
    \          new_message.push_str(&letter);\n        }\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpnsokiqrz.rs:15:19\n\
    \   |\n15 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().collect::<Vec<char>>().into_iter().map(|c|\
    \ {\n        let idx = c.to_ascii_lowercase().position(|&x| x == 'a' || x == 'e'\
    \ || x == 'i' || x == 'o' || x == 'u');\n        if idx < 2 {\n            c.to_ascii_lowercase()\n\
    \        } else if idx > 2 {\n            c.to_ascii_lowercase().chars().nth(idx).to_string()\n\
    \        } else {\n            c.to_ascii_lowercase()\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `position` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpmgdey3hr.rs:13:42\n   |\n13 |         let idx = c.to_ascii_lowercase().position(|&x|\
    \ x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u');\n   |           \
    \                               ^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpmgdey3hr.rs:17:36\n\
    \   |\n17 |             c.to_ascii_lowercase().chars().nth(idx).to_string()\n\
    \   |                                    ^^^^^ method not found in `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        match c.to_ascii_uppercase() {\n            \"A\" => \"T\",\n   \
    \         \"B\" => \"S\",\n            \"C\" => \"K\",\n            \"D\" => \"\
    G\",\n            \"E\" => \"H\",\n            \"F\" => \"U\",\n            \"\
    G\" => \"V\",\n            \"H\" => \"R\",\n            \"I\" => \"L\",\n    \
    \        \"J\" => \"M\",\n            \"K\" => \"N\",\n            \"L\" => \"\
    W\",\n            \"M\" => \"Y\",\n            \"N\" => \"X\",\n            \"\
    O\" => \"P\",\n            \"P\" => \"Q\",\n            \"Q\" => \"Z\",\n    \
    \        \"R\" => \"F\",\n            \"S\" => \"U\",\n            \"T\" => \"\
    Z\",\n            \"U\" => \"D\",\n            \"V\" => \"T\",\n            \"\
    W\" => \"P\",\n            \"X\" => \"O\",\n            \"Y\" => \"M\",\n    \
    \        \"Z\" => \"S\",\n            _ => result.append(c),\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqjr6r7fu.rs:15:13\n   |\n\
    14 |         match c.to_ascii_uppercase() {\n   |               ----------------------\
    \ this expression has type `char`\n15 |             \"A\" => \"T\",\n   |    \
    \         ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqjr6r7fu.rs:16:13\n   |\n14 |         match c.to_ascii_uppercase()\
    \ {\n   |               ---------------------- this expression has type `char`\n\
    15 |             \"A\" => \"T\",\n16 |             \"B\" => \"S\",\n   |     \
    \        ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqjr6r7fu.rs:17:13\n   |\n14 |         match c.to_ascii_uppercase()\
    \ {\n   |               ---------------------- this expression has type `char`\n\
    ...\n17 |             \"C\" => \"K\",\n   |             ^^^ expected `char`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqjr6r7fu.rs:18:13\n\
    \   |\n14 |         match c.to_ascii_uppercase() {\n   |               ----------------------\
    \ this expression has type `char`\n...\n18 |             \"D\" => \"G\",\n   |\
    \             ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqjr6r7fu.rs:19:13\n   |\n14 |         match c.to_ascii_uppercase()\
    \ {\n   |               ---------------------- this expression has type `char`\n\
    ...\n19 |             \"E\" => \"H\",\n   |             ^^^ expected `char`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqjr6r7fu.rs:20:13\n\
    \   |\n14 |         match c.to_ascii_uppercase() {\n   |               ----------------------\
    \ this expression has type `char`\n...\n20 |             \"F\" => \"U\",\n   |\
    \             ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqjr6r7fu.rs:21:13\n   |\n14 |         match c.to_ascii_uppercase()\
    \ {\n   |               ---------------------- this expression has type `char`\n\
    ...\n21 |             \"G\" => \"V\",\n   |             ^^^ expected `char`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqjr6r7fu.rs:22:13\n\
    \   |\n14 |         match c.to_ascii_uppercase() {\n   |              "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for\
    \ c in message {\n        if let Some(x) = letters.find(|c| *c == c) {\n     \
    \       new_message += x.to_ascii_uppercase();\n        } else {\n           \
    \ new_message += c;\n        }\n    }\n    for c in vowels.chars() {\n       \
    \ if let Some(x) = new_message.find(|c| *c == c) {\n            new_message =\
    \ new_message.replace(&c, &x.to_ascii_uppercase());\n        }\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpvwqrjkk9.rs:15:14\n\
    \   |\n15 |     for c in message {\n   |              ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no\
    \ method named `to_ascii_uppercase` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpvwqrjkk9.rs:17:30\n   |\n17 |             new_message += x.to_ascii_uppercase();\n\
    \   |                              ^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `to_ascii_uppercase` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmpvwqrjkk9.rs:24:54\n   |\n24 |             new_message\
    \ = new_message.replace(&c, &x.to_ascii_uppercase());\n   |                  \
    \                                    ^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n   --> /tmp/tmpvwqrjkk9.rs:24:39\n\
    \    |\n24  |             new_message = new_message.replace(&c, &x.to_ascii_uppercase());\n\
    \    |                                       ^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n    |\n    = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n    = help: the trait `Pattern<'a>` is implemented for `char`\n\
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n    = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `str::<impl str>::replace`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output_message = message;\n    let mut vowels\
    \ = 'aeiouyAEIOUY';\n    \n    for i in vowels.len() {\n        output_message\
    \ = output_message.replace(i + 1, 'x');\n    }\n\n    for i in 0..message.len()\
    \ {\n        output_message = output_message.chars().filter(|c| c != 'a' && c\
    \ != 'e' && c != 'i' && c != 'o' && c != 'u').collect::<String>();\n        output_message\
    \ = output_message.join(\"\");\n        output_message = output_message.replace(i\
    \ as usize + 1, 'x');\n    }\n\n    output_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp55cetpae.rs:13:22\n\
    \   |\n13 |     let mut vowels = 'aeiouyAEIOUY';\n   |                      ^^^^^^^^^^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    13 |     let mut vowels = \"aeiouyAEIOUY\";\n   |                      ~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp55cetpae.rs:16:56\n   |\n16 |\
    \         output_message = output_message.replace(i + 1, 'x');\n   |         \
    \                                               ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    16 |         output_message = output_message.replace(i + 1, \"x\");\n   |    \
    \                                                    ~~~\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp55cetpae.rs:20:62\n   |\n20 |   \
    \      output_message = output_message.chars().filter(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u').collect::<String>();\n   |            \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp55cetpae.rs:20:74\n   |\n20\
    \ |         output_message = output_message.chars().filter(|c| c != 'a' && c !=\
    \ 'e' && c != 'i' && c != 'o' && c != 'u').collect::<String>();\n   |        \
    \                                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp55cetpae.rs:20:86\n\
    \   |\n20 |         output_message = output_message.chars().filter(|c| c != 'a'\
    \ && c != 'e' && c != 'i' && c != 'o' && c != 'u').collect::<String>();\n   |\
    \                                                                            \
    \          ^^ no impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = message;\n    new_message.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').for_each(|c| {\n        new_message.push('a' - c + 1);\n\
    \    });\n    new_message.chars().filter(|c| c >= 'a' && c <= 'z').for_each(|c|\
    \ {\n        new_message.push(c - 'a' + 1);\n    });\n    new_message.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').for_each(|c| {\n        let vowels: Vec<_> = vec![\"a\"\
    ,\"e\",\"i\",\"o\",\"u\"];\n        let mut pos = 0;\n        let mut last_vowel\
    \ = 0;\n        for v in vowels.iter().cloned() {\n            let mut pos = new_message.find(&c);\
    \ \n            if pos != -1 {\n                if pos - last_vowel == 2 {\n \
    \                   new_message.insert(pos, v);\n                }\n         \
    \       last_vowel = pos;\n            }\n        }\n    });\n    new_message.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').for_each(|c| {\n        let vowels: Vec<_> = vec![\"A\"\
    ,\"E\",\"I\",\"O\",\"U\"];\n        let mut pos = 0;\n        let mut last_vowel\
    \ = 0;\n        for v in vowels.iter().cloned() {\n            let mut pos = new_message.find(&c);\
    \ \n            if pos != -1 {\n                if pos - last_vowel == 2 {\n \
    \                   new_message.insert(pos, v);\n                }\n         \
    \       last_vowel = pos;\n            }\n        }\n    });\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp94jnjxkt.rs:13:41\n   |\n\
    13 |     new_message.chars().filter(|c| c >= 'A' && c <= 'Z').for_each(|c| {\n\
    \   |                                         ^^^\n   |                      \
    \                   |\n   |                                         expected `&char`,\
    \ found `char`\n   |                                         help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp94jnjxkt.rs:13:53\n\
    \   |\n13 |     new_message.chars().filter(|c| c >= 'A' && c <= 'Z').for_each(|c|\
    \ {\n   |                                                     ^^^\n   |      \
    \                                               |\n   |                      \
    \                               expected `&char`, found `char`\n   |         \
    \                                            help: consider borrowing here: `&'Z'`\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp94jnjxkt.rs:14:30\n\
    \   |\n14 |         new_message.push('a' - c + 1);\n   |                     \
    \     --- ^ - char\n   |                          |\n   |                    \
    \      char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp94jnjxkt.rs:16:41\n\
    \   |\n16 |     new_message.chars().filter(|c| c >= 'a' && c <= 'z').for_each(|c|\
    \ {\n   |                                         ^^^\n   |                  \
    \                       |\n   |                                         expected\
    \ `&char`, found `char`\n   |                                         help: consider\
    \ borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp94jnjxkt.rs:16:53\n\
    \   |\n16 |     new_message.chars().filter(|c| c >= 'a' && c <= 'z').for_each(|c|\
    \ {\n   |                                                     ^^^\n   |      \
    \                                               |\n   |                      \
    \                               expected `&char`, found `char`\n   |         \
    \                                            help: consider borrowing here: `&'z'`\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp94jnjxkt.rs:17:28\n\
    \   |\n17 |         new_mess"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.len() <= 3 {\n        // 1 case\n      \
    \  encode(message.to_lowercase());\n    } else {\n        // 2 cases\n       \
    \ let mut encoded = message.to_lowercase();\n        for (i, char) in &mut encoded\
    \ {\n            if char == 'a' || char == 'e' || char == 'i' || char == 'o' ||\
    \ char == 'u' {\n                encoded = encoded.chars().filter(|c| *c != 'a'\
    \ && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').collect();\n          \
    \      break;\n            }\n        }\n        for (i, char) in &mut encoded\
    \ {\n            if char == 'a' || char == 'e' || char == 'i' || char == 'o' ||\
    \ char == 'u' {\n                encoded = encoded.chars().filter(|c| *c != 'a'\
    \ && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').collect();\n          \
    \      break;\n            }\n        }\n        for (i, char) in &mut encoded\
    \ {\n            if char == 'a' || char == 'e' || char == 'i' || char == 'o' ||\
    \ char == 'u' {\n                encoded = encoded.chars().filter(|c| *c != 'a'\
    \ && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').collect();\n          \
    \      break;\n            }\n        }\n        for (i, char) in &mut encoded\
    \ {\n            if char == 'a' || char == 'e' || char == 'i' || char == 'o' ||\
    \ char == 'u' {\n                encoded = encoded.chars().filter(|c| *c != 'a'\
    \ && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').collect();\n          \
    \      break;\n            }\n        }\n        for (i, char) in &mut encoded\
    \ {\n            if char == 'a' || char == 'e' || char == 'i' || char == 'o' ||\
    \ char == 'u' {\n                encoded = encoded.chars().filter(|c| *c != 'a'\
    \ && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').collect();\n          \
    \      break;\n            }\n        }\n        for (i, char) in &mut encoded\
    \ {\n            if char == 'a' || char == 'e' || char == 'i' || char == 'o' ||\
    \ char == 'u' {\n                encoded = encoded.chars().filter(|c| *c != 'a'\
    \ && *c != 'e' && *c != 'i' && *c != 'o' && *\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpshqyzh1a.rs:60:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n15 |     } else {\n   |         \
    \   - unclosed delimiter\n...\n48 |         for (i, char) in &mut encoded {\n\
    \   |                                       - unclosed delimiter\n49 |       \
    \      if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char ==\
    \ 'u' {\n   |                                                                \
    \                        - this delimiter might not be properly closed...\n50\
    \ |                 encoded = encoded.chars().filter(|c| *c != 'a' && *c != 'e'\
    \ && *c != 'i' && *c != 'o' && *\n51 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n60 | }\n   |   ^\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpshqyzh1a.rs:51:1\n   |\n51 | }\n   | ^ expected expression\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpshqyzh1a.rs:50:49\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n50 |     \
    \            encoded = encoded.chars().filter(|c| *c != 'a' && *c != 'e' && *c\
    \ != 'i' && *c != 'o' && *\n   |                                             \
    \    ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpshqyzh1a.rs:12:27\n   |\n12 |       if message.len()\
    \ <= 3 {\n   |  ___________________________^\n13 | |         // 1 case\n14 | |\
    \         encode(message.to_lowercase());\n   | |                            \
    \           - help: remove this semicolon\n15 | |     } else {\n   | |_____^ expected\
    \ struct `String`, found `()`\n\nerror[E0277]: `String` is not an iterator\n \
    \ --> /tmp/tmpshqyzh1a.rs:18:26\n   |\n18 |         for (i, char) in &mut encoded\
    \ {\n   |                          ^^^^^^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requ"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Get list of letters\n    let mut letters = message.chars().cloned().collect::<Vec<&'static\
    \ str>>();\n\n    // Get list of vowels\n    let mut vowels = \"aeiou\".chars().cloned().collect::<Vec<&'static\
    \ str>>();\n\n    // Get list of letters that appears 2 places ahead of vowels\n\
    \    let mut pairs = letters.iter().cloned().filter(|&c| vowels.contains(&c)).cloned().collect::<Vec<&'static\
    \ str>>();\n\n    // Get list of letters that appears 2 places ahead of vowels\n\
    \    let mut reverse = pairs.iter().cloned().cloned().collect::<Vec<&'static str>>();\n\
    \n    // Swap and encode each letter in the message\n    for (index, &c) in letters.iter().enumerate()\
    \ {\n        letters[index] = if pair.contains(&c) {\n            pair.swap(index,\
    \ pair.index(index) + 1);\n            &vowels[pair.index(index)]\n        } else\
    \ {\n            c\n        };\n    }\n\n    // Reverse letters in pairs\n   \
    \ for &c in pairs.iter() {\n        reverse.insert(pair.index(&c), &c);\n    }\n\
    \n    // Join reversed pairs and letters\n    String::from_utf8(letters.iter().chain(reverse).collect::<Vec<String>>()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `pair` in this scope\n  --> /tmp/tmpki72md6x.rs:26:29\n\
    \   |\n26 |         letters[index] = if pair.contains(&c) {\n   |            \
    \                 ^^^^ help: a local variable with a similar name exists: `pairs`\n\
    \nerror[E0425]: cannot find value `pair` in this scope\n  --> /tmp/tmpki72md6x.rs:27:13\n\
    \   |\n27 |             pair.swap(index, pair.index(index) + 1);\n   |       \
    \      ^^^^ help: a local variable with a similar name exists: `pairs`\n\nerror[E0425]:\
    \ cannot find value `pair` in this scope\n  --> /tmp/tmpki72md6x.rs:27:30\n  \
    \ |\n27 |             pair.swap(index, pair.index(index) + 1);\n   |         \
    \                     ^^^^ help: a local variable with a similar name exists:\
    \ `pairs`\n\nerror[E0425]: cannot find value `pair` in this scope\n  --> /tmp/tmpki72md6x.rs:28:21\n\
    \   |\n28 |             &vowels[pair.index(index)]\n   |                     ^^^^\
    \ help: a local variable with a similar name exists: `pairs`\n\nerror[E0425]:\
    \ cannot find value `pair` in this scope\n  --> /tmp/tmpki72md6x.rs:36:24\n  \
    \ |\n36 |         reverse.insert(pair.index(&c), &c);\n   |                  \
    \      ^^^^ help: a local variable with a similar name exists: `pairs`\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpki72md6x.rs:13:39\n\
    \     |\n13   |     let mut letters = message.chars().cloned().collect::<Vec<&'static\
    \ str>>();\n     |                                       ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<Chars<'_>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpki72md6x.rs:13:48\n   |\n13 |       let mut\
    \ letters = message.chars().cloned().collect::<Vec<&'static str>>();\n   |   \
    \                                               ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.len() < 2 {\n        return message.to_owned();\n\
    \    }\n    let mut result = String::new();\n    let mut replacement = String::from(\"\
    a\");\n    let mut vowel = String::from(\"e\");\n    let mut prev_vowel = String::from(\"\
    e\");\n    let mut i = 1;\n    \n    for letter in &message {\n        if letter\
    \ == letter.to() {\n            result.push('a');\n            i += 1;\n     \
    \   } else if letter == vowel {\n            replacement = prev_vowel;\n     \
    \       i += 2;\n        } else {\n            result.push((letter - prev_vowel\
    \ - i).to_digit(16).unwrap());\n        }\n        prev_vowel = vowel;\n     \
    \   vowel = letter;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpah2s9646.rs:21:19\n\
    \   |\n21 |     for letter in &message {\n   |                   ^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = \"\";\n    let mut alphabet\
    \ = char::from('a');\n    let mut count = 0;\n    let mut vowel_count = 0;\n \
    \   for (i, c) in message.chars().enumerate() {\n        count += 1;\n       \
    \ if !is_letter_upper(c) {\n            vowel_count += 1;\n        }\n       \
    \ if vowel_count == 2 {\n            encoded_message += alphabet.to_ascii_lowercase();\n\
    \            alphabet = alphabet.wrap();\n            vowel_count = 0;\n     \
    \   }\n        alphabet = alphabet.wrap();\n        alphabet += c;\n    }\n  \
    \  encoded_message += alphabet.to_ascii_lowercase();\n    encoded_message\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_letter_upper` in this scope\n  -->\
    \ /tmp/tmpb1q9mw3v.rs:18:13\n   |\n18 |         if !is_letter_upper(c) {\n   |\
    \             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpb1q9mw3v.rs:22:13\n\
    \   |\n22 |             encoded_message += alphabet.to_ascii_lowercase();\n  \
    \ |             ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `&str`\n\nerror[E0599]: no\
    \ method named `wrap` found for type `char` in the current scope\n  --> /tmp/tmpb1q9mw3v.rs:23:33\n\
    \   |\n23 |             alphabet = alphabet.wrap();\n   |                    \
    \             ^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `wrap` found for type `char` in the current scope\n  --> /tmp/tmpb1q9mw3v.rs:26:29\n\
    \   |\n26 |         alphabet = alphabet.wrap();\n   |                        \
    \     ^^^^ method not found in `char`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `char`\n  --> /tmp/tmpb1q9mw3v.rs:27:9\n   |\n\
    27 |         alphabet += c;\n   |         --------^^^^^\n   |         |\n   |\
    \         cannot use `+=` on type `char`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmpb1q9mw3v.rs:29:5\n   |\n\
    29 |     encoded_message += alphabet.to_ascii_lowercase();\n   |     ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb1q9mw3v.rs:30:5\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |                               ------ expected `String` because\
    \ of return type\n...\n30 |     encoded_message\n   |     ^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0425, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: Vec<char> = Vec::new();\n    \n  \
    \  // encode all the letters \n    for letter in message.chars() {\n        encoded.push((((letter.to_ascii_lowercase()\
    \ | 0x20) as char).to_string()[0..1].to_ascii_lowercase() );\n    }\n    \n  \
    \  // encode all the vowels\n    for vowel in 'AEIOU'.chars() {\n        for index\
    \ in 0..2 {\n            let index = index + vowel.to_string().len() - 1;\n  \
    \          encoded.push( encoded[*index] );\n        }\n    }\n    encoded.join(\"\
    \\n\")\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpmtft27oo.rs:20:18\n\
    \   |\n20 |     for vowel in 'AEIOU'.chars() {\n   |                  ^^^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    20 |     for vowel in \"AEIOU\".chars() {\n   |                  ~~~~~~~\n\nerror:\
    \ mismatched closing delimiter: `}`\n  --> /tmp/tmpmtft27oo.rs:16:21\n   |\n15\
    \ |     for letter in message.chars() {\n   |                                \
    \   - closing delimiter possibly meant for this\n16 |         encoded.push((((letter.to_ascii_lowercase()\
    \ | 0x20) as char).to_string()[0..1].to_ascii_lowercase() );\n   |           \
    \          ^ unclosed delimiter\n17 |     }\n   |     ^ mismatched closing delimiter\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `;`\n  -->\
    \ /tmp/tmpmtft27oo.rs:16:21\n   |\n16 |         encoded.push((((letter.to_ascii_lowercase()\
    \ | 0x20) as char).to_string()[0..1].to_ascii_lowercase() );\n   |           \
    \          ^ unclosed delimiter                                              \
    \                       ^ help: `)` may belong here\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpmtft27oo.rs:17:5\n   |\n17 |     }\n   |     ^ expected\
    \ expression\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmpmtft27oo.rs:16:22\n   |\n16 |         encoded.push((((letter.to_ascii_lowercase()\
    \ | 0x20) as char).to_string()[0..1].to_ascii_lowercase() );\n   |           \
    \           ^                                                                \
    \                     ^^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n16 -         encoded.push((((letter.to_ascii_lowercase()\
    \ | 0x20) as char).to_string()[0..1].to_ascii_lowercase() );\n16 +         encoded.push(((letter.to_ascii_lowercase()\
    \ | 0x20) as char).to_string()[0..1].to_ascii_lowercase();\n   | \n\nerror[E0369]:\
    \ no implementation for `char | {integer}`\n  --> /tmp/tmpmtft27oo.rs:16:53\n\
    \   |\n16 |         encoded.push((((letter.to_ascii_lowercase() | 0x20) as char).to_string()[0..1].to_ascii"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        if c.is_uppercase()\
    \ {\n            c as char\n        } else if c == 'A' || (c == 'a' && message.chars().nth(1).unwrap().is_uppercase())\
    \ {\n            message.chars().nth(1).unwrap() as char\n        } else if c\
    \ == 'E' || (c == 'e' && message.chars().nth(2).unwrap().is_uppercase()) {\n \
    \           message.chars().nth(2).unwrap() as char\n        } else if c == 'I'\
    \ || (c == 'i' && message.chars().nth(3).unwrap().is_uppercase()) {\n        \
    \    message.chars().nth(3).unwrap() as char\n        } else if c == 'O' || (c\
    \ == 'o' && message.chars().nth(4).unwrap().is_uppercase()) {\n            message.chars().nth(4).unwrap()\
    \ as char\n        } else if c == 'U' || (c == 'u' && message.chars().nth(5).unwrap().is_uppercase())\
    \ {\n            message.chars().nth(5).unwrap() as char\n        } else if c\
    \ == 'Y' || (c == 'y' && message.chars().nth(6).unwrap().is_uppercase()) {\n \
    \           message.chars().nth(6).unwrap() as char\n        } else if c == 'a'\
    \ || (c == 'a' && message.chars().nth(7).unwrap().is_uppercase()) {\n        \
    \    message.chars().nth(7).unwrap() as char\n        } else if c == 'e' || (c\
    \ == 'e' && message.chars().nth(8).unwrap().is_uppercase()) {\n            message.chars().nth(8).unwrap()\
    \ as char\n        } else if c == 'i' || (c == 'i' && message.chars().nth(9).unwrap().is_uppercase())\
    \ {\n            message.chars().nth(9).unwrap() as char\n        } else if c\
    \ == 'o' || (c == 'o' && message.chars().nth(10).unwrap().is_uppercase()) {\n\
    \            message.chars().nth(10).unwrap() as char\n        } else if c ==\
    \ 'u' || (c == 'u' && message.chars().nth(11).unwrap().is_uppercase()) {\n   \
    \         message.chars().nth(11).unwrap() as char\n        } else if c == 'y'\
    \ || (c == 'y' && message.chars().nth(12).unwrap().is_uppercase()) {\n       \
    \     message.chars().nth(12).unwrap() as char\n        } else {\n           \
    \ c\n        }\n    }).collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpnj3fx45w.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n\n    for (i, char)\
    \ in message.chars().enumerate() {\n        if i % 2 == 0 {\n            result.push_str(&encode(&char));\n\
    \        } else {\n            result.push_str(&encode(&char[1..]));\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiktcri8j.rs:16:37\n   |\n\
    16 |             result.push_str(&encode(&char));\n   |                      \
    \               ^^^^^ expected struct `String`, found `&char`\n   |\nhelp: try\
    \ using a conversion method\n   |\n16 |             result.push_str(&encode((&char).to_string()));\n\
    \   |                                     +     +++++++++++++\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpiktcri8j.rs:18:38\n\
    \   |\n18 |             result.push_str(&encode(&char[1..]));\n   |          \
    \                            ^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    encode::encode(message)\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `encode`\n\
    \  --> /tmp/tmpzlv2zuxp.rs:12:5\n   |\n12 |     encode::encode(message)\n   |\
    \     ^^^^^^ use of undeclared crate or module `encode`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        let index = english.char_indices().unwrap().find(|(c,)|\
    \ c.eq(c));\n        match index {\n            Some(i) => english.chars().nth(i).unwrap().to_string(),\n\
    \            None => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `english` in this scope\n  --> /tmp/tmprrz9978f.rs:13:21\n\
    \   |\n13 |         let index = english.char_indices().unwrap().find(|(c,)| c.eq(c));\n\
    \   |                     ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `english` in this scope\n  --> /tmp/tmprrz9978f.rs:15:24\n   |\n\
    15 |             Some(i) => english.chars().nth(i).unwrap().to_string(),\n   |\
    \                        ^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut builder: Vec<_> = message.chars().collect();\n\
    \    for letter in builder {\n        let mut replace = LettersVowels::new();\n\
    \        let index = replace.get(letter.to_string());\n        if index != None\
    \ {\n            builder[index] = letter.to_uppercase();\n        }\n    }\n \
    \   let result = builder.join();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `LettersVowels`\n\
    \  --> /tmp/tmp3p_mymwo.rs:14:27\n   |\n14 |         let mut replace = LettersVowels::new();\n\
    \   |                           ^^^^^^^^^^^^^ use of undeclared type `LettersVowels`\n\
    \nerror[E0599]: the method `join` exists for struct `Vec<char>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp3p_mymwo.rs:20:26\n   |\n20 |     let\
    \ result = builder.join();\n   |                          ^^^^ method cannot be\
    \ called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output_message = String::new();\n    let mut\
    \ pos = 0;\n    for ch in message {\n        if ch.is_uppercase() {\n        \
    \    output_message += ch.to_lowercase();\n            pos += 1;\n        } else\
    \ {\n            output_message += ch.to_uppercase();\n        }\n        let\
    \ mut index = 0;\n        while index < pos {\n            output_message[pos\
    \ + index + 1] = \n                alphabet_to_index_alphabet(alphabet[alphabet[pos\
    \ + index] - 97]) + 1;\n            index += 1;\n        }\n        pos += 1;\n\
    \    }\n    return output_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `alphabet_to_index_alphabet` in this\
    \ scope\n  --> /tmp/tmp9nw8d8ra.rs:24:17\n   |\n24 |                 alphabet_to_index_alphabet(alphabet[alphabet[pos\
    \ + index] - 97]) + 1;\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n\
    \  --> /tmp/tmp9nw8d8ra.rs:24:44\n   |\n24 |                 alphabet_to_index_alphabet(alphabet[alphabet[pos\
    \ + index] - 97]) + 1;\n   |                                            ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `alphabet` in this\
    \ scope\n  --> /tmp/tmp9nw8d8ra.rs:24:53\n   |\n24 |                 alphabet_to_index_alphabet(alphabet[alphabet[pos\
    \ + index] - 97]) + 1;\n   |                                                 \
    \    ^^^^^^^^ not found in this scope\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmp9nw8d8ra.rs:14:15\n   |\n14 |     for ch in message {\n   |   \
    \            ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp9nw8d8ra.rs:23:13\n\
    \   |\n23 |             output_message[pos + index + 1] = \n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `ru"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut mappings = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut letters = Vec::new();\n    for x in message.chars()\
    \ {\n        if x.to_ascii_lowercase() == 'a' || x.to_ascii_lowercase() == 'e'\
    \ || x.to_ascii_lowercase() == 'i' || x.to_ascii_lowercase() == 'o' || x.to_ascii_lowercase()\
    \ == 'u'\n        {\n            mappings.push(x);\n        }\n        if x.to_ascii_lowercase()\
    \ == 'b'\n        {\n            mappings.push(x);\n        }\n        if x.to_ascii_lowercase()\
    \ == 'c' || x.to_ascii_lowercase() == 'd' || x.to_ascii_lowercase() == 'f' ||\
    \ x.to_ascii_lowercase() == 'g' || x.to_ascii_lowercase() == 'h' || x.to_ascii_lowercase()\
    \ == 'j' || x.to_ascii_lowercase() == 'k' || x.to_ascii_lowercase() == 'l' ||\
    \ x.to_ascii_lowercase() == 'm' || x.to_ascii_lowercase() == 'n' || x.to_ascii_lowercase()\
    \ == 'p' || x.to_ascii_lowercase() == 'q' || x.to_ascii_lowercase() == 'r' ||\
    \ x.to_ascii_lowercase() == 's' || x.to_ascii_lowercase() == 't' || x.to_ascii_lowercase()\
    \ == 'v' || x.to_ascii_lowercase() == 'w' || x.to_ascii_lowercase() == 'x' ||\
    \ x.to_ascii_lowercase() == 'y' || x.to_ascii_lowercase() == 'z'\n        {\n\
    \            mappings.push(x);\n        }\n        if x.to_ascii_lowercase() ==\
    \ 'A' || x.to_ascii_lowercase() == 'E' || x.to_ascii_lowercase() == 'I' || x.to_ascii_lowercase()\
    \ == 'O' || x.to_ascii_lowercase() == 'U'\n        {\n            mappings.push(x);\n\
    \        }\n        if x.to_ascii_lowercase() == 'B'\n        {\n            mappings.push(x);\n\
    \        }\n        if x.to_ascii_lowercase() == 'C' || x.to_ascii_lowercase()\
    \ == 'D' || x.to_ascii_lowercase() == 'F' || x.to_ascii_lowercase() == 'G' ||\
    \ x.to_ascii_lowercase() == 'H' || x.to_ascii_lowercase() == 'J' || x.to_ascii_lowercase()\
    \ == 'K' || x.to_ascii_lowercase() == 'L' || x.to_ascii_lowercase() == 'M' ||\
    \ x.to_ascii_lowercase() == 'N' || x.to_ascii_lowercase() == 'P' || x.to_ascii_lowercase()\
    \ == 'Q' || x.to_ascii_lowercase() == 'R' || x.to_ascii_lowercase() == 'S' ||\
    \ x.to_ascii_lowercase() == 'T' || x.to_ascii_lowercase() == 'V' || x.to_ascii_lowercase()\
    \ == 'W' || x.to_ascii_lowercase() == 'X' || x.to_ascii_lowercase() == 'Y' ||\
    \ x.to_ascii_lowercase() == 'Z'\n        {\n            mappings.push(x);\n  \
    \      }\n        if x.to_ascii_lowercase() == '0' || x.to_ascii_lowercase() ==\
    \ '1' || x.to_ascii_lowercase() == '2' || x.to_ascii_lowercase() == '3' || x.to_ascii_lowercase()\
    \ == '4' || x.to_ascii_lowercase() == '5' || x.to_ascii_lowercase() == '\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpa1bfgxou.rs:40:236\n\
    \   |\n40 | ...'4' || x.to_ascii_lowercase() == '5' || x.to_ascii_lowercase()\
    \ == '\n   |                                                                 \
    \     ^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut vowels = vec!['A', 'a', 'E', 'e', 'I', 'i',\
    \ 'O', 'o', 'U', 'u'];\n    for i in 0..message.len() {\n        let mut replacement\
    \ = ' ';\n        if let Some(pos) = vowels.binary_search(&message[i]) {\n   \
    \         let pos = pos + 1;\n            replacement = match pos {\n        \
    \        0 => \"Z\",\n                1 => \"A\",\n                2 => \"a\"\
    ,\n                3 => \"E\",\n                4 => \"e\",\n                5\
    \ => \"I\",\n                6 => \"i\",\n                7 => \"O\",\n      \
    \          8 => \"o\",\n                9 => \"U\",\n                10 => \"\
    u\",\n                _ => \"X\",\n            };\n            vowels.swap(pos,\
    \ pos + 1);\n        }\n        message = message.replace(&message[i], replacement);\n\
    \    }\n    return message\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb7270z3x.rs:15:50\n\
    \   |\n15 |         if let Some(pos) = vowels.binary_search(&message[i]) {\n \
    \  |                                                  ^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb7270z3x.rs:15:16\n\
    \   |\n15 |         if let Some(pos) = vowels.binary_search(&message[i]) {\n \
    \  |                ^^^^^^^^^   --------------------------------- this expression\
    \ has type `Result<usize, usize>`\n   |                |\n   |               \
    \ expected enum `Result`, found enum `Option`\n   |\n   = note: expected enum\
    \ `Result<usize, usize>`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb7270z3x.rs:18:22\n   |\n18 |              \
    \   0 => \"Z\",\n   |                      ^^^ expected `char`, found `&str`\n\
    \   |\nhelp: if you meant to write a `char` literal, use single quotes\n   |\n\
    18 |                 0 => 'Z',\n   |                      ~~~\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb7270z3x.rs:33:36\n\
    \   |\n33 |         message = message.replace(&message[i], replacement);\n   |\
    \                                    ^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut map = HashMap::new();\n    let vowels = \"\
    aeiouy\".chars().collect::<Vec<&str>>();\n    for (i, c) in message.chars().iter().enumerate()\
    \ {\n        match c {\n            ' ' => map.entry(i).or_insert(c),\n      \
    \      'a' => {\n                map.entry(i - 1).or_insert(vowels[i % vowels.len()])\n\
    \            },\n            'e' => {\n                map.entry(i - 1).or_insert(vowels[i\
    \ % vowels.len()])\n            },\n            'i' => {\n                map.entry(i\
    \ - 1).or_insert(vowels[i % vowels.len()])\n            },\n            'o' =>\
    \ {\n                map.entry(i - 1).or_insert(vowels[i % vowels.len()])\n  \
    \          },\n            'u' => {\n                map.entry(i - 1).or_insert(vowels[i\
    \ % vowels.len()])\n            },\n            'y' => {\n                map.entry(i\
    \ - 1).or_insert(vowels[i % vowels.len()])\n            },\n            _ => {\n\
    \                map.entry(i - 1).or_insert(c)\n            }\n        }\n   \
    \ }\n    \n    let mut result = String::new();\n    for (i, c) in map.iter().enumerate()\
    \ {\n        result.append(c);\n        if i < map.len() - 2 {\n            result.append(map.get(i\
    \ + 1).unwrap());\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpdki5j15b.rs:12:19\n   |\n12 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ a value of type `Vec<&str>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpdki5j15b.rs:13:35\n     |\n13   |     let vowels\
    \ = \"aeiouy\".chars().collect::<Vec<&str>>();\n     |                       \
    \            ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `iter` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpdki5j15b.rs:14:35\n   |\n14 |  \
    \   for (i, c) in message.chars().iter().enumerate() {\n   |                 \
    \                  ^^^^ private field, not a method\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmpdki5j15b.rs:43:16\n\
    \   |\n43 |         result.append(c);\n   |                ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpdki5j15b.rs:45:20\n   |\n45 |          \
    \   result.append(map.get(i + 1).unwrap());\n   |                    ^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for &c in message\
    \ {\n        let ascii_code = match c.to_ascii_lowercase() {\n            \"a\"\
    \ => 0x61,\n            \"b\" => 0x62,\n            \"c\" => 0x63,\n         \
    \   \"d\" => 0x64,\n            \"e\" => 0x65,\n            \"f\" => 0x66,\n \
    \           \"g\" => 0x67,\n            \"h\" => 0x68,\n            \"i\" => 0x69,\n\
    \            \"j\" => 0x6A,\n            \"k\" => 0x6B,\n            \"l\" =>\
    \ 0x6C,\n            \"m\" => 0x6D,\n            \"n\" => 0x6E,\n            \"\
    o\" => 0x6F,\n            \"p\" => 0x70,\n            \"q\" => 0x71,\n       \
    \     \"r\" => 0x72,\n            \"s\" => 0x73,\n            \"t\" => 0x74,\n\
    \            \"u\" => 0x75,\n            \"v\" => 0x76,\n            \"w\" =>\
    \ 0x77,\n            \"x\" => 0x78,\n            \"y\" => 0x79,\n            \"\
    z\" => 0x7A,\n            _ => return \"\",\n        };\n        let vowel = match\
    \ &c {\n            'a' => 'a',\n            'e' => 'a',\n            'i' => 'a',\n\
    \            'o' => 'o',\n            'u' => 'u',\n            _ => return \"\"\
    ,\n        };\n        result.push_str(&vowel.to_string());\n        result.push_str(&ascii_code);\n\
    \        result.push(' ');\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpphmixer6.rs:13:15\n\
    \   |\n13 |     for &c in message {\n   |               ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpphmixer6.rs:41:25\n   |\n41 |             _ => return \"\
    \",\n   |                         ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpphmixer6.rs:52:25\n\
    \   |\n52 |         result.push_str(&ascii_code);\n   |                      \
    \   ^^^^^^^^^^^ expected `str`, found integer\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&{integer}`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for letter in\
    \ message.chars().filter(|&x| x >= 'A' && x <= 'Z') {\n        let mut position\
    \ = 0;\n        for vowel in vowels {\n            if letter == vowel {\n    \
    \            let mut index = vowel.find_position(letter);\n                while\
    \ index != 0 {\n                    position += index;\n                    index\
    \ -= 1;\n                }\n                result += &vowels[position];\n   \
    \         }\n        }\n        result += &letter;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmp0m5ak7ii.rs:15:22\n\
    \   |\n15 |         for vowel in vowels {\n   |                      ^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `vowels` in this scope\n\
    \  --> /tmp/tmp0m5ak7ii.rs:22:28\n   |\n22 |                 result += &vowels[position];\n\
    \   |                            ^^^^^^ help: a local variable with a similar\
    \ name exists: `vowel`\n\nerror[E0599]: no method named `find_position` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp0m5ak7ii.rs:17:39\n   |\n\
    17 |                 let mut index = vowel.find_position(letter);\n   |      \
    \                                 ^^^^^^^^^^^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0m5ak7ii.rs:25:19\n   |\n25 |  \
    \       result += &letter;\n   |                   ^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c\n        }\n        if c.is_uppercase() {\n            c.swapcase()\n\
    \        }\n        if c.is_digit() {\n            c.to_string()\n        }\n\
    \        if c.is_ascii() {\n            if c.is_lowercase() {\n              \
    \  c.to_string()\n            }\n            if c.is_uppercase() {\n         \
    \       c.to_string().swapcase()\n            }\n        }\n    }).map(|c| {\n\
    \        if c.is_lowercase() {\n            c\n        }\n        if c.is_uppercase()\
    \ {\n            c.swapcase()\n        }\n        if c.is_digit() {\n        \
    \    c.to_string()\n        }\n        if c.is_ascii() {\n            if c.is_lowercase()\
    \ {\n                c.to_string()\n            }\n            if c.is_uppercase()\
    \ {\n                c.to_string().swapcase()\n            }\n        }\n    }).map(|c|\
    \ {\n        if c.is_lowercase() {\n            c\n        }\n        if c.is_uppercase()\
    \ {\n            c.swapcase()\n        }\n        if c.is_digit() {\n        \
    \    c.to_string()\n        }\n        if c.is_ascii() {\n            if c.is_lowercase()\
    \ {\n                c.to_string()\n            }\n            if c.is_uppercase()\
    \ {\n                c.to_string().swapcase()\n            }\n        }\n    }).map(|c|\
    \ {\n        if c.is_lowercase() {\n            c\n        }\n        if c.is_uppercase()\
    \ {\n            c.swapcase()\n        }\n        if c.is_digit() {\n        \
    \    c.to_string()\n        }\n        if c.is_ascii() {\n            if c.is_lowercase()\
    \ {\n                c.to_string()\n            }\n            if c.is_uppercase()\
    \ {\n                c.to_string().swapcase()\n            }\n        }\n    }).map(|c|\
    \ {\n        if c.is_lowercase() {\n            c\n        }\n        if c.is_uppercase()\
    \ {\n            c.swapcase()\n        }\n        if c.is_digit() {\n        \
    \    c.to_string()\n        }\n        if c.is_ascii() {\n            if c.is_lowercase()\
    \ {\n                c.to_string()\n            }\n            if c.is_uppercase()\
    \ {\n                c.to_string().swapcase()\n            }\n        }\n    }).map(|c|\
    \ {\n        if c.is_lowercase() {\n            c\n        }\n        if c.is_uppercase()\
    \ {\n            c.swapcase()\n        }\n        if c.is_digit() {\n        \
    \    c.to_string()\n        }\n        if c.is_ascii() {\n            if c.is_lowercase()\
    \ {\n                c.to_string()\n            }\n            if c.is_uppercase()\
    \ {\n                c.to_string().swapcase()\n            }\n        }\n    }).map(|c|\
    \ {\n        if c.is_lowercase() {\n            c\n        }\n\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmplvdb_hji.rs:134:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n120 |     }).map(|c| {\n    |\
    \           - unclosed delimiter\n...\n134 | }\n    |   ^\n\nerror: expected one\
    \ of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n   --> /tmp/tmplvdb_hji.rs:127:1\n\
    \    |\n125 | }\n    |  - expected one of `)`, `,`, `.`, `?`, or an operator\n\
    126 | \n127 | fn main() {\n    | ^^ unexpected token\n\nerror: aborting due to\
    \ 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels:\
    \ Vec<&str> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut cases: Vec<&str>\
    \ = vec![\"A\", \"E\", \"I\", \"O\", \"U\"];\n    for letter in message.chars()\
    \ {\n        if let Some(pos) = vowels.index(letter) {\n            result.push_str(&cases[pos-1]);\n\
    \        } else {\n            result.push_str(&cases[vowels.len()]);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmp5sjaubrh.rs:16:35\n   |\n16 |         if let Some(pos)\
    \ = vowels.index(letter) {\n   |                                   ^^^^^ method\
    \ not found in `Vec<&str>`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    fn vowel_count(char: char) -> usize {\n        let\
    \ mut cnt = 0;\n        loop {\n            if char == 'a' || char == 'e' || char\
    \ == 'i' || char == 'o' || char == 'u' {\n                break;\n           \
    \ }\n            cnt += 1;\n            char =\n                char.next::<()>().unwrap();\n\
    \        }\n        cnt\n    }\n\n    fn letter_count(char: char) -> usize {\n\
    \        let mut cnt = 0;\n        loop {\n            if char == 'A' || char\
    \ == 'E' || char == 'I' || char == 'O' || char == 'U' {\n                break;\n\
    \            }\n            cnt += 1;\n            char =\n                char.next::<()>().unwrap();\n\
    \        }\n        cnt\n    }\n\n    fn translate_swap<char, output>(char: char,\
    \ output: &mut output) {\n        if char == 'a' || char == 'e' || char == 'i'\
    \ || char == 'o' || char == 'u' {\n            output.write_char(char.next::<()>().unwrap());\n\
    \        }\n        if char == 'A' || char == 'E' || char == 'I' || char == 'O'\
    \ || char == 'U' {\n            output.write_char(char.next::<()>().unwrap());\n\
    \        }\n    }\n\n    fn translate_vowel(char: char, output: &mut output) {\n\
    \        output.write_char('K')\n    }\n\n    let mut output: String = String::new();\n\
    \    for char in message.chars() {\n        let mut output: &mut String = (&mut\
    \ output);\n        translate_swap(char, output);\n        translate_vowel(char,\
    \ output);\n    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0573]: expected type, found local variable `output`\n  --> /tmp/tmpndx0itxo.rs:47:49\n\
    \   |\n47 |     fn translate_vowel(char: char, output: &mut output) {\n   |  \
    \                                               ^^^^^^ not a type\n\nwarning:\
    \ type parameter `char` should have an upper camel case name\n  --> /tmp/tmpndx0itxo.rs:38:23\n\
    \   |\n38 |     fn translate_swap<char, output>(char: char, output: &mut output)\
    \ {\n   |                       ^^^^ help: convert the identifier to upper camel\
    \ case (notice the capitalization): `Char`\n   |\n   = note: `#[warn(non_camel_case_types)]`\
    \ on by default\n\nwarning: type parameter `output` should have an upper camel\
    \ case name\n  --> /tmp/tmpndx0itxo.rs:38:29\n   |\n38 |     fn translate_swap<char,\
    \ output>(char: char, output: &mut output) {\n   |                           \
    \  ^^^^^^ help: convert the identifier to upper camel case (notice the capitalization):\
    \ `Output`\n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmpndx0itxo.rs:53:39\n\
    \   |\n53 |         let mut output: &mut String = (&mut output);\n   |       \
    \                                ^           ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n53 -         let mut output:\
    \ &mut String = (&mut output);\n53 +         let mut output: &mut String = &mut\
    \ output;\n   | \n\nerror[E0599]: no method named `next` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpndx0itxo.rs:20:22\n   |\n20 |          \
    \       char.next::<()>().unwrap();\n   |                      ^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `next` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpndx0itxo.rs:33:22\n   |\n33 |          \
    \       char.next::<()>().unwrap();\n   |                      ^^^^ method not\
    \ found in `char`\n\nerror[E0369]: binary operation `==` cannot be applied to\
    \ type `char`\n  --> /tmp/tmpndx0itxo.rs:39:17\n   |\n39 |         if char ==\
    \ 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n   |    \
    \        ---- ^^ --- char\n   |            |\n   |            char\n   |\nhel"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut ascii_map = HashMap::new();\n    for letter\
    \ in message.chars() {\n        let mut key = ascii_map.entry(letter).or_insert(0);\n\
    \        key = key + 1;\n        ascii_map.insert(letter, key);\n    }\n    let\
    \ mut result = String::new();\n    for letter in ascii_map.keys().cloned() {\n\
    \        let mut key = ascii_map.entry(letter).or_insert(0);\n        key = key\
    \ + 2;\n        result = result + key.to_string();\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp4mfr7sxb.rs:12:25\n   |\n12 |     let mut ascii_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for i in message.chars()\
    \ {\n        let v = i.as_bytes().nth(3).unwrap();\n        result.push((*v as\
    \ char).to_string());\n        result.push((*v as char).to_string());\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpma5o_yyc.rs:14:19\n   |\n14 |         let v = i.as_bytes().nth(3).unwrap();\n\
    \   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut char_map = String::new();\n\n    for char in\
    \ message {\n        match char {\n            'a' => char_map.push('a'),\n  \
    \          'e' => char_map.push('e'),\n            'i' => char_map.push('i'),\n\
    \            'o' => char_map.push('o'),\n            'u' => char_map.push('u'),\n\
    \            _ => char_map.push(char),\n        }\n    }\n\n    let mut swap =\
    \ String::new();\n\n    for char in char_map {\n        match char {\n       \
    \     'a' => swap.push('z'),\n            'e' => swap.push('z'),\n           \
    \ 'i' => swap.push('z'),\n            'o' => swap.push('z'),\n            'u'\
    \ => swap.push('z'),\n            _ => swap.push(char),\n        }\n    }\n\n\
    \    for char in swap {\n        match char {\n            'a' => char_map.push('z'),\n\
    \            'e' => char_map.push('z'),\n            'i' => char_map.push('z'),\n\
    \            'o' => char_map.push('z'),\n            'u' => char_map.push('z'),\n\
    \            _ => char_map.push(char),\n        }\n    }\n\n    char_map\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp4aab7w8c.rs:14:17\n\
    \   |\n14 |     for char in message {\n   |                 ^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp4aab7w8c.rs:27:17\n   |\n27 |   \
    \  for char in char_map {\n   |                 ^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmp4aab7w8c.rs:38:17\n   |\n38 |     for char in swap\
    \ {\n   |                 ^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().filter(|x| *x == 'a' || *x == 'e' ||\
    \ *x == 'i' || *x == 'o' || *x == 'u').map(|x| x.to_ascii_lowercase()).collect()\n\
    \        .iter()\n        .map(|x| x.to_ascii_lowercase())\n        .zip(message.chars().filter(|x|\
    \ *x == 'A' || *x == 'E' || *x == 'I' || *x == 'O' || *x == 'U').map(|x| x.to_ascii_lowercase()).collect())\n\
    \        .filter_map(|(first, second)| (&first as *const i8).wrapping_sub(second\
    \ as *const i8).wrapping_sub(32).wrapping_sub(32) as u32).collect::<Vec<u32>>()\n\
    \        .iter()\n        .map(|x| {\n            match x % 32 {\n           \
    \     0 => \"A\".to_string(),\n                1 => \"B\".to_string(),\n     \
    \           2 => \"C\".to_string(),\n                3 => \"D\".to_string(),\n\
    \                4 => \"E\".to_string(),\n                5 => \"F\".to_string(),\n\
    \                6 => \"G\".to_string(),\n                7 => \"H\".to_string(),\n\
    \                8 => \"I\".to_string(),\n                9 => \"J\".to_string(),\n\
    \                10 => \"K\".to_string(),\n                11 => \"L\".to_string(),\n\
    \                12 => \"M\".to_string(),\n                13 => \"N\".to_string(),\n\
    \                14 => \"O\".to_string(),\n                15 => \"P\".to_string(),\n\
    \                16 => \"Q\".to_string(),\n                17 => \"R\".to_string(),\n\
    \                18 => \"S\".to_string(),\n                19 => \"T\".to_string(),\n\
    \                20 => \"U\".to_string(),\n                21 => \"V\".to_string(),\n\
    \                22 => \"W\".to_string(),\n                23 => \"X\".to_string(),\n\
    \                24 => \"Y\".to_string(),\n                25 => \"Z\".to_string(),\n\
    \                26 => \"a\".to_string(),\n                27 => \"b\".to_string(),\n\
    \                28 => \"c\".to_string(),\n                29 => \"d\".to_string(),\n\
    \                30 => \"e\".to_string(),\n                31 => \"f\".to_string(),\n\
    \                32 => \"g\".to_string(),\n                33 => \"h\".to_string(),\n\
    \                34 => \"i\".to_string(),\n                35 => \"j\".to_string(),\n\
    \                36 => \"k\".to_string(),\n                37 => \"l\".to_string(),\n\
    \                38 => \"m\".to_string(),\n                39 => \"n\".to_string(),\n\
    \                40 => \"o\".to_string(),\n                41 => \"\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpgj2unpne.rs:70:109\n\
    \   |\n70 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    71 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = \"\";\n    for (index, c) in message.chars().enumerate()\
    \ {\n        let mut newC = c;\n        if c.is_lowercase() {\n            newC\
    \ = newC + ('A' as u8);\n        }\n        if c.is_uppercase() {\n          \
    \  newC = newC + ('A' as u8);\n        }\n        if c.is_digit() {\n        \
    \    newC = newC + ('0' as u8);\n        }\n        if c.is_punct() {\n      \
    \      newC = newC + ('0' as u8);\n        }\n        if c.is_whitespace() {\n\
    \            newC = newC + ('0' as u8);\n        }\n        output += newC;\n\
    \        if (index + 1) % 2 == 0 {\n            let mut newC = output;\n     \
    \       for (i, c2) in message.chars().enumerate().rev() {\n                if\
    \ c2 == c {\n                    newC = output + ('a' as u8);\n              \
    \  }\n                output += newC;\n            }\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `u8` to `char`\n  --> /tmp/tmpueacs5qb.rs:16:25\n\
    \   |\n16 |             newC = newC + ('A' as u8);\n   |                    ----\
    \ ^ ----------- u8\n   |                    |\n   |                    char\n\n\
    error[E0369]: cannot add `u8` to `char`\n  --> /tmp/tmpueacs5qb.rs:19:25\n   |\n\
    19 |             newC = newC + ('A' as u8);\n   |                    ---- ^ -----------\
    \ u8\n   |                    |\n   |                    char\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpueacs5qb.rs:21:14\n\
    \    |\n21  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |              |\n    |              expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0369]: cannot add `u8`\
    \ to `char`\n  --> /tmp/tmpueacs5qb.rs:22:25\n   |\n22 |             newC = newC\
    \ + ('0' as u8);\n   |                    ---- ^ ----------- u8\n   |        \
    \            |\n   |                    char\n\nerror[E0599]: no method named\
    \ `is_punct` found for type `char` in the current scope\n  --> /tmp/tmpueacs5qb.rs:24:14\n\
    \   |\n24 |         if c.is_punct() {\n   |              ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0369]: cannot add `u8` to `char`\n  --> /tmp/tmpueacs5qb.rs:25:25\n\
    \   |\n25 |             newC = newC + ('0' as u8);\n   |                    ----\
    \ ^ ----------- u8\n   |                    |\n   |                    char\n\n\
    error[E0369]: cannot add `u8` to `char`\n  --> /tmp/tmpueacs5qb.rs:28:25\n   |\n\
    28 |             newC = newC + ('0' as u8);\n   |                    ---- ^ -----------\
    \ u8\n   |                    |\n   |                    char\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpueacs5qb.rs:30:9\n\
    \   |\n30 |         output += newC;\n   |         ------^^^^^^^^\n   |       \
    \  |\n   |         cannot use `+=` on type `&str`\n\nerror[E0277]: the trait bound\
    \ `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpueacs5qb.rs:33:56\n\
    \     |\n33   |             for (i, c2) in message.chars().enumerate().rev() {\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = message;\n    let mut counter:\
    \ usize = 0;\n    let mut letter_counter: usize = 0;\n    let mut vowel_counter:\
    \ usize = 0;\n    let mut letter_mapping = [String::new(); 26];\n\n    for letter\
    \ in new_message.chars() {\n        let mut new_letter = letter;\n        \n \
    \       // Map every letter of english alphabet to a letter that appears\n   \
    \     // 2 places ahead of that letter in the english alphabet\n        if letter_counter\
    \ + 2 > new_message.len() {\n            letter_counter += 2;\n            new_letter\
    \ = letter_mapping[letter_counter];\n        } else {\n            letter_counter\
    \ += 1;\n            new_letter = letter_mapping[letter_counter];\n        }\n\
    \        \n        // Map every vowel from a given message to a letter that appears\n\
    \        // 2 places ahead of that vowel in the english alphabet\n        if vowel_counter\
    \ + 2 > new_message.len() {\n            vowel_counter += 2;\n            new_letter\
    \ += vowel_mapping[vowel_counter];\n        } else {\n            vowel_counter\
    \ += 1;\n            new_letter += vowel_mapping[vowel_counter];\n        }\n\n\
    \        new_message += new_letter;\n        counter += 1;\n    }\n\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowel_mapping` in this scope\n  --> /tmp/tmp2yqfd2va.rs:35:27\n\
    \   |\n35 |             new_letter += vowel_mapping[vowel_counter];\n   |    \
    \                       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `vowel_mapping` in this scope\n  --> /tmp/tmp2yqfd2va.rs:38:27\n\
    \   |\n38 |             new_letter += vowel_mapping[vowel_counter];\n   |    \
    \                       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the trait bound `String: Copy` is not satisfied\n  --> /tmp/tmp2yqfd2va.rs:16:31\n\
    \   |\n16 |     let mut letter_mapping = [String::new(); 26];\n   |          \
    \                     ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n\
    \   |\n   = note: the `Copy` trait is required because this value will be copied\
    \ for each element of the array\n   = help: consider creating a new `const` item\
    \ and initializing it with the result of the function call to be used in the repeat\
    \ position, like `const VAL: Type = const_fn();` and `let x = [VAL; 42];`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2yqfd2va.rs:25:26\n   |\n19 |  \
    \       let mut new_letter = letter;\n   |                              ------\
    \ expected due to this value\n...\n25 |             new_letter = letter_mapping[letter_counter];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2yqfd2va.rs:28:26\n\
    \   |\n19 |         let mut new_letter = letter;\n   |                       \
    \       ------ expected due to this value\n...\n28 |             new_letter =\
    \ letter_mapping[letter_counter];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp2yqfd2va.rs:41:24\n   |\n41 |         new_message += new_letter;\n\
    \   |                        ^^^^^^^^^^ expected `&str`, found `char`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut message = String::from(message);\n    let mut\
    \ output = 'Z';\n\n    for char in &message {\n        output += match char {\n\
    \            'A'..='Z' => {\n                match output[output.len()-2..output.len()-1]\
    \ {\n                    'a' => &'A',\n                    'b'..='c' => &'B',\n\
    \                    'd'..='g' => &'D',\n                    'h'..='r' => &'H',\n\
    \                    's'..='z' => &'S',\n                    _ => {\n        \
    \                let mut index = output.len();\n                        let mut\
    \ vowel_index = index;\n                        while vowel_index > 0 && vowel_index\
    \ < output.len() {\n                            if output[vowel_index] == 'a'\
    \ {\n                                vowel_index += 1;\n                     \
    \       } else if output[vowel_index] == 'e' {\n                             \
    \   vowel_index += 1;\n                            } else if output[vowel_index]\
    \ == 'i' {\n                                vowel_index += 1;\n              \
    \              } else if output[vowel_index] == 'o' {\n                      \
    \          vowel_index += 1;\n                            } else if output[vowel_index]\
    \ == 'u' {\n                                vowel_index += 1;\n              \
    \              } else if output[vowel_index] == 'y' {\n                      \
    \          vowel_index += 1;\n                            } else {\n         \
    \                       break;\n                            }\n              \
    \          }\n                        output[vowel_index] = char;\n          \
    \          }\n                }\n            }\n            'a'..='z' => {\n \
    \               match output[output.len()-1..output.len()-1] {\n             \
    \       'a' => &'a',\n                    'b'..='c' => &'b',\n               \
    \     'd'..='g' => &'d',\n                    'h'..='r' => &'h',\n           \
    \         's'..='z' => &'s',\n                    _ => {\n                   \
    \     let mut index = output.len();\n                        let mut vowel_index\
    \ = index;\n                        while vowel_index > 0 && vowel_index < output.len()\
    \ {\n                            if output[vowel_index] == 'a' {\n           \
    \                     vowel_index += 1;\n                            } else if\
    \ output[vowel_index] == 'e' {\n                                vowel_index +=\
    \ 1;\n                            } else if output[vowel_index] == 'i' {\n   \
    \                             vowel_index += 1;\n                            }\
    \ else if output[vowel_index] == 'o' {\n                                vowel_index\
    \ += 1;\n                            } else if output[vowel_index] == 'u' {\n\
    \                                vowel_index += 1;\n                         \
    \   } else if output[vowel_index] == 'y' {\n                                vowel_index\
    \ += 1;\n                            } else {\n                              \
    \  break;\n                            }\n                        }\n        \
    \                output[vowel_index] = char;\n                    }\n        \
    \        }\n            }\n            _ => char,\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp14utvonc.rs:89:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n15 |     for char in &message {\n\
    \   |                          - unclosed delimiter\n16 |         output += match\
    \ char {\n   |                              - this delimiter might not be properly\
    \ closed...\n...\n80 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n89 | }\n   |   ^\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found keyword `fn`\n  --> /tmp/tmp14utvonc.rs:11:38\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                                      ^ unclosed delimiter\n\
    ...\n80 | }\n   |  -\n   |  |\n   |  expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n   |  help: `}` may belong here\n81 | \n82 | fn main() {\n   | ^^\
    \ unexpected token\n\nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmp14utvonc.rs:15:17\n\
    \   |\n15 |     for char in &message {\n   |                 ^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14utvonc.rs:15:5\n\
    \   |\n11 |   fn encode(message: String) -> String {\n   |                   \
    \              ------ expected `String` because of return type\n...\n15 | /  \
    \   for char in &message {\n16 | |         output += match char {\n17 | |    \
    \         'A'..='Z' => {\n18 | |                 match output[output.len()-2..output.len()-1]\
    \ {\n...  |\n88 | |     assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO\
    \ WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n89 | | }\n   | |__^\
    \ expected struct `String`, found `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut buffer = String::new();\n    let mut buffer_index\
    \ = 0;\n    let mut next_index = -1;\n    let mut current_char = 0;\n    let mut\
    \ alphabet = [\n        'a'.to_string(),\n        'b'.to_string(),\n        'c'.to_string(),\n\
    \        'd'.to_string(),\n        'e'.to_string(),\n        'f'.to_string(),\n\
    \        'g'.to_string(),\n        'h'.to_string(),\n        'i'.to_string(),\n\
    \        'j'.to_string(),\n        'k'.to_string(),\n        'l'.to_string(),\n\
    \        'm'.to_string(),\n        'n'.to_string(),\n        'o'.to_string(),\n\
    \        'p'.to_string(),\n        'q'.to_string(),\n        'r'.to_string(),\n\
    \        's'.to_string(),\n        't'.to_string(),\n        'u'.to_string(),\n\
    \        'v'.to_string(),\n        'w'.to_string(),\n        'x'.to_string(),\n\
    \        'y'.to_string(),\n        'z'.to_string()\n    ];\n    for &c in &message\
    \ {\n        current_char = (c - 'a').wrapping_add(1);\n        buffer.push((alphabet[current_char\
    \ as usize]).to_string());\n        if current_char == next_index {\n        \
    \    buffer.push(c);\n        } else {\n            buffer.push((alphabet[next_index\
    \ as usize]).to_string());\n            buffer.push(c);\n        }\n        buffer_index\
    \ += 1;\n        next_index = current_char;\n    }\n    buffer\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp_n8ln9vc.rs:44:15\n\
    \   |\n44 |     for &c in &message {\n   |               ^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_n8ln9vc.rs:46:21\n\
    \   |\n46 |         buffer.push((alphabet[current_char as usize]).to_string());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0277]: cannot subtract `char` from `char`\n\
    \  --> /tmp/tmp_n8ln9vc.rs:45:27\n   |\n45 |         current_char = (c - 'a').wrapping_add(1);\n\
    \   |                           ^ no implementation for `char - char`\n   |\n\
    \   = help: the trait `Sub` is not implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_n8ln9vc.rs:50:25\n   |\n50 |             buffer.push((alphabet[next_index\
    \ as usize]).to_string());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp_n8ln9vc.rs:14:26\n   |\n14 |     let mut\
    \ next_index = -1;\n   |                          ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().filter(|&c| c.is_alphabetic(32)).map(|c|\n\
    \        match c {\n            'a' => { 'A' }\n            'b' => { 'B' }\n \
    \           'c' => { 'C' }\n            'd' => { 'D' }\n            'e' => { 'E'\
    \ }\n            'f' => { 'F' }\n            'g' => { 'G' }\n            'h' =>\
    \ { 'H' }\n            'i' => { 'I' }\n            'j' => { 'J' }\n          \
    \  'k' => { 'K' }\n            'l' => { 'L' }\n            'm' => { 'M' }\n  \
    \          'n' => { 'N' }\n            'o' => { 'O' }\n            'p' => { 'P'\
    \ }\n            'q' => { 'Q' }\n            'r' => { 'R' }\n            's' =>\
    \ { 'S' }\n            't' => { 'T' }\n            'u' => { 'U' }\n          \
    \  'v' => { 'V' }\n            'w' => { 'W' }\n            'x' => { 'X' }\n  \
    \          'y' => { 'Y' }\n            'z' => { 'Z' }\n            'A' => { 'a'\
    \ }\n            'B' => { 'b' }\n            'C' => { 'c' }\n            'D' =>\
    \ { 'd' }\n            'E' => { 'e' }\n            'F' => { 'f' }\n          \
    \  'G' => { 'g' }\n            'H' => { 'h' }\n            'I' => { 'i' }\n  \
    \          'J' => { 'j' }\n            'K' => { 'k' }\n            'L' => { 'l'\
    \ }\n            'M' => { 'm' }\n            'N' => { 'n' }\n            'O' =>\
    \ { 'o' }\n            'P' => { 'p' }\n            'Q' => { 'q' }\n          \
    \  'R' => { 'r' }\n            'S' => { 's' }\n            'T' => { 't' }\n  \
    \          'U' => { 'u' }\n            'V' => { 'v' }\n            'W' => { 'w'\
    \ }\n            'X' => { 'x' }\n            'Y' => { 'y' }\n            'Z' =>\
    \ { 'z' }\n            _ => {\n                let mut buffer = Vec::new();\n\
    \                buffer.push(c);\n                let mut letter = false;\n  \
    \              while !letter {\n                    let mut letter = buffer.last().unwrap().to_ascii_lowercase().contains(&c).unwrap();\n\
    \                    buffer.pop();\n                    let mut i = 1;\n     \
    \               while !letter {\n                        \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuz1ws53b.rs:85:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n12 |     message.chars().filter(|&c| c.is_alphabetic(32)).map(|c|\n\
    \   |                                                         - unclosed delimiter\n\
    13 |         match c {\n   |                 - unclosed delimiter\n...\n66 | \
    \            _ => {\n   |                  - unclosed delimiter\n...\n70 |   \
    \              while !letter {\n   |                               - unclosed\
    \ delimiter\n...\n74 |                     while !letter {\n   |             \
    \                      - this delimiter might not be properly closed...\n75 |\
    \                         \n76 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n85 | }\n   |   ^\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpuz1ws53b.rs:12:35\n    |\n12  |\
    \     message.chars().filter(|&c| c.is_alphabetic(32)).map(|c|\n    |        \
    \                           ^^^^^^^^^^^^^ -- supplied 1 argument\n    |      \
    \                             |\n    |                                   expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no method named `contains` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpuz1ws53b.rs:71:82\n   |\n71 |                     let mut letter = buffer.last().unwrap().to_ascii_lowercase().contains(&c).unwrap();\n\
    \   |                                                                        \
    \          ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuz1ws53b.rs:12:5\n   |\n11 |   fn encode(message: String) -> String\
    \ {\n   |                                 ------ expected `String` because of\
    \ return type\n12 | /     message.chars().filter(|&c| c.is_alphabetic(32)).map(|c|\n\
    13 | |         match c {\n14 | |             'a' => { 'A' }\n15 | |          \
    \   'b' => { 'B' }\n...  |\n84 | |     assert_eq!(candidate(String::from(\"I DoNt\
    \ KnOw WhAt tO WrItE\")), String::from(\"k dQnT k"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut answer = String::new();\n    let mut count\
    \ = 0;\n    for i in message.chars() {\n        if i.to_ascii_lowercase() == 'a'\
    \ {\n            answer.push_str(&'b');\n            count += 1;\n        }\n\
    \        else if i.to_ascii_lowercase() == 'b' {\n            answer.push_str(&'c');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 'c' {\n            answer.push_str(&'d');\n            count += 1;\n       \
    \ }\n        else if i.to_ascii_lowercase() == 'd' {\n            answer.push_str(&'e');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 'e' {\n            answer.push_str(&'f');\n            count += 1;\n       \
    \ }\n        else if i.to_ascii_lowercase() == 'f' {\n            answer.push_str(&'g');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 'g' {\n            answer.push_str(&'h');\n            count += 1;\n       \
    \ }\n        else if i.to_ascii_lowercase() == 'h' {\n            answer.push_str(&'i');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 'i' {\n            answer.push_str(&'j');\n            count += 1;\n       \
    \ }\n        else if i.to_ascii_lowercase() == 'j' {\n            answer.push_str(&'k');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 'k' {\n            answer.push_str(&'l');\n            count += 1;\n       \
    \ }\n        else if i.to_ascii_lowercase() == 'l' {\n            answer.push_str(&'m');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 'm' {\n            answer.push_str(&'n');\n            count += 1;\n       \
    \ }\n        else if i.to_ascii_lowercase() == 'n' {\n            answer.push_str(&'o');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 'o' {\n            answer.push_str(&'p');\n            count += 1;\n       \
    \ }\n        else if i.to_ascii_lowercase() == 'p' {\n            answer.push_str(&'q');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 'q' {\n            answer.push_str(&'r');\n            count += 1;\n       \
    \ }\n        else if i.to_ascii_lowercase() == 'r' {\n            answer.push_str(&'s');\n\
    \            count += 1;\n        }\n        else if i.to_ascii_lowercase() ==\
    \ 's' {\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmjq1m9cr.rs:97:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for i in message.chars()\
    \ {\n   |                              - unclosed delimiter\n...\n87 |       \
    \  else if i.to_ascii_lowercase() == 's' {\n   |                             \
    \                  - this delimiter might not be properly closed...\n88 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n97 | }\n\
    \   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmjq1m9cr.rs:16:29\n\
    \   |\n16 |             answer.push_str(&'b');\n   |                         \
    \    ^^^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmjq1m9cr.rs:20:29\n   |\n20 |             answer.push_str(&'c');\n \
    \  |                             ^^^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmjq1m9cr.rs:24:29\n   |\n24 |             answer.push_str(&'d');\n\
    \   |                             ^^^^ expected `str`, found `char`\n   |\n  \
    \ = note: expected reference `&str`\n              found reference `&char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpmjq1m9cr.rs:28:29\n   |\n28 |  \
    \           answer.push_str(&'e');\n   |                             ^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmjq1m9cr.rs:32:29\n\
    \   |\n32 |             answer.push_str(&'f');\n   |                         \
    \    ^^^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmjq1m9cr.rs:36:29\n   |\n36 |             answer.push_str(&'g');\n \
    \  |                             ^^^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              foun"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    for (i, letter) in\
    \ message.chars().enumerate() {\n        if letter.is_lowercase() || letter.is_uppercase()\
    \ {\n            s.push_str(letter);\n        } else {\n            if let Some((i,j))\
    \ = vowels.iter().position(|vowel| vowel == letter) {\n                s.push_str(alphabet[alphabet.len()\
    \ - j].to_string());\n            } else {\n                s.push_str(alphabet[alphabet.len()\
    \ - i].to_string());\n            }\n        }\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmp3758vc0j.rs:17:34\n\
    \   |\n17 |             if let Some((i,j)) = vowels.iter().position(|vowel| vowel\
    \ == letter) {\n   |                                  ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp3758vc0j.rs:18:28\n\
    \   |\n18 |                 s.push_str(alphabet[alphabet.len() - j].to_string());\n\
    \   |                            ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmp3758vc0j.rs:18:37\n\
    \   |\n18 |                 s.push_str(alphabet[alphabet.len() - j].to_string());\n\
    \   |                                     ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp3758vc0j.rs:20:28\n\
    \   |\n20 |                 s.push_str(alphabet[alphabet.len() - i].to_string());\n\
    \   |                            ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmp3758vc0j.rs:20:37\n\
    \   |\n20 |                 s.push_str(alphabet[alphabet.len() - i].to_string());\n\
    \   |                                     ^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3758vc0j.rs:15:24\n   |\n15 |  \
    \           s.push_str(letter);\n   |                        ^^^^^^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::new();\n    let vowels\
    \ = \"aeiou\";\n    for vowel in vowels.chars().skip_while(|c| c != 'a') {\n \
    \       if let Some(index) = message.char_indices().index(&vowel) {\n        \
    \    let a = message[..index].to_lowercase().chars().next().unwrap();\n      \
    \      let b = message[index + 1..].to_lowercase().chars().next().unwrap();\n\
    \            new_message.push((&a as char).to_string());\n            new_message.push((&b\
    \ as char).to_string());\n        } else {\n            new_message.push(vowel.to_string());\n\
    \        }\n    }\n    new_message.push_str(message);\n    new_message.trim_end();\n\
    \    new_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpakaioi1p.rs:14:50\n\
    \   |\n14 |     for vowel in vowels.chars().skip_while(|c| c != 'a') {\n   | \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `index` found for struct `CharIndices` in the current scope\n\
    \  --> /tmp/tmpakaioi1p.rs:15:53\n   |\n15 |         if let Some(index) = message.char_indices().index(&vowel)\
    \ {\n   |                                                     ^^^^^ method not\
    \ found in `CharIndices<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpakaioi1p.rs:18:30\n\
    \   |\n18 |             new_message.push((&a as char).to_string());\n   |    \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpakaioi1p.rs:19:30\n\
    \   |\n19 |             new_message.push((&b as char).to_string());\n   |    \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpakaioi1p.rs:21:30\n\
    \   |\n21 |             new_message.push(vowel.to_string());\n   |           \
    \                   ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpakaioi1p.rs:24:26\n   |\n24 |\
    \     new_message.push_str(message);\n   |                          ^^^^^^^\n\
    \   |                          |\n   |                          expected `&str`,\
    \ found struct `String`\n   |                          help: consider borrowing\
    \ here: `&message`\n\nerror[E0606]: casting `&char` as `char` is invalid\n  -->\
    \ /tmp/tmpakaioi1p.rs:18:30\n   |\n18 |             new_message.push((&a as char).to_string());\n\
    \   |                              ^^^^^^^^^^^^\n\nerror[E0606]: casting `&char`\
    \ as `char` is invalid\n  --> /tmp/tmpakaioi1p.rs:19:30\n   |\n19 |          \
    \   new_message.push((&b as char).to_string());\n   |                        \
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut out = String::new();\n    let mut index = 0;\n\
    \    let mut letter_pairs = Vec::new();\n    let mut vowels: Vec<&str> = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letter_counts = Vec::new();\n\
    \    for ch in message {\n        if index > message.len() - 1 {\n           \
    \ break;\n        }\n        let pair = encode_pair(ch, index, &mut letter_counts);\n\
    \        if pair == Some((index, index + 1)) {\n            letter_pairs.push((index\
    \ + 1, index));\n        }\n        \n        index += 1;\n    }\n    if letter_pairs.len()\
    \ == 0 {\n        return out;\n    }\n\n    let mut letters = Vec::new();\n  \
    \  let mut letter_counts = Vec::new();\n    let mut current_index = 0;\n    for\
    \ &(first, last) in letter_pairs {\n        let mut first = encode_pair(letter_pairs[first][0],\
    \ first, &mut letter_counts);\n        let mut last = encode_pair(letter_pairs[last][0],\
    \ first, &mut letter_counts);\n        \n        if letter_counts.iter().all(|&x|\
    \ x == 0) {\n            letters.push(first);\n            letters.push(last);\n\
    \        } else {\n            let mut a = first;\n            let mut b = last;\n\
    \            for letter in &letters {\n                if *letter > a {\n    \
    \                let mut letter = letter;\n                    letter = letter.to_lowercase().chars().filter_map(|x|\
    \ *x == x).next().unwrap();\n                    a = letter;\n               \
    \ }\n                if *letter > b {\n                    let mut letter = letter;\n\
    \                    letter = letter.to_lowercase().chars().filter_map(|x| *x\
    \ == x).next().unwrap();\n                    b = letter;\n                }\n\
    \            }\n            letters.push(a);\n            letters.push(b);\n \
    \       }\n    }\n\n    let mut counts = Vec::new();\n    for &(i, j) in letter_pairs\
    \ {\n        counts.push(letter_counts[j].to_owned().to_string());\n    }\n  \
    \  out = letters.iter().fold(out.to_owned(), |mut acc, x| {\n        acc.push_str(&*x).push_str(&counts[*x\
    \ - *acc.len() + 1]);\n        acc\n    });\n    out\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode_pair` in this scope\n  --> /tmp/tmp5me_huqo.rs:21:20\n\
    \   |\n21 |         let pair = encode_pair(ch, index, &mut letter_counts);\n \
    \  |                    ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `encode_pair` in this scope\n  --> /tmp/tmp5me_huqo.rs:36:25\n\
    \   |\n36 |         let mut first = encode_pair(letter_pairs[first][0], first,\
    \ &mut letter_counts);\n   |                         ^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `encode_pair` in this scope\n\
    \  --> /tmp/tmp5me_huqo.rs:37:24\n   |\n37 |         let mut last = encode_pair(letter_pairs[last][0],\
    \ first, &mut letter_counts);\n   |                        ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5me_huqo.rs:15:38\n\
    \   |\n15 |     let mut vowels: Vec<&str> = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', ...\n\
    \   |                                      ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    15 |     let mut vowels: Vec<&str> = vec![\"A\", 'B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\
    \ 'X', 'Y', 'Z'];\n   |                                      ~~~\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp5me_huqo.rs:17:15\n   |\n17 |   \
    \  for ch in message {\n   |               ^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5me_huqo.rs:35:9\n   |\n35 |     for &(first, last) in letter_pairs\
    \ {\n   |         ^^^^^^^^^^^^^^    ------------ this expression has type `Option<(usize,\
    \ usize)>`\n   |         |\n   |         expected tuple, found reference\n   |\n\
    \   = note:  expected tuple `(usize, usize)`\n           found reference `&_`\n\
    \nerror[E030"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut alphabet = vec!['a'..'z', 'A'..'Z'];\n    alphabet.sort_unstable();\n\
    \n    let mut vowels = vec!['e'..'i', 'a'..'o', 'o'..'u'];\n    vowels.sort_unstable();\n\
    \n    let mut new_message = \"\".to_string();\n    for c in message {\n      \
    \  if let Some(_) = alphabet.binary_search(&c) {\n            new_message += vowels[alphabet.binary_search(&c\
    \ + 2)];\n        } else {\n            new_message += c;\n        }\n    }\n\n\
    \    new_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `std::ops::Range<char>: Ord` is not satisfied\n\
    \    --> /tmp/tmpx31r0eeb.rs:13:14\n     |\n13   |     alphabet.sort_unstable();\n\
    \     |              ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `std::ops::Range<char>`\n\
    \     |\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\
    \nerror[E0277]: the trait bound `std::ops::Range<char>: Ord` is not satisfied\n\
    \    --> /tmp/tmpx31r0eeb.rs:16:12\n     |\n16   |     vowels.sort_unstable();\n\
    \     |            ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `std::ops::Range<char>`\n\
    \     |\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\
    \nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpx31r0eeb.rs:19:14\n\
    \   |\n19 |     for c in message {\n   |              ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the\
    \ trait bound `std::ops::Range<char>: Ord` is not satisfied\n    --> /tmp/tmpx31r0eeb.rs:20:35\n\
    \     |\n20   |         if let Some(_) = alphabet.binary_search(&c) {\n     |\
    \                                   ^^^^^^^^^^^^^ the trait `Ord` is not implemented\
    \ for `std::ops::Range<char>`\n     |\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::binary_search`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx31r0eeb.rs:20:16\n\
    \   |\n20 |         if let Some(_) = alphabet.binary_search(&c) {\n   |      \
    \          ^^^^^^^   -------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0277]: the trait bound `std::ops::Range<char>:\
    \ Ord` is not satisfied\n    --> /tmp/tmpx31r0eeb.rs:21:44\n     |\n21   |   \
    \          new_message += vowels[alphabet.binary_search(&c + 2)];\n     |    \
    \                                        ^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = message;\n\n    for i in message.chars()\
    \ {\n        if i.is_vowel() {\n            new_message = new_message.to_string().replace(i.to_string(),\
    \ i.to_string() + &i.to_string() + &i.to_string() + &i.to_string() + &i.to_string());\n\
    \        }\n        else {\n            new_message = new_message.to_string().replace(i.to_string(),\
    \ &i.to_string());\n        }\n    }\n    new_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpcdmqx1pq.rs:15:14\n   |\n15 |         if i.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `String`\n   --> /tmp/tmpcdmqx1pq.rs:16:51\n\
    \    |\n16  | ...   new_message = new_message.to_string().replace(i.to_string(),\
    \ i.to_string() + &i.to_string() + &i.to_string() + &i.to_string() + &i....\n\
    \    |                                             ^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `String`\n    |\n    = help: the trait `FnMut<(char,)>` is not\
    \ implemented for `String`\n    = help: the following other types implement trait\
    \ `Pattern<'a>`:\n              &'b String\n              &'b str\n          \
    \    &'c &'b str\n    = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `str::<impl str>::replace`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcdmqx1pq.rs:16:74\n   |\n16 |\
    \ ...place(i.to_string(), i.to_string() + &i.to_string() + &i.to_string() + &i.to_string()\
    \ + &i.to_string());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&(i.to_string() + &i.to_string() + &i.to_string() + &i.to_string() +\
    \ &i.to_string())`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found\
    \ `String`\n   --> /tmp/tmpcdmqx1pq.rs:19:51\n    |\n19  |             new_message\
    \ = new_message.to_string().replace(i.to_string(), &i.to_string());\n    |   \
    \                                                ^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `String`\n    |\n    = help: the trait `FnMut<(char,)>` is not\
    \ implemented for `String`\n    = help: the following other types implement trait\
    \ `Pattern<'a>`:\n              &'b String\n              &'b str\n          \
    \    &'c &'b str\n    = note: required because of the"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().for_each(|c| {\n        if ('a' <=\
    \ c && c <= 'z') {\n            c as char\n        } else if ('A' <= c && c <=\
    \ 'Z') {\n            c as char\n        } else if ('0' <= c && c <= '9') {\n\
    \            c as char\n        } else if ('1' <= c && c <= '9') {\n         \
    \   c as char\n        } else if ('2' <= c && c <= '9') {\n            c as char\n\
    \        } else if ('3' <= c && c <= '9') {\n            c as char\n        }\
    \ else if ('4' <= c && c <= '9') {\n            c as char\n        } else if ('5'\
    \ <= c && c <= '9') {\n            c as char\n        } else if ('6' <= c && c\
    \ <= '9') {\n            c as char\n        } else if ('7' <= c && c <= '9') {\n\
    \            c as char\n        } else if ('8' <= c && c <= '9') {\n         \
    \   c as char\n        } else if ('9' <= c && c <= '9') {\n            c as char\n\
    \        } else if ('!' <= c && c <= '@') {\n            c as char\n        }\
    \ else if ('&' <= c && c <= '$') {\n            c as char\n        } else if ('*'\
    \ <= c && c <= '(') {\n            c as char\n        } else if (')' <= c && c\
    \ <= '*') {\n            c as char\n        } else if ('+' <= c && c <= '=') {\n\
    \            c as char\n        } else if ('-' <= c && c <= '/') {\n         \
    \   c as char\n        } else if ('.' <= c && c <= '@') {\n            c as char\n\
    \        } else if (',' <= c && c <= '@') {\n            c as char\n        }\
    \ else if ('/' <= c && c <= ':') {\n            c as char\n        } else if (';'\
    \ <= c && c <= ':') {\n            c as char\n        } else if ('?' <= c && c\
    \ <= '@') {\n            c as char\n        } else if ('%' <= c && c <= '@') {\n\
    \            c as char\n        } else if ('>' <= c && c <= '@') {\n         \
    \   c as char\n        } else if ('[' <= c && c <= '@') {\n            \n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp61umae0e.rs:74:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n12 |     message.chars().for_each(|c|\
    \ {\n   |                             -    - unclosed delimiter\n   |        \
    \                     |\n   |                             unclosed delimiter\n\
    ...\n63 |         } else if ('[' <= c && c <= '@') {\n   |                   \
    \                       - this delimiter might not be properly closed...\n64 |\
    \             \n65 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n74 | }\n   |   ^\n\nwarning: unnecessary parentheses around `if` condition\n\
    \  --> /tmp/tmp61umae0e.rs:13:12\n   |\n13 |         if ('a' <= c && c <= 'z')\
    \ {\n   |            ^                    ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n13 -         if ('a' <=\
    \ c && c <= 'z') {\n13 +         if 'a' <= c && c <= 'z' {\n   | \n\nwarning:\
    \ unnecessary parentheses around `if` condition\n  --> /tmp/tmp61umae0e.rs:15:19\n\
    \   |\n15 |         } else if ('A' <= c && c <= 'Z') {\n   |                 \
    \  ^                    ^\n   |\nhelp: remove these parentheses\n   |\n15 -  \
    \       } else if ('A' <= c && c <= 'Z') {\n15 +         } else if 'A' <= c &&\
    \ c <= 'Z' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n\
    \  --> /tmp/tmp61umae0e.rs:17:19\n   |\n17 |         } else if ('0' <= c && c\
    \ <= '9') {\n   |                   ^                    ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n17 -         } else if ('0' <= c && c <= '9') {\n17\
    \ +         } else if '0' <= c && c <= '9' {\n   | \n\nwarning: unnecessary parentheses\
    \ around `if` condition\n  --> /tmp/tmp61umae0e.rs:19:19\n   |\n19 |         }\
    \ else if ('1' <= c && c <= '9') {\n   |                   ^                 \
    \   ^\n   |\nhelp: remove these parentheses\n   |\n19 -         } else if ('1'\
    \ <= c && c <= '9') {\n19 +         } else if '1' <= c && c <= '9' {\n   | \n\n\
    warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp61umae0e.rs:2"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encodedMessage = \"\".to_string();\n    let\
    \ vowels = \"aeiou\".to_string();\n    message.chars().for_each(|c|{\n       \
    \ if c.is_alphabetic() {\n            if c.as_bytes().contains(vowels.as_bytes())\
    \ {\n                let index = vowels.as_bytes().find_index(c.as_bytes());\n\
    \                encodedMessage += &vowels[(index + 2) as usize];\n          \
    \  } else {\n                encodedMessage += &c;\n            }\n        } else\
    \ {\n            encodedMessage += &c.to_string();\n        }\n    });\n    encodedMessage\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpej5ij9lz.rs:16:18\n   |\n16 |             if c.as_bytes().contains(vowels.as_bytes())\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `find_index` found for reference `&[u8]` in the current scope\n\
    \  --> /tmp/tmpej5ij9lz.rs:17:47\n   |\n17 |                 let index = vowels.as_bytes().find_index(c.as_bytes());\n\
    \   |                                               ^^^^^^^^^^ method not found\
    \ in `&[u8]`\n\nerror[E0599]: no method named `as_bytes` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpej5ij9lz.rs:17:60\n   |\n17 |          \
    \       let index = vowels.as_bytes().find_index(c.as_bytes());\n   |        \
    \                                                    ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpej5ij9lz.rs:18:36\n   |\n18 |                 encodedMessage +=\
    \ &vowels[(index + 2) as usize];\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpej5ij9lz.rs:20:35\n\
    \   |\n20 |                 encodedMessage += &c;\n   |                      \
    \             ^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  message.chars().filter_map(|c| match c {\n      'a' =>\
    \ 'A',\n      'e' => 'E',\n      'i' => 'I',\n      'o' => 'O',\n      'u' =>\
    \ 'U',\n      'y' => match message.chars().position(|c| c == 'Y') {\n        Some(i)\
    \ => 'Y',\n        None => 'Y',\n      },\n      'A' => \"X\",\n      'E' => \"\
    Z\",\n      \"I\" => \"H\",\n      \"O\" => \"G\",\n      \"U\" => \"F\",\n  \
    \    'Y' => match message.chars().position(|c| c == 'Y') {\n        Some(i) =>\
    \ \"Y\",\n        None => \"Y\",\n      },\n      'Y' => \"Y\",\n      'Z' =>\
    \ \"Z\",\n      'a' => \"X\",\n      'e' => \"Z\",\n      \"i\" => \"H\",\n  \
    \    \"o\" => \"G\",\n      \"u\" => \"F\",\n      'y' => match message.chars().position(|c|\
    \ c == 'Y') {\n        Some(i) => \"Y\",\n        None => \"Y\",\n      },\n \
    \     'y' => \"Y\",\n      'z' => \"Z\",\n    }).collect::<String>()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbi9dt40b.rs:24:7\n   |\n\
    12 |   message.chars().filter_map(|c| match c {\n   |                        \
    \                - this expression has type `char`\n...\n24 |       \"I\" => \"\
    H\",\n   |       ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbi9dt40b.rs:25:7\n   |\n12 |   message.chars().filter_map(|c|\
    \ match c {\n   |                                        - this expression has\
    \ type `char`\n...\n25 |       \"O\" => \"G\",\n   |       ^^^ expected `char`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbi9dt40b.rs:26:7\n\
    \   |\n12 |   message.chars().filter_map(|c| match c {\n   |                 \
    \                       - this expression has type `char`\n...\n26 |       \"\
    U\" => \"F\",\n   |       ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbi9dt40b.rs:35:7\n   |\n12 |   message.chars().filter_map(|c|\
    \ match c {\n   |                                        - this expression has\
    \ type `char`\n...\n35 |       \"i\" => \"H\",\n   |       ^^^ expected `char`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbi9dt40b.rs:36:7\n\
    \   |\n12 |   message.chars().filter_map(|c| match c {\n   |                 \
    \                       - this expression has type `char`\n...\n36 |       \"\
    o\" => \"G\",\n   |       ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbi9dt40b.rs:37:7\n   |\n12 |   message.chars().filter_map(|c|\
    \ match c {\n   |                                        - this expression has\
    \ type `char`\n...\n37 |       \"u\" => \"F\",\n   |       ^^^ expected `char`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbi9dt40b.rs:13:14\n\
    \   |\n13 |       'a' => 'A',\n   |              ^^^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `char`\nhelp: try wrapping the expression in `Some`\n   |\n13 |       'a' =>\
    \ Some('A'),\n   |              +++++   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbi9dt40b.rs:19:20\n   |\n19 |         Some(i) => 'Y',\n   |   \
    \                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().skip_while(u8::is_ascii).map(|c| \n\
    \        match c {\n            'a' => b'A',\n            'e' => b'E',\n     \
    \       'i' => b'I',\n            'o' => b'O',\n            'u' => b'U',\n   \
    \         'A' => b'a',\n            'E' => b'e',\n            'I' => b'i',\n \
    \           'O' => b'o',\n            'U' => b'u',\n            _ => b,\n    \
    \    }).collect::<String>().into()\n        .to_string()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpir0jz2ta.rs:24:18\n\
    \   |\n24 |             _ => b,\n   |                  ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0631]: type mismatch in function arguments\n\
    \    --> /tmp/tmpir0jz2ta.rs:12:32\n     |\n12   |     message.chars().skip_while(u8::is_ascii).map(|c|\
    \ \n     |                     ---------- ^^^^^^^^^^^^\n     |               \
    \      |          |\n     |                     |          expected signature\
    \ of `for<'r> fn(&'r char) -> _`\n     |                     |          found\
    \ signature of `for<'r> fn(&'r u8) -> _`\n     |                     required\
    \ by a bound introduced by this call\n     |\nnote: required by a bound in `skip_while`\n\
    \nerror[E0599]: the method `map` exists for struct `SkipWhile<Chars<'_>, for<'r>\
    \ fn(&'r u8) -> bool {core::num::<impl u8>::is_ascii}>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpir0jz2ta.rs:12:46\n   |\n12 |       message.chars().skip_while(u8::is_ascii).map(|c|\
    \ \n   |                                                ^^^ method cannot be called\
    \ on `SkipWhile<Chars<'_>, for<'r> fn(&'r u8) -> bool {core::num::<impl u8>::is_ascii}>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<for<'r> fn(&'r u8) -> bool {core::num::<impl\
    \ u8>::is_ascii} as FnOnce<(&char,)>>::Output = bool`\n           which is required\
    \ by `SkipWhile<Chars<'_>, for<'r> fn(&'r u8) -> bool {core::num::<impl u8>::is_ascii}>:\
    \ Iterator`\n           `for<'r> fn(&'r u8) -> bool {core::num::<impl u8>::is_ascii}:\
    \ FnMut<(&char,)>`\n           which is required by `SkipWhile<Chars<'_>, for<'r>\
    \ fn(&'r u8) -> bool {core::num::<impl u8>::is_ascii}>: Iterator`\n          \
    \ `SkipWhile<Chars<'_>, for<'r> fn(&'r u8) -> bool {core::num::<impl u8>::is_ascii}>:\
    \ Iterator`\n           which is required by `&mut SkipWhile<Chars<'_>, for<'r>\
    \ fn(&'r u8) -> bool {core::num::<impl u8>::is_ascii}>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599,\
    \ E0"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = \"aeiou\".to_string();\n    let mut letters\
    \ = Vec::new();\n\n    for i in message.chars() {\n        let index = i.to_ascii_lowercase().find(|&v|\
    \ vowels.contains(&v));\n        if index == Some(i.to_ascii_lowercase().len()\
    \ - 1) {\n            letters.push(format!(\"{}\", i.to_ascii_lowercase()[index\
    \ - i]));\n        } else {\n            letters.push(format!(\"{}\", i.to_ascii_lowercase()[index\
    \ + 1]));\n        }\n    }\n    String::from_utf8(letters.as_slice())\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpcr0r81mr.rs:16:44\n   |\n16 |         let index = i.to_ascii_lowercase().find(|&v|\
    \ vowels.contains(&v));\n   |                                            ^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `len` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpcr0r81mr.rs:17:49\n   |\n17\
    \ |         if index == Some(i.to_ascii_lowercase().len() - 1) {\n   |       \
    \                                          ^^^ method not found in `char`\n\n\
    error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpcr0r81mr.rs:18:40\n\
    \   |\n18 |             letters.push(format!(\"{}\", i.to_ascii_lowercase()[index\
    \ - i]));\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpcr0r81mr.rs:20:40\n\
    \   |\n20 |             letters.push(format!(\"{}\", i.to_ascii_lowercase()[index\
    \ + 1]));\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcr0r81mr.rs:23:23\n   |\n23 |\
    \     String::from_utf8(letters.as_slice())\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&[String]`\n   |\n   = note: expected struct `Vec<u8>`\n\
    \           found reference `&[String]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcr0r81mr.rs:23:5\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                               ------ expected `String` because of return\
    \ type\n...\n23 |     String::from_utf8(letters.as_slice())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Result`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Result<String, FromUtf8Error>`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = Vec::new();\n    \n    for (i, c) in message.chars().enumerate() {\n     \
    \   let prev_i = i - 2;\n        \n        if prev_i < 0 {\n            vowels.push(c);\
    \ \n            continue;\n        }\n\n        match vowels.iter().position(|x|\
    \ x == c) {\n            Some(index) => result.push_str(&vowels[index..index +\
    \ 2].to_lowercase()),\n            None => {\n                vowels.push(c);\n\
    \                continue;\n            }\n        }\n    }\n    \n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqb8lmvfw.rs:23:44\n\
    \   |\n23 |         match vowels.iter().position(|x| x == c) {\n   |         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]: no\
    \ method named `to_lowercase` found for slice `[char]` in the current scope\n\
    \  --> /tmp/tmpqb8lmvfw.rs:24:70\n   |\n24 |             Some(index) => result.push_str(&vowels[index..index\
    \ + 2].to_lowercase()),\n   |                                                \
    \                      ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_vec`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if let Ok(index) = (message.find_index(c.to_uppercase()) + 1).ok()\
    \ {\n            result.push((*c).to_string());\n            result.push((*message[index]).to_string());\n\
    \        } else {\n            result.push((*c).to_string());\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find_index` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpnts_93lf.rs:14:37\n   |\n14 |         if let\
    \ Ok(index) = (message.find_index(c.to_uppercase()) + 1).ok() {\n   |        \
    \                             ^^^^^^^^^^ method not found in `String`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpnts_93lf.rs:15:25\n   |\n\
    15 |             result.push((*c).to_string());\n   |                        \
    \ ^^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpnts_93lf.rs:18:25\n\
    \   |\n18 |             result.push((*c).to_string());\n   |                 \
    \        ^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encodedMessage = \"\".to_string();\n    for\
    \ letter in message.chars() {\n        let vowels = get_vowels(letter);\n    \
    \    encodedMessage += if vowels.len() > 2 {\n            vowels.get(1).unwrap()\
    \ + vowels.get(2).unwrap()\n        } else {\n            letter\n        };\n\
    \    }\n    return encodedMessage;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_vowels` in this scope\n  --> /tmp/tmp6ulf6_fd.rs:14:22\n\
    \   |\n14 |         let vowels = get_vowels(letter);\n   |                   \
    \   ^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6ulf6_fd.rs:18:13\n   |\n18 |             letter\n   |             ^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = \"aeiouy\";\n    for c in message.chars() {\n        if vowels.contains(&c.to_ascii_lowercase())\
    \ {\n            encoded.push_str(&encode(&c.to_ascii_lowercase()[1..]));\n  \
    \      } else {\n            encoded.push_str(&encode(&c.to_ascii_lowercase()));\n\
    \        }\n    }\n    encoded;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpck70wc7x.rs:15:28\n\
    \     |\n15   |         if vowels.contains(&c.to_ascii_lowercase()) {\n     |\
    \                   -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                   |\n     |                  \
    \ required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n15   |         if vowels.contains(*&c.to_ascii_lowercase())\
    \ {\n     |                            +\n\nerror[E0608]: cannot index into a\
    \ value of type `char`\n  --> /tmp/tmpck70wc7x.rs:16:39\n   |\n16 |          \
    \   encoded.push_str(&encode(&c.to_ascii_lowercase()[1..]));\n   |           \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpck70wc7x.rs:18:38\n   |\n18 |             encoded.push_str(&encode(&c.to_ascii_lowercase()));\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\nhelp: try using a conversion method\n   |\n18\
    \ |             encoded.push_str(&encode((&c.to_ascii_lowercase()).to_string()));\n\
    \   |                                      +                       +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpck70wc7x.rs:11:31\n   |\n11 |\
    \ fn encode(message: String) -> String {\n   |    ------                     ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n21 |     encoded;\n\
    \   |            - help: remove this semicolon\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result: Vec<String> = vec![];\n    let mut\
    \ char_map: HashMap<String, String> = HashMap::new();\n    let mut vowels_map:\
    \ HashMap<u8, u8> = HashMap::new();\n    let mut next_vowel: u8 = 0;\n    for\
    \ c in message.chars() {\n        if c.is_lowercase() {\n            char_map.insert(c.to_string(),\
    \ c.to_string() + next_vowel.to_string());\n            next_vowel += 1;\n   \
    \     } else {\n            next_vowel = 0;\n            char_map.insert(c.to_string(),\
    \ c.to_string());\n        }\n    }\n    char_map.entry().for_each(|pair| {\n\
    \        let mut prev_vowel: u8 = 0;\n        if let Some(&(prev_char, next_char))\
    \ = vowels_map.entry().nth(pair.key.to_u8()) {\n            match prev_char.cmp(&next_char)\
    \ {\n                cmp::Ordering::Less => result.push(cmp::replace(&mut pair.value,\
    \ pair.key, 'z').to_string()),\n                cmp::Ordering::Equal => result.push(cmp::replace(&mut\
    \ pair.value, pair.key, 'Z').to_string()),\n                cmp::Ordering::Greater\
    \ => result.push(cmp::replace(&mut pair.value, pair.key, 'Z').to_string()),\n\
    \            }\n        } else {\n            result.push(cmp::replace(&mut pair.value,\
    \ pair.key, 'Z').to_string());\n        }\n    });\n    result.join(\"\");\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmptzxsv11i.rs:29:17\n   |\n29 |                 cmp::Ordering::Less\
    \ => result.push(cmp::replace(&mut pair.value, pair.key, 'z').to_string()),\n\
    \   |                 ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmptzxsv11i.rs:29:52\n\
    \   |\n29 |                 cmp::Ordering::Less => result.push(cmp::replace(&mut\
    \ pair.value, pair.key, 'z').to_string()),\n   |                             \
    \                       ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmptzxsv11i.rs:30:17\n\
    \   |\n30 |                 cmp::Ordering::Equal => result.push(cmp::replace(&mut\
    \ pair.value, pair.key, 'Z').to_string()),\n   |                 ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `cmp`\n  --> /tmp/tmptzxsv11i.rs:30:53\n   |\n30 |         \
    \        cmp::Ordering::Equal => result.push(cmp::replace(&mut pair.value, pair.key,\
    \ 'Z').to_string()),\n   |                                                   \
    \  ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `cmp`\n  --> /tmp/tmptzxsv11i.rs:31:17\n \
    \  |\n31 |                 cmp::Ordering::Greater => result.push(cmp::replace(&mut\
    \ pair.value, pair.key, 'Z').to_string()),\n   |                 ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `cmp`\n  --> /tmp/tmptzxsv11i.rs:31:55\n   |\n31 |         \
    \        cmp::Ordering::Greater => result.push(cmp::replace(&mut pair.value, pair.key,\
    \ 'Z').to_string()),\n   |                                                   \
    \    ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `cmp`\n  --> /tmp/tmptzxsv11i.rs:34:25\n \
    \  |\n34 |             result.push(cmp::replace(&mut pair.value, pair.key, 'Z').t"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    for i in 0..message.len()\
    \ {\n        if let Some(j) = (message.len() - i).wrapping_add(1) {\n        \
    \    let c = &message[j];\n            if c.is_upper() {\n                let\
    \ mut k = i;\n                while k > 0 && message[k.0 as usize - 1] == c {\n\
    \                    k /= 2;\n                }\n                s += &message[k];\n\
    \            } else if c.is_lower() {\n                s += &message[i];\n   \
    \         } else {\n                s += c;\n            }\n        }\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyc80vtiu.rs:14:16\n   |\n\
    14 |         if let Some(j) = (message.len() - i).wrapping_add(1) {\n   |    \
    \            ^^^^^^^   ----------------------------------- this expression has\
    \ type `usize`\n   |                |\n   |                expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<_>`\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpyc80vtiu.rs:18:42\n   |\n18 |                 while\
    \ k > 0 && message[k.0 as usize - 1] == c {\n   |                            \
    \              ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyc80vtiu.rs:21:23\n   |\n21 |                 s += &message[k];\n\
    \   |                       ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyc80vtiu.rs:23:23\n   |\n23 |                 s += &message[i];\n\
    \   |                       ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome err"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    loop {\n        let mut encoded = String::new();\n\
    \        for vowel in 'aeiou' {\n            let pos = vowel.position();\n   \
    \         let vowel_letter = &vowel;\n            let vowel_letter_2 = &vowel.next();\n\
    \            encoded += &message[pos + 1..].chars().map(|c| {\n              \
    \  match c {\n                    vowel_letter => vowel_letter,\n            \
    \        c => c,\n                    vowel_letter_2 => vowel_letter_2,\n    \
    \            }\n            }).collect::<String>();\n            if message.len()\
    \ < 2 {\n                break;\n            }\n            let vowel_index =\
    \ message.char_indices().find_index(|(_, c2)| c1 == c2);\n            encoded\
    \ += &message[vowel_index + 1..].chars().map(|c| {\n                match c {\n\
    \                    vowel => vowel,\n                    c => c,\n          \
    \      }\n            }).collect::<String>();\n        }\n        encoded;\n \
    \   }\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpocdm_xy3.rs:14:22\n\
    \   |\n14 |         for vowel in 'aeiou' {\n   |                      ^^^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    14 |         for vowel in \"aeiou\" {\n   |                      ~~~~~~~\n\nerror[E0425]:\
    \ cannot find value `c1` in this scope\n  --> /tmp/tmpocdm_xy3.rs:28:75\n   |\n\
    28 |             let vowel_index = message.char_indices().find_index(|(_, c2)|\
    \ c1 == c2);\n   |                                                           \
    \                ^^ help: a local variable with a similar name exists: `c2`\n\n\
    error[E0599]: no method named `find_index` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmpocdm_xy3.rs:28:54\n   |\n28 |             let vowel_index\
    \ = message.char_indices().find_index(|(_, c2)| c1 == c2);\n   |             \
    \                                         ^^^^^^^^^^ method not found in `CharIndices<'_>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  message\n    .chars()\n    .filter(|c| c.is_alphabetic())\n\
    \    .filter(|c| c.is_lowercase())\n    .map(|c| c.to_lowercase().chars().map(|x|\
    \ x.to_ascii_lowercase()).collect::<Vec<_>>())\n    .flatten()\n    .zip(message.chars().filter(|c|\
    \ !c.is_alphabetic()).map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>())\n \
    \   .map(|(c1, (c2, c3))| {\n      if c1 == c3 && c2 != c1 {\n        c1\n   \
    \   } else if c2 == c3 {\n        c2\n      } else if c1 == c2 {\n        (c2,\
    \ c1)\n      } else if c1 < c3 {\n        (c1, c2)\n      } else if c3 > c1 {\n\
    \        (c2, c3)\n      } else {\n        (c2, c1)\n      }\n    })\n    .collect()\n\
    \    .iter()\n    .map(|c| c.to_ascii_lowercase())\n    .collect()\n    .iter()\n\
    \    .map(|c| c.to_string())\n    .collect::<String>()\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmpny4dwt47.rs:16:31\n   |\n16 |     .map(|c|\
    \ c.to_lowercase().chars().map(|x| x.to_ascii_lowercase()).collect::<Vec<_>>())\n\
    \   |                               ^^^^^ method not found in `ToLowercase`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpny4dwt47.rs:19:16\n   |\n19 |  \
    \   .map(|(c1, (c2, c3))| {\n   |                ^^^^^^^^- expected due to this\n\
    \   |                |\n   |                expected `char`, found tuple\n   |\n\
    \   = note: expected type `char`\n             found tuple `(_, _)`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut buffer = String::new();\n    let mut prev_vowel\
    \ = String::new();\n    let mut last_vowel = String::new();\n\n    for letter\
    \ in message.chars() {\n        buffer.push_str(&letter as char);\n\n        if\
    \ letter == ' ' {\n            buffer.push_str(\" \");\n            continue;\n\
    \        }\n\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n            last_vowel = letter;\n            continue;\n\
    \        }\n\n        buffer.push_str(&last_vowel);\n        last_vowel = String::new();\n\
    \    }\n\n    buffer.push_str(&last_vowel);\n    return buffer;\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpifx6r73c.rs:17:25\n   |\n\
    17 |         buffer.push_str(&letter as char);\n   |                         ^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpifx6r73c.rs:25:26\n\
    \   |\n14 |     let mut last_vowel = String::new();\n   |                    \
    \      ------------- expected due to this value\n...\n25 |             last_vowel\
    \ = letter;\n   |                          ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                          |\n   |              \
    \            expected struct `String`, found `char`\n\nerror[E0606]: casting `&char`\
    \ as `char` is invalid\n  --> /tmp/tmpifx6r73c.rs:17:25\n   |\n17 |         buffer.push_str(&letter\
    \ as char);\n   |                         ^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0606.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.len() == 0 {\n        return \"\";\n   \
    \ }\n    let mut encoded = message.to_string();\n    for (i, &c) in encoded.chars().enumerate()\
    \ {\n        match c {\n            'a' => encoded.replace(i, i + 1, b'A'),\n\
    \            'e' => encoded.replace(i, i + 1, b'E'),\n            'i' => encoded.replace(i,\
    \ i + 1, b'I'),\n            'o' => encoded.replace(i, i + 1, b'O'),\n       \
    \     'u' => encoded.replace(i, i + 1, b'U'),\n            'A' => encoded.replace(i,\
    \ i + 1, b'a'),\n            'E' => encoded.replace(i, i + 1, b'e'),\n       \
    \     'I' => encoded.replace(i, i + 1, b'i'),\n            'O' => encoded.replace(i,\
    \ i + 1, b'o'),\n            'U' => encoded.replace(i, i + 1, b'u'),\n       \
    \     _ => (),\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphp9xh7qb.rs:13:16\n   |\n\
    11 | fn encode(message: String) -> String {\n   |                            \
    \   ------ expected `String` because of return type\n12 |     if message.len()\
    \ == 0 {\n13 |         return \"\";\n   |                ^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphp9xh7qb.rs:16:13\n   |\n16 |     for (i, &c) in encoded.chars().enumerate()\
    \ {\n   |             ^^     --------------------------- this expression has type\
    \ `Option<(usize, char)>`\n   |             |\n   |             expected `char`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \   --> /tmp/tmphp9xh7qb.rs:18:28\n    |\n18  |             'a' => encoded.replace(i,\
    \ i + 1, b'A'),\n    |                            ^^^^^^^ -  -----  ---- supplied\
    \ 3 arguments\n    |                            |\n    |                     \
    \       expected 2 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \   --> /tmp/tmphp9xh7qb.rs:19:28\n    |\n19  |             'e' => encoded.replace(i,\
    \ i + 1, b'E'),\n    |                            ^^^^^^^ -  -----  ---- supplied\
    \ 3 arguments\n    |                            |\n    |                     \
    \       expected 2 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \   --> /tmp/tmphp9xh7qb.rs:20:28\n    |\n20  |             'i' => encoded.replace(i,\
    \ i + 1, b'I'),\n    |                            ^^^^^^^ -  -----  ---- supplied\
    \ 3 arguments\n    |                            |\n    |                     \
    \       expected 2 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0061]: this function takes 2 arguments b"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::with_capacity(message.len());\n\
    \    let mut vowel_count = 0;\n\n    for (i, ch) in message.chars().enumerate()\
    \ {\n        if ch.is_upper() {\n            if i != 0 && vowel_count != 2 {\n\
    \                new_message += ch.to_lowercase();\n            }\n        } else\
    \ if ch.is_lower() {\n            if i != 0 && vowel_count != 0 {\n          \
    \      new_message += ch.to_uppercase();\n            }\n        } else {\n  \
    \          new_message += ch;\n        }\n        vowel_count = vowel_count +\
    \ 1;\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbec2f44i.rs:16:15\n   |\n16 |         if ch.is_upper()\
    \ {\n   |               ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbec2f44i.rs:18:32\n\
    \   |\n18 |                 new_message += ch.to_lowercase();\n   |          \
    \                      ^^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n\
    \nerror[E0599]: no method named `is_lower` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbec2f44i.rs:20:22\n   |\n20 |         } else if ch.is_lower()\
    \ {\n   |                      ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_lowercase`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbec2f44i.rs:22:32\n   |\n22 |                 new_message += ch.to_uppercase();\n\
    \   |                                ^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ struct `ToUppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbec2f44i.rs:25:28\n\
    \   |\n25 |             new_message += ch;\n   |                            ^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in message.chars()\
    \ {\n        let mut replaced = false;\n        // replace all vowels with letter\
    \ 2 places ahead\n        for i in 1..=3 {\n            if c.to_ascii_lowercase()[i]\
    \ == 'a' {\n                res += 'b';\n                replaced = true;\n  \
    \              continue;\n            }\n            if c.to_ascii_lowercase()[i]\
    \ == 'e' {\n                res += 'f';\n                replaced = true;\n  \
    \              continue;\n            }\n            if c.to_ascii_lowercase()[i]\
    \ == 'i' {\n                res += 'g';\n                replaced = true;\n  \
    \              continue;\n            }\n            if c.to_ascii_lowercase()[i]\
    \ == 'o' {\n                res += 'h';\n                replaced = true;\n  \
    \              continue;\n            }\n            if c.to_ascii_lowercase()[i]\
    \ == 'u' {\n                res += 'j';\n                replaced = true;\n  \
    \              continue;\n            }\n        }\n\n        // replace all non-vowels\
    \ with letter 2 places ahead\n        let index = c.to_ascii_lowercase().find(|c|\
    \ !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'));\n        if index\
    \ > -1 {\n            res += 'k';\n            res += c.to_ascii_lowercase()[index\
    \ + 1];\n            replaced = true;\n        }\n\n        if replaced {\n  \
    \          continue;\n        }\n\n        // no vowels found, append the char\n\
    \        res.append(c);\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpdbfes_or.rs:17:16\n\
    \   |\n17 |             if c.to_ascii_lowercase()[i] == 'a' {\n   |          \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbfes_or.rs:18:24\n\
    \   |\n18 |                 res += 'b';\n   |                        ^^^ expected\
    \ `&str`, found `char`\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n18 |                 res += \"b\";\n   |              \
    \          ~~~\n\nerror[E0608]: cannot index into a value of type `char`\n  -->\
    \ /tmp/tmpdbfes_or.rs:22:16\n   |\n22 |             if c.to_ascii_lowercase()[i]\
    \ == 'e' {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdbfes_or.rs:23:24\n   |\n23 |                 res += 'f';\n\
    \   |                        ^^^ expected `&str`, found `char`\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n23 |          \
    \       res += \"f\";\n   |                        ~~~\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmpdbfes_or.rs:27:16\n   |\n27\
    \ |             if c.to_ascii_lowercase()[i] == 'i' {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdbfes_or.rs:28:24\n   |\n28 |\
    \                 res += 'g';\n   |                        ^^^ expected `&str`,\
    \ found `char`\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n28 |                 res += \"g\";\n   |                     \
    \   ~~~\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpdbfes_or.rs:32:16\n\
    \   |\n32 |             if c.to_ascii_lowercase()[i] == 'o' {\n   |          \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbfes_or.rs:33:24\n\
    \   |\n33 |                 res += 'h';\n   |                        ^^^ expected\
    \ `&str`, found `char`\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n33 |                 res += \"h\";\n   |              \
    \          ~~~\n\nerror[E0608]: cannot index into a value of type `char`\n  -->\
    \ /tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| if c == 'a' || c == 'e' ||\
    \ c == 'i'\n                           || c == 'o' || c == 'u' {c.to_owned()}\n\
    \                           else if c == 'A' || c == 'E' || c == 'I' \n      \
    \                     || c == 'O' || c == 'U' {c.to_owned()}\n               \
    \            else if c == 'l' || c == 'L' {c.to_owned()}\n                   \
    \        else if c == 's' || c == 'S' {c.to_owned()}\n                       \
    \    else if c == 'z' || c == 'Z' {c.to_owned()}\n                           else\
    \ {c.to_uppercase().to_owned()})\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmp0mq8zddc.rs:19:34\n\
    \   |\n18 |   ...                   else if c == 'z' || c == 'Z' {c.to_owned()}\n\
    \   |                              -                        ------------ expected\
    \ because of this\n   |  ____________________________|\n   | |\n19 | | ...   \
    \                else {c.to_uppercase().to_owned()})\n   | |_____________________________^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ `if` and `else` have incompatible types\n   |                              \
    \ |\n   |                               expected `char`, found struct `ToUppercase`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut alphabet = HashMap::new();\n    alphabet.insert(\"\
    a\".to_string(), 0);\n    alphabet.insert(\"b\".to_string(), 1);\n    alphabet.insert(\"\
    c\".to_string(), 2);\n    alphabet.insert(\"d\".to_string(), 3);\n    alphabet.insert(\"\
    e\".to_string(), 4);\n    alphabet.insert(\"f\".to_string(), 5);\n    alphabet.insert(\"\
    g\".to_string(), 6);\n    alphabet.insert(\"h\".to_string(), 7);\n    alphabet.insert(\"\
    i\".to_string(), 8);\n    alphabet.insert(\"j\".to_string(), 9);\n    alphabet.insert(\"\
    k\".to_string(), 10);\n    alphabet.insert(\"l\".to_string(), 11);\n    alphabet.insert(\"\
    m\".to_string(), 12);\n    alphabet.insert(\"n\".to_string(), 13);\n    alphabet.insert(\"\
    o\".to_string(), 14);\n    alphabet.insert(\"p\".to_string(), 15);\n    alphabet.insert(\"\
    q\".to_string(), 16);\n    alphabet.insert(\"r\".to_string(), 17);\n    alphabet.insert(\"\
    s\".to_string(), 18);\n    alphabet.insert(\"t\".to_string(), 19);\n    alphabet.insert(\"\
    u\".to_string(), 20);\n    alphabet.insert(\"v\".to_string(), 21);\n    alphabet.insert(\"\
    w\".to_string(), 22);\n    alphabet.insert(\"x\".to_string(), 23);\n    alphabet.insert(\"\
    y\".to_string(), 24);\n    alphabet.insert(\"z\".to_string(), 25);\n\n    let\
    \ mut buffer = String::new();\n    let mut i = 0;\n    let mut j = 0;\n    for\
    \ letter in message.chars() {\n        if i == 0 {\n            i += alphabet.entry(letter.to_string()).or_insert(0);\n\
    \        }\n        if letter == 'a' {\n            buffer.push_str(&alphabet.entry(letter.to_string()).or_insert(0).to_string());\n\
    \            i += 1;\n        }\n        if letter == 'e' {\n            buffer.push_str(&alphabet.entry(letter.to_string()).or_insert(1).to_string());\n\
    \            i += 1;\n        }\n        if letter == 'i' {\n            buffer.push_str(&alphabet.entry(letter.to_string()).or_insert(2).to_string());\n\
    \            i += 1;\n        }\n        if letter == 'o' {\n            buffer.push_str(&alphabet.entry(letter.to_string()).or_insert(3).to_string());\n\
    \            i += 1;\n        }\n        if letter == 'u' {\n            buffer.push_str(&alphabet.entry(letter.to_string()).or_insert(4).to_string());\n\
    \            i += 1;\n        }\n        if letter == 'A' {\n            buffer.push_str(&alphabet.entry(letter.to_string()).or_insert(5).to_string());\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxgobht_s.rs:78:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n43 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n67 |  \
    \       if letter == 'A' {\n   |                          - this delimiter might\
    \ not be properly closed...\n68 |             buffer.push_str(&alphabet.entry(letter.to_string()).or_insert(5).to_string());\n\
    69 | }\n   | - ...as it matches this but it has different indentation\n...\n78\
    \ | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmpxgobht_s.rs:12:24\n   |\n12 |     let mut alphabet = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxgobht_s.rs:43:5\n   |\n11 |   fn encode(message:\
    \ String) -> String {\n   |                                 ------ expected `String`\
    \ because of return type\n...\n43 | /     for letter in message.chars() {\n44\
    \ | |         if i == 0 {\n45 | |             i += alphabet.entry(letter.to_string()).or_insert(0);\n\
    46 | |         }\n...  |\n77 | |     assert_eq!(candidate(String::from(\"I DoNt\
    \ KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n78 |\
    \ | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = \"\";\n    for letter in &message\
    \ {\n        if letter == ' ' {\n            new_message += \"_\";\n        }\
    \ else {\n            let mut replacements = vec![];\n            for vowel in\
    \ &vowels {\n                let vowel_index = vowel.find(&letter);\n        \
    \        if vowel_index != 0 {\n                    replacements.push(vowel[vowel_index\
    \ + 1]);\n                }\n            }\n            new_message += replacements.join(\"\
    \").to_string();\n        }\n    }\n    new_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmp3em9iae9.rs:18:27\n\
    \   |\n18 |             for vowel in &vowels {\n   |                         \
    \  ^^^^^^ not found in this scope\n\nerror[E0277]: `&String` is not an iterator\n\
    \  --> /tmp/tmp3em9iae9.rs:13:19\n   |\n13 |     for letter in &message {\n  \
    \ |                   ^^^^^^^^ `&String` is not an iterator\n   |\n   = help:\
    \ the trait `Iterator` is not implemented for `&String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&String`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp3em9iae9.rs:15:13\n\
    \   |\n15 |             new_message += \"_\";\n   |             -----------^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp3em9iae9.rs:24:13\n\
    \   |\n24 |             new_message += replacements.join(\"\").to_string();\n\
    \   |             -----------^--^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |     \
    \        |           |\n   |             |           `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |             cannot use `+=` on type `&str`\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3em9iae9.rs:27:5\n   |\n11 | fn\
    \ encode(message: String) -> String {\n   |                               ------\
    \ expected `String` because of return type\n...\n27 |     new_message\n   |  \
    \   ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |   \
    \  |\n   |     expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0368,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::new();\n    let mut lookup\
    \ = HashMap::new();\n    let mut i = 0;\n    for &c in message.chars() {\n   \
    \     let mut newLetter = c.to_ascii_lowercase();\n        if lookup.contains_key(&newLetter)\
    \ {\n            output += lookup.entry(newLetter).or_insert(\"\").clone();\n\
    \        } else {\n            lookup.insert(newLetter, c.to_ascii_lowercase());\n\
    \        }\n        i += 1;\n    }\n    return output;\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpyd_dik30.rs:13:22\n   |\n13 |     let mut lookup = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyd_dik30.rs:15:9\n   |\n15 |     for &c in message.chars()\
    \ {\n   |         ^^    --------------- this expression has type `Option<char>`\n\
    \   |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Replace all vowels in message with character after\
    \ that\n    let mut encoded_message = String::new();\n    let vowels = \"aeiouAEIOU\"\
    ;\n    for pos in 0..message.len() {\n        if message.chars().skip(pos).count(|c|\
    \ vowels.contains(&c)) {\n            encoded_message.push_str(&message.chars().skip(pos).next()\
    \ - pos + 1);\n        } else {\n            encoded_message.push_str(&message.chars().skip(pos));\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpfcf4z4v6.rs:16:38\n    |\n16  |         if message.chars().skip(pos).count(|c|\
    \ vowels.contains(&c)) {\n    |                                      ^^^^^ -----------------------\
    \ supplied 1 argument\n    |                                      |\n    |   \
    \                                   expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcf4z4v6.rs:16:12\n\
    \   |\n16 |         if message.chars().skip(pos).count(|c| vowels.contains(&c))\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `usize`\n\nerror[E0369]: cannot subtract `usize` from\
    \ `&Option<char>`\n  --> /tmp/tmpfcf4z4v6.rs:17:72\n   |\n17 |             encoded_message.push_str(&message.chars().skip(pos).next()\
    \ - pos + 1);\n   |                                      ---------------------------------\
    \ ^ --- usize\n   |                                      |\n   |             \
    \                         &Option<char>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfcf4z4v6.rs:19:38\n   |\n19 |             encoded_message.push_str(&message.chars().skip(pos));\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found struct `Skip`\n   |\n   = note: expected reference `&str`\n   \
    \           found reference `&Skip<Chars<'_>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308, E0369.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Write your code here\n    let mut new_message =\
    \ message;\n    let vowels = \"aeiou\";\n    for (i, l) in new_message.chars().enumerate()\
    \ {\n        let mut index = i;\n        let mut count = 1;\n        while index\
    \ < new_message.len() {\n            let c = new_message[index];\n           \
    \ if c == l {\n                new_message = new_message.to_string().replace(&l,\
    \ &vowels[count as usize]);\n                count = 1;\n            } else if\
    \ c == vowels[count as usize] {\n                count += 1;\n            } else\
    \ {\n                count = 1;\n            }\n            index += 1;\n    \
    \    }\n    }\n    return new_message.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0arckfwt.rs:19:21\n\
    \   |\n19 |             let c = new_message[index];\n   |                    \
    \ ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n\
    \   --> /tmp/tmp0arckfwt.rs:21:55\n    |\n21  |                 new_message =\
    \ new_message.to_string().replace(&l, &vowels[count as usize]);\n    |       \
    \                                                ^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n    |\n    = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n    = help: the trait `Pattern<'a>` is implemented for `char`\n\
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n    = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `str::<impl str>::replace`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp0arckfwt.rs:21:68\n\
    \   |\n21 |                 new_message = new_message.to_string().replace(&l,\
    \ &vowels[count as usize]);\n   |                                            \
    \                        ^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp0arckfwt.rs:23:28\n\
    \   |\n23 |      "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut res = String::with_capacity(message.len());\n\
    \    let mut vowels = Vowels.iter();\n    let mut pos = 0;\n\n    // Iterate through\
    \ every letter in the message.\n    for (i, c) in message.chars().enumerate()\
    \ {\n        // Handle non-letters.\n        if !c.is_letter() {\n           \
    \ res.extend(&c[..pos]);\n            continue;\n        }\n\n        // Swap\
    \ the case of every letter in the message.\n        res.extend(&c.to_uppercase());\n\
    \n        // For every vowel we encounter, swap the case\n        // of the vowel.\n\
    \        for (j, vowel) in vowels {\n            // If the vowel is the same as\
    \ the next letter,\n            // then we're at the end of the message, so \n\
    \            // break the loop.\n            if j == i {\n                break;\n\
    \            }\n\n            let mut vowel_start = j;\n            let mut vowel_end\
    \ = vowel_start + 1;\n\n            // Handle the case where the vowel is at the\
    \ end.\n            if pos == message.len() - 1 {\n                vowel_start\
    \ = j + 1;\n                vowel_end = message.len() - 1;\n            }\n\n\
    \            // If the letter is a vowel, swap the case.\n            if message.chars().nth(vowel_end).unwrap().is_vowel()\
    \ {\n                res.extend(&message.chars().nth(vowel_start).unwrap().to_lowercase());\n\
    \                res.extend(&message.chars().nth(vowel_end).unwrap().to_uppercase());\n\
    \            } else {\n                res.extend(&message.chars().nth(vowel_end).unwrap().to_lowercase());\n\
    \            }\n        }\n\n        // Increment the message position, so the\
    \ next \n        // letter to check is one behind the current one.\n        pos\
    \ += 1;\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `Vowels` in this scope\n  --> /tmp/tmpqkmekou9.rs:13:22\n\
    \   |\n13 |     let mut vowels = Vowels.iter();\n   |                      ^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `is_letter` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpqkmekou9.rs:19:15\n   |\n19\
    \ |         if !c.is_letter() {\n   |               ^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpqkmekou9.rs:20:25\n\
    \   |\n20 |             res.extend(&c[..pos]);\n   |                         ^^^^^^^^\n\
    \nerror[E0277]: `&ToUppercase` is not an iterator\n   --> /tmp/tmpqkmekou9.rs:25:20\n\
    \    |\n25  |         res.extend(&c.to_uppercase());\n    |             ------\
    \ ^^^^^^^^^^^^^^^^^ `&ToUppercase` is not an iterator\n    |             |\n \
    \   |             required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `&ToUppercase`\n    = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&ToUppercase`\n\
    note: required by a bound in `extend`\nhelp: consider dereferencing here\n   \
    \ |\n25  |         res.extend(*&c.to_uppercase());\n    |                    +\n\
    help: consider removing the leading `&`-reference\n    |\n25  -         res.extend(&c.to_uppercase());\n\
    25  +         res.extend(c.to_uppercase());\n    | \nhelp: consider changing this\
    \ borrow's mutability\n    |\n25  |         res.extend(&mut c.to_uppercase());\n\
    \    |                    ~~~~\n\nerror[E0599]: no method named `is_vowel` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpqkmekou9.rs:47:56\n   |\n\
    47 |             if message.chars().nth(vowel_end).unwrap().is_vowel() {\n   |\
    \                                                        ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0277]: `&ToLowercase` is not an iterator\n   --> /tmp/tmpqkmekou9.rs:48:28\n\
    \    |\n48  |                 res.extend(&message.chars().nth(vowel_start).unwrap().to_lowercase());\n\
    \    |                     ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `&ToLowe"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut lastVowel\
    \ = 0;\n    for ch in message.chars() {\n        if ch.is_uppercase() {\n    \
    \        match ch.chars().next() {\n                Some(vowel) => {\n       \
    \             res.push((&vowel + &vowel[lastVowel])[..]);\n                  \
    \  lastVowel += 1;\n                }\n                None => {\n           \
    \         res.push((&vowel)[..]);\n                    lastVowel = 0;\n      \
    \          }\n            }\n        } else {\n            match ch.chars().next()\
    \ {\n                Some(vowel) => {\n                    res.push((&vowel +\
    \ &vowel[lastVowel])[..]);\n                    lastVowel += 1;\n            \
    \    }\n                None => res.push((&ch)[..]),\n            }\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpa43auo5v.rs:22:32\n\
    \   |\n22 |                     res.push((&vowel)[..]);\n   |                \
    \                ^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmpa43auo5v.rs:16:22\n\
    \   |\n16 |             match ch.chars().next() {\n   |                      ^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `chars` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpa43auo5v.rs:27:22\n   |\n27\
    \ |             match ch.chars().next() {\n   |                      ^^^^^ method\
    \ not found in `char`\n\nerror[E0608]: cannot index into a value of type `&char`\n\
    \  --> /tmp/tmpa43auo5v.rs:32:34\n   |\n32 |                 None => res.push((&ch)[..]),\n\
    \   |                                  ^^^^^^^^^\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Create our translation table\n    let mut table\
    \ = [String::new(); 26];\n    let mut vowel = [String::new(); 26];\n    for c\
    \ in 0..message.len() {\n        // Uppercase each letter and swap case\n    \
    \    let i = c as usize;\n        let ch = message[c - 1].to_lowercase();\n  \
    \      table[i] = ch;\n        table[i + 32] = ch;\n        table[i + 64] = ch;\n\
    \        // For each vowel, map the two letters to each vowel\n        if ch ==\
    \ u'a' || ch == u'e' || ch == u'i' || ch == u'o' || ch == u'u'\n            ||\
    \ ch == u'y' {\n            vowel[i] = ch;\n            vowel[i + 32] = ch;\n\
    \            vowel[i + 64] = ch;\n        }\n    }\n    // Replace all vowels\
    \ by the letter that comes 2 places ahead\n    for c in 0..table.len() {\n   \
    \     if vowel[c] == u'a' || vowel[c] == u'e' || vowel[c] == u'i'\n          \
    \  || vowel[c] == u'o' || vowel[c] == u'u' {\n            // For a, e, i, o, u:\
    \ We have already replaced it earlier\n            continue;\n        }\n    \
    \    let i = c as usize;\n        let mut vowel_pos = 0;\n        let mut vowel_next_pos\
    \ = 0;\n        while vowel_pos < table.len() {\n            let vowel_ch = table[vowel_pos];\n\
    \            if vowel_ch == c {\n                // Found a vowel. Now find its\
    \ two letters ahead\n                vowel_next_pos = vowel_pos + 1;\n       \
    \         let vowel_next_ch = table[vowel_next_pos];\n                if vowel_next_ch\
    \ == c {\n                    // We have found a consonant. Keep going\n     \
    \               vowel_pos += 2;\n                    continue;\n             \
    \   }\n                vowel_pos += 1;\n                continue;\n          \
    \  }\n            vowel_pos += 1;\n        }\n        // The letter at i has 2\
    \ letters ahead of it. So replace it\n        table[i] = vowel[vowel_next_pos];\n\
    \    }\n    let mut result = String::new();\n    // Go through each letter and\
    \ add it to the result\n    for c in table.iter() {\n        result += *c;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found `'a'`\n  --> /tmp/tmpspugnsy7.rs:23:19\n   |\n\
    23 |         if ch == u'a' || ch == u'e' || ch == u'i' || ch == u'o' || ch ==\
    \ u'u'\n   |         --        ^^^ expected `{`\n   |         |\n   |        \
    \ this `if` expression has a condition, but no block\n   |\nhelp: try placing\
    \ this code inside a block\n   |\n23 |         if ch == u{ 'a' || ch == u }'e'\
    \ || ch == u'i' || ch == u'o' || ch == u'u'\n   |                   +        \
    \        +\n\nerror: expected `{`, found `'a'`\n  --> /tmp/tmpspugnsy7.rs:32:25\n\
    \   |\n32 |         if vowel[c] == u'a' || vowel[c] == u'e' || vowel[c] == u'i'\n\
    \   |         --              ^^^ expected `{`\n   |         |\n   |         this\
    \ `if` expression has a condition, but no block\n   |\nhelp: try placing this\
    \ code inside a block\n   |\n32 |         if vowel[c] == u{ 'a' || vowel[c] ==\
    \ u }'e' || vowel[c] == u'i'\n   |                         +                 \
    \     +\n\nerror[E0277]: the trait bound `String: Copy` is not satisfied\n  -->\
    \ /tmp/tmpspugnsy7.rs:13:22\n   |\n13 |     let mut table = [String::new(); 26];\n\
    \   |                      ^^^^^^^^^^^^^ the trait `Copy` is not implemented for\
    \ `String`\n   |\n   = note: the `Copy` trait is required because this value will\
    \ be copied for each element of the array\n   = help: consider creating a new\
    \ `const` item and initializing it with the result of the function call to be\
    \ used in the repeat position, like `const VAL: Type = const_fn();` and `let x\
    \ = [VAL; 42];`\n\nerror[E0277]: the trait bound `String: Copy` is not satisfied\n\
    \  --> /tmp/tmpspugnsy7.rs:14:22\n   |\n14 |     let mut vowel = [String::new();\
    \ 26];\n   |                      ^^^^^^^^^^^^^ the trait `Copy` is not implemented\
    \ for `String`\n   |\n   = note: the `Copy` trait is required because this value\
    \ will be copied for each element of the array\n   = help: consider creating a\
    \ new `const` item and initializing it with the result of the function call to\
    \ be used in the repeat position, like `const VAL: Type = const_fn();` and `let\
    \ x = [VAL; 42];`\n\nerror[E0277]: the type `String` cannot be indexe"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO: Write a solution\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk7pf4oqt.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = Vec::new();\n    let mut vowels =\
    \ vec![1, 2, 3, 4];\n    for &c in message {\n        let mut index = vowels.iter().position(|x|\
    \ c == x).unwrap();\n        encoded.push(c[..index + 2]);\n        vowels.remove(&index);\n\
    \    }\n    String::from_utf8(encoded.into_iter().chain(message.into_bytes()).collect()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpr4r17ioh.rs:14:15\n\
    \   |\n14 |     for &c in message {\n   |               ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr4r17ioh.rs:17:23\n   |\n17 |         vowels.remove(&index);\n\
    \   |                       ^^^^^^ expected `usize`, found `&usize`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n17 -         vowels.remove(&index);\n17\
    \ +         vowels.remove(index);\n   | \n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = message.chars().cloned().collect::<Vec<String>>();\n\
    \    for i in 0..message.len() {\n        if encoded.len() == 0 {\n          \
    \  encoded.push(\"T\");\n        }\n        if let Some(index) = (message.chars().skip(i\
    \ + 1).find(|c| *c == c.to_lowercase()).unwrap()).unwrap() {\n            for\
    \ j in i .. index {\n                encoded.push((encoded.len() - j).to_string());\n\
    \            }\n            encoded.push((index + 1).to_string());\n        }\
    \ else {\n            for j in i .. message.len() {\n                encoded.push((encoded.len()\
    \ - j).to_string());\n            }\n        }\n    }\n    encoded.join::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpguilszsq.rs:12:39\n     |\n12   |     let mut encoded =\
    \ message.chars().cloned().collect::<Vec<String>>();\n     |                 \
    \                      ^^^^^^ expected reference, found `char`\n     |\n     =\
    \ note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpguilszsq.rs:12:48\n   |\n12 |       let mut encoded = message.chars().cloned().collect::<Vec<String>>();\n\
    \   |                                                  ^^^^^^^ method cannot be\
    \ called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpguilszsq.rs:17:74\n\
    \   |\n17 |         if let Some(index) = (message.chars().skip(i + 1).find(|c|\
    \ *c == c.to_lowercase()).unwrap()).unwrap() {\n   |                         \
    \                                                 ^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `ToLowercase`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpguilszsq.rs:17:102\n   |\n17\
    \ |         if let Some(index) = (message.chars().skip(i + 1).find(|c| *c == c.to_lowercase()).unwrap()).unwrap()\
    \ {\n   |                                                                    \
    \                                  ^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().fold(String::new(), |mut acc, c| {\n\
    \        if c >= 'a' && c <= 'z' {\n            acc.push_str(&c.to_lowercase());\n\
    \        } else if c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n          \
    \  acc.push_str(&c.to_uppercase());\n        } else {\n            acc.push_str(&c.to_lowercase());\n\
    \            acc.push_str(&c.to_uppercase());\n        }\n        acc\n    }).to_string()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8dhjiok4.rs:14:26\n   |\n\
    14 |             acc.push_str(&c.to_lowercase());\n   |                      \
    \    ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8dhjiok4.rs:16:26\n   |\n16 |\
    \             acc.push_str(&c.to_uppercase());\n   |                         \
    \ ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&ToUppercase`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8dhjiok4.rs:18:26\n   |\n18 |  \
    \           acc.push_str(&c.to_lowercase());\n   |                          ^^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `ToLowercase`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&ToLowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8dhjiok4.rs:19:26\n   |\n19 |             acc.push_str(&c.to_uppercase());\n\
    \   |                          ^^^^^^^^^^^^^^^^^ expected `str`, found struct\
    \ `ToUppercase`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&ToUppercase`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Write your function here\n    return message;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp14s_326v.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut messageToEncode = message;\n    let mut result:\
    \ String = messageToEncode.to_owned();\n    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n\n    let mut index = result.find('a');\n    while index >= 0 {\n   \
    \     \n        let index = result.find('a', index + 1);\n        if index ==\
    \ -1 {\n            break;\n        }\n\n        let index = result.find('a',\
    \ index + 1);\n\n        // Get the letter that is 2 places ahead of the vowel\
    \ and swap \n        // the letters. \n        let letter = result.to_string()[index];\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index + 1);\n\
    \        result.swap(index, index + 1);\n        result.swap(index, index\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpd0kq8y4g.rs:96:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     while index >= 0 {\n   |\
    \                      - this delimiter might not be properly closed...\n...\n\
    87 | }\n   | - ...as it matches this but it has different indentation\n...\n96\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpd0kq8y4g.rs:86:20\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n86 |     \
    \    result.swap(index, index\n   |                    ^ unclosed delimiter\n\
    87 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd0kq8y4g.rs:17:20\n   |\n17 |     while index >= 0 {\n   |    \
    \                ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n17 |     while index >= Some(0) {\n   |    \
    \                +++++ +\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpd0kq8y4g.rs:19:44\n   |\n19 |         let index = result.find('a',\
    \ index + 1);\n   |                                      ----- ^ - {integer}\n\
    \   |                                      |\n   |                           \
    \           Option<usize>\n\nerror[E0061]: this function takes 1 argument but\
    \ 2 arguments were supplied\n    --> /tmp/tmpd0kq8y4g.rs:19:28\n     |\n19   |\
    \         let index = result.find('a', index + 1);\n     |                   \
    \         ^^^^ ---  --------- supplied 2 arguments\n     |                   \
    \         |\n     |                            expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd0kq8y4g.rs:20:21\n\
    \   |\n20 |         if index == -1 {\n   |                     ^^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `{integer}`\nhelp: try wrappin"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut letter_counter\
    \ = HashSet::new();\n    let mut vowels = ['a','e','i','o','u'];\n    for &x in\
    \ &message {\n        \n        let vowel_index = vowels.iter().position(|vowel|\
    \ x == vowel);\n        \n        if vowel_index == Some(0) {\n            encoded.push(x);\n\
    \        } else {\n            let a_index = vowels.iter().position(|vowel| vowel\
    \ == a_index + 1).unwrap();\n            encoded.push((&vowels[a_index..]).join(''));\n\
    \        }\n        \n        if !letter_counter.contains(&(x)) {\n          \
    \  letter_counter.insert(x);\n        }\n    }\n    \n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpvkntcqbi.rs:23:53\n   |\n\
    23 |             encoded.push((&vowels[a_index..]).join(''));\n   |          \
    \                                           ^ empty character literal\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpvkntcqbi.rs:13:30\n\
    \   |\n13 |     let mut letter_counter = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `a_index` in this scope\n  --> /tmp/tmpvkntcqbi.rs:22:67\n\
    \   |\n22 |             let a_index = vowels.iter().position(|vowel| vowel ==\
    \ a_index + 1).unwrap();\n   |                                               \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0277]: `&String`\
    \ is not an iterator\n  --> /tmp/tmpvkntcqbi.rs:15:15\n   |\n15 |     for &x in\
    \ &message {\n   |               ^^^^^^^^ `&String` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror[E0277]: can't compare `char` with `&char`\n  --> /tmp/tmpvkntcqbi.rs:17:60\n\
    \   |\n17 |         let vowel_index = vowels.iter().position(|vowel| x == vowel);\n\
    \   |                                                            ^^ no implementation\
    \ for `char == &char`\n   |\n   = help: the trait `PartialEq<&char>` is not implemented\
    \ for `char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ the method `join` exists for reference `&[char]`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpvkntcqbi.rs:23:47\n   |\n23 |             encoded.push((&vowels[a_index..]).join(''));\n\
    \   |                                               ^^^^ method cannot be called\
    \ on `&[char]` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[char]: Join<_>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Your code here\n    \n    return \"\";\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd5ytyaxm.rs:14:12\n   |\n\
    11 | fn encode(message: String) -> String {\n   |                            \
    \   ------ expected `String` because of return type\n...\n14 |     return \"\"\
    ;\n   |            ^^- help: try using a conversion method: `.to_string()`\n \
    \  |            |\n   |            expected struct `String`, found `&str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        let mut new_ch = ch;\n        \n        if let Some(vowel) = ch2vowel.get(&new_ch)\
    \ {\n            new_ch = vowel.clone();\n        }\n\n        for vowel in vowels\
    \ {\n            if let Some(vowel2) = ch2vowel.get(&vowel) {\n              \
    \  if new_ch == vowel2 {\n                    new_ch = get_vowel(&vowel);\n  \
    \                  break;\n                }\n            }\n        }\n     \
    \   \n        result += new_ch;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ch2vowel` in this scope\n  --> /tmp/tmp31p3t14k.rs:16:30\n\
    \   |\n16 |         if let Some(vowel) = ch2vowel.get(&new_ch) {\n   |       \
    \                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `vowels` in this scope\n  --> /tmp/tmp31p3t14k.rs:20:22\n   |\n20\
    \ |         for vowel in vowels {\n   |                      ^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `ch2vowel` in this scope\n\
    \  --> /tmp/tmp31p3t14k.rs:21:35\n   |\n21 |             if let Some(vowel2) =\
    \ ch2vowel.get(&vowel) {\n   |                                   ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `get_vowel` in this\
    \ scope\n  --> /tmp/tmp31p3t14k.rs:23:30\n   |\n23 |                     new_ch\
    \ = get_vowel(&vowel);\n   |                              ^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p3t14k.rs:29:19\n\
    \   |\n29 |         result += new_ch;\n   |                   ^^^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().enumerate().filter(|&(index, value)|\n\
    \        value >= 'a' && value <= 'z'\n    ) // Filter out all non-alphabetic\
    \ characters\n    .filter(|&(index, value)| {\n        let prev_letter = if index\
    \ == 0 { None } else { &message[index - 2] };\n        let next_letter = if index\
    \ + 1 == message.len() { None } else { &message[index + 1] };\n        if prev_letter.is_some()\
    \ && next_letter == &'z' {\n            true\n        } else if prev_letter.is_some()\
    \ && next_letter == &'Z' {\n            true\n        } else if prev_letter ==\
    \ &'A' && next_letter == &'z' {\n            true\n        } else if prev_letter\
    \ == &'A' && next_letter == &'Z' {\n            true\n        } else {\n     \
    \       false\n        }\n    })\n    .map(|(index, value)| {\n        let mut\
    \ result = vec![value];\n        \n        let mut vowels = vec!['A', 'E', 'I',\
    \ 'O', 'U'];\n        for v in vowels.iter() {\n            let mut index = index\
    \ - 1;\n            \n            while index >= 0 {\n                if message[index]\
    \ == v {\n                    result.push((message[index + 1] as char) - 'A');\n\
    \                    break;\n                }\n                index -= 1;\n\
    \            }\n        }\n        \n        result\n    })\n    .collect::<Vec<_>>()\n\
    \    .collect::<String>()\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpal7o1ajh.rs:16:58\n\
    \   |\n16 |         let prev_letter = if index == 0 { None } else { &message[index\
    \ - 2] };\n   |                                                          ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpal7o1ajh.rs:16:57\n\
    \   |\n16 |         let prev_letter = if index == 0 { None } else { &message[index\
    \ - 2] };\n   |                                           ----          ^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found reference\n   |                              \
    \             |\n   |                                           expected because\
    \ of this\n   |\n   = note:   expected enum `Option<_>`\n           found reference\
    \ `&_`\nhelp: consider removing the borrow\n   |\n16 -         let prev_letter\
    \ = if index == 0 { None } else { &message[index - 2] };\n16 +         let prev_letter\
    \ = if index == 0 { None } else { message[index - 2] };\n   | \n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpal7o1ajh.rs:17:74\n\
    \   |\n17 |         let next_letter = if index + 1 == message.len() { None } else\
    \ { &message[index + 1] };\n   |                                             \
    \                             ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \ "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result: String = String::new();\n    for (i,\
    \ ch) in message.chars().enumerate() {\n        match ch {\n            'a' =>\
    \ result.push_str(&\"T\"),\n            'b' => result.push_str(&\"G\"),\n    \
    \        'c' => result.push_str(&\"S\"),\n            'd' => result.push_str(&\"\
    S\"),\n            'e' => result.push_str(&\"C\"),\n            'f' => result.push_str(&\"\
    C\"),\n            'g' => result.push_str(&\"G\"),\n            'h' => result.push_str(&\"\
    S\"),\n            'i' => result.push_str(&\"S\"),\n            'j' => result.push_str(&\"\
    S\"),\n            'k' => result.push_str(&\"S\"),\n            'l' => result.push_str(&\"\
    S\"),\n            'm' => result.push_str(&\"S\"),\n            'n' => result.push_str(&\"\
    S\"),\n            'o' => result.push_str(&\"S\"),\n            'p' => result.push_str(&\"\
    S\"),\n            'q' => result.push_str(&\"Q\"),\n            'r' => result.push_str(&\"\
    S\"),\n            's' => result.push_str(&\"S\"),\n            't' => result.push_str(&\"\
    T\"),\n            'u' => result.push_str(&\"S\"),\n            'v' => result.push_str(&\"\
    S\"),\n            'w' => result.push_str(&\"S\"),\n            'x' => result.push_str(&\"\
    S\"),\n            'y' => result.push_str(&\"S\"),\n            'z' => result.push_str(&\"\
    S\"),\n            _ => {}\n        };\n        result.push_str(&\" \");\n   \
    \ };\n    return result;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"    \"`,\n right: `\"tgst\"`', /tmp/tmpcstq720v.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut alphabet: Vec<char> = [\"A\".to_char() .. \"\
    Z\".to_char()].to_vec();\n    alphabet.insert(alphabet.len(), \"a\".to_char());\n\
    \    alphabet.insert(alphabet.len(), \"b\".to_char());\n    alphabet.insert(alphabet.len(),\
    \ \"c\".to_char());\n    alphabet.insert(alphabet.len(), \"d\".to_char());\n \
    \   alphabet.insert(alphabet.len(), \"e\".to_char());\n    alphabet.insert(alphabet.len(),\
    \ \"f\".to_char());\n    alphabet.insert(alphabet.len(), \"g\".to_char());\n \
    \   alphabet.insert(alphabet.len(), \"h\".to_char());\n    alphabet.insert(alphabet.len(),\
    \ \"i\".to_char());\n    alphabet.insert(alphabet.len(), \"j\".to_char());\n \
    \   alphabet.insert(alphabet.len(), \"k\".to_char());\n    alphabet.insert(alphabet.len(),\
    \ \"l\".to_char());\n    alphabet.insert(alphabet.len(), \"m\".to_char());\n \
    \   alphabet.insert(alphabet.len(), \"n\".to_char());\n    alphabet.insert(alphabet.len(),\
    \ \"o\".to_char());\n    alphabet.insert(alphabet.len(), \"p\".to_char());\n \
    \   alphabet.insert(alphabet.len(), \"q\".to_char());\n    alphabet.insert(alphabet.len(),\
    \ \"r\".to_char());\n    alphabet.insert(alphabet.len(), \"s\".to_char());\n \
    \   alphabet.insert(alphabet.len(), \"t\".to_char());\n    alphabet.insert(alphabet.len(),\
    \ \"u\".to_char());\n    alphabet.insert(alphabet.len(), \"v\".to_char());\n \
    \   alphabet.insert(alphabet.len(), \"w\".to_char());\n    alphabet.insert(alphabet.len(),\
    \ \"x\".to_char());\n    alphabet.insert(alphabet.len(), \"y\".to_char());\n \
    \   alphabet.insert(alphabet.len(), \"z\".to_char());\n\n    let mut encoded =\
    \ \"\";\n    let mut current = alphabet.len();\n    \n    for letter in message.chars()\
    \ {\n        if let Some(next) = alphabet.get_mut(current + 2) {\n           \
    \ if letter.is_uppercase() {\n                encoded += next.to_ascii_lowercase();\n\
    \            } else {\n                encoded += next.to_ascii_uppercase();\n\
    \            }\n        } else {\n            if letter.is_uppercase() {\n   \
    \             encoded += &alphabet[0];\n            } else {\n               \
    \ encoded += &alphabet[9];\n            }\n        }\n        current += 1;\n\
    \    }\n    return encoded;\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_char` found for reference `&'static str`\
    \ in the current scope\n  --> /tmp/tmp3kc8x6jk.rs:12:40\n   |\n12 |     let mut\
    \ alphabet: Vec<char> = [\"A\".to_char() .. \"Z\".to_char()].to_vec();\n   | \
    \                                       ^^^^^^^ method not found in `&'static\
    \ str`\n\nerror[E0599]: no method named `to_char` found for reference `&'static\
    \ str` in the current scope\n  --> /tmp/tmp3kc8x6jk.rs:12:57\n   |\n12 |     let\
    \ mut alphabet: Vec<char> = [\"A\".to_char() .. \"Z\".to_char()].to_vec();\n \
    \  |                                                         ^^^^^^^ method not\
    \ found in `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3kc8x6jk.rs:12:35\n\
    \   |\n12 |     let mut alphabet: Vec<char> = [\"A\".to_char() .. \"Z\".to_char()].to_vec();\n\
    \   |                       ---------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `std::ops::Range`\n   |                      \
    \ |\n   |                       expected due to this\n   |\n   = note: expected\
    \ struct `Vec<char>`\n              found struct `Vec<std::ops::Range<_>>`\n\n\
    error[E0599]: no method named `to_char` found for reference `&'static str` in\
    \ the current scope\n  --> /tmp/tmp3kc8x6jk.rs:13:41\n   |\n13 |     alphabet.insert(alphabet.len(),\
    \ \"a\".to_char());\n   |                                         ^^^^^^^ method\
    \ not found in `&'static str`\n\nerror[E0599]: no method named `to_char` found\
    \ for reference `&'static str` in the current scope\n  --> /tmp/tmp3kc8x6jk.rs:14:41\n\
    \   |\n14 |     alphabet.insert(alphabet.len(), \"b\".to_char());\n   |      \
    \                                   ^^^^^^^ method not found in `&'static str`\n\
    \nerror[E0599]: no method named `to_char` found for reference `&'static str` in\
    \ the current scope\n  --> /tmp/tmp3kc8x6jk.rs:15:41\n   |\n15 |     alphabet.insert(alphabet.len(),\
    \ \"c\".to_char());\n   |                                         ^^^^^^^ method\
    \ not found in `&'static str`\n\nerror[E0599]: no method named `to_char` found\
    \ for reference `&'static str` in the current scope\n  --> /tmp/tmp3kc8x6jk.rs:16:41\n\
    \   |\n1"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut out: String = String::new();\n    let mut vowels:\
    \ Vec<char> = vec!['a','e','i','o','u','A','E','I','O','U'];\n    for ch in message.chars()\
    \ {\n        if let Some(ch) = ch.to_lowercase() {\n            if vowels.contains(&ch)\
    \ {\n                out.push(vowels.iter().position(|&x| *x == ch).unwrap().to_string());\n\
    \            }\n            else {\n                out.push(ch);\n          \
    \  }\n        }\n    }\n    out\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptfm3x1fa.rs:15:16\n   |\n\
    15 |         if let Some(ch) = ch.to_lowercase() {\n   |                ^^^^^^^^\
    \   ----------------- this expression has type `ToLowercase`\n   |           \
    \     |\n   |                expected struct `ToLowercase`, found enum `Option`\n\
    \   |\n   = note: expected struct `ToLowercase`\n                found enum `Option<_>`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmptfm3x1fa.rs:17:54\n\
    \   |\n17 |                 out.push(vowels.iter().position(|&x| *x == ch).unwrap().to_string());\n\
    \   |                                                      ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptfm3x1fa.rs:17:26\n   |\n17 |              \
    \   out.push(vowels.iter().position(|&x| *x == ch).unwrap().to_string());\n  \
    \ |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::from(\"\");\n    for\
    \ (i, letter) in message.chars().enumerate().cloned() {\n        if let Some(vowel)\
    \ = find_vowel_at(message, i) { \n            new_message.push_str(replace_in_message(message,\
    \ i, vowel));\n        }\n        else {\n            new_message.push_str(letter);\n\
    \        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_vowel_at` in this scope\n  -->\
    \ /tmp/tmpl7786k3y.rs:14:30\n   |\n14 |         if let Some(vowel) = find_vowel_at(message,\
    \ i) { \n   |                              ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `replace_in_message` in this scope\n  -->\
    \ /tmp/tmpl7786k3y.rs:15:34\n   |\n15 |             new_message.push_str(replace_in_message(message,\
    \ i, vowel));\n   |                                  ^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0271]: type mismatch resolving `<Enumerate<Chars<'_>>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpl7786k3y.rs:13:52\n     |\n13   |\
    \     for (i, letter) in message.chars().enumerate().cloned() {\n     |      \
    \                                              ^^^^^^ expected reference, found\
    \ tuple\n     |\n     = note: expected reference `&_`\n                    found\
    \ tuple `(usize, char)`\nnote: required by a bound in `cloned`\n\nerror[E0271]:\
    \ type mismatch resolving `<Enumerate<Chars<'_>> as Iterator>::Item == &_`\n \
    \ --> /tmp/tmpl7786k3y.rs:13:24\n   |\n13 |     for (i, letter) in message.chars().enumerate().cloned()\
    \ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(usize, char)`\n \
    \          found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Enumerate<Chars<'_>>>`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `Cloned<Enumerate<Chars<'_>>>`\n\
    \nerror[E0271]: type mismatch resolving `<Enumerate<Chars<'_>> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpl7786k3y.rs:13:24\n   |\n13 |     for (i, letter) in message.chars().enumerate().cloned()\
    \ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(usize, char)`\n \
    \          found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome er"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = message;\n    for c in encoded.chars()\
    \ {\n        if let Some(d) = english_vowels[c] {\n            let n = c + 1;\n\
    \            encoded = encoded.replace(c);\n            encoded = encoded.replace(d,\
    \ n);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `english_vowels` in this scope\n  --> /tmp/tmp8llsays9.rs:14:26\n\
    \   |\n14 |         if let Some(d) = english_vowels[c] {\n   |               \
    \           ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add\
    \ `{integer}` to `char`\n  --> /tmp/tmp8llsays9.rs:15:23\n   |\n15 |         \
    \    let n = c + 1;\n   |                     - ^ - {integer}\n   |          \
    \           |\n   |                     char\n\nerror[E0061]: this function takes\
    \ 2 arguments but 1 argument was supplied\n   --> /tmp/tmp8llsays9.rs:16:31\n\
    \    |\n16  |             encoded = encoded.replace(c);\n    |               \
    \                ^^^^^^^ - supplied 1 argument\n    |                        \
    \       |\n    |                               expected 2 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0369, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().filter_map(|c| {\n        match c {\n\
    \            'A'..'Z' => Some(char::from(c) - 'A' + 1),\n            'a'..'z'\
    \ => Some(char::from(c) - 'a' + 1),\n            _ => None,\n        }\n    }).map(|&i|\
    \ alphabet[i % 26]).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpv1pnwta1.rs:18:17\n\
    \   |\n18 |     }).map(|&i| alphabet[i % 26]).collect()\n   |                \
    \ ^^^^^^^^ not found in this scope\n\nerror[E0658]: exclusive range pattern syntax\
    \ is experimental\n  --> /tmp/tmpv1pnwta1.rs:14:13\n   |\n14 |             'A'..'Z'\
    \ => Some(char::from(c) - 'A' + 1),\n   |             ^^^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpv1pnwta1.rs:15:13\n\
    \   |\n15 |             'a'..'z' => Some(char::from(c) - 'a' + 1),\n   |     \
    \        ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0369]: cannot subtract `char` from `char`\n \
    \ --> /tmp/tmpv1pnwta1.rs:14:44\n   |\n14 |             'A'..'Z' => Some(char::from(c)\
    \ - 'A' + 1),\n   |                              ------------- ^ --- char\n  \
    \ |                              |\n   |                              char\n\n\
    error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpv1pnwta1.rs:15:44\n\
    \   |\n15 |             'a'..'z' => Some(char::from(c) - 'a' + 1),\n   |     \
    \                         ------------- ^ --- char\n   |                     \
    \         |\n   |                              char\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0369, E0425, E0658.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| if c.is_ascii_lowercase() \n\
    \                           || c.is_ascii_uppercase() \n                     \
    \      || c.is_ascii_digit() \n                           || c.is_ascii_letter()\n\
    \                           {c.to_string()}\n                           else\n\
    \                           {c.to_string().swapcase()}\n                     \
    \      ).collect::<Vec<_>>().join(\"\").replace_indices\n    (\n        &mut String::from(\"\
    MGHSTCBAHTVWYNQ\"),\n        |i| i.1.to_string()\n    );\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpsmjuw8uz.rs:15:33\n   |\n15 | ...         \
    \          || c.is_ascii_letter()\n   |                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `swapcase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpsmjuw8uz.rs:18:43\n   |\n18 | ...                   {c.to_string().swapcase()}\n\
    \   |                                      ^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `replace_indices` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpsmjuw8uz.rs:19:59\n   |\n19 | ...         \
    \          ).collect::<Vec<_>>().join(\"\").replace_indices\n   |            \
    \                                          ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `replacen`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsmjuw8uz.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut buffer = String::new();\n    for (i, letter)\
    \ in message.chars().enumerate() {\n        let mut j = i;\n        loop {\n \
    \           let mut next = letter;\n            let mut vowel_count = 1;\n   \
    \         let mut has_vowel = false;\n            loop {\n                if j\
    \ - i + 1 >= 3 && letter != ' ' {\n                    has_vowel = true;\n   \
    \                 break;\n                }\n                if letter == ' '\
    \ {\n                    break;\n                }\n                next = alphabet.chars().nth(j\
    \ - i + 1).unwrap();\n                vowel_count += 1;\n                j +=\
    \ 1;\n            }\n            buffer.push_str(&alphabet.chars().nth(i - vowel_count).unwrap());\n\
    \            if has_vowel {\n                buffer.push_str(&next);\n       \
    \     } else {\n                buffer.push_str(&letter);\n            }\n   \
    \     }\n    }\n    buffer\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp35s9ss6f.rs:27:24\n\
    \   |\n27 |                 next = alphabet.chars().nth(j - i + 1).unwrap();\n\
    \   |                        ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmp35s9ss6f.rs:31:30\n\
    \   |\n31 |             buffer.push_str(&alphabet.chars().nth(i - vowel_count).unwrap());\n\
    \   |                              ^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp35s9ss6f.rs:33:33\n   |\n33 |              \
    \   buffer.push_str(&next);\n   |                                 ^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp35s9ss6f.rs:35:33\n\
    \   |\n35 |                 buffer.push_str(&letter);\n   |                  \
    \               ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: Vec<String> = Vec::new();\n    let\
    \ mut char_num = 0;\n    let mut char_val = 0;\n    for c in message.chars() {\n\
    \        match c {\n            'a' ... 'z' => char_num = c - 'a' + 1,\n     \
    \       'A' ... 'Z' => char_val = c - 'A' + 1,\n            _ => char_num += 1,\n\
    \        }\n        encoded.push((&char_num).to_string() + char_val.to_string());\n\
    \        char_num = 0;\n        char_val = 0;\n    }\n    encoded.push((&char_num).to_string());\n\
    \    encoded.push(&char_val.to_string());\n    encoded.join(\"\").to_string()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpzu6avvtk.rs:17:17\n\
    \   |\n17 |             'a' ... 'z' => char_num = c - 'a' + 1,\n   |         \
    \        ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpzu6avvtk.rs:18:17\n\
    \   |\n18 |             'A' ... 'Z' => char_val = c - 'A' + 1,\n   |         \
    \        ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this\
    \ is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpzu6avvtk.rs:17:41\n\
    \   |\n17 |             'a' ... 'z' => char_num = c - 'a' + 1,\n   |         \
    \                              - ^ --- char\n   |                            \
    \           |\n   |                                       char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpzu6avvtk.rs:18:41\n   |\n\
    18 |             'A' ... 'Z' => char_val = c - 'A' + 1,\n   |                \
    \                       - ^ --- char\n   |                                   \
    \    |\n   |                                       char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzu6avvtk.rs:21:48\n   |\n21 |         encoded.push((&char_num).to_string()\
    \ + char_val.to_string());\n   |                                             \
    \   ^^^^^^^^^^^^^^^^^^^^\n   |                                               \
    \ |\n   |                                                expected `&str`, found\
    \ struct `String`\n   |                                                help: consider\
    \ borrowing here: `&char_val.to_string()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzu6avv"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: Vec<char> = Vec::new();\n    for i\
    \ in 0..message.len() {\n        let mut counter = 0;\n        let letter = message[i];\n\
    \        for j in 0..message.len() {\n            counter += 1;\n            if\
    \ i == j {\n                continue;\n            }\n            if letter ==\
    \ message[j] {\n                break;\n            }\n        }\n        encoded.push((letter\
    \ + counter).to_string());\n    }\n    encoded.push(\"\");\n    encoded.join(\"\
    \").to_string()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu3_757u2.rs:15:22\n\
    \   |\n15 |         let letter = message[i];\n   |                      ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu3_757u2.rs:21:26\n   |\n21 |             if letter == message[j]\
    \ {\n   |                          ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu3_757u2.rs:27:18\n\
    \   |\n27 |     encoded.push(\"\");\n   |                  ^^ expected `char`,\
    \ found `&str`\n\nerror[E0599]: the method `join` exists for struct `Vec<char>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpu3_757u2.rs:28:13\n \
    \  |\n28 |     encoded.join(\"\").to_string()\n   |             ^^^^ method cannot\
    \ be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc -"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::with_capacity(message.len());\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            let\
    \ idx = ascii_lowercase().find(c.to_ascii_lowercase());\n            result.push_str(&ascii_lowercase()[idx\
    \ as usize]);\n        } else {\n            result.push_str(&ascii_lowercase()[c.to_ascii_lowercase()]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ascii_lowercase` in this scope\n  -->\
    \ /tmp/tmpzlzjfg0c.rs:15:23\n   |\n15 |             let idx = ascii_lowercase().find(c.to_ascii_lowercase());\n\
    \   |                       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `ascii_lowercase` in this scope\n  --> /tmp/tmpzlzjfg0c.rs:16:30\n\
    \   |\n16 |             result.push_str(&ascii_lowercase()[idx as usize]);\n \
    \  |                              ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `ascii_lowercase` in this scope\n  --> /tmp/tmpzlzjfg0c.rs:18:30\n\
    \   |\n18 |             result.push_str(&ascii_lowercase()[c.to_ascii_lowercase()]);\n\
    \   |                              ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    let mut l = message.char_indices().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable_by_key(|&a| a.0);\n    for index in l.iter().cloned() {\n\
    \        let c = message.chars().nth(index.0).unwrap();\n        if c.is_ascii_uppercase()\
    \ {\n            let index = index.0 + 2;\n            if index < l.len() {\n\
    \                let mut c = message.chars().nth(index).unwrap();\n          \
    \      let mut index = index + 2;\n                while index < l.len() {\n \
    \                   c = c.to_ascii_lowercase().to_ascii_uppercase();\n       \
    \             s = format!(\"{}{}{}\", c, s, c);\n                    index = index\
    \ + 2;\n                }\n            }\n        } else {\n            let c\
    \ = message.chars().nth(index).unwrap();\n            let mut index = index +\
    \ 2;\n            while index < l.len() {\n                c = c.to_ascii_lowercase().to_ascii_uppercase();\n\
    \                s = format!(\"{}{}{}\", c, s, c);\n                index = index\
    \ + 2;\n            }\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<CharIndices<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp7qzubfjh.rs:13:40\n     |\n13   |     let mut l = message.char_indices().cloned().collect::<Vec<_>>();\n\
    \     |                                        ^^^^^^ expected reference, found\
    \ tuple\n     |\n     = note: expected reference `&_`\n                    found\
    \ tuple `(usize, char)`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<CharIndices<'_>>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp7qzubfjh.rs:13:49\n    |\n13  |  \
    \     let mut l = message.char_indices().cloned().collect::<Vec<_>>();\n    |\
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<CharIndices<'_>>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `<CharIndices<'_>\
    \ as Iterator>::Item = &_`\n            which is required by `Cloned<CharIndices<'_>>:\
    \ Iterator`\n            `Cloned<CharIndices<'_>>: Iterator`\n            which\
    \ is required by `&mut Cloned<CharIndices<'_>>: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for letter in\
    \ message {\n        // Get the index of the letter we're trying to swap case\n\
    \        let index: usize = alpha.index(letter.to_lowercase());\n        // Get\
    \ the letter that appears 2 places ahead of the letter we're \n        // swapping\
    \ case\n        let next_letter: char = alpha[index + 1];\n        // If we're\
    \ not swapping case, just add it to the result\n        if !letter.is_lowercase()\
    \ {\n            result.push_str(letter);\n        } else {\n            // Swap\
    \ case\n            result.push_str(letter.to_lowercase());\n            // Add\
    \ the next letter to its position\n            result.push_str(next_letter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alpha` in this scope\n  --> /tmp/tmpvqcsd2wt.rs:15:28\n\
    \   |\n15 |         let index: usize = alpha.index(letter.to_lowercase());\n \
    \  |                            ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alpha` in this scope\n  --> /tmp/tmpvqcsd2wt.rs:18:33\n \
    \  |\n18 |         let next_letter: char = alpha[index + 1];\n   |           \
    \                      ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpvqcsd2wt.rs:13:19\n   |\n13 |     for letter\
    \ in message {\n   |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvqcsd2wt.rs:26:29\n   |\n26 |             result.push_str(next_letter);\n\
    \   |                             ^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut decodedMessage: String = message;\n    for\
    \ ch in decodedMessage {\n        decodedMessage.replace(ch.to_ascii_lowercase(),\
    \ ch.to_ascii_lowercase()[..2] + ch.to_ascii_lowercase()[1..]);\n    }\n    decodedMessage\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpsq6kg4zc.rs:13:15\n\
    \   |\n13 |     for ch in decodedMessage {\n   |               ^^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for (i, ch) in\
    \ message.chars().enumerate() {\n        match ch {\n            'a' => result.push('A'),\n\
    \            'b' => result.push('B'),\n            'c' => result.push('C'),\n\
    \            'd' => result.push('D'),\n            'e' => result.push('E'),\n\
    \            'f' => result.push('F'),\n            'g' => result.push('G'),\n\
    \            'h' => result.push('H'),\n            'i' => result.push('I'),\n\
    \            'j' => result.push('J'),\n            'k' => result.push('K'),\n\
    \            'l' => result.push('L'),\n            'm' => result.push('m'),\n\
    \            'n' => result.push('N'),\n            'o' => result.push('O'),\n\
    \            'p' => result.push('P'),\n            'q' => result.push('Q'),\n\
    \            'r' => result.push('R'),\n            's' => result.push('S'),\n\
    \            't' => result.push('T'),\n            'u' => result.push('U'),\n\
    \            'v' => result.push('V'),\n            'w' => result.push('W'),\n\
    \            'x' => result.push('X'),\n            'y' => result.push('Y'),\n\
    \            'z' => result.push('Z'),\n            'A' => result.push('A'),\n\
    \            'B' => result.push('B'),\n            'C' => result.push('C'),\n\
    \            'D' => result.push('D'),\n            'E' => result.push('E'),\n\
    \            'F' => result.push('F'),\n            'G' => result.push('G'),\n\
    \            'H' => result.push('H'),\n            'I' => result.push('I'),\n\
    \            'J' => result.push('J'),\n            'K' => result.push('K'),\n\
    \            'L' => result.push('L'),\n            'M' => result.push('m'),\n\
    \            'N' => result.push('N'),\n            'O' => result.push('O'),\n\
    \            'P' => result.push('P'),\n            'Q' => result.push('Q'),\n\
    \            'R' => result.push('R'),\n            'S' => result.push('S'),\n\
    \            'T' => result.push('T'),\n            'U' => result.push('U'),\n\
    \            'V' => result.push('V'),\n            'W' => result.push('W'),\n\
    \            'X' => result.push('X'),\n            'Y' => result.push('Y'),\n\
    \            'Z' => result.push('Z'),\n            c => result.push(c),\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpctbewqcd.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: String = String::new();\n    let mut\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut counts = HashMap::new();\n\
    \    let mut current_vowel = vowels.iter().position(|&x| message.chars().any(|&y|\
    \ x == y)).unwrap();\n\n    let mut temp_message = message;\n    for ch in temp_message\
    \ {\n        let mut new_index = current_vowel;\n        if let Some(&mut count)\
    \ = counts.entry(ch as u8).or_insert(0usize) {\n            new_index += *count;\n\
    \        }\n\n        counts.entry(ch as u8).or_insert(0usize) += 1;\n       \
    \ current_vowel = match new_index {\n            1 => match vowels.iter().position(|&x|\
    \ message.chars().any(|&y| x == y)).unwrap() {\n                None => vowels.iter().position(|&x|\
    \ message.chars().any(|&y| x == y)).unwrap(),\n                Some(x) => x,\n\
    \            },\n            2 => match vowels.iter().position(|&x| message.chars().any(|&y|\
    \ x == y)).unwrap() {\n                None => vowels.iter().position(|&x| message.chars().any(|&y|\
    \ x == y)).unwrap(),\n                Some(x) => x,\n            },\n        \
    \    3 => match vowels.iter().position(|&x| message.chars().any(|&y| x == y)).unwrap()\
    \ {\n                None => vowels.iter().position(|&x| message.chars().any(|&y|\
    \ x == y)).unwrap(),\n                Some(x) => x,\n            },\n        \
    \    4 => match vowels.iter().position(|&x| message.chars().any(|&y| x == y)).unwrap()\
    \ {\n                None => vowels.iter().position(|&x| message.chars().any(|&y|\
    \ x == y)).unwrap(),\n                Some(x) => x,\n            },\n        \
    \    5 => match vowels.iter().position(|&x| message.chars().any(|&y| x == y)).unwrap()\
    \ {\n                None => vowels.iter().position(|&x| message.chars().any(|&y|\
    \ x == y)).unwrap(),\n                Some(x) => x,\n            },\n        \
    \    _ => 0,\n        };\n        encoded.push_str(&vowels[new_index]);\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp53jlwcm5.rs:14:22\n   |\n14 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp53jlwcm5.rs:15:78\n   |\n15 |     let mut current_vowel\
    \ = vowels.iter().position(|&x| message.chars().any(|&y| x == y)).unwrap();\n\
    \   |                                                                        \
    \      ^--\n   |                                                             \
    \                 ||\n   |                                                   \
    \                           |expected due to this\n   |                      \
    \                                                        expected `char`, found\
    \ reference\n   |                                                            \
    \                  help: did you mean `y`: `&char`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmp53jlwcm5.rs:18:15\n   |\n18 |     for ch in temp_message\
    \ {\n   |               ^^^^^^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror[E0067]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmp53jlwcm5.rs:24:50\n   |\n24 |         counts.entry(ch as u8).or_insert(0usize)\
    \ += 1;\n   |         ---------------------------------------- ^^\n   |      \
    \   |\n   |         cannot assign to this expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp53jlwcm5.rs:26:73\n   |\n26 |             1 => match vowels.iter().position(|&x|\
    \ message.chars().any(|&y| x == y)).unwrap() {\n   |                         \
    \                                                ^--\n   |                   \
    \                                                      ||\n   |              \
    \                    "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for (i, char)\
    \ in message.chars().enumerate() {\n        if i > 0 && i % 2 == 0 {\n       \
    \     result.push('a');\n        }\n        \n        let a = char.to_ascii_lowercase();\n\
    \        let b = &'a' as &'a';\n        if a == b {\n            result.push(a);\n\
    \        } else {\n            result.push(get_vowel_pair(a - 'a'.to_ascii_lowercase()));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected type, found `'a'`\n  --> /tmp/tmp9hoiicxa.rs:19:26\n  \
    \ |\n19 |         let b = &'a' as &'a';\n   |                          ^^^ expected\
    \ type\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: String = String::new();\n    let mut\
    \ alphabet = vec!['T', 'H', 'K', 'S', 'C', 'G', 'G', 'M'];\n    let mut count:\
    \ usize = 0;\n    for letter in message.chars() {\n        if alphabet[count]\
    \ == letter {\n            encoded += alphabet[count];\n            count += 1;\n\
    \        } else {\n            encoded += alphabet[count];\n            count\
    \ += 1;\n            for _ in 0..2 {\n                if alphabet[count] == letter\
    \ {\n                    encoded += alphabet[count];\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    encoded.to_string()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp52rnucn_.rs:17:24\n   |\n\
    17 |             encoded += alphabet[count];\n   |                        ^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp52rnucn_.rs:20:24\n\
    \   |\n20 |             encoded += alphabet[count];\n   |                    \
    \    ^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp52rnucn_.rs:24:32\n   |\n24 |                     encoded\
    \ += alphabet[count];\n   |                                ^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut newmessage = \"\";\n    let mut index = message[0]\
    \ as usize;\n    for let mut character in message.chars() {\n        if character\
    \ == ' ' {\n            newmessage += ' ';\n        } else {\n            if index\
    \ == 0 || character as usize - index == 2 {\n                newmessage += &'A'[(character\
    \ as usize - index - 1) as usize];\n            } else {\n                newmessage\
    \ += &'a'[(character as usize - index - 1) as usize];\n            }\n       \
    \ }\n        index = character;\n    }\n    newmessage\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `let`\n  --> /tmp/tmp9cd6aw5c.rs:14:9\n\
    \   |\n14 |     for let mut character in message.chars() {\n   |         ^^^ expected\
    \ identifier, found keyword\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp9cd6aw5c.rs:14:12\n\
    \   |\n14 |     for let mut character in message.chars() {\n   |            ^\
    \ help: try adding `in` here\n\nerror: expected expression, found keyword `mut`\n\
    \  --> /tmp/tmp9cd6aw5c.rs:14:13\n   |\n14 |     for let mut character in message.chars()\
    \ {\n   |             ^^^ expected expression\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmp9cd6aw5c.rs:13:21\n   |\n13\
    \ |     let mut index = message[0] as usize;\n   |                     ^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: String = \"\";\n\n    for c in message.chars()\
    \ {\n        let n = english_letters.find(|&(_, a)| a == c);\n        encoded\
    \ += swap_case(n) + c;\n    }\n\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `english_letters` in this scope\n  -->\
    \ /tmp/tmpvk55hhi2.rs:15:17\n   |\n15 |         let n = english_letters.find(|&(_,\
    \ a)| a == c);\n   |                 ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `swap_case` in this scope\n  --> /tmp/tmpvk55hhi2.rs:16:20\n\
    \   |\n16 |         encoded += swap_case(n) + c;\n   |                    ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvk55hhi2.rs:12:31\n\
    \   |\n12 |     let mut encoded: String = \"\";\n   |                      ------\
    \   ^^- help: try using a conversion method: `.to_string()`\n   |            \
    \          |        |\n   |                      |        expected struct `String`,\
    \ found `&str`\n   |                      expected due to this\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars()\n        .map(|c| if ('A' <= c && c\
    \ <= 'Z') || (a <= c && c <= 'Z') \n                     || (a <= c && c <= 'z')\
    \ || (a <= c && c <= 'Z') \n                     || (a <= c && c <= 'z') || (a\
    \ <= c && c <= 'Z') \n                     || (a <= c && c <= 'z'){ c } else {\
    \ c })\n        .collect::<Vec<_>>()\n        .join(\"\")\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmpocrqih8i.rs:13:48\n\
    \   |\n13 |         .map(|c| if ('A' <= c && c <= 'Z') || (a <= c && c <= 'Z')\
    \ \n   |                                                ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0425]: cannot find value `a` in this\
    \ scope\n  --> /tmp/tmpocrqih8i.rs:14:26\n   |\n14 |                      || (a\
    \ <= c && c <= 'z') || (a <= c && c <= 'Z') \n   |                          ^\
    \ help: a local variable with a similar name exists: `c`\n\nerror[E0425]: cannot\
    \ find value `a` in this scope\n  --> /tmp/tmpocrqih8i.rs:14:50\n   |\n14 |  \
    \                    || (a <= c && c <= 'z') || (a <= c && c <= 'Z') \n   |  \
    \                                                ^ help: a local variable with\
    \ a similar name exists: `c`\n\nerror[E0425]: cannot find value `a` in this scope\n\
    \  --> /tmp/tmpocrqih8i.rs:15:26\n   |\n15 |                      || (a <= c &&\
    \ c <= 'z') || (a <= c && c <= 'Z') \n   |                          ^ help: a\
    \ local variable with a similar name exists: `c`\n\nerror[E0425]: cannot find\
    \ value `a` in this scope\n  --> /tmp/tmpocrqih8i.rs:15:50\n   |\n15 |       \
    \               || (a <= c && c <= 'z') || (a <= c && c <= 'Z') \n   |       \
    \                                           ^ help: a local variable with a similar\
    \ name exists: `c`\n\nerror[E0425]: cannot find value `a` in this scope\n  -->\
    \ /tmp/tmpocrqih8i.rs:16:26\n   |\n16 |                      || (a <= c && c <=\
    \ 'z'){ c } else { c })\n   |                          ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0599]: the method `join` exists for\
    \ struct `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmpocrqih8i.rs:18:10\n\
    \   |\n18 |         .join(\"\")\n   |          ^^^^ method cannot be called on\
    \ `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[char]: Join<_>`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rust"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\n    // Get all vowels appearing\
    \ 2 places ahead\n    for x in vowels.iter().rev().skip(1) {\n        let vowel_pos\
    \ = message.index(x);\n        let vowel_next_pos = (vowel_pos + 1) % message.length();\n\
    \n        result.push(message[vowel_next_pos]);\n    }\n\n    // Replace vowels\
    \ found in message\n    for x in vowels.iter().rev() {\n        result.push(message[message.index(x)]);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgrupoaqn.rs:17:33\n   |\n17 |         let vowel_pos\
    \ = message.index(x);\n   |                                 ^^^^^ method not found\
    \ in `String`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpgrupoaqn.rs:18:56\n   |\n18 |         let vowel_next_pos = (vowel_pos\
    \ + 1) % message.length();\n   |                                             \
    \           ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0599]: no method named `index` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpgrupoaqn.rs:25:37\n   |\n25 |         result.push(message[message.index(x)]);\n\
    \   |                                     ^^^^^ method not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.length() == 0 {\n        return \"\"\n \
    \   }\n    let mut message1 = message;\n    let mut message2 = message;\n    let\
    \ mut ascii_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut vowel_alphabet\
    \ = \"AEIOU\";\n    let mut mut_ascii_alphabet = ascii_alphabet.clone();\n   \
    \ let mut mut_vowel_alphabet = vowel_alphabet.clone();\n    for i in 0..message1.len()\
    \ {\n        if message1.chars().next().unwrap() == ascii_alphabet.chars().next().unwrap()\
    \ {\n            mut_ascii_alphabet = mut_ascii_alphabet.replace(message1.chars().next().unwrap(),\
    \ ascii_alphabet.chars().next().unwrap());\n        }\n        if message1.chars().next().unwrap()\
    \ == vowel_alphabet.chars().next().unwrap() {\n            mut_vowel_alphabet\
    \ = mut_vowel_alphabet.replace(message1.chars().next().unwrap(), vowel_alphabet.chars().next().unwrap());\n\
    \        }\n    }\n    let mut_message2 = message2;\n    for i in 0..message2.len()\
    \ {\n        if message2.chars().next().unwrap() == ascii_alphabet.chars().next().unwrap()\
    \ {\n            mut_ascii_alphabet = mut_ascii_alphabet.replace(message2.chars().next().unwrap(),\
    \ ascii_alphabet.chars().next().unwrap());\n        }\n        if message2.chars().next().unwrap()\
    \ == vowel_alphabet.chars().next().unwrap() {\n            mut_vowel_alphabet\
    \ = mut_vowel_alphabet.replace(message2.chars().next().unwrap(), vowel_alphabet.chars().next().unwrap());\n\
    \        }\n    }\n    let mut message3 = message;\n    for i in 0..message3.len()\
    \ {\n        if message3.chars().next().unwrap() == mut_ascii_alphabet.chars().next().unwrap()\
    \ {\n            message3 = message3.replace(message3.chars().next().unwrap(),\
    \ mut_ascii_alphabet.chars().next().unwrap());\n        }\n        if message3.chars().next().unwrap()\
    \ == mut_vowel_alphabet.chars().next().unwrap() {\n            message3 = message3.replace(message3.chars().next().unwrap(),\
    \ mut_vowel_alphabet.chars().next().unwrap());\n        }\n    }\n    message3\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpatmg0q_1.rs:12:16\n   |\n12 |     if message.length()\
    \ == 0 {\n   |                ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpatmg0q_1.rs:13:16\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \          ------ expected `String` because of return type\n12 |     if message.length()\
    \ == 0 {\n13 |         return \"\"\n   |                ^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpatmg0q_1.rs:23:95\n   |\n23 |             mut_ascii_alphabet =\
    \ mut_ascii_alphabet.replace(message1.chars().next().unwrap(), ascii_alphabet.chars().next().unwrap());\n\
    \   |                                                                        \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpatmg0q_1.rs:23:34\n\
    \   |\n19 |     let mut mut_ascii_alphabet = ascii_alphabet.clone();\n   |   \
    \                               ---------------------- expected due to this value\n\
    ...\n23 |             mut_ascii_alphabet = mut_ascii_alphabet.replace(message1.chars().next().unwrap(),\
    \ ascii_alphabet.chars().next().unwrap());\n   |                             \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                  |\n   |                               \
    \   expected `&str`, found struct `String`\n   |                             \
    \     help: consider borrowing here: `&mut_ascii_alphabet.replace(message1.chars().next().unwrap(),\
    \ ascii_alphabet.chars().next().unwrap())`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpatmg0q_1.rs:26:95\n   |\n26 |             mut_vowel_alphabet =\
    \ mut_vowel_alphabet.replace(message1.chars().next().unwrap(), vowel_alphabet.chars().next().unwrap());\n\
    \   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: String = String::with_capacity(message.len()\
    \ * 2);\n    let mut vowels = Vowels::new();\n    let mut has_vowel = false;\n\
    \n    for &letter in message {\n        has_vowel = has_vowel || vowels.contains(&letter);\n\
    \        if has_vowel {\n            encoded += &vowels[vowels.find(&letter)];\n\
    \        } else {\n            encoded += &letter;\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Vowels`\n  -->\
    \ /tmp/tmplx_4z1du.rs:13:22\n   |\n13 |     let mut vowels = Vowels::new();\n\
    \   |                      ^^^^^^ use of undeclared type `Vowels`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmplx_4z1du.rs:16:20\n   |\n16 |   \
    \  for &letter in message {\n   |                    ^^^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmplx_4z1du.rs:16:10\n\
    \   |\n16 |     for &letter in message {\n   |          ^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    let mut i = 0;\n  \
    \  let mut vowels = \"aeiouAEIOU\".to_string();\n    while i <= message.len()\
    \ {\n        let letter = message.chars().nth(i).unwrap();\n        i += 1;\n\
    \        if letter.is_ascii_uppercase() {\n            s.push_str(&letter);\n\
    \        } else {\n            s.push_str(&vowels[vowels.find(&letter).unwrap().iter().position(|c|\
    \ c.is_ascii_uppercase())]);\n        }\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphdc37031.rs:19:24\n   |\n\
    19 |             s.push_str(&letter);\n   |                        ^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmphdc37031.rs:21:44\n     |\n21   |            \
    \ s.push_str(&vowels[vowels.find(&letter).unwrap().iter().position(|c| c.is_ascii_uppercase())]);\n\
    \     |                                       ---- ^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                       |\n    \
    \ |                                       required by a bound introduced by this\
    \ call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::find`\n\
    help: consider dereferencing here\n     |\n21   |             s.push_str(&vowels[vowels.find(*&letter).unwrap().iter().position(|c|\
    \ c.is_ascii_uppercase())]);\n     |                                         \
    \   +\n\nerror[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmphdc37031.rs:21:62\n   |\n21 |             s.push_str(&vowels[vowels.find(&letter).unwrap().iter().position(|c|\
    \ c.is_ascii_uppercase())]);\n   |                                           \
    \                   ^^^^ method not found in `usize`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for char in message.chars().skip_while(|&c|\
    \ !Char::is_alpha(c)) {\n        let mut replacement = String::new();\n      \
    \  let mut index = char.as_bytes().count(|&b| b == 'a');\n        if index ==\
    \ 0 {\n            result.push(b'a');\n        } else {\n            for _ in\
    \ 0..index {\n                replacement.push(b'a');\n            }\n       \
    \ }\n        for _ in 0..index {\n            let mut index = char.as_bytes().index(|&b|\
    \ b == 'a');\n            if index != 0 {\n                replacement.push(b'a');\n\
    \            }\n        }\n        result.push(&replacement);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmp3r6xmnse.rs:13:50\n\
    \   |\n13 |     for char in message.chars().skip_while(|&c| !Char::is_alpha(c))\
    \ {\n   |                                                  ^^^^ use of undeclared\
    \ type `Char`\n\nerror[E0599]: no method named `as_bytes` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp3r6xmnse.rs:15:30\n   |\n15 |         let\
    \ mut index = char.as_bytes().count(|&b| b == 'a');\n   |                    \
    \          ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3r6xmnse.rs:17:25\n   |\n17 |             result.push(b'a');\n\
    \   |                         ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3r6xmnse.rs:20:34\n   |\n20 |              \
    \   replacement.push(b'a');\n   |                                  ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0599]: no method named `as_bytes` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp3r6xmnse.rs:24:34\n   |\n24 |   \
    \          let mut index = char.as_bytes().index(|&b| b == 'a');\n   |       \
    \                           ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3r6xmnse.rs:26:34\n   |\n26 |              \
    \   replacement.push(b'a');\n   |                                  ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r6xmnse.rs:29:21\n\
    \   |\n29 |         result.push(&replacement);\n   |                     ^^^^^^^^^^^^\
    \ expected `char`, found `&String`\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.chars().count() > 26 {\n        panic!(\"\
    Too many letters!\");\n    }\n    let mut encoder = String::new();\n    for letter\
    \ in message.chars() {\n        let vowel_position = vowels[letter];\n       \
    \ if vowel_position == 0 {\n            encoder += letter;\n        } else {\n\
    \            encoder += vowels[vowel_position].to_string();\n            encoder\
    \ += letter;\n        }\n    }\n    encoder\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpf9t4a4dt.rs:17:30\n\
    \   |\n17 |         let vowel_position = vowels[letter];\n   |               \
    \               ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `vowels` in this scope\n  --> /tmp/tmpf9t4a4dt.rs:21:24\n   |\n21 |        \
    \     encoder += vowels[vowel_position].to_string();\n   |                   \
    \     ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpf9t4a4dt.rs:19:24\n   |\n19 |             encoder += letter;\n   | \
    \                       ^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf9t4a4dt.rs:22:24\n   |\n22 |             encoder\
    \ += letter;\n   |                        ^^^^^^ expected `&str`, found `char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded: Vec<String> = Vec::new();\n    \n\
    \    // Encode each letter\n    for ch in message.chars() {\n        let mut ch\
    \ = ch;\n        // Swap the case of all letters\n        if ch >= 'a' && ch <=\
    \ 'z' {\n            let mut index = ch as u32 - ('a' as u32);\n            ch\
    \ = &'a' + index + 'A' as char;\n        }\n        encoded.push(ch);\n    }\n\
    \    // Replace vowels with their 2 letters\n    for (i, ch) in encoded.iter().enumerate()\
    \ {\n        if ch >= 'a' && ch <= 'z' {\n            let mut index = ch as u32\
    \ - ('a' as u32);\n            for j in 2..3 {\n                if index + j <\
    \ 'z' {\n                    index = index + j;\n                    break;\n\
    \                }\n            }\n            encoded[i] = 'a' + index + 'A'\
    \ as char;\n        }\n    }\n    // Convert back to string\n    String::from_utf8(encoded)\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `u32` to `&char`\n  --> /tmp/tmphx7p8vy_.rs:20:23\n\
    \   |\n20 |             ch = &'a' + index + 'A' as char;\n   |               \
    \   ---- ^ ----- u32\n   |                  |\n   |                  &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphx7p8vy_.rs:22:22\n   |\n22 |  \
    \       encoded.push(ch);\n   |                      ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                      |\n   |                  \
    \    expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphx7p8vy_.rs:26:18\n   |\n26 |         if ch >= 'a' && ch <= 'z'\
    \ {\n   |                  ^^^ expected `&String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphx7p8vy_.rs:26:31\n   |\n26 |         if ch\
    \ >= 'a' && ch <= 'z' {\n   |                               ^^^ expected `&String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphx7p8vy_.rs:29:32\n\
    \   |\n29 |                 if index + j < 'z' {\n   |                       \
    \         ^^^ expected `u32`, found `char`\n   |\nhelp: you can cast a `char`\
    \ to a `u32`, since a `char` always occupies 4 bytes\n   |\n29 |             \
    \    if index + j < 'z' as u32 {\n   |                                    ++++++\n\
    \nerror[E0369]: cannot add `u32` to `char`\n  --> /tmp/tmphx7p8vy_.rs:34:30\n\
    \   |\n34 |             encoded[i] = 'a' + index + 'A' as char;\n   |        \
    \                  --- ^ ----- u32\n   |                          |\n   |    \
    \                      char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphx7p8vy_.rs:38:23\n\
    \   |\n38 |     String::from_utf8(encoded)\n   |                       ^^^^^^^\
    \ expected `u8`, found struct `String`\n   |\n   = note: expected struct `Vec<u8>`\n\
    \              found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphx7p8vy_.rs:38:5\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |                               ------ expected `String` because of return\
    \ type\n...\n38 |     String::from_utf8(encoded)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Result`\n   |\n   = n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encodedMessage = String::new();\n    for letter\
    \ in message.chars().cloned().collect::<String>() {\n        encodedMessage.push((&letter)[1..].to_lowercase());\n\
    \        encodedMessage.push((&letter)[1..].to_lowercase());\n    }\n    encodedMessage\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp6yhrzo5e.rs:13:35\n     |\n13   |     for letter in message.chars().cloned().collect::<String>()\
    \ {\n     |                                   ^^^^^^ expected reference, found\
    \ `char`\n     |\n     = note: expected reference `&_`\n                     found\
    \ type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp6yhrzo5e.rs:13:44\n   |\n13 |       for letter in message.chars().cloned().collect::<String>()\
    \ {\n   |                                              ^^^^^^^ method cannot be\
    \ called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().flat_map(|c| {\n        // Map all\
    \ letters to their upper case.\n        let mut s = String::new();\n        for\
    \ ch in c.to_string().chars() {\n            if !ch.is_upper() {\n           \
    \     s = format!(\"{}{}\", ch, s);\n            } else {\n                s =\
    \ format!(\"{}{}\", ch.to_ascii_uppercase(), s);\n            }\n        }\n \
    \       // Replace all vowels with their 2 places ahead vowel in the english alphabet.\n\
    \        s.replace(\"a\", \"A\").replace(\"e\", \"E\").replace(\"i\", \"I\").replace(\"\
    o\", \"O\").replace(\"u\", \"U\")\n            .replace(\"A\", \"a\").replace(\"\
    E\", \"e\").replace(\"I\", \"i\").replace(\"O\", \"o\").replace(\"U\", \"u\");\n\
    \        s\n    })\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_xufg207.rs:16:20\n   |\n16 |             if !ch.is_upper()\
    \ {\n   |                    ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_uppercase`\n\nerror[E0277]: `String` is not an iterator\n\
    \    --> /tmp/tmp_xufg207.rs:12:30\n     |\n12   |       message.chars().flat_map(|c|\
    \ {\n     |  _____________________--------_^\n     | |                     |\n\
    \     | |                     required by a bound introduced by this call\n13\
    \   | |         // Map all letters to their upper case.\n14   | |         let\
    \ mut s = String::new();\n15   | |         for ch in c.to_string().chars() {\n\
    ...    |\n25   | |         s\n26   | |     })\n     | |_____^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n     |\n     = help: the\
    \ trait `Iterator` is not implemented for `String`\n     = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by a bound in `flat_map`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_xufg207.rs:12:5\n\
    \   |\n11 |   fn encode(message: String) -> String {\n   |                   \
    \              ------ expected `String` because of return type\n12 | /     message.chars().flat_map(|c|\
    \ {\n13 | |         // Map all letters to their upper case.\n14 | |         let\
    \ mut s = String::new();\n15 | |         for ch in c.to_string().chars() {\n...\
    \  |\n25 | |         s\n26 | |     })\n   | |______^ expected struct `String`,\
    \ found struct `FlatMap`\n   |\n   = note: expected struct `String`\n        \
    \      found struct `FlatMap<Chars<'_>, String, [closure@/tmp/tmp_xufg207.rs:12:30:\
    \ 26:6]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut swap = false;\n    let mut index = 0;\n   \
    \ let mut result = String::new();\n    for char in message.chars().flat_map(|c|{\n\
    \        if c.is_uppercase() {\n            if swap {\n                result.push('a');\n\
    \            } else {\n                result.push('A');\n            }\n    \
    \        swap = !swap;\n            index ++;\n            return Ok(c);\n   \
    \     }\n        Ok(c)\n    }) {\n        if swap {\n            result.push(char);\n\
    \        } else {\n            result.push(char.upcase());\n        }\n      \
    \  index ++;\n        swap = !swap;\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpro0uovz5.rs:23:19\n\
    \   |\n23 |             index ++;\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n23 |             { let tmp =\
    \ index ; index += 1; tmp };\n   |             +++++++++++       ~~~~~~~~~~~~~~~~~~~\n\
    23 -             index ++;\n23 +             index  += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpro0uovz5.rs:33:15\n   |\n33\
    \ |         index ++;\n   |               ^^ not a valid postfix operator\n  \
    \ |\nhelp: use `+= 1` instead\n   |\n33 |         { let tmp = index ; index +=\
    \ 1; tmp };\n   |         +++++++++++       ~~~~~~~~~~~~~~~~~~~\n33 -        \
    \ index ++;\n33 +         index  += 1;\n   | \n\nerror[E0599]: no method named\
    \ `upcase` found for type `char` in the current scope\n  --> /tmp/tmpro0uovz5.rs:31:30\n\
    \   |\n31 |             result.push(char.upcase());\n   |                    \
    \          ^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut vowels = \"aeiou\".to_string();\n    let mut\
    \ letter_map = {\n        'a' => 0,\n        'b' => 1,\n        'c' => 2,\n  \
    \      'd' => 3,\n        'e' => 4,\n        'f' => 5,\n        'g' => 6,\n  \
    \      'h' => 7,\n        'i' => 8,\n        'j' => 9,\n        'k' => 10,\n \
    \       'l' => 11,\n        'm' => 12,\n        'n' => 13,\n        'o' => 14,\n\
    \        'p' => 15,\n        'q' => 16,\n        'r' => 17,\n        's' => 18,\n\
    \        't' => 19,\n        'u' => 20,\n        'v' => 21,\n        'w' => 22,\n\
    \        'x' => 23,\n        'y' => 24,\n        'z' => 25\n    };\n\n    let\
    \ mut new_message = \"\";\n    for char in message {\n        if let Some(i) =\
    \ vowels.find(char.chars().nth(0)) {\n            new_message += &vowels[i as\
    \ usize];\n        } else {\n            new_message += &letter_map[char.chars().nth(0)];\n\
    \        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmp477gpd7v.rs:14:13\n   |\n14 |         'a' => 0,\n   |         \
    \    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmp477gpd7v.rs:43:17\n   |\n43 |     for char\
    \ in message {\n   |                 ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp477gpd7v.rs:45:29\n   |\n45 |         \
    \    new_message += &vowels[i as usize];\n   |                             ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp477gpd7v.rs:45:13\n   |\n45 |             new_message\
    \ += &vowels[i as usize];\n   |             -----------^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp477gpd7v.rs:50:5\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                               ------ expected `String`\
    \ because of return type\n...\n50 |     new_message\n   |     ^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0368.\nFor more informati"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut message = message;\n    let vowels = \"aeiouy\"\
    ;\n    for (i, v) in message.chars().enumerate() {\n        if let Some(next)\
    \ = message.chars().skip(i+1).find(|c| vowels.contains(&c)) {\n            message\
    \ = message.chars().rev().skip(i+1).collect::<String>().reverse().collect();\n\
    \            message = v + &message[next.index()..];\n        }\n    }\n    message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpj0bz4ble.rs:15:80\n\
    \     |\n15   |         if let Some(next) = message.chars().skip(i+1).find(|c|\
    \ vowels.contains(&c)) {\n     |                                             \
    \                          -------- ^^ expected an `Fn<(char,)>` closure, found\
    \ `char`\n     |                                                             \
    \          |\n     |                                                         \
    \              required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n     = help: the trait\
    \ `Pattern<'a>` is implemented for `char`\n     = note: required because of the\
    \ requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&&char`\nnote:\
    \ required by a bound in `core::str::<impl str>::contains`\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpj0bz4ble.rs:16:75\n   |\n16 |             message = message.chars().rev().skip(i+1).collect::<String>().reverse().collect();\n\
    \   |                                                                        \
    \   ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0599]: no method named `index` found for type `char` in the current scope\n\
    \  --> /tmp/tmpj0bz4ble.rs:17:41\n   |\n17 |             message = v + &message[next.index()..];\n\
    \   |                                         ^^^^^ method not found in `char`\n\
    \nerror[E0369]: cannot add `&str` to `char`\n  --> /tmp/tmpj0bz4ble.rs:17:25\n\
    \   |\n17 |             message = v + &message[next.index()..];\n   |        \
    \               - ^ ------------------------ &str\n   |                      \
    \ |\n   |                       char\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.len() != 26 {\n        panic!(\"encode requires\
    \ 26 characters\");\n    }\n    let mut swap = HashMap::new();\n    let mut vowels\
    \ = HashMap::new();\n    let mut last = 0;\n    for x in 0..26 {\n        if let\
    \ Some(next) = message[last..x].chars().filter(|c| c.is_ascii_lowercase()).next()\
    \ {\n            swap.insert(next, x);\n        }\n        last = x+1;\n    }\n\
    \    let mut lastlast = 0;\n    for x in 0..message.len() {\n        if let Some(next)\
    \ = message[last..x].chars().filter(|c| c.is_ascii_lowercase()).next() {\n   \
    \         let y = swap.get_mut(next).unwrap();\n            vowels.insert(next,\
    \ y as usize);\n        }\n        lastlast = x+1;\n    }\n    String::from_utf8_lossy(&message[lastlast..])\n\
    \        .chars()\n        .filter(|c| vowels.contains_key(c as usize))\n    \
    \    .map(move |c| {\n            let a = vowels.remove(&c as usize) + 1;\n  \
    \          swap.insert(c, a);\n            c\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp69k97se0.rs:15:20\n   |\n15 |     let mut swap = HashMap::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp69k97se0.rs:16:22\n\
    \   |\n16 |     let mut vowels = HashMap::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp69k97se0.rs:32:29\n   |\n32 |     String::from_utf8_lossy(&message[lastlast..])\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^ expected slice `[u8]`,\
    \ found `str`\n   |\n   = note: expected reference `&[u8]`\n              found\
    \ reference `&str`\n\nerror[E0606]: casting `&char` as `usize` is invalid\n  -->\
    \ /tmp/tmp69k97se0.rs:34:41\n   |\n34 |         .filter(|c| vowels.contains_key(c\
    \ as usize))\n   |                                         ^^^^^^^^^^\n   |\n\
    \   = help: cast through a raw pointer first\n\nerror[E0606]: casting `&char`\
    \ as `usize` is invalid\n  --> /tmp/tmp69k97se0.rs:36:35\n   |\n36 |         \
    \    let a = vowels.remove(&c as usize) + 1;\n   |                           \
    \        ^^^^^^^^^^^\n   |\n   = help: cast through a raw pointer first\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut char_map = HashMap::new();\n\n    for chr in\
    \ message.chars() {\n        let chr = chr.to_lowercase();\n        char_map.entry(chr).or_insert(0);\n\
    \        char_map.entry(chr + chr).or_insert(0);\n    }\n\n    let mut result:\
    \ Vec<char> = vec![];\n    let mut i = 0;\n    char_map.iter().for_each(|&(k,v)|\
    \ *i += v.0);\n    while i < message.len() {\n        let mut j = 0;\n       \
    \ char_map.iter().for_each(|&(k,v)| *j += v.0);\n        if j != i {\n       \
    \     result.push(&message[i]);\n            result.push((*i + j).to_string());\n\
    \            i += 1;\n        }\n    }\n    String::from(result).unwrap()\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpzq6b7ozk.rs:12:24\n   |\n12 |     let mut char_map = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0369]:\
    \ cannot add `ToLowercase` to `ToLowercase`\n  --> /tmp/tmpzq6b7ozk.rs:17:28\n\
    \   |\n17 |         char_map.entry(chr + chr).or_insert(0);\n   |            \
    \            --- ^ --- ToLowercase\n   |                        |\n   |      \
    \                  ToLowercase\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpzq6b7ozk.rs:22:39\n   |\n22 |     char_map.iter().for_each(|&(k,v)|\
    \ *i += v.0);\n   |                                       ^^\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpzq6b7ozk.rs:25:43\n \
    \  |\n25 |         char_map.iter().for_each(|&(k,v)| *j += v.0);\n   |       \
    \                                    ^^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpzq6b7ozk.rs:27:26\n   |\n27 |         \
    \    result.push(&message[i]);\n   |                          ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzq6b7ozk.rs:27:25\n\
    \   |\n27 |             result.push(&message[i]);\n   |                      \
    \   ^^^^^^^^^^^ expected `char`, found reference\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\nhelp: consider removing the borrow\n\
    \   |\n27 -             result.push(&message[i]);\n27 +             result.push(message[i]);\n\
    \   | \n\nerror[E0"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut swapper = String::new();\n    let mut vowels\
    \ = String::new();\n    let mut alphabet = String::new();\n    let mut length\
    \ = 0;\n\n    message.chars().for_each(|c| {\n        if let Some(index) = alphabet.chars().position(|c|\
    \ *c == c) {\n            swapper[length] = swapper[length].to_uppercase();\n\
    \            swapper[length + 1] = swapper[length + 1].to_lowercase();\n     \
    \       vowels += swapper[length];\n            alphabet.insert(index + 1, c.to_lowercase());\n\
    \        }\n        else {\n            alphabet += c.to_string();\n         \
    \   swapper.push(c.to_uppercase());\n        }\n        length +=1;\n    });\n\
    \n    alphabet += vowels;\n    let mut index = alphabet.chars().position(|c| {\n\
    \        let mut pos = 0;\n        c.chars().for_each(|c| {\n            if *c\
    \ != c.to_lowercase() && pos != 0 {\n                pos += 1;\n            }\n\
    \        });\n        pos == 0\n    });\n    alphabet.insert(index + 1, vowels.to_lowercase());\n\
    \    alphabet\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmppy5y1h7a.rs:18:60\n\
    \   |\n18 |         if let Some(index) = alphabet.chars().position(|c| *c == c)\
    \ {\n   |                                                            ^^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmppy5y1h7a.rs:19:13\n\
    \   |\n19 |             swapper[length] = swapper[length].to_uppercase();\n  \
    \ |             ^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n  \
    \ |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmppy5y1h7a.rs:19:31\n   |\n19 |             swapper[length] = swapper[length].to_uppercase();\n\
    \   |                               ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmppy5y1h7a.rs:20:13\n   |\n20 |             swapper[length + 1] =\
    \ swapper[length + 1].to_lowercase();\n   |             ^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the followi"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    let mut\
    \ vowels = vec!['o', 'a', 'u'];\n    let mut lowercase = vec!['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];\n\
    \n    for c in message.chars() {\n        if c.to_lowercase() == c {\n       \
    \     let c = c.to_lowercase().chars().next().unwrap().to_string();\n        \
    \    encoded_message.push(c);\n        }\n        else if vowels.contains(c) {\n\
    \            let replacement = lowercase[vowels.iter().position(|x| x.to_string()\
    \ == c).unwrap() as usize];\n            encoded_message.push((replacement + c)\
    \ as char);\n        }\n        else {\n            encoded_message.push(c);\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpv7f15zxh.rs:17:29\n   |\n17 |         if c.to_lowercase() == c\
    \ {\n   |            ---------------- ^^ - char\n   |            |\n   |     \
    \       ToLowercase\n\nerror[E0599]: no method named `chars` found for struct\
    \ `ToLowercase` in the current scope\n  --> /tmp/tmpv7f15zxh.rs:18:38\n   |\n\
    18 |             let c = c.to_lowercase().chars().next().unwrap().to_string();\n\
    \   |                                      ^^^^^ method not found in `ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv7f15zxh.rs:21:33\n   |\n21 |\
    \         else if vowels.contains(c) {\n   |                                 ^\n\
    \   |                                 |\n   |                                \
    \ expected `&char`, found `char`\n   |                                 help: consider\
    \ borrowing here: `&c`\n\nerror[E0277]: can't compare `String` with `char`\n \
    \ --> /tmp/tmpv7f15zxh.rs:22:82\n   |\n22 |             let replacement = lowercase[vowels.iter().position(|x|\
    \ x.to_string() == c).unwrap() as usize];\n   |                              \
    \                                                    ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0369]: cannot add\
    \ `char` to `char`\n  --> /tmp/tmpv7f15zxh.rs:23:47\n   |\n23 |             encoded_message.push((replacement\
    \ + c) as char);\n   |                                   ----------- ^ - char\n\
    \   |                                   |\n   |                              \
    \     char\n\nerror: aborting due to 5 previous errors\n\nS"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::with_capacity(message.len());\n\
    \    for ch in &message {\n        match ch {\n            'A' .. 'Z' => output\
    \ += &'a'[ch as usize - 'A' as usize],\n            'a' .. 'z' => output += &'a'[ch\
    \ as usize - 'a' as usize],\n            '0' .. '9' => output += &'0'[ch as usize\
    \ - '0' as usize],\n            _ => output.push(*ch),\n        }\n    }\n   \
    \ output\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp3664x0t7.rs:15:13\n\
    \   |\n15 |             'A' .. 'Z' => output += &'a'[ch as usize - 'A' as usize],\n\
    \   |             ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp3664x0t7.rs:16:13\n   |\n16 |             'a' .. 'z' => output\
    \ += &'a'[ch as usize - 'a' as usize],\n   |             ^^^^^^^^^^\n   |\n  \
    \ = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for\
    \ more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp3664x0t7.rs:17:13\n   |\n17 |             '0' .. '9' => output\
    \ += &'0'[ch as usize - '0' as usize],\n   |             ^^^^^^^^^^\n   |\n  \
    \ = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for\
    \ more information\n\nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmp3664x0t7.rs:13:15\n\
    \   |\n13 |     for ch in &message {\n   |               ^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0608]: cannot index into a value of type `char`\n  -->\
    \ /tmp/tmp3664x0t7.rs:15:38\n   |\n15 |             'A' .. 'Z' => output += &'a'[ch\
    \ as usize - 'A' as usize],\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmp3664x0t7.rs:16:38\n\
    \   |\n16 |             'a' .. 'z' => output += &'a'[ch as usize - 'a' as usize],\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmp3664x0t7.rs:17:38\n\
    \   |\n17 |             '0' .. '9' => output += &'0'[ch as usize - '0' as usize],\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp3664x0t7.rs:18"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for (i, c) in\
    \ message.chars().enumerate() {\n        // Swap case of 'c' with 'a' if 'c' is\
    \ not the 1st character in the message\n        // and if the character is not\
    \ 'a'\n        // and if the character is not 'e'\n        if i > 0 && c != 'a'\
    \ && c != 'e' {\n            result += \"a\".to_string();\n        }\n       \
    \ // Replace all vowels in 'c' with 'a' if 'c' is not the first character \n \
    \       // and if the character is not 'a'\n        // and if the character is\
    \ not 'e'\n        else if c != 'a' && c != 'e' {\n            result += c.to_string();\n\
    \        }\n        // Replace all vowels in 'c' with 'b' if 'c' is not the first\
    \ character \n        // and if the character is not 'a'\n        // and if the\
    \ character is not 'e'\n        else if c != 'a' && c != 'e' {\n            result\
    \ += c.to_string();\n        }\n        // Replace all vowels in 'c' with 'c'\
    \ if 'c' is not the first character \n        // and if the character is not 'a'\n\
    \        // and if the character is not 'e'\n        else if c != 'a' && c !=\
    \ 'e' {\n            result += c.to_string();\n        }\n        // Replace all\
    \ vowels in 'c' with 'd' if 'c' is not the first character \n        // and if\
    \ the character is not 'a'\n        // and if the character is not 'e'\n     \
    \   else if c != 'a' && c != 'e' {\n            result += c.to_string();\n   \
    \     }\n        // Replace all vowels in 'c' with 'e' if 'c' is not the first\
    \ character \n        // and if the character is not 'a'\n        // and if the\
    \ character is not 'e'\n        else if c != 'a' && c != 'e' {\n            result\
    \ += c.to_string();\n        }\n        // Replace all vowels in 'c' with 'f'\
    \ if 'c' is not the first character \n        // and if the character is not 'a'\n\
    \        // and if the character is not 'e'\n        else if c != 'a' && c !=\
    \ 'e' {\n            result += c.to_string();\n        }\n        // Replace all\
    \ vowels in 'c' with 'g' if 'c' is not the first character \n        // and if\
    \ the character is not 'a'\n        // and if the character is not 'e'\n     \
    \   else if c != 'a' && c != 'e' {\n            result += c.to_string();\n   \
    \     }\n        // Replace all vowels in 'c' with 'h' if 'c' is not the first\
    \ character \n        // and if the character is not 'a'\n        // and if the\
    \ character is not 'e'\n        else if c != '\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp1_trpyva.rs:65:22\n\
    \   |\n65 |         else if c != '\n   |                      ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in message.chars()\
    \ {\n        res.push_str(&encode(c.to_string()));\n    }\n    res.push_str(\"\
    K\");\n    return res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Create a list of all of the characters in the message,\
    \ including spaces\n    let mut chars = message.chars();\n    chars = chars.into_iter().filter(|c|\
    \ !c.is_whitespace());\n    chars = chars.map(|c| c.to_lowercase());\n    \n \
    \   // Create a list of all the characters in the english alphabet\n    let mut\
    \ english = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
    \ 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    //\
    \ Create a list of all permutations of the english alphabet\n    let mut perms\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut permutation\
    \ = vec![];\n\n    while !perms.is_empty() {\n        // Take the first element\
    \ from the permutation list\n        let first_char = perms.remove(0);\n\n   \
    \     // Add all elements after the first_char position in 'chars' to the \n \
    \       // permutation list\n        for c in chars.iter().skip(first_char + 1)\
    \ {\n            let next_char = c.to_lowercase().next().unwrap();\n         \
    \   perms.push(next_char);\n        }\n\n        // Add the first_char element\
    \ to the permutation list\n        permutation.push(first_char);\n    }\n\n  \
    \  // Convert the list of permutations back into a string\n    let mut result\
    \ = vec![];\n    for i in permutation.iter() {\n        result.push(english[i]);\n\
    \    }\n\n    // Concatenate the result with the message\n    result.iter_mut().chain(chars).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5k33uqd6.rs:14:13\n   |\n\
    13 |     let mut chars = message.chars();\n   |                     ---------------\
    \ expected due to this value\n14 |     chars = chars.into_iter().filter(|c| !c.is_whitespace());\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Chars`, found struct `Filter`\n   |\n   = note: expected struct `Chars<'_>`\n\
    \              found struct `Filter<Chars<'_>, [closure@/tmp/tmp5k33uqd6.rs:14:38:\
    \ 14:60]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5k33uqd6.rs:15:13\n\
    \   |\n13 |     let mut chars = message.chars();\n   |                     ---------------\
    \ expected due to this value\n14 |     chars = chars.into_iter().filter(|c| !c.is_whitespace());\n\
    15 |     chars = chars.map(|c| c.to_lowercase());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Chars`, found struct `Map`\n   |\n   = note: expected struct\
    \ `Chars<'_>`\n              found struct `Map<Chars<'_>, [closure@/tmp/tmp5k33uqd6.rs:15:23:\
    \ 15:43]>`\n\nerror[E0599]: no method named `iter` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmp5k33uqd6.rs:30:24\n   |\n30 |         for c\
    \ in chars.iter().skip(first_char + 1) {\n   |                        ^^^^ private\
    \ field, not a method\n\nerror[E0369]: cannot add `{integer}` to `char`\n  -->\
    \ /tmp/tmp5k33uqd6.rs:30:47\n   |\n30 |         for c in chars.iter().skip(first_char\
    \ + 1) {\n   |                                    ---------- ^ - {integer}\n \
    \  |                                    |\n   |                              \
    \      char\n\nerror[E0277]: the type `[char]` cannot be indexed by `&char`\n\
    \  --> /tmp/tmp5k33uqd6.rs:42:21\n   |\n42 |         result.push(english[i]);\n\
    \   |                     ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>` is not implemented\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Index<&char>` for `Vec<char>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as IntoIterator>::Item == &mut _`\n   --> /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut swap = String::new();\n    let mut alphabet:\
    \ HashMap<&'static str, u32> = HashMap::new();\n    for ch in message.chars()\
    \ {\n        if !alphabet.contains_key(ch.to_string()) {\n            alphabet.insert(ch.to_string(),\
    \ 1);\n        } else {\n            let mut a = alphabet.entry(ch.to_string()).or_insert(0);\n\
    \            a += 1;\n            alphabet.entry(ch.to_string()).or_insert(a);\n\
    \        }\n    }\n    alphabet.insert(\" \", 2);\n    let mut result = String::new();\n\
    \    for ch in message.chars() {\n        let mut a = alphabet.entry(ch.to_string()).or_insert(0);\n\
    \        let mut b = alphabet.entry(ch.to_string()).or_insert(0);\n        let\
    \ a = a / 2;\n        let b = b / 2;\n        swap += String::from_str(&format!(\"\
    {}{}\", ch.to_string(), a % 2)); \n        swap += String::from_str(&format!(\"\
    {}{}\", ch.to_string(), b % 2)); \n    }\n    result += swap;\n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp5ngr_pkb.rs:13:23\n\
    \   |\n13 |     let mut alphabet: HashMap<&'static str, u32> = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp5ngr_pkb.rs:13:52\n\
    \   |\n13 |     let mut alphabet: HashMap<&'static str, u32> = HashMap::new();\n\
    \   |                                                    ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp5ngr_pkb.rs:30:25\n   |\n\
    30 |         swap += String::from_str(&format!(\"{}{}\", ch.to_string(), a % 2));\
    \ \n   |                         ^^^^^^^^ function or associated item not found\
    \ in `String`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]:\
    \ no function or associated item named `from_str` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp5ngr_pkb.rs:31:25\n   |\n31 |         swap\
    \ += String::from_str(&format!(\"{}{}\", ch.to_string(), b % 2)); \n   |     \
    \                    ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5ngr_pkb.rs:33:15\n   |\n33 |     result += swap;\n   |\
    \               ^^^^\n   |               |\n   |               expected `&str`,\
    \ found struct `String`\n   |               help: consider borrowing here: `&swap`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0412,"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut alphabet: Vec<String> = vec!['Z', 'a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels: Vec<String> =\
    \ vec!['AEIOUaeiou'];\n    for letter in alphabet {\n        for vowel in vowels\
    \ {\n            let position = alphabet.index(&letter);\n            if position\
    \ < alphabet.len() - 2 {\n                let vowel_position = alphabet.index(&vowel);\n\
    \                if position < vowel_position {\n                    let next_letter\
    \ = alphabet[position + 2];\n                    alphabet[position] = vowel;\n\
    \                    alphabet[position + 1] = next_letter;\n                 \
    \   break;\n                }\n            }\n        }\n    }\n\n    let mut\
    \ result = Vec::new();\n    for letter in message {\n        result.push(alphabet[alphabet.index(&letter)].clone());\n\
    \    }\n\n    if result.len() == message.len() {\n        result\n    } else {\n\
    \        format!(\"{}\", message.chars().map(|c| {\n            match c {\n  \
    \              'a' => \"AEIOUaeiou\".chars().nth(0),\n                'e' => \"\
    AEIOUaeiou\".chars().nth(1),\n                'i' => \"AEIOUaeiou\".chars().nth(2),\n\
    \                'o' => \"AEIOUaeiou\".chars().nth(3),\n                'u' =>\
    \ \"AEIOUaeiou\".chars().nth(4),\n                'A' => \"AEIOUaeiou\".chars().nth(0),\n\
    \                'E' => \"AEIOUaeiou\".chars().nth(1),\n                'I' =>\
    \ \"AEIOUaeiou\".chars().nth(2),\n                'O' => \"AEIOUaeiou\".chars().nth(3),\n\
    \                'U' => \"AEIOUaeiou\".chars().nth(4),\n                '0' =>\
    \ \"ABCDEFG\".chars().nth(0),\n                '1' => \"ABCDEFG\".chars().nth(1),\n\
    \                '2' => \"ABCDEFG\".chars().nth(2),\n                '3' => \"\
    ABCDEFG\".chars().nth(3),\n                '4' => \"ABCDEFG\".chars().nth(4),\n\
    \                '5' => \"ABCDEFG\".chars().nth(5),\n                '6' => \"\
    ABCDEFG\".chars().nth(6),\n                '7' => \"ABCDEFG\".chars().nth(7),\n\
    \                '8' => \"ABCDEFG\".chars().nth(8),\n                '9' => \"\
    ABC\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp9ml5luq0.rs:13:40\n\
    \   |\n13 |     let mut vowels: Vec<String> = vec!['AEIOUaeiou'];\n   |      \
    \                                  ^^^^^^^^^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n13 |     let mut vowels: Vec<String>\
    \ = vec![\"AEIOUaeiou\"];\n   |                                        ~~~~~~~~~~~~\n\
    \nerror[E0765]: unterminated double quote string\n  --> /tmp/tmp9ml5luq0.rs:67:109\n\
    \   |\n67 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    68 | | }\n   | |__^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    match message.chars() {\n        &'a' | &'A' => message.chars().map(|c|\
    \ match c {\n            'a' | &'A' => c == 'a' || c == 'A' ? 'K' : 'K',\n   \
    \         'b' | &'B' => c == 'b' || c == 'B' ? 'K' : 'K',\n            'c' | &'C'\
    \ => c == 'c' || c == 'C' ? 'K' : 'K',\n            'd' | &'D' => c == 'd' ||\
    \ c == 'D' ? 'K' : 'K',\n            'e' | &'E' => c == 'e' || c == 'E' ? 'K'\
    \ : 'K',\n            'f' | &'F' => c == 'f' || c == 'F' ? 'K' : 'K',\n      \
    \      'g' | &'G' => c == 'g' || c == 'G' ? 'K' : 'K',\n            'h' | &'H'\
    \ => c == 'h' || c == 'H' ? 'K' : 'K',\n            'i' | &'I' => c == 'i' ||\
    \ c == 'I' ? 'K' : 'K',\n            'j' | &'J' => c == 'j' || c == 'J' ? 'K'\
    \ : 'K',\n            'k' | &'K' => c == 'k' || c == 'K' ? 'K' : 'K',\n      \
    \      'l' | &'L' => c == 'l' || c == 'L' ? 'K' : 'K',\n            'm' | &'M'\
    \ => c == 'm' || c == 'M' ? 'K' : 'K',\n            'n' | &'N' => c == 'n' ||\
    \ c == 'N' ? 'K' : 'K',\n            'o' | &'O' => c == 'o' || c == 'O' ? 'K'\
    \ : 'K',\n            'p' | &'P' => c == 'p' || c == 'P' ? 'K' : 'K',\n      \
    \      'q' | &'Q' => c == 'q' || c == 'Q' ? 'K' : 'K',\n            'r' | &'R'\
    \ => c == 'r' || c == 'R' ? 'K' : 'K',\n            's' | &'S' => c == 's' ||\
    \ c == 'S' ? 'K' : 'K',\n            't' | &'T' => c == 't' || c == 'T' ? 'K'\
    \ : 'K',\n            'u' | &'U' => c == 'u' || c == 'U' ? 'K' : 'K',\n      \
    \      'v' | &'V' => c == 'v' || c == 'V' ? 'K' : 'K',\n            'w' | &'W'\
    \ => c == 'w' || c == 'W' ? 'K' : 'K',\n            'x' | \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoe6h0xbq.rs:47:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n12 |     match message.chars() {\n   |\
    \                           - unclosed delimiter\n13 |         &'a' | &'A' =>\
    \ message.chars().map(|c| match c {\n   |                                    \
    \       - unclosed delimiter\n...\n47 | }\n   |   ^\n\nerror: expected one of\
    \ `,`, `.`, `?`, `}`, or an operator, found `'K'`\n  --> /tmp/tmpoe6h0xbq.rs:11:38\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 ^ unclosed delimiter\n...\n14 |             'a' | &'A' => c\
    \ == 'a' || c == 'A' ? 'K' : 'K',\n   |                        --            \
    \           -^^^ expected one of `,`, `.`, `?`, `}`, or an operator\n   |    \
    \                    |                        |\n   |                        |\
    \                        help: `}` may belong here\n   |                     \
    \   while parsing the `match` arm starting here\n\nerror: expected one of `)`,\
    \ `,`, `.`, `?`, or an operator, found keyword `fn`\n  --> /tmp/tmpoe6h0xbq.rs:40:1\n\
    \   |\n38 | }\n   |  - expected one of `)`, `,`, `.`, `?`, or an operator\n39\
    \ | \n40 | fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels:\
    \ Vec<&'static str> = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut letters: Vec<&'static str> = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\
    \ 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    \n  \
    \  vowels.iter().for_each(|v| {\n        if let Some(vowel) = message.chars().position(|c|\
    \ c == v) {\n            encoded.push_str(&letters[vowel.succ_mut(1)]);\n    \
    \    } else {\n            encoded.push_str(&v);\n        }\n    });\n    \n \
    \   for (i, &a) in message.chars().enumerate() {\n        if let Some(vowel) =\
    \ message.chars().position(|c| c == a) {\n            encoded.push_str(&letters[vowel.succ_mut(1)\
    \ + i]);\n        } else {\n            encoded.push_str(&a);\n        }\n   \
    \ }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmvcnu48j.rs:13:46\n   |\n\
    13 |     let mut vowels: Vec<&'static str> = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S...\n   |    \
    \                                          ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    13 |     let mut vowels: Vec<&'static str> = vec![\"A\", 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n   |                                              ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmvcnu48j.rs:14:47\n   |\n14 |\
    \     let mut letters: Vec<&'static str> = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', '...\n   |     \
    \                                          ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    14 |     let mut letters: Vec<&'static str> = vec![\"A\", 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \   |                                               ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmvcnu48j.rs:17:64\n   |\n17 |         if let Some(vowel)\
    \ = message.chars().position(|c| c == v) {\n   |                             \
    \                                   ^ expected `char`, found `&&str`\n\nerror[E0599]:\
    \ no method named `succ_mut` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpmvcnu48j.rs:18:45\n   |\n18 |             encoded.push_str(&letters[vowel.succ_mut(1)]);\n\
    \   |                                             ^^^^^^^^ method not found in\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmvcnu48j.rs:24:13\n\
    \   |\n24 |     for (i, &a) in message.chars().enumerate() {\n   |           \
    \  ^^     --------------------------- this expres"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    \n  \
    \  for (i, letter) in message.chars().enumerate() {\n        let letter = String::from(letter);\n\
    \        // Swaps case for all letters\n        // For example 'a' becomes 'A'\n\
    \        let letter_within_alphabet = if letter.is_uppercase() {\n           \
    \ letter.to_uppercase()\n        } else {\n            letter.to_lowercase()\n\
    \        };\n        // For example 'e' becomes 'E'\n        let letter_within_alphabet\
    \ = if letter.is_uppercase() {\n            letter.to_lowercase()\n        } else\
    \ {\n            letter.to_uppercase()\n        };\n        let mut current_letter\
    \ = String::from(letter);\n        // Replace all vowels in message\n        for\
    \ vowel in &vowels {\n            let vowel_index = vowel.as_bytes();\n      \
    \      if letter.contains(vowel) {\n                let vowel_after_index = vowel_index.iter().position(|&b|b\
    \ == vowel).unwrap();\n                let vowel_before_vowel_index = vowel_index.iter().position(|&b|b\
    \ == letter).unwrap();\n                let vowel_letter = if vowel_after_index\
    \ != 0 {\n                    letter[vowel_after_index..vowel_before_vowel_index].to_lowercase()\n\
    \                } else {\n                    letter[vowel_before_vowel_index..vowel_index].to_uppercase()\n\
    \                };\n                current_letter += vowel_letter;\n       \
    \     }\n        }\n        // Add letter to encoded message\n        encoded_message\
    \ += current_letter;\n    }\n    return encoded_message;\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpmi33826c.rs:31:23\n\
    \   |\n31 |         for vowel in &vowels {\n   |                       ^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `is_uppercase` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpmi33826c.rs:18:48\n\
    \   |\n18 |         let letter_within_alphabet = if letter.is_uppercase() {\n\
    \   |                                                ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]:\
    \ no method named `is_uppercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpmi33826c.rs:24:48\n   |\n24 |         let letter_within_alphabet\
    \ = if letter.is_uppercase() {\n   |                                         \
    \       ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmi33826c.rs:45:28\n\
    \   |\n45 |         encoded_message += current_letter;\n   |                 \
    \           ^^^^^^^^^^^^^^\n   |                            |\n   |          \
    \                  expected `&str`, found struct `String`\n   |              \
    \              help: consider borrowing here: `&current_letter`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = message;\n    for (index, char) in\
    \ encoded.chars().enumerate() {\n        if char >= 'a' && char <= 'z' {\n   \
    \         let pos = char - 'a' as usize;\n            let previosChar = encoded.get(index\
    \ - 1);\n            if previosChar == 'a' || previosChar == 'e' ||\n        \
    \        previosChar == 'i' || previosChar == 'o' ||\n                previosChar\
    \ == 'u' {\n                continue;\n            }\n            let pos = pos\
    \ - 1;\n            if pos == 0 {\n                encoded += encoded.get(index\
    \ - 2);\n                encoded += char;\n            } else {\n            \
    \    encoded += encoded.get(index - 2);\n                encoded += char;\n  \
    \              encoded += encoded.get(index - 1);\n            }\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmpqlsj6f7u.rs:15:28\n\
    \   |\n15 |             let pos = char - 'a' as usize;\n   |                 \
    \      ---- ^ ------------ usize\n   |                       |\n   |         \
    \              char\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n\
    \   --> /tmp/tmpqlsj6f7u.rs:16:43\n    |\n16  |             let previosChar =\
    \ encoded.get(index - 1);\n    |                                       --- ^^^^^^^^^\
    \ string indices are ranges of `usize`\n    |                                \
    \       |\n    |                                       required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    note: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqlsj6f7u.rs:17:31\n   |\n17 |             if previosChar\
    \ == 'a' || previosChar == 'e' ||\n   |                               ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&_>`\n \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqlsj6f7u.rs:17:53\n\
    \   |\n17 |             if previosChar == 'a' || previosChar == 'e' ||\n   | \
    \                                                    ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<&_>`\n              found\
    \ type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqlsj6f7u.rs:18:32\n\
    \   |\n18 |                 previosChar == 'i' || previosChar == 'o' ||\n   |\
    \                                ^^^ expected enum `Option`, found `char`\n  \
    \ |\n   = note: expected enum `Option<&_>`\n              found type `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqlsj6f7u.rs:18:54\n   |\n18 |  \
    \               previosChar == 'i' || previosChar == 'o' ||\n   |            \
    \                                          ^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<&_>`\n              found type `char`\n\
    \nerror[E0308]: mismatched "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut index = 0;\n    let mut new_message = \"\"\
    ;\n    while index < message.len() {\n        let letter = message[index];\n \
    \       if let Some(index) = get_letter_position(letter) {\n            new_message\
    \ += swapcase(letter);\n            new_message += vowel_encode(index);\n    \
    \    } else {\n            new_message += letter;\n        }\n        index +=\
    \ 1; \n    }\n    return new_message;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_letter_position` in this scope\n\
    \  --> /tmp/tmp_ac_4es2.rs:16:30\n   |\n16 |         if let Some(index) = get_letter_position(letter)\
    \ {\n   |                              ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `swapcase` in this scope\n  --> /tmp/tmp_ac_4es2.rs:17:28\n\
    \   |\n17 |             new_message += swapcase(letter);\n   |               \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `vowel_encode` in this scope\n  --> /tmp/tmp_ac_4es2.rs:18:28\n   |\n18 |  \
    \           new_message += vowel_encode(index);\n   |                        \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp_ac_4es2.rs:15:22\n   |\n15 |         let\
    \ letter = message[index];\n   |                      ^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp_ac_4es2.rs:20:13\n   |\n20 |             new_message\
    \ += letter;\n   |             -----------^^^^^^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_ac_4es2.rs:24:12\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |                               ------ expected `String` because of return\
    \ type\n...\n24 |     return new_message;\n   |            ^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |            |\n   |     \
    \       expected struct `String`, found `&str`\n\nerror: aborting due"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = message;\n    new_message.chars().map(|c|{\n\
    \        let mut vowels = vec![];\n        let mut new_c = c;\n        match c\
    \ {\n            'a' ... 'z' => vowels.push('a'),\n            'A' ... 'Z' =>\
    \ vowels.push('A'),\n            '0' ... '9' => vowels.push('0'),\n          \
    \  _ => {}\n        }\n        vowels.iter().rev().for_each(|vowel|{\n       \
    \     new_c = new_c.replace_range(vowel, vowel+2, &vowel);\n        });\n    \
    \    new_c\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpx0m8uk5_.rs:17:17\n\
    \   |\n17 |             'a' ... 'z' => vowels.push('a'),\n   |               \
    \  ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpx0m8uk5_.rs:18:17\n\
    \   |\n18 |             'A' ... 'Z' => vowels.push('A'),\n   |               \
    \  ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted\
    \ in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note:\
    \ for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpx0m8uk5_.rs:19:17\n\
    \   |\n19 |             '0' ... '9' => vowels.push('0'),\n   |               \
    \  ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted\
    \ in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note:\
    \ for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0599]: no method named `replace_range` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpx0m8uk5_.rs:23:27\n   |\n23 |             new_c = new_c.replace_range(vowel,\
    \ vowel+2, &vowel);\n   |                           ^^^^^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0369]: cannot add `{integer}` to `&char`\n  --> /tmp/tmpx0m8uk5_.rs:23:53\n\
    \   |\n23 |             new_c = new_c.replace_range(vowel, vowel+2, &vowel);\n\
    \   |                                                -----^- {integer}\n   | \
    \                                               |\n   |                      \
    \                          &char\n\nerror: aborting due to 2 previous errors;\
    \ 3 warnings emitted\n\nSome errors have"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut letters = message.chars().map(|c| c.to_lowercase());\n\
    \    letters = letters.filter_map(|c| c.chars().count());\n    letters = letters.chain(|c|\
    \ c.chars().filter(|c| c != 'a' || c != 'e' || c != 'i' || c != 'o' || c != 'u'))\n\
    \        .map(|c| c + '2');\n\n    let mut output: Vec<String> = vec![];\n   \
    \ letters.for_each(|c| {\n        output.push(*c);\n    });\n    letters.to_owned()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmp768ae16b.rs:13:40\n   |\n13 |     letters =\
    \ letters.filter_map(|c| c.chars().count());\n   |                           \
    \             ^^^^^ method not found in `ToLowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp768ae16b.rs:13:15\n   |\n12 |     let mut letters = message.chars().map(|c|\
    \ c.to_lowercase());\n   |                       -----------------------------------------\n\
    \   |                       |                   |\n   |                      \
    \ |                   the expected closure\n   |                       |     \
    \              the found closure\n   |                       expected due to this\
    \ value\n13 |     letters = letters.filter_map(|c| c.chars().count());\n   | \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Map`,\
    \ found struct `FilterMap`\n   |\n   = note: expected struct `Map<Chars<'_>, _>`\n\
    \              found struct `FilterMap<Map<Chars<'_>, _>, [closure@/tmp/tmp768ae16b.rs:13:34:\
    \ 13:55]>`\n\nerror[E0369]: cannot add `char` to `ToLowercase`\n  --> /tmp/tmp768ae16b.rs:15:20\n\
    \   |\n15 |         .map(|c| c + '2');\n   |                  - ^ --- char\n \
    \  |                  |\n   |                  ToLowercase\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp768ae16b.rs:14:15\n   |\n12 |       let mut letters = message.chars().map(|c|\
    \ c.to_lowercase());\n   |                         -----------------------------------------\n\
    \   |                         |                   |\n   |                    \
    \     |                   the expected closure\n   |                         |\
    \                   the found closure\n   |                         expected due\
    \ to this value\n13 |       letters = letters.filter_map(|c| c.chars().count());\n\
    14 |       letters = letters.chain(|c| c.chars().filter(|c| c != 'a' || c != 'e'\
    \ || c != 'i' || c != 'o' || c != 'u'))\n   |  _______________^\n15 | |      \
    \   .map(|c| c + '2');\n   | |_________________________^ expected struct `Chars`,\
    \ found struct `std::iter::Chain`\n   |\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut vowels = HashSet::new();\n    let mut letters\
    \ = HashSet::new();\n    vowels.insert(vowel_a());\n    vowels.insert(vowel_e());\n\
    \    vowels.insert(vowel_i());\n    vowels.insert(vowel_o());\n    vowels.insert(vowel_u());\n\
    \    letters.insert(letter_a());\n    letters.insert(letter_e());\n    letters.insert(letter_f());\n\
    \    letters.insert(letter_i());\n    letters.insert(letter_l());\n    letters.insert(letter_o());\n\
    \    letters.insert(letter_u());\n    letters.insert(letter_c());\n    letters.insert(letter_m());\n\
    \    letters.insert(letter_p());\n    letters.insert(letter_s());\n    letters.insert(letter_t());\n\
    \    letters.insert(letter_g());\n    letters.insert(letter_k());\n    let mut\
    \ message = message.to_lowercase();\n    for char in message.chars() {\n     \
    \   let index = message.index(char);\n        if index >= 2 {\n            if\
    \ let Some(pos) = vowels.iter().position(|vowel| vowel == char) {\n          \
    \      let a = pos + 2;\n                let b = a + 1;\n                let c\
    \ = b + 2;\n                let d = c + 1;\n                let e = d + 1;\n \
    \               let f = e + 2;\n                let g = f + 1;\n             \
    \   let h = g + 2;\n                let i = h + 1;\n                let j = i\
    \ + 1;\n                let k = j + 2;\n                let l = k + 1;\n     \
    \           let m = l + 1;\n                let n = m + 2;\n                let\
    \ o = n + 1;\n                let p = o + 1;\n                let q = p + 2;\n\
    \                let r = q + 1;\n                let s = r + 2;\n            \
    \    let t = s + 1;\n                let u = t + 1;\n                let v = u\
    \ + 2;\n                let w = v + 1;\n                let x = w + 1;\n     \
    \           let y = x + 2;\n                let z = y + 1;\n                let\
    \ a = z + 1;\n                let b = a + 1;\n                let c = b + 2;\n\
    \                let d = c + 1;\n                let e = d + 1;\n            \
    \    let f = e + 2;\n                let g = f + 1;\n                let h = g\
    \ + 2;\n                let i = h + 1;\n                let j = i + 1;\n     \
    \           let k = j + 2;\n                let l = k + 1;\n                let\
    \ m = l + 1;\n                let n = m + 2;\n                let o = n + 1;\n\
    \                let p = o + 1;\n                let q = p + 2;\n            \
    \    let r = q + 1;\n                let s = r + 2;\n                let t = s\
    \ + 1;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8d7zyld4.rs:93:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n34 |     for char in message.chars()\
    \ {\n   |                                 - unclosed delimiter\n35 |         let\
    \ index = message.index(char);\n36 |         if index >= 2 {\n   |           \
    \            - unclosed delimiter\n37 |             if let Some(pos) = vowels.iter().position(|vowel|\
    \ vowel == char) {\n   |                                                     \
    \                         - this delimiter might not be properly closed...\n...\n\
    84 | }\n   | - ...as it matches this but it has different indentation\n...\n93\
    \ | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmp8d7zyld4.rs:12:22\n   |\n12 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp8d7zyld4.rs:13:23\n\
    \   |\n13 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ function `vowel_a` in this scope\n  --> /tmp/tmp8d7zyld4.rs:14:19\n   |\n14\
    \ |     vowels.insert(vowel_a());\n   |                   ^^^^^^^ help: a local\
    \ variable with a similar name exists: `vowels`\n\nerror[E0425]: cannot find function\
    \ `vowel_e` in this scope\n  --> /tmp/tmp8d7zyld4.rs:15:19\n   |\n15 |     vowels.insert(vowel_e());\n\
    \   |                   ^^^^^^^ help: a local variable with a similar name exists:\
    \ `vowels`\n\nerror[E0425]: cannot find function `vowel_i` in this scope\n  -->\
    \ /tmp/tmp8d7zyld4.rs:16:19\n   |\n16 |     vowels.insert(vowel_i());\n   |  \
    \                 ^^^^^^^ help: a local variable with a similar name exists: `vowels`\n\
    \nerror[E0425]: cannot find function `vowel_o` in this scope\n  --> /tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut message2 = message;\n\n    for i in 0..message.len()\
    \ {\n        if message.chars().any(|c| c == i {\n            return message2;\n\
    \        }) {\n            let i = i as usize;\n            let c = message.chars().nth(i).unwrap();\n\
    \            let index = c - 'A' as usize;\n\n            if index > 0 {\n   \
    \             message2 = &message2.chars().nth(index - 1) + \"A\" + &message2.chars().nth(i\
    \ + 1);\n            }\n        }\n    }\n\n    message2\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `return`\n  --> /tmp/tmp5ktbtnw6.rs:16:13\n\
    \   |\n15 |         if message.chars().any(|c| c == i {\n   |                \
    \                         - while parsing this struct\n16 |             return\
    \ message2;\n   |             ^^^^^^ expected identifier, found keyword\n\nerror[E0574]:\
    \ expected struct, variant or union type, found local variable `i`\n  --> /tmp/tmp5ktbtnw6.rs:15:41\n\
    \   |\n15 |         if message.chars().any(|c| c == i {\n   |                \
    \                         ^ not a struct, variant or union type\n\nerror[E0369]:\
    \ cannot subtract `usize` from `char`\n  --> /tmp/tmp5ktbtnw6.rs:20:27\n   |\n\
    20 |             let index = c - 'A' as usize;\n   |                         -\
    \ ^ ------------ usize\n   |                         |\n   |                 \
    \        char\n\nerror[E0369]: cannot add `&str` to `&Option<char>`\n  --> /tmp/tmp5ktbtnw6.rs:23:61\n\
    \   |\n23 |                 message2 = &message2.chars().nth(index - 1) + \"A\"\
    \ + &message2.chars().nth(i + 1);\n   |                            --------------------------------\
    \ ^ --- &str\n   |                            |\n   |                        \
    \    &Option<char>\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0574.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut out = '';\n    let alphabet = vec!['A', 'B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut map: HashMap<&str, &str>\
    \ = HashMap::new();\n    for (i, &char) in alphabet.iter().enumerate() {\n   \
    \     map.insert(char, &alphabet[(alphabet.len() - i) as usize]);\n    }\n   \
    \ for i in 0..message.len() {\n        if let Some(key) = map.get(&message[i])\
    \ {\n            out += key;\n        } else {\n            out += message[i];\n\
    \        }\n    }\n    out\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpd7x_83zr.rs:12:20\n   |\n\
    12 |     let mut out = '';\n   |                    ^ empty character literal\n\
    \nerror[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpd7x_83zr.rs:14:18\n\
    \   |\n14 |     let mut map: HashMap<&str, &str> = HashMap::new();\n   |     \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd7x_83zr.rs:14:40\n\
    \   |\n14 |     let mut map: HashMap<&str, &str> = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd7x_83zr.rs:19:37\n\
    \   |\n19 |         if let Some(key) = map.get(&message[i]) {\n   |          \
    \                           ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpd7x_83zr.rs:22:20\n   |\n22 |             out += message[i];\n\
    \   |                    ^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String a"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.length < 2 {\n        return message;\n\
    \    }\n    let mut new_message = \"\";\n    for (i, &letter) in message.chars().enumerate()\
    \ {\n        let mut new_letter = letter;\n        if i < message.length() - 1\
    \ {\n            if letter == 'a' {\n                new_letter = swap_case_letter(letter);\n\
    \            } else if letter == 'e' {\n                new_letter = swap_case_letter(letter);\n\
    \            } else if letter == 'i' {\n                new_letter = swap_case_letter(letter);\n\
    \            } else if letter == 'o' {\n                new_letter = swap_case_letter(letter);\n\
    \            } else if letter == 'u' {\n                new_letter = swap_case_letter(letter);\n\
    \            }\n        }\n        new_message += new_letter;\n    }\n    return\
    \ new_message;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap_case_letter` in this scope\n \
    \ --> /tmp/tmp6o_6mhss.rs:20:30\n   |\n20 |                 new_letter = swap_case_letter(letter);\n\
    \   |                              ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `swap_case_letter` in this scope\n  --> /tmp/tmp6o_6mhss.rs:22:30\n\
    \   |\n22 |                 new_letter = swap_case_letter(letter);\n   |     \
    \                         ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `swap_case_letter` in this scope\n  --> /tmp/tmp6o_6mhss.rs:24:30\n\
    \   |\n24 |                 new_letter = swap_case_letter(letter);\n   |     \
    \                         ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `swap_case_letter` in this scope\n  --> /tmp/tmp6o_6mhss.rs:26:30\n\
    \   |\n26 |                 new_letter = swap_case_letter(letter);\n   |     \
    \                         ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `swap_case_letter` in this scope\n  --> /tmp/tmp6o_6mhss.rs:28:30\n\
    \   |\n28 |                 new_letter = swap_case_letter(letter);\n   |     \
    \                         ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0609]:\
    \ no field `length` on type `String`\n  --> /tmp/tmp6o_6mhss.rs:12:16\n   |\n\
    12 |     if message.length < 2 {\n   |                ^^^^^^ unknown field\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6o_6mhss.rs:16:13\n   |\n16 |  \
    \   for (i, &letter) in message.chars().enumerate() {\n   |             ^^^^^^^\
    \     --------------------------- this expression has type `Option<(usize, char)>`\n\
    \   |             |\n   |             expected `char`, found reference\n   | \
    \            help: you can probably remove the explicit borrow: `letter`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp6o_6mhss.rs:18:24\n   |\n18 |         if i < message.length() - 1 {\n\
    \   |                        ^^^^^^ help: there is an associated f"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut message = message;\n    let mut index = 1;\n\
    \    let mut i = 0;\n    while i < message.len() {\n        let currentChar =\
    \ &message[i];\n        if currentChar == &'A' {\n            i += 1;\n      \
    \  } else if currentChar == &'a' {\n            i += 1;\n        } else if currentChar\
    \ == &'B' {\n            i += 1;\n        } else if currentChar == &'b' {\n  \
    \          i += 1;\n        } else if currentChar == &'C' {\n            i +=\
    \ 1;\n        } else if currentChar == &'c' {\n            i += 1;\n        }\
    \ else if currentChar == &'D' {\n            i += 1;\n        } else if currentChar\
    \ == &'d' {\n            i += 1;\n        } else if currentChar == &'E' {\n  \
    \          i += 1;\n        } else if currentChar == &'e' {\n            i +=\
    \ 1;\n        } else if currentChar == &'F' {\n            i += 1;\n        }\
    \ else if currentChar == &'f' {\n            i += 1;\n        } else if currentChar\
    \ == &'G' {\n            i += 1;\n        } else if currentChar == &'g' {\n  \
    \          i += 1;\n        } else if currentChar == &'H' {\n            i +=\
    \ 1;\n        } else if currentChar == &'h' {\n            i += 1;\n        }\
    \ else if currentChar == &'I' {\n            i += 1;\n        } else if currentChar\
    \ == &'i' {\n            i += 1;\n        } else if currentChar == &'J' {\n  \
    \          i += 1;\n        } else if currentChar == &'j' {\n            i +=\
    \ 1;\n        } else if currentChar == &'K' {\n            i += 1;\n        }\
    \ else if currentChar == &'k' {\n            i += 1;\n        } else if currentChar\
    \ == &'L' {\n            i += 1;\n        } else if currentChar == &'l' {\n  \
    \          i += 1;\n        } else if currentChar == &'M' {\n            i +=\
    \ 1;\n        } else if currentChar == &'m' {\n            i += 1;\n        }\
    \ else if currentChar == &'N' {\n            i += 1;\n        } else if currentChar\
    \ == &'n' {\n            i += 1;\n        } else if currentChar == &'O' {\n  \
    \          i += 1;\n        } else if currentChar == &'o' {\n            i +=\
    \ 1;\n        } else \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2sh98e40.rs:87:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n15 |     while i < message.len()\
    \ {\n   |                             - this delimiter might not be properly closed...\n\
    ...\n78 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    87 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp2sh98e40.rs:78:1\n\
    \   |\n78 | }\n   | ^ expected `{`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp2sh98e40.rs:16:28\n   |\n16 |         let\
    \ currentChar = &message[i];\n   |                            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2sh98e40.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    if message.len() > 12 {\n        String::from(\"\"\
    .to_string());\n    }\n    else {\n        let mut map = String::new();\n    \
    \    let mut letters = HashMap::new();\n        let mut vowels = HashMap::new();\n\
    \        for letter in message.chars() {\n            map.push(letter);\n    \
    \        if let Some(vowel) = map.chars().position(|c| *c == letter) {\n     \
    \           vowels.insert(vowel, letter);\n            }\n        }\n        let\
    \ mut index = 0;\n        let mut new_letters = String::new();\n        for vowel\
    \ in vowels.keys() {\n            map.replace(vowel, vowels[vowel].to_string());\n\
    \        }\n        for letter in map.chars() {\n            if index == map.len()\
    \ {\n                new_letters.push_str(&map[&index..]);\n                index\
    \ = 0;\n            }\n            map.push(letter);\n            index += 1;\n\
    \        }\n        new_letters.push_str(&map[&index..]);\n        new_letters.to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp1lbioxj8.rs:17:27\n   |\n17 |         let mut letters = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp1lbioxj8.rs:18:26\n\
    \   |\n18 |         let mut vowels = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1lbioxj8.rs:12:27\n   |\n12 |       if message.len() > 12 {\n \
    \  |  ___________________________^\n13 | |         String::from(\"\".to_string());\n\
    \   | |                                     - help: remove this semicolon\n14\
    \ | |     }\n   | |_____^ expected struct `String`, found `()`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp1lbioxj8.rs:21:59\n   |\n\
    21 |             if let Some(vowel) = map.chars().position(|c| *c == letter) {\n\
    \   |                                                           ^^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<&usize>`\n  --> /tmp/tmp1lbioxj8.rs:32:39\n\
    \   |\n32 |                 new_letters.push_str(&map[&index..]);\n   |      \
    \                                 ^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `RangeFrom<&usize>`\n   |\n   = help: the trait `Index<RangeFrom<&usize>>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<&usize>`\n\
    \  --> /tmp/tmp1lbioxj8.rs:38:31\n   |\n38 |         new_lett"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut alphabet = [97; 26];\n    let mut vowel = [5;\
    \ 26];\n\n    for c in message.chars() {\n        alphabet[alphabet.iter().position(|&x|\
    \ x == c).unwrap()] = c - 96;\n    }\n\n    for c in message.chars() {\n     \
    \   if c >= 'a' && c <= 'z' {\n            vowel[vowel.iter().position(|&x| x\
    \ == c).unwrap()] = c - 5 + 'a';\n        } else {\n            vowel[vowel.iter().position(|&x|\
    \ x == c).unwrap()] = c - 95;\n        }\n    }\n\n    let mut result = Vec::new();\n\
    \    for i in 0..message.len() {\n        result.push(vowel[vowel.iter().position(|&x|\
    \ x == message[i]).unwrap()] + alphabet[alphabet.iter().position(|&x| x == message[i]).unwrap()]);\n\
    \    }\n    result.join(\"\").to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2uf08dj9.rs:16:53\n   |\n\
    16 |         alphabet[alphabet.iter().position(|&x| x == c).unwrap()] = c - 96;\n\
    \   |                                                     ^ expected integer,\
    \ found `char`\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmp2uf08dj9.rs:16:50\n\
    \   |\n16 |         alphabet[alphabet.iter().position(|&x| x == c).unwrap()] =\
    \ c - 96;\n   |                                                  ^^ no implementation\
    \ for `{integer} == char`\n   |\n   = help: the trait `PartialEq<char>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `char`\n  --> /tmp/tmp2uf08dj9.rs:16:70\n   |\n16 |         alphabet[alphabet.iter().position(|&x|\
    \ x == c).unwrap()] = c - 96;\n   |                                          \
    \                          - ^ -- {integer}\n   |                            \
    \                                        |\n   |                             \
    \                                       char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2uf08dj9.rs:21:51\n   |\n21 |             vowel[vowel.iter().position(|&x|\
    \ x == c).unwrap()] = c - 5 + 'a';\n   |                                     \
    \              ^ expected integer, found `char`\n\nerror[E0277]: can't compare\
    \ `{integer}` with `char`\n  --> /tmp/tmp2uf08dj9.rs:21:48\n   |\n21 |       \
    \      vowel[vowel.iter().position(|&x| x == c).unwrap()] = c - 5 + 'a';\n   |\
    \                                                ^^ no implementation for `{integer}\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 ot"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut buf: Vec<char> = vec![0; message.length()];\n\
    \    let mut j = 0;\n    for i in 0..message.length() {\n        let c = message[i];\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n       \
    \     || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n        \
    \    buf.push(c as char);\n        } else {\n            let n = buf.len();\n\
    \            buf.push((n - j) as char);\n            buf.push(c);\n          \
    \  j = n;\n        }\n    }\n    encode(buf.clone()).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeywoaeyo.rs:12:35\n   |\n\
    12 |     let mut buf: Vec<char> = vec![0; message.length()];\n   |           \
    \                        ^ expected `char`, found `u8`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpeywoaeyo.rs:12:46\n\
    \   |\n12 |     let mut buf: Vec<char> = vec![0; message.length()];\n   |    \
    \                                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpeywoaeyo.rs:14:25\n\
    \   |\n14 |     for i in 0..message.length() {\n   |                         ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpeywoaeyo.rs:15:17\n\
    \   |\n15 |         let c = message[i];\n   |                 ^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeywoaeyo.rs:26:12\n\
    \   |\n26 |     encode(buf.clone()).to_string()\n   |            ^^^^^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n\
    \              found struct `Vec<char>`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `usize`\n  --> /tmp/tmpeywoaeyo.rs:21:22\n   |\n21 |        \
    \     buf.push((n - j) as char);\n   |                      ^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpeywoaeyo.rs:21:22\n\
    \   |\n21 |             buf.push((n - j) as cha"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let vowels = \"\
    AEIOU\".to_vec();\n    \n    for letter in message.chars() {\n        if letter\
    \ in vowels {\n            result.push((&message[vowels.iter().position(|x| x\
    \ == &letter).unwrap() + 1] as char).to_string());\n        } else {\n       \
    \     result.push(letter.to_string());\n        }\n    }\n    \n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpctzyvboz.rs:16:19\n\
    \   |\n16 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0599]: no method named `to_vec` found for reference `&'static\
    \ str` in the current scope\n  --> /tmp/tmpctzyvboz.rs:13:26\n   |\n13 |     let\
    \ vowels = \"AEIOU\".to_vec();\n   |                          ^^^^^^ method not\
    \ found in `&'static str`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut letter_count:\
    \ usize = 0;\n    let mut vowel_count: usize = 0;\n    for letter in message.chars()\
    \ {\n        if let Letter::Vowel(vowel) = (letter) {\n            letter_count++;\n\
    \            if letter_count == 2 {\n                vowel_count += 2;\n     \
    \       }\n        }\n        if let Letter::Alpha(letter) = (letter) {\n    \
    \        result.append(&vowel_count.to_string());\n            vowel_count +=\
    \ 1;\n            result.append(&vowel.to_string());\n            vowel_count\
    \ = 0;\n            letter_count = 0;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp2jrvtiv9.rs:17:25\n\
    \   |\n17 |             letter_count++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |         \
    \    { let tmp = letter_count; letter_count += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n17 -             letter_count++;\n17\
    \ +             letter_count += 1;\n   | \n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Letter`\n  --> /tmp/tmp2jrvtiv9.rs:16:16\n   |\n16 |\
    \         if let Letter::Vowel(vowel) = (letter) {\n   |                ^^^^^^\
    \ use of undeclared type `Letter`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Letter`\n  --> /tmp/tmp2jrvtiv9.rs:22:16\n   |\n22 |         if let Letter::Alpha(letter)\
    \ = (letter) {\n   |                ^^^^^^ use of undeclared type `Letter`\n\n\
    error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmp2jrvtiv9.rs:25:28\n\
    \   |\n25 |             result.append(&vowel.to_string());\n   |             \
    \               ^^^^^ not found in this scope\n\nwarning: unnecessary parentheses\
    \ around `let` scrutinee expression\n  --> /tmp/tmp2jrvtiv9.rs:16:39\n   |\n16\
    \ |         if let Letter::Vowel(vowel) = (letter) {\n   |                   \
    \                    ^      ^\n   |\n   = note: `#[warn(unused_parens)]` on by\
    \ default\nhelp: remove these parentheses\n   |\n16 -         if let Letter::Vowel(vowel)\
    \ = (letter) {\n16 +         if let Letter::Vowel(vowel) = letter {\n   | \n\n\
    warning: unnecessary parentheses around `let` scrutinee expression\n  --> /tmp/tmp2jrvtiv9.rs:22:40\n\
    \   |\n22 |         if let Letter::Alpha(letter) = (letter) {\n   |          \
    \                              ^      ^\n   |\nhelp: remove these parentheses\n\
    \   |\n22 -         if let Letter::Alpha(letter) = (letter) {\n22 +         if\
    \ let Letter::Alpha(letter) = letter {\n   | \n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmp2jrvtiv9.rs:23:20\n\
    \   |\n23 |             result.append(&vowel_count.to_string());\n   |       \
    \          "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut messages = message.chars().collect::<Vec<char>>();\n\
    \    for (i, &c) in messages.iter().enumerate() {\n        match c.to_ascii_lowercase().to_ascii_lowercase().find(|&i|\
    \ i != 'a') {\n            None => messages[i] = c.to_ascii_lowercase(),\n   \
    \         Some(i) => {\n                let a = messages.iter().skip(i).next();\n\
    \                if !a.is_none() {\n                    messages[i] = a.unwrap().to_ascii_lowercase();\n\
    \                }\n            }\n        }\n    }\n    messages.iter().map(|c|\
    \ c.to_ascii_lowercase()).collect::<String>().to_string()\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp9ovhn2bn.rs:14:59\n   |\n14 |         match c.to_ascii_lowercase().to_ascii_lowercase().find(|&i|\
    \ i != 'a') {\n   |                                                          \
    \ ^^^^ method not found in `char`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels: Vec<&'static str> = vec![\"a\", \"e\",\
    \ \"i\", \"o\", \"u\"];\n    let vowel_count = vowels.len();\n    let ascii_table\
    \ = ascii_lowercase();\n    let mut encoded_message = String::new();\n    for\
    \ (i, c) in message.chars().enumerate() {\n        let mut encoded = String::new();\n\
    \        match c.to_ascii_lowercase().as_ref() {\n            \"a\" => encoded.push(ascii_table[0]),\n\
    \            \"b\" => encoded.push(ascii_table[1]),\n            \"c\" => encoded.push(ascii_table[2]),\n\
    \            \"d\" => encoded.push(ascii_table[3]),\n            \"e\" => encoded.push(ascii_table[4]),\n\
    \            \"f\" => encoded.push(ascii_table[5]),\n            \"g\" => encoded.push(ascii_table[6]),\n\
    \            \"h\" => encoded.push(ascii_table[7]),\n            \"i\" => encoded.push(ascii_table[8]),\n\
    \            \"j\" => encoded.push(ascii_table[9]),\n            \"k\" => encoded.push(ascii_table[10]),\n\
    \            \"l\" => encoded.push(ascii_table[11]),\n            \"m\" => encoded.push(ascii_table[12]),\n\
    \            \"n\" => encoded.push(ascii_table[13]),\n            \"o\" => encoded.push(ascii_table[14]),\n\
    \            \"p\" => encoded.push(ascii_table[15]),\n            \"q\" => encoded.push(ascii_table[16]),\n\
    \            \"r\" => encoded.push(ascii_table[17]),\n            \"s\" => encoded.push(ascii_table[18]),\n\
    \            \"t\" => encoded.push(ascii_table[19]),\n            \"u\" => encoded.push(ascii_table[20]),\n\
    \            \"v\" => encoded.push(ascii_table[21]),\n            \"w\" => encoded.push(ascii_table[22]),\n\
    \            \"x\" => encoded.push(ascii_table[23]),\n            \"y\" => encoded.push(ascii_table[24]),\n\
    \            \"z\" => encoded.push(ascii_table[25]),\n            _ => unreachable!(),\n\
    \        };\n        for j in 0..(vowel_count - 1) {\n            let prev_vowel\
    \ = vowels[j];\n            match encoded.chars().next() {\n                None\
    \ => unreachable!(),\n                Some(c) => match c.to_ascii_lowercase().as_ref()\
    \ {\n                    \"a\" => encoded.remove(ascii_table[prev_vowel]),\n \
    \                   \"b\" => encoded.replace(ascii_table[prev_vowel], \"c\"),\n\
    \                    \"c\" => encoded.replace(ascii_table[prev_vowel], \"d\"),\n\
    \                    \"d\" => encoded.replace(ascii_table[prev_vowel], \"e\"),\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp80dvub69.rs:65:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     for (i, c) in message.chars().enumerate()\
    \ {\n   |                                               - unclosed delimiter\n\
    ...\n47 |         for j in 0..(vowel_count - 1) {\n   |                      \
    \                 - unclosed delimiter\n48 |             let prev_vowel = vowels[j];\n\
    49 |             match encoded.chars().next() {\n   |                        \
    \                  - unclosed delimiter\n50 |                 None => unreachable!(),\n\
    51 |                 Some(c) => match c.to_ascii_lowercase().as_ref() {\n   |\
    \                                                                  - this delimiter\
    \ might not be properly closed...\n...\n56 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n65 | }\n   |   ^\n\nerror: expected identifier,\
    \ found keyword `fn`\n  --> /tmp/tmp80dvub69.rs:58:1\n   |\n58 | fn main() {\n\
    \   | ^^ expected identifier, found keyword\n\nerror: expected one of `=>`, `@`,\
    \ `if`, or `|`, found `main`\n  --> /tmp/tmp80dvub69.rs:58:4\n   |\n58 | fn main()\
    \ {\n   |    ^^^^ expected one of `=>`, `@`, `if`, or `|`\n\nerror[E0425]: cannot\
    \ find function `ascii_lowercase` in this scope\n  --> /tmp/tmp80dvub69.rs:14:23\n\
    \   |\n14 |     let ascii_table = ascii_lowercase();\n   |                   \
    \    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `as_ref` found for type `char` in the current scope\n  --> /tmp/tmp80dvub69.rs:18:38\n\
    \   |\n18 |         match c.to_ascii_lowercase().as_ref() {\n   |            \
    \                          ^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `as_ref` found for type `char` in the current scope\n  --> /tmp/tmp80dvub69.rs:51:57\n\
    \   |\n51 |                 Some(c) => match c.to_ascii_lowercase().as_ref() {\n\
    \   |                                                         ^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: `match` arms have incompatible types\n  -->\
    \ /t"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let index = alphabet.index(c) + 1;\n        result.push((match index\
    \ {\n            2 => alphabet[c - 'a'],\n            3 => alphabet[c - 'a'] +\
    \ 'o',\n            4 => alphabet[c - 'a'] + 'i',\n            _ => c\n      \
    \  }).to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmplpu5j8i_.rs:14:21\n\
    \   |\n14 |         let index = alphabet.index(c) + 1;\n   |                 \
    \    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `alphabet`\
    \ in this scope\n  --> /tmp/tmplpu5j8i_.rs:16:18\n   |\n16 |             2 =>\
    \ alphabet[c - 'a'],\n   |                  ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmplpu5j8i_.rs:17:18\n\
    \   |\n17 |             3 => alphabet[c - 'a'] + 'o',\n   |                  ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `alphabet` in this\
    \ scope\n  --> /tmp/tmplpu5j8i_.rs:18:18\n   |\n18 |             4 => alphabet[c\
    \ - 'a'] + 'i',\n   |                  ^^^^^^^^ not found in this scope\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmplpu5j8i_.rs:16:29\n   |\n\
    16 |             2 => alphabet[c - 'a'],\n   |                           - ^ ---\
    \ char\n   |                           |\n   |                           char\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmplpu5j8i_.rs:17:29\n\
    \   |\n17 |             3 => alphabet[c - 'a'] + 'o',\n   |                  \
    \         - ^ --- char\n   |                           |\n   |               \
    \            char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmplpu5j8i_.rs:18:29\n\
    \   |\n18 |             4 => alphabet[c - 'a'] + 'i',\n   |                  \
    \         - ^ --- char\n   |                           |\n   |               \
    \            char\n\nerror: aborting due to 7 previous errors\n\nSome errors have\
    \ detailed explanations: E0369, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars()\n        .map(|c| {\n            if\
    \ c.is_uppercase() {\n                c.to_ascii_lowercase()\n            } else\
    \ {\n                c.to_ascii_uppercase()\n            }\n        })\n     \
    \   .filter(|c| c.is_ascii_letter())\n        .map(|c| {\n            if c.contains('a')\
    \ {\n                let mut i = 0;\n                let mut j = 0;\n        \
    \        while i < c.len() {\n                    if c.chars().next() == c[j]\
    \ {\n                        i += 1;\n                        j += 1;\n      \
    \              } else {\n                        break;\n                    }\n\
    \                }\n                return c.chars()\n                    .filter(|&x|\
    \ x.is_ascii_uppercase())\n                    .collect::<String>().to_string();\n\
    \            } else {\n                c\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmphi1eg4_0.rs:20:23\n   |\n20 |         .filter(|c|\
    \ c.is_ascii_letter())\n   |                       ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0599]: no\
    \ method named `contains` found for type `char` in the current scope\n  --> /tmp/tmphi1eg4_0.rs:22:18\n\
    \   |\n22 |             if c.contains('a') {\n   |                  ^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `len` found for type `char`\
    \ in the current scope\n  --> /tmp/tmphi1eg4_0.rs:25:29\n   |\n25 |          \
    \       while i < c.len() {\n   |                             ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmphi1eg4_0.rs:26:26\n   |\n26 |             \
    \        if c.chars().next() == c[j] {\n   |                          ^^^^^ method\
    \ not found in `char`\n\nerror[E0608]: cannot index into a value of type `char`\n\
    \  --> /tmp/tmphi1eg4_0.rs:26:44\n   |\n26 |                     if c.chars().next()\
    \ == c[j] {\n   |                                            ^^^^\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmphi1eg4_0.rs:33:26\n\
    \   |\n33 |                 return c.chars()\n   |                          ^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::with_capacity(message.len()\
    \ * 3);\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"];\n  \
    \  let vowels2 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    for i in 0..message.len()\
    \ {\n        let letter = &message[i];\n        if letter.chars().all(|c| vowels.contains(&c))\
    \ {\n            result.push_str(&letter + &vowels[vowels.iter().position(|c|\
    \ c == &letter as *const _ as char).unwrap() + 1]);\n        } else if letter.chars().all(|c|\
    \ vowels2.contains(&c)) {\n            result.push_str(&letter + &vowels2[vowels2.iter().position(|c|\
    \ c == &letter as *const _ as char).unwrap() + 1]);\n        } else {\n      \
    \      result.push_str(&letter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp01g329or.rs:16:23\n\
    \   |\n16 |         let letter = &message[i];\n   |                       ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output_message: String = String::new();\n \
    \   for (index, letter) in message.chars().enumerate() {\n        let (current_letter,\
    \ next_letter) = if index == 0 {\n            (letter, 'A')\n        } else {\n\
    \            (letter, message[index - 1])\n        };\n        if current_letter\
    \ >= 'a' && current_letter <= 'z' {\n            let vowel_index = current_letter\
    \ - 'a' as usize;\n            let vowel_letter = &vowels[vowel_index];\n    \
    \        output_message.push_str(&vowel_letter);\n        } else {\n         \
    \   output_message.push_str(&letter);\n        }\n    }\n    output_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmp9yeepj7v.rs:21:33\n\
    \   |\n21 |             let vowel_letter = &vowels[vowel_index];\n   |       \
    \                          ^^^^^^ not found in this scope\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9yeepj7v.rs:17:22\n\
    \   |\n17 |             (letter, message[index - 1])\n   |                   \
    \   ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmp9yeepj7v.rs:20:46\n\
    \   |\n20 |             let vowel_index = current_letter - 'a' as usize;\n   |\
    \                               -------------- ^ ------------ usize\n   |    \
    \                           |\n   |                               char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9yeepj7v.rs:24:37\n   |\n24 |             output_message.push_str(&letter);\n\
    \   |                                     ^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0369, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO: implement this function\n\n    return \"\"\
    .to_string();\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpg07sgh5i.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
