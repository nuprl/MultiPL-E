name: HumanEval_118_get_closest_vowel
language: rust
results:
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  \n  let word = word.to_lowercase();\n  let mut vowel_count\
    \ = 0;\n  let mut current_vowel_index = 0;\n  \n  // search backwards from end\
    \ of string\n  for index in word.rev().chars().rev().rposition(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n    \n    if index < 0 {\n\
    \      break;\n    }\n    \n    let vowel = word.chars().nth(index).unwrap();\n\
    \    \n    // vowel is in range and we haven't reached the start\n    if vowel\
    \ == current_vowel_index + 1 && current_vowel_index != 0 {\n      vowel_count++;\n\
    \    }\n    \n    current_vowel_index = vowel;\n  }\n  \n  if vowel_count == 0\
    \ {\n    return \"\";\n  }\n  \n  return word.chars().nth(word.chars().rposition(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') + 1).unwrap();\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7jhxjlar.rs:28:18\n\
    \   |\n28 |       vowel_count++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |       { let tmp = vowel_count;\
    \ vowel_count += 1; tmp };\n   |       +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    28 -       vowel_count++;\n28 +       vowel_count += 1;\n   | \n\nerror[E0599]:\
    \ `String` is not an iterator\n   --> /tmp/tmp7jhxjlar.rs:18:21\n    |\n18  |\
    \     for index in word.rev().chars().rev().rposition(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n    |                       ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7jhxjlar.rs:27:17\n   |\n27 |     if vowel == current_vowel_index\
    \ + 1 && current_vowel_index != 0 {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jhxjlar.rs:31:27\n\
    \   |\n15 |   let mut current_vowel_index = 0;\n   |                         \
    \        - expected due to this value\n...\n31 |     current_vowel_index = vowel;\n\
    \   |                           ^^^^^ expected integer, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7jhxjlar.rs:35:12\n   |\n11 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n35 |     return \"\";\n   |          \
    \  ^^- help: try using a conversion method: `.to_string()`\n   |            |\n\
    \   |            expected struct `String`, found `&str`\n\nerror[E0277]: the trait\
    \ bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmp7jhxjlar.rs:38:40\n\
    \     |\n38   |   return word.chars().nth(word.chars().rposition(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') + 1).un"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec!['u', 'i', 'a', 'e', 'i', 'o',\
    \ 'u', 'a', 'e', 'i', 'o', 'u', 'a', 'e', 'i', 'o'];\n    \n    for consonant\
    \ in word.chars().rev() {\n        if let Some(vowel) = vowels.binary_search(&consonant)\
    \ {\n            vowels.remove(vowel);\n            \n            if vowels.len()\
    \ < 2 {\n                return String::new();\n            }\n        }\n   \
    \ }\n\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpov24o3b9.rs:15:16\n   |\n\
    15 |         if let Some(vowel) = vowels.binary_search(&consonant) {\n   |   \
    \             ^^^^^^^^^^^   -------------------------------- this expression has\
    \ type `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().filter_map(|c| {\n        if c.is_uppercase()\
    \ || c.is_lowercase() {\n            if c.is_uppercase() {\n                Some(c.to_uppercase())\n\
    \            } else if c.is_lowercase() {\n                Some(c.to_lowercase())\n\
    \            } else {\n                None\n            }\n        } else if\
    \ c.is_vowel() {\n            Some(c.to_uppercase())\n        } else {\n     \
    \       None\n        }\n    }).find(|c| c.is_some()).map(|c| c.unwrap()).unwrap_or(\"\
    \")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp33odvss3.rs:17:22\n   |\n\
    17 |                 Some(c.to_lowercase())\n   |                      ^^^^^^^^^^^^^^^^\
    \ expected struct `ToUppercase`, found struct `ToLowercase`\n\nerror[E0599]: no\
    \ method named `is_vowel` found for type `char` in the current scope\n  --> /tmp/tmp33odvss3.rs:21:21\n\
    \   |\n21 |         } else if c.is_vowel() {\n   |                     ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_some` found\
    \ for reference `&ToUppercase` in the current scope\n  --> /tmp/tmp33odvss3.rs:26:19\n\
    \   |\n26 |     }).find(|c| c.is_some()).map(|c| c.unwrap()).unwrap_or(\"\")\n\
    \   |                   ^^^^^^^ method not found in `&ToUppercase`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `ToUppercase` in the current scope\n\
    \  --> /tmp/tmp33odvss3.rs:26:40\n   |\n26 |     }).find(|c| c.is_some()).map(|c|\
    \ c.unwrap()).unwrap_or(\"\")\n   |                                        ^^^^^^\
    \ method not found in `ToUppercase`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut min_distance = word.len() as i32;\n    let\
    \ mut vowel = String::new();\n    for &c in word.chars().cloned() {\n        if\
    \ c == ' ' {\n            continue;\n        }\n        let distance = word.char_indices()\n\
    \                        .iter()\n                        .filter(|(_, index)|\
    \ index < word.len())\n                        .map(|(_, index)| index as i32)\n\
    \                        .min();\n        if min_distance > distance {\n     \
    \       min_distance = distance;\n            vowel = String::from(c.to_lowercase());\n\
    \        }\n    }\n    return vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpncrj4i6g.rs:14:28\n     |\n14   |     for &c in word.chars().cloned()\
    \ {\n     |                            ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpncrj4i6g.rs:14:15\n\
    \   |\n14 |     for &c in word.chars().cloned() {\n   |               ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpncrj4i6g.rs:14:15\n   |\n14 |     for &c in word.chars().cloned()\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `iter` found for struct `CharIndices` in the current\
    \ scope\n  --> /tmp/tmpncrj4i6g.rs:19:26\n   |\n19 |                         .iter()\n\
    \   |                          ^^^^ private field, not a method\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().filter(|&(_, c)| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').filter(|&(_, c)| !c.is_lowercase()).filter(|&(_,\
    \ c)| c.is_uppercase()).filter(|&(_, c)| c.is_ascii()).unwrap_or(\"\")\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap_or` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpwoul87x7.rs:12:207\n   |\n12 | ...c.is_uppercase()).filter(|&(_,\
    \ c)| c.is_ascii()).unwrap_or(\"\")\n   |                                    \
    \                 ^^^^^^^^^ method not found in `Filter<Filter<Filter<Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpwoul87x7.rs:12:37: 12:103]>, [closure@/tmp/tmpwoul87x7.rs:12:112:\
    \ 12:139]>, [closure@/tmp/tmpwoul87x7.rs:12:148: 12:174]>, [closure@/tmp/tmpwoul87x7.rs:12:183:\
    \ 12:205]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().skip_while(|c| {\n        c < 'A' || c\
    \ > 'Z' ||\n            c < 'a' || c > 'z' ||\n            c < '0' || c > '9'\n\
    \    }).take_while(|c| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i'\
    \ && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c != 'U').collect()\n   \
    \     .join(\"\\u{1F447}\") \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1e7b1kad.rs:13:13\n   |\n\
    13 |         c < 'A' || c > 'Z' ||\n   |             ^^^\n   |             |\n\
    \   |             expected `&char`, found `char`\n   |             help: consider\
    \ borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1e7b1kad.rs:13:24\n\
    \   |\n13 |         c < 'A' || c > 'Z' ||\n   |                        ^^^\n \
    \  |                        |\n   |                        expected `&char`, found\
    \ `char`\n   |                        help: consider borrowing here: `&'Z'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1e7b1kad.rs:14:17\n   |\n14 |  \
    \           c < 'a' || c > 'z' ||\n   |                 ^^^\n   |            \
    \     |\n   |                 expected `&char`, found `char`\n   |           \
    \      help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1e7b1kad.rs:14:28\n   |\n14 |             c < 'a' || c > 'z' ||\n\
    \   |                            ^^^\n   |                            |\n   |\
    \                            expected `&char`, found `char`\n   |            \
    \                help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1e7b1kad.rs:15:17\n   |\n15 |             c < '0' || c\
    \ > '9'\n   |                 ^^^\n   |                 |\n   |              \
    \   expected `&char`, found `char`\n   |                 help: consider borrowing\
    \ here: `&'0'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1e7b1kad.rs:15:28\n\
    \   |\n15 |             c < '0' || c > '9'\n   |                            ^^^\n\
    \   |                            |\n   |                            expected `&char`,\
    \ found `char`\n   |                            help: consider borrowing here:\
    \ `&'9'`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1e7b1kad.rs:16:25\n\
    \   |\n16 |     }).take_while(|c| c != 'a' && c != 'A' && c != 'e' && c != 'E'\
    \ && c != 'i' && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c != 'U...\n\
    \   |                         ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemen"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = String::new();\n    for mut i\
    \ in word.reverse().chars() {\n        let mut i = i as u32;\n        if i as\
    \ usize > 2 {\n            i += 1;\n        }\n        if i as usize == 4 {\n\
    \            vowel_index.push(\"ae\");\n        }\n        if i as usize == 5\
    \ {\n            vowel_index.push(\"ai\");\n        }\n        if i as usize ==\
    \ 6 {\n            vowel_index.push(\"au\");\n        }\n        if i as usize\
    \ == 7 {\n            vowel_index.push(\"au\");\n        }\n        if i as usize\
    \ == 8 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 9 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 10 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 11 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 12 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 13 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 14 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 15 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 16 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 17 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 18 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 19 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 20 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 21 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 22 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 23 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 24 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 25 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 26 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 27 {\n            vowel_index.push(\"ou\");\n        }\n        if i as usize\
    \ == 28 {\n            vowel_index.push(\"ou\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n   --> /tmp/tmpqr572yo0.rs:108:65\n\
    \    |\n108 |       assert_eq!(candidate(String::from(\"Above\")), String::from(\"\
    o\"));\n    |  _________________________________________________________________^\n\
    109 | | }\n    | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    let mut vowels = HashSet::new();\n    let mut\
    \ letters = word.chars().collect::<Vec<_>>();\n    letters.pop();\n    letters.pop();\n\
    \    letters.reverse();\n    \n    let vowels0 = chars::vowels.collect::<Vec<_>>();\n\
    \    let vowels1 = chars::vowels.collect::<Vec<_>>();\n    \n    vowels0.clone()\
    \ + vowels1.clone() + letters.clone() + letters.clone().reverse()\n        .iter()\n\
    \        .cloned()\n        .filter(|&x| vowels.contains(x))\n        .cloned()\n\
    \        .collect::<Vec<_>>();\n    \n    vowels.iter().cloned().filter(|&x| vowels0.contains(x)).cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmpug268_cj.rs:19:19\n   |\n19 |     let vowels0 = chars::vowels.collect::<Vec<_>>();\n\
    \   |                   ^^^^^ use of undeclared crate or module `chars`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `chars`\n  --> /tmp/tmpug268_cj.rs:20:19\n\
    \   |\n20 |     let vowels1 = chars::vowels.collect::<Vec<_>>();\n   |       \
    \            ^^^^^ use of undeclared crate or module `chars`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpug268_cj.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0599]: no method named `iter`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpug268_cj.rs:23:10\n\
    \   |\n23 |         .iter()\n   |          ^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let len = word.len();\n    let mut start = 0;\n    let mut end = len\
    \ - 1;\n    while start <= end {\n        let mid = (start + end) / 2;\n     \
    \   let vowel = word[mid];\n        if word.contains(&vowel) {\n            return\
    \ vowel;\n        } else if vowels.contains(&vowel) {\n            end = mid -\
    \ 1;\n        } else {\n            start = mid + 1;\n        }\n    }\n    return\
    \ \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6q0mg93w.rs:18:21\n\
    \   |\n18 |         let vowel = word[mid];\n   |                     ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6q0mg93w.rs:21:35\n\
    \   |\n21 |         } else if vowels.contains(&vowel) {\n   |                \
    \                   ^^^^^^ expected `&str`, found struct `String`\n   |\n   =\
    \ note: expected reference `&&str`\n              found reference `&String`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut consonants: Vec<usize> = vec![\n        0x1d0,\
    \ 0x1d1, 0x1d2, 0x1d3, 0x1d4, 0x1d5, 0x1d6, 0x1d7, 0x1d8,\n        0x1d9, 0x1dc,\
    \ 0x1db, 0x1de,\n    ];\n    let mut vowels: Vec<usize> = vec![\n        0x1d0,\
    \ 0x1d8, 0x1d9,\n    ];\n\n    for (index, char) in word.chars().enumerate().take(word.len()\
    \ - 1) {\n        if consonants.contains(char) {\n            consonants.push(char);\n\
    \        } else {\n            if vowels.contains(char) {\n                vowels.push(char);\n\
    \            } else {\n                return \"\";\n            }\n        }\n\
    \    }\n    if consonants.len() > vowels.len() {\n        return \"\".to_string();\n\
    \    }\n    let mut min: usize;\n    let mut max: usize;\n    for (index, char)\
    \ in word.chars().enumerate().take(word.len() - 1) {\n        if char == consonants[vowels.len()].to_usize()\
    \ {\n            min = index;\n        }\n        if char == consonants[0].to_usize()\
    \ {\n            max = index;\n        }\n    }\n    if max < min {\n        return\
    \ \"\".to_string();\n    }\n    let mid = (min + max) / 2;\n    let mut vowel:\
    \ String;\n    if vowels.contains(consonants[mid].to_usize()) {\n        vowel\
    \ = consonants[mid].to_string();\n    } else {\n        vowel = vowels[mid].to_string();\n\
    \    }\n    return vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_ns6ks0.rs:21:32\n   |\n\
    21 |         if consonants.contains(char) {\n   |                            \
    \    ^^^^ expected `&usize`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf_ns6ks0.rs:22:29\n   |\n22 |             consonants.push(char);\n\
    \   |                             ^^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_ns6ks0.rs:24:32\n   |\n24 |             if\
    \ vowels.contains(char) {\n   |                                ^^^^ expected `&usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf_ns6ks0.rs:25:29\n\
    \   |\n25 |                 vowels.push(char);\n   |                         \
    \    ^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpf_ns6ks0.rs:27:24\n   |\n27 |                 return \"\";\n   |\
    \                        ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&str`\n\nerror[E0599]: no method named `to_usize` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpf_ns6ks0.rs:37:45\n   |\n37 |         if\
    \ char == consonants[vowels.len()].to_usize() {\n   |                        \
    \                     ^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no\
    \ method named `to_usize` found for type `usize` in the current scope\n  --> /tmp/tmpf_ns6ks0.rs:40:34\n\
    \   |\n40 |         if char == consonants[0].to_usize() {\n   |              \
    \                    ^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no\
    \ method named `to_usize` found for type `usize` in the current scope\n  --> /tmp/tmpf_ns6ks0.rs:49:40\n\
    \   |\n49 |     if vowels.contains(consonants[mid].to_usize()) {\n   |       \
    \                                 ^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to 8 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    fn is_vowel(s: &String) -> bool {\n        let v =\
    \ s.as_bytes().nth(1).unwrap();\n        v.is_uppercase() || v == 0xAC00 ||\n\
    \            v == 0xAC05 || v == 0xAC0E || v == 0xAC12 || v == 0xAC15\n    }\n\
    \n    let mut vowels = String::new();\n\n    for c in word.chars().nth(word.len()\
    \ - 1) {\n        let mut found = false;\n        for &i in &c {\n           \
    \ if is_vowel(&i) {\n                found = true;\n                break;\n \
    \           }\n        }\n        if !found {\n            vowels.push_str(&c.to_string());\n\
    \        }\n    }\n    if vowels.len() == 0 {\n        \"\"\n    } else {\n  \
    \      vowels\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&char` is not an iterator\n  --> /tmp/tmpewx5szg5.rs:22:19\n\
    \   |\n22 |         for &i in &c {\n   |                   ^^ `&char` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&char`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpewx5szg5.rs:33:9\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    33 |         \"\"\n   |         ^^- help: try using a conversion method: `.to_string()`\n\
    \   |         |\n   |         expected struct `String`, found `&str`\n\nerror[E0599]:\
    \ no method named `nth` found for reference `&[u8]` in the current scope\n  -->\
    \ /tmp/tmpewx5szg5.rs:13:30\n   |\n13 |         let v = s.as_bytes().nth(1).unwrap();\n\
    \   |                              ^^^ method not found in `&[u8]`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n\n    for i in word.rchars().rev().skip_while(|c| !vowels.contains(c))\
    \ {\n        let vowel = vowels[vowels.iter().position(|&x| x == &i).unwrap()];\n\
    \        if i != vowel {\n            return String::from(vowel);\n        }\n\
    \    }\n    \"\"\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rchars` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3zos3n15.rs:14:19\n   |\n14 |     for i in word.rchars().rev().skip_while(|c|\
    \ !vowels.contains(c)) {\n   |                   ^^^^^^ help: there is an associated\
    \ function with a similar name: `chars`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3zos3n15.rs:20:5\n   |\n11 | fn get_closest_vowel(word: String) -> String\
    \ {\n   |                                       ------ expected `String` because\
    \ of return type\n...\n20 |     \"\"\n   |     ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = \"aeiouAEIOU\".to_string();\n    for\
    \ c in word.chars().rev() {\n        if let Some(index) = vowels.rfind(&c.to_lowercase())\
    \ {\n            if index != 0 {\n                vowels = vowels[..index];\n\
    \            }\n        }\n    }\n    vowels\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `ToLowercase`\n \
    \ --> /tmp/tmpt1nv_dtw.rs:14:43\n   |\n14 |         if let Some(index) = vowels.rfind(&c.to_lowercase())\
    \ {\n   |                                     ----- ^^^^^^^^^^^^^^^^^ expected\
    \ an `Fn<(char,)>` closure, found `ToLowercase`\n   |                        \
    \             |\n   |                                     required by a bound\
    \ introduced by this call\n   |\n   = help: the trait `Fn<(char,)>` is not implemented\
    \ for `ToLowercase`\n   = help: the following other types implement trait `Pattern<'a>`:\n\
    \             &'b String\n             &'b [char; N]\n             &'b [char]\n\
    \             &'b str\n             &'c &'b str\n             [char; N]\n    \
    \         char\n             pattern::MultiCharEqPattern<C>\n   = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&ToLowercase`\n\
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt1nv_dtw.rs:16:26\n\
    \   |\n12 |     let mut vowels = \"aeiouAEIOU\".to_string();\n   |           \
    \           ------------------------ expected due to this value\n...\n16 |   \
    \              vowels = vowels[..index];\n   |                          ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \        |\n   |                          expected struct `String`, found `str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: HashSet<&str> = HashSet::new();\n \
    \   vowels.insert(\"a\".to_owned());\n    vowels.insert(\"e\".to_owned());\n \
    \   vowels.insert(\"i\".to_owned());\n    vowels.insert(\"o\".to_owned());\n \
    \   vowels.insert(\"u\".to_owned());\n    vowels.insert(\"y\".to_owned());\n \
    \   vowels.insert(\"a\".to_owned());\n    vowels.insert(\"e\".to_owned());\n \
    \   vowels.insert(\"i\".to_owned());\n    vowels.insert(\"o\".to_owned());\n \
    \   vowels.insert(\"u\".to_owned());\n    vowels.insert(\"y\".to_owned());\n \
    \   vowels.insert(\"a\".to_owned());\n    vowels.insert(\"e\".to_owned());\n \
    \   vowels.insert(\"i\".to_owned());\n    vowels.insert(\"o\".to_owned());\n \
    \   vowels.insert(\"u\".to_owned());\n    vowels.insert(\"y\".to_owned());\n \
    \   let mut word: Vec<&str> = word.split_whitespace();\n    let mut index: usize\
    \ = 0;\n    let mut min_vowel: Option<&str> = None;\n    let mut vowel_index:\
    \ usize = 0;\n    loop {\n        if word.len() <= index + 1 {\n            break;\n\
    \        }\n        let first_char = &word[index];\n        let last_char = &word[word.len()\
    \ - 1];\n        if vowels.contains(first_char) {\n            vowel_index = index;\n\
    \        }\n        if vowels.contains(last_char) {\n            vowel_index =\
    \ word.len() - 1;\n        }\n        index += 1;\n        let vowel_range = &vowels[vowel_index..(vowel_index\
    \ + 1)];\n        for vowel in vowel_range {\n            if first_char == vowel\
    \ {\n                break;\n            }\n            if vowel == last_char\
    \ {\n                break;\n            }\n            let first_char = &word[index];\n\
    \            let last_char = &word[word.len() - 1];\n            if vowels.contains(first_char)\
    \ {\n                vowel_index = index;\n            }\n            if vowels.contains(last_char)\
    \ {\n                vowel_index = word.len() - 1;\n            }\n          \
    \  index += 1;\n            if index >= word.len() {\n                break;\n\
    \            }\n        }\n        if index >= word.len() {\n            break;\n\
    \        }\n        let vowel_range = &vowels[vowel_index..(vowel_index + 1)];\n\
    \        let mut min_vowel_char = first_char;\n        for vowel in vowel_range\
    \ {\n            if min_vowel_char == vowel {\n                min_vowel_char\
    \ = first_char\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3twcko0d.rs:94:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n35 |     loop {\n\
    \   |          - unclosed delimiter\n...\n74 |         for vowel in vowel_range\
    \ {\n   |                                  - unclosed delimiter\n75 |        \
    \     if min_vowel_char == vowel {\n   |                                     \
    \   - this delimiter might not be properly closed...\n76 |                 min_vowel_char\
    \ = first_char\n77 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n94 | }\n   |   ^\n\nerror[E0412]: cannot find type `HashSet` in this scope\n\
    \  --> /tmp/tmp3twcko0d.rs:12:21\n   |\n12 |     let mut vowels: HashSet<&str>\
    \ = HashSet::new();\n   |                     ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp3twcko0d.rs:12:37\n   |\n12 |     let mut vowels: HashSet<&str>\
    \ = HashSet::new();\n   |                                     ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3twcko0d.rs:31:31\n   |\n\
    31 |     let mut word: Vec<&str> = word.split_whitespace();\n   |            \
    \       ---------   ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                   |\n   |                   expected\
    \ due to this\n   |\n   = note: expected struct `Vec<&str>`\n              found\
    \ struct `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3twcko0d.rs:37:13\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    37 |             break;\n   |             ^^^^^\n   |             |\n   |    \
    \         expected struct `String`, found `()`\n   |             help: give it\
    \ a value of the exp"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut i = word.len();\n    while i >= 0 {\n     \
    \   match word.chars().position(|&c| c == 'A' || c == 'E' || c == 'I' || c ==\
    \ 'O' || c == 'U') {\n            None => return \"\",\n            Some(start)\
    \ => {\n                if word.chars().position(|&c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n                    i += start - 'a' as\
    \ usize - 1;\n                } else {\n                    i -= start;\n    \
    \            }\n            }\n        }\n        i--;\n    }\n    return \"\"\
    ;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp_y7sa22v.rs:24:12\n\
    \   |\n24 |         i--;\n   |            ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_y7sa22v.rs:14:38\n   |\n14 |         match\
    \ word.chars().position(|&c| c == 'A' || c == 'E' || c == 'I' || c == 'O' || c\
    \ == 'U') {\n   |                                      ^--\n   |             \
    \                         ||\n   |                                      |expected\
    \ due to this\n   |                                      expected `char`, found\
    \ reference\n   |                                      help: did you mean `c`:\
    \ `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_y7sa22v.rs:15:28\n  \
    \ |\n15 |             None => return \"\",\n   |                            ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_y7sa22v.rs:17:43\n\
    \   |\n17 |                 if word.chars().position(|&c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n   |                               \
    \            ^--\n   |                                           ||\n   |    \
    \                                       |expected due to this\n   |          \
    \                                 expected `char`, found reference\n   |     \
    \                                      help: did you mean `c`: `&char`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_y7sa22v.rs:17:20\n   |\n17 |              \
    \   if word.chars().position(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowel_set = vec!['a', 'e', 'i', 'o', 'u'];\n  \
    \  word.chars().enumerate().filter(|&(idx, _)| vowel_set.contains(&word.chars().nth(idx).unwrap()))\n\
    \        .enumerate()\n        .map(|(idx, vowel)| word.chars().nth(idx + 1).unwrap())\n\
    \        .filter(|&c| vowel == 'u' || vowel == 'o' || vowel == 'i' || vowel ==\
    \ 'e')\n        .first()\n        .unwrap()\n        .to_string()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpe5s51zhu.rs:16:22\n\
    \   |\n16 |         .filter(|&c| vowel == 'u' || vowel == 'o' || vowel == 'i'\
    \ || vowel == 'e')\n   |                      ^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpe5s51zhu.rs:16:38\n\
    \   |\n16 |         .filter(|&c| vowel == 'u' || vowel == 'o' || vowel == 'i'\
    \ || vowel == 'e')\n   |                                      ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `vowel` in this scope\n  -->\
    \ /tmp/tmpe5s51zhu.rs:16:54\n   |\n16 |         .filter(|&c| vowel == 'u' || vowel\
    \ == 'o' || vowel == 'i' || vowel == 'e')\n   |                              \
    \                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `vowel` in this scope\n  --> /tmp/tmpe5s51zhu.rs:16:70\n   |\n16\
    \ |         .filter(|&c| vowel == 'u' || vowel == 'o' || vowel == 'i' || vowel\
    \ == 'e')\n   |                                                              \
    \        ^^^^^ not found in this scope\n\nerror[E0599]: no method named `first`\
    \ found for struct `Filter` in the current scope\n  --> /tmp/tmpe5s51zhu.rs:17:10\n\
    \   |\n17 |         .first()\n   |          ^^^^^ method not found in `Filter<Map<Enumerate<Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpe5s51zhu.rs:13:37: 13:100]>>, [closure@/tmp/tmpe5s51zhu.rs:15:14:\
    \ 15:63]>, [closure@/tmp/tmpe5s51zhu.rs:16:17: 16:82]>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = String::new();\n    for vowel in 'a'\
    \ .. 'z' {\n        let mut curr_idx = word.len();\n        loop {\n         \
    \   let c = word[curr_idx - 1];\n            curr_idx = curr_idx.saturating_sub(1);\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                res\
    \ = c.to_string() + res;\n            }\n            else {\n                break;\n\
    \            }\n        }\n    }\n    return res;\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1latinsw.rs:16:21\n\
    \   |\n16 |             let c = word[curr_idx - 1];\n   |                    \
    \ ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code here\n    let mut vowels = \"aeiou\";\n\
    \    let mut word_list = word.chars();\n    while let Some(c) = word_list.next()\
    \ {\n        if vowels.contains(&c.to_lowercase()) {\n            let pos = word_list.position(|c|\
    \ *c == c);\n            word_list = word_list.skip(pos).take(1);\n        } else\
    \ {\n            word_list = word_list.skip(1).take(1);\n        }\n    }\n  \
    \  word_list.next()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `ToLowercase`\n \
    \   --> /tmp/tmpllkjwsou.rs:16:28\n     |\n16   |         if vowels.contains(&c.to_lowercase())\
    \ {\n     |                   -------- ^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `ToLowercase`\n     |                   |\n     |           \
    \        required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `Fn<(char,)>` is not implemented for `ToLowercase`\n     = help: the following\
    \ other types implement trait `Pattern<'a>`:\n               &'b String\n    \
    \           &'b [char; N]\n               &'b [char]\n               &'b str\n\
    \               &'c &'b str\n               [char; N]\n               char\n \
    \              pattern::MultiCharEqPattern<C>\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&ToLowercase`\n     =\
    \ note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&ToLowercase`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpllkjwsou.rs:17:46\n\
    \   |\n17 |             let pos = word_list.position(|c| *c == c);\n   |     \
    \                                         ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpllkjwsou.rs:18:40\n   |\n18 |             word_list = word_list.skip(pos).take(1);\n\
    \   |                                        ^^^ expected `usize`, found enum\
    \ `Option`\n   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpllkjwsou.rs:18:25\n   |\n14 |\
    \     let mut word_list = word.chars();\n   |                         ------------\
    \ expected due to this value\n...\n18 |             word_list = word_list.skip(pos).take(1);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`,\
    \ found struct `std::iter::Take`\n   |\n   = note: expected struct `Chars<'_>`\n\
    \              found struct `std::iter::Take<Skip<Chars<'_>>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpllkjwsou.rs:20:25\n   |\n14 |     let mut word_"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"\"; word.len()];\n    vowels.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i == 0 {\n            if v == 'a' || v == 'e' || v == 'i'\
    \ || v == 'o' || v == 'u' {\n                vowels[i] = v;\n            }\n \
    \       } else if i == word.len() - 1 {\n            if v == 'a' || v == 'e' ||\
    \ v == 'i' || v == 'o' || v == 'u' {\n                vowels[i] = v;\n       \
    \     }\n        } else {\n            let next = match i {\n                0\
    \ => i + 1,\n                _ => i + 2,\n            };\n            if v ==\
    \ 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n                vowels[i]\
    \ = v;\n            }\n            if v == 'a' && word[next] == 'a' {\n      \
    \          vowels[i] = v;\n            }\n            if v == 'e' && word[next]\
    \ == 'e' {\n                vowels[i] = v;\n            }\n            if v ==\
    \ 'i' && word[next] == 'i' {\n                vowels[i] = v;\n            }\n\
    \            if v == 'o' && word[next] == 'o' {\n                vowels[i] = v;\n\
    \            }\n            if v == 'u' && word[next] == 'u' {\n             \
    \   vowels[i] = v;\n            }\n        }\n    });\n    vowels\n        .iter()\n\
    \        .cloned()\n        .max_by_key(|&x| {\n            let mut i = 0;\n \
    \           word\n                .bytes()\n                .enumerate()\n   \
    \             .filter(|&(a, b)| *a != b)\n                .filter(|&(a, b)| a\
    \ == x)\n                .next()\n                .unwrap()\n                .1\
    \ == x\n        })\n        .unwrap()\n        .to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4zsn76gk.rs:13:49\n   |\n\
    13 |     vowels.iter_mut().enumerate().for_each(|(i, &v)| {\n   |            \
    \                                     ^^- expected due to this\n   |         \
    \                                        |\n   |                             \
    \                    types differ in mutability\n   |                        \
    \                         help: you can probably remove the explicit borrow: `v`\n\
    \   |\n   = note: expected mutable reference `&mut &str`\n                   \
    \   found reference `&_`\n\nerror[E0277]: can't compare `&str` with `char`\n \
    \ --> /tmp/tmp4zsn76gk.rs:15:18\n   |\n15 |             if v == 'a' || v == 'e'\
    \ || v == 'i' || v == 'o' || v == 'u' {\n   |                  ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmp4zsn76gk.rs:15:30\n   |\n15 |            \
    \ if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n   |        \
    \                      ^^ no implementation for `&str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels_start = vec![\"a\", \"e\", \"i\", \"o\"\
    , \"u\"];\n    let vowels_end = vec![\"e\", \"i\", \"o\", \"u\"];\n    \n    let\
    \ mut vowel_iter: Vec<&str> = word.chars().filter(|c| vowels_start.contains(&c)).chain(word.chars().filter(|c|\
    \ vowels_end.contains(&c))).collect();\n    \n    vowel_iter.sort_by_key(|&c|\
    \ vowels_start.iter().position(|&v1| v1 == c).unwrap());\n    \n    vowel_iter.pop().unwrap()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5bj_rn0n.rs:15:83\n   |\n\
    15 |     let mut vowel_iter: Vec<&str> = word.chars().filter(|c| vowels_start.contains(&c)).chain(word.chars().filter(|c|\
    \ vowels_end.contains(...\n   |                                              \
    \                                     ^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&&str`\n              found reference `&&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5bj_rn0n.rs:15:138\n   |\n15 |\
    \ ....chain(word.chars().filter(|c| vowels_end.contains(&c))).collect();\n   |\
    \                                                       ^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&&str`\n              found reference\
    \ `&&char`\n\nerror[E0277]: a value of type `Vec<&str>` cannot be built from an\
    \ iterator over elements of type `char`\n    --> /tmp/tmp5bj_rn0n.rs:15:144\n\
    \     |\n15   | ...els_end.contains(&c))).collect();\n     |                 \
    \          ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5bj_rn0n.rs:19:5\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    19 |     vowel_iter.pop().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = Vec::new();\n    for ch in word.chars()\
    \ {\n        if ch.is_vowel() {\n            vowels.push(ch);\n        }\n   \
    \ }\n    if vowels.len() == 0 {\n        return \"\";\n    }\n    let mut i =\
    \ 0;\n    let mut j = vowels.len() - 1;\n    while i <= j {\n        let mut vowel\
    \ = vowels[i];\n        i += 1;\n        while j < vowels.len() && vowels[j].is_vowel()\
    \ {\n            j -= 1;\n        }\n        if i <= j {\n            if let Some(consonant_after_vowel)\
    \ = word[i + ..j].chars().last() {\n                if consonant_after_vowel.is_vowel()\
    \ {\n                    return vowel.to_string();\n                }\n      \
    \      }\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpajyyuxze.rs:14:15\n   |\n14 |         if ch.is_vowel()\
    \ {\n   |               ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpajyyuxze.rs:19:16\n   |\n11 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n19 |         return \"\";\n   |      \
    \          ^^- help: try using a conversion method: `.to_string()`\n   |     \
    \           |\n   |                expected struct `String`, found `&str`\n\n\
    error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpajyyuxze.rs:26:45\n   |\n26 |         while j < vowels.len()\
    \ && vowels[j].is_vowel() {\n   |                                            \
    \ ^^^^^^^^ method not found in `char`\n\nerror[E0277]: cannot add `RangeTo<usize>`\
    \ to `usize`\n  --> /tmp/tmpajyyuxze.rs:30:57\n   |\n30 |             if let Some(consonant_after_vowel)\
    \ = word[i + ..j].chars().last() {\n   |                                     \
    \                    ^ no implementation for `usize + RangeTo<usize>`\n   |\n\
    \   = help: the trait `Add<RangeTo<usize>>` is not implemented for `usize`\n \
    \  = help: the following other types implement trait `Add<Rhs>`:\n           \
    \  <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() == 0 {\n        return \"\".to_string();\n\
    \    }\n    \n    let mut vowel = \"a\".to_string();\n    let mut vowel_start_pos\
    \ = word.len() - 1;\n    let mut vowel_end_pos = word.len() - 1;\n    \n    let\
    \ mut consonant = \"b\".to_string();\n    let mut consonant_start_pos = 0;\n \
    \   let mut consonant_end_pos = 0;\n    \n    while vowel_start_pos >= 0 && vowel_end_pos\
    \ >= 0 && consonant_start_pos >= 0 && consonant_end_pos >= 0 {\n        if word[vowel_end_pos].is_lowercase()\
    \ {\n            if word[vowel_start_pos].is_lowercase() && word[vowel_end_pos].to_string().eq_ignore_ascii_case(vowel)\
    \ {\n                vowel = vowel.into();\n                vowel_end_pos += 1;\n\
    \                vowel_start_pos -= 1;\n            }\n        }\n        if word[consonant_end_pos].is_lowercase()\
    \ {\n            if word[consonant_start_pos].is_lowercase() && word[consonant_end_pos].to_string().eq_ignore_ascii_case(consonant)\
    \ {\n                consonant = consonant.into();\n                consonant_end_pos\
    \ += 1;\n                consonant_start_pos -= 1;\n            }\n        }\n\
    \        \n        if vowel_start_pos >= 0 {\n            vowel = word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    a\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    i\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    o\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    u\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    e\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    \xE4\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    \xF6\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    \xFC\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    c\") // TODO\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    d\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    p\")\n                || word[vowel_start_pos].to_string().eq_ignore_ascii_case(\"\
    f\")\n                || word[vowel_start_pos].to_string().eq_ignore_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpy7xjacd6.rs:71:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n24 |     while vowel_start_pos\
    \ >= 0 && vowel_end_pos >= 0 && consonant_start_pos >= 0 && consonant_end_pos\
    \ >= 0 {\n   |                                                               \
    \                                             - unclosed delimiter\n...\n40 |\
    \         if vowel_start_pos >= 0 {\n   |                                 - this\
    \ delimiter might not be properly closed...\n...\n54 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n71 | }\n   |   ^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7xjacd6.rs:25:12\n\
    \   |\n25 |         if word[vowel_end_pos].is_lowercase() {\n   |            ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy7xjacd6.rs:26:16\n   |\n26 |             if word[vowel_start_pos].is_lowercase()\
    \ && word[vowel_end_pos].to_string().eq_ignore_ascii_case(vowel) {\n   |     \
    \           ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<Range"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.to_lowercase();\n    let mut vowels:\
    \ Vec<&str> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_count:\
    \ usize = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut current_char:\
    \ char;\n    let mut next_char: char;\n    for char in word.chars() {\n      \
    \  if vowels.contains(char) {\n            vowel_count += 1;\n        } else {\n\
    \            if vowel_count < 2 {\n                start = end;\n            }\
    \ else if vowel_count == 2 {\n                start = end;\n                end\
    \ = end;\n            } else {\n                break;\n            }\n      \
    \  }\n    }\n    if vowel_count < 2 {\n        return \"\";\n    }\n    if vowel_count\
    \ == 2 {\n        return vowels[0];\n    }\n    let mut best_match: char = \"\"\
    ;\n    for _ in 0..(vowel_count - 1) {\n        best_match = \"\";\n        for\
    \ _ in 0..(vowel_count - 1) {\n            current_char = word[start];\n     \
    \       next_char = word[end];\n            if current_char != next_char {\n \
    \               break;\n            }\n            best_match += next_char;\n\
    \            start += 1;\n            end += 1;\n        }\n        if best_match\
    \ != \"\" {\n            return best_match;\n        }\n    }\n    return \"\"\
    ;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpokj64a7d.rs:20:28\n   |\n\
    20 |         if vowels.contains(char) {\n   |                            ^^^^\
    \ expected `&&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpokj64a7d.rs:34:16\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    34 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpokj64a7d.rs:39:32\n\
    \   |\n39 |     let mut best_match: char = \"\";\n   |                       \
    \  ----   ^^ expected `char`, found `&str`\n   |                         |\n \
    \  |                         expected due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpokj64a7d.rs:41:22\n   |\n39 |     let mut best_match: char\
    \ = \"\";\n   |                         ---- expected due to this type\n40 | \
    \    for _ in 0..(vowel_count - 1) {\n41 |         best_match = \"\";\n   |  \
    \                    ^^ expected `char`, found `&str`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpokj64a7d.rs:43:28\n\
    \   |\n43 |             current_char = word[start];\n   |                    \
    \        ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpokj64a7d.rs:44:25\n\
    \   |\n44 |             next_char = word[end];\n   |                         ^^^^^^^^^\
    \ `String` cannot be inde"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut vowels: Vec<&str>\
    \ = vec![];\n    for i in word.chars() {\n        if let c = 'a' <= i && i <=\
    \ 'z' {\n            counter++;\n            vowels.push(i);\n        }\n    \
    \    if let c = 'A' <= i && i <= 'Z' {\n            counter++;\n            vowels.push(i);\n\
    \        }\n    }\n    if counter <= 1 {\n        return \"\".to_string();\n \
    \   }\n    vowels.sort_by_key(|&x| x.cmp(&word[word.len() - counter..].to_lowercase()));\n\
    \    vowels.pop().unwrap()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp395xn2xa.rs:16:20\n\
    \   |\n16 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    16 -             counter++;\n16 +             counter += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp395xn2xa.rs:20:20\n   |\n20\
    \ |             counter++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n20 |             { let tmp = counter; counter\
    \ += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n20\
    \ -             counter++;\n20 +             counter += 1;\n   | \n\nerror[E0658]:\
    \ `let` expressions in this position are unstable\n  --> /tmp/tmp395xn2xa.rs:15:12\n\
    \   |\n15 |         if let c = 'a' <= i && i <= 'z' {\n   |            ^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror[E0658]: `let` expressions in this position are\
    \ unstable\n  --> /tmp/tmp395xn2xa.rs:19:12\n   |\n19 |         if let c = 'A'\
    \ <= i && i <= 'Z' {\n   |            ^^^^^^^^^^^^^^^^\n   |\n   = note: see issue\
    \ #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp395xn2xa.rs:28:5\n   |\n11 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n...\n28 |     vowels.pop().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0658.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 2 {\n        return \"\".to_string();\n\
    \    }\n\n    let mut res = String::new();\n    let vowels = vec![\"a\", \"e\"\
    , \"i\", \"o\", \"u\"];\n    let mut vowel = String::new();\n    let mut i = 0;\n\
    \n    while i < word.len() {\n        for v in vowels.iter() {\n            if\
    \ word[i] == v {\n                vowel = v;\n                i += 1;\n      \
    \      }\n        }\n    }\n\n    while vowel.len() > 0 {\n        match vowel.chars().nth(vowel.len()\
    \ - 1) {\n            Some(c) if c >= 'a' && c <= 'z' => res += c.to_string(),\n\
    \            Some(c) if c >= 'A' && c <= 'Z' => res += c.to_string(),\n      \
    \      _ => res += vowel.to_string(),\n        }\n    }\n\n    return res.to_string();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu9yzivn6.rs:23:16\n\
    \   |\n23 |             if word[i] == v {\n   |                ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu9yzivn6.rs:24:25\n\
    \   |\n18 |     let mut vowel = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n24 |                 vowel = v;\n   |     \
    \                    ^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `&&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu9yzivn6.rs:32:55\n\
    \   |\n32 |             Some(c) if c >= 'a' && c <= 'z' => res += c.to_string(),\n\
    \   |                                                       ^^^^^^^^^^^^^\n  \
    \ |                                                       |\n   |            \
    \                                           expected `&str`, found struct `String`\n\
    \   |                                                       help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu9yzivn6.rs:33:55\n\
    \   |\n33 |             Some(c) if c >= 'A' && c <= 'Z' => res += c.to_string(),\n\
    \   |                                                       ^^^^^^^^^^^^^\n  \
    \ |                                                       |\n   |            \
    \                                           expected `&str`, found struct `String`\n\
    \   |                                                       help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: m"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 2 {\n        return \"\";\n    }\n\
    \    let mut vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"];\n    vowels.sort();\n\
    \    vowels.reverse();\n    let mut cur_letter = &word[word.len() - 1];\n    for\
    \ vowel in vowels {\n        if cur_letter == vowel {\n            return vowel.to_string();\n\
    \        }\n        cur_letter = &word[word.len() - 1 - vowel.len()];\n    }\n\
    \    return \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6_ankcmj.rs:13:16\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if word.len() < 2 {\n13 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp6_ankcmj.rs:18:27\n   |\n\
    18 |     let mut cur_letter = &word[word.len() - 1];\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6_ankcmj.rs:23:23\n\
    \   |\n23 |         cur_letter = &word[word.len() - 1 - vowel.len()];\n   |  \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut left = 0\n    let mut right = word.len() -\
    \ 1;\n    while left < right {\n        let current = word.chars().nth(left).unwrap();\n\
    \        let next_char = word.chars().nth(right).unwrap();\n        if current\
    \ == \"a\" {\n            if next_char != \"a\" {\n                return \"\"\
    ;\n            } else {\n                left += 1;\n                right -=\
    \ 1;\n            }\n        } else if current == \"e\" {\n            if next_char\
    \ != \"e\" {\n                return \"\";\n            } else {\n           \
    \     left += 1;\n                right -= 1;\n            }\n        } else if\
    \ current == \"i\" {\n            if next_char != \"i\" {\n                return\
    \ \"\";\n            } else {\n                left += 1;\n                right\
    \ -= 1;\n            }\n        } else if current == \"o\" {\n            if next_char\
    \ != \"o\" {\n                return \"\";\n            } else {\n           \
    \     left += 1;\n                right -= 1;\n            }\n        } else if\
    \ current == \"u\" {\n            if next_char != \"u\" {\n                return\
    \ \"\";\n            } else {\n                left += 1;\n                right\
    \ -= 1;\n            }\n        }\n    }\n    \"\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb84jgfjs.rs:12:21\n\
    \   |\n12 |     let mut left = 0\n   |                     ^ help: add `;` here\n\
    13 |     let mut right = word.len() - 1;\n   |     --- unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb84jgfjs.rs:17:23\n   |\n17 |         if current\
    \ == \"a\" {\n   |                       ^^^ expected `char`, found `&str`\n \
    \  |\nhelp: if you meant to write a `char` literal, use single quotes\n   |\n\
    17 |         if current == 'a' {\n   |                       ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb84jgfjs.rs:18:29\n   |\n18 |             if\
    \ next_char != \"a\" {\n   |                             ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n18 |             if next_char != 'a' {\n   |                 \
    \            ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb84jgfjs.rs:19:24\n\
    \   |\n19 |                 return \"\";\n   |                        ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        |\n\
    \   |                        expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb84jgfjs.rs:24:30\n   |\n24 |         } else\
    \ if current == \"e\" {\n   |                              ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n24 |         } else if current == 'e' {\n   |                \
    \              ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb84jgfjs.rs:25:29\n\
    \   |\n25 |             if next_char != \"e\" {\n   |                        \
    \     ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char`\
    \ literal, use single quotes\n   |\n25 |             if next_char != 'e' {\n \
    \  |                             ~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb84jgfjs.rs:31:30\n   |\n31 |         } else if current == \"i\" {\n\
    \   |                              ^^^ expected `char`, found `&str`\n   |\nhelp:\
    \ if you meant to write a `char` literal, use single quotes\n   |\n31 |      \
    \   }"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word_start = word.char_indices().next().unwrap();\n\
    \    let mut current_vowel = String::new();\n    let mut current_consonant = String::new();\n\
    \    loop {\n        let current_vowel = word_start.index(b\"a\").unwrap().unwrap()\
    \ + 1;\n        let current_consonant = word_start.index(b\"b\").unwrap().unwrap()\
    \ + 1;\n        if current_vowel >= word.len() {\n            break;\n       \
    \ }\n        if word.chars().last().unwrap() as u8 == word.chars().nth(current_consonant).unwrap()\
    \ as u8 {\n            return current_vowel.to_string();\n        }\n        word_start.seek(current_vowel);\n\
    \    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmpgaslqdzc.rs:16:40\n   |\n16 |         let current_vowel\
    \ = word_start.index(b\"a\").unwrap().unwrap() + 1;\n   |                    \
    \                    ^^^^^ method not found in `(usize, char)`\n\nerror[E0599]:\
    \ no method named `index` found for tuple `(usize, char)` in the current scope\n\
    \  --> /tmp/tmpgaslqdzc.rs:17:44\n   |\n17 |         let current_consonant = word_start.index(b\"\
    b\").unwrap().unwrap() + 1;\n   |                                            ^^^^^\
    \ method not found in `(usize, char)`\n\nerror[E0599]: no method named `seek`\
    \ found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpgaslqdzc.rs:24:20\n\
    \   |\n24 |         word_start.seek(current_vowel);\n   |                    ^^^^\
    \ method not found in `(usize, char)`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = 0;\n    let mut prev_consonant_index\
    \ = 0;\n    let mut prev_vowel_index = 0;\n    let mut vowels_set: HashSet<String>\
    \ = HashSet::new();\n    let mut cur_consonant_index = word\n        .chars()\n\
    \        .map(|c| c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n\
    \        .count() as u32;\n    let mut cur_vowel_index = word\n        .chars()\n\
    \        .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \        .count() as u32;\n    let mut cur_vowel_index2 = word\n        .chars()\n\
    \        .filter(|c| c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n\
    \        .count() as u32;\n    for c in word.chars() {\n        if c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n            vowels_set.insert(&word.to_string());\n\
    \        }\n    }\n    vowels_set.iter().cloned().filter(|&x| vowels_set.contains(&x.to_string()).unwrap_or(false)).iter().cloned().fold(String::new(),\
    \ |a, &x| *a = x.to_string());\n    while vowel_index < cur_vowel_index {\n  \
    \      vowel_index += 1;\n        prev_consonant_index = cur_consonant_index;\n\
    \        prev_vowel_index = cur_vowel_index;\n        while vowel_index < cur_vowel_index\
    \ {\n            cur_consonant_index -= 1;\n            if cur_consonant_index\
    \ == 0 {\n                cur_consonant_index = word\n                    .chars()\n\
    \                    .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n                    .count() as u32;\n                cur_vowel_index\
    \ -= 1;\n                if cur_vowel_index == 0 {\n                    cur_vowel_index\
    \ = word\n                        .chars()\n                        .filter(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n                \
    \        .count() as u32;\n                    cur_vowel_index2 = word\n     \
    \                   .chars()\n                        .filter(|c| c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U')\n                        .count()\
    \ as u32;\n                }\n            }\n            let mut cur_vowel_index\
    \ = word\n                .chars()\n                .filter(|c| c == 'a' || c\
    \ == 'e' || \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8te1n0sr.rs:77:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n34 |     while vowel_index\
    \ < cur_vowel_index {\n   |                                         - unclosed\
    \ delimiter\n...\n38 |         while vowel_index < cur_vowel_index {\n   |   \
    \                                          - this delimiter might not be properly\
    \ closed...\n...\n60 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n77 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp8te1n0sr.rs:59:24\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n59 |                 .filter(|c| c == 'a' || c == 'e' || \n   |         \
    \               ^ unclosed delimiter\n60 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected expression, found `)`\n  --> /tmp/tmp8te1n0sr.rs:60:1\n   |\n\
    60 | }\n   | ^ expected expression\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n  --> /tmp/tmp8te1n0sr.rs:15:25\n   |\n15 |     let mut vowels_set:\
    \ HashSet<String> = HashSet::new();\n   |                         ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmp8te1n0sr.rs:15:43\n   |\n15 |  \
    \   let mut vowels_set: HashSet<String> = HashSet::new();\n   |              \
    \                             ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp8te1n0sr.rs:22:23\n   |\n22\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                       ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is imp"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().find(|&(_, c)| {\n       \
    \ let idx = c.to_string();\n        (&c.to_string()[..] == \"a\" || &c.to_string()[..]\
    \ == \"e\" || &c.to_string()[..] == \"i\" || &c.to_string()[..] == \"o\" || &c.to_string()[..]\
    \ == \"u\") && c.to_string().chars().any(|&b| *b != &idx)\n    }).unwrap()\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ftt7fy1.rs:14:183\n   |\n\
    14 | ...ring()[..] == \"u\") && c.to_string().chars().any(|&b| *b != &idx)\n \
    \  |                                                     ^--\n   |           \
    \                                          ||\n   |                          \
    \                           |expected due to this\n   |                      \
    \                               expected `char`, found reference\n   |       \
    \                                              help: did you mean `b`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2ftt7fy1.rs:12:5\n   |\n11 |   fn\
    \ get_closest_vowel(word: String) -> String {\n   |                          \
    \               ------ expected `String` because of return type\n12 | /     word.chars().enumerate().find(|&(_,\
    \ c)| {\n13 | |         let idx = c.to_string();\n14 | |         (&c.to_string()[..]\
    \ == \"a\" || &c.to_string()[..] == \"e\" || &c.to_string()[..] == \"i\" || &c.to_string()[..]\
    \ == \"o\" || &c.to_string...\n15 | |     }).unwrap()\n   | |_______________^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `String`\n\
    \               found tuple `(usize, char)`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    word.chars()\n\
    \        .windows(2)\n        .filter(|&c| c.is_ascii_letter())\n        .filter(|&c|\
    \ !c.is_ascii_upper())\n        .cloned()\n        .for_each(|c| {\n         \
    \   if let Some(&(_,c)) = c.as_ref().find_last_mut() {\n                result\
    \ = if c == c.to_ascii_lowercase() {\n                    c.to_ascii_uppercase()\n\
    \                } else {\n                    c.to_ascii_lowercase()\n      \
    \          };\n            }\n        })\n        .collect();\n    \n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `windows` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpkmcm7pf5.rs:14:10\n   |\n14 |         .windows(2)\n\
    \   |          ^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    let mut vowels: Vec<String> = vec![\"\", \"a\"\
    , \"e\", \"i\", \"o\", \"u\"];\n    vowels.sort_by(|a, b| {\n        word.chars().nth(0).unwrap()\
    \ <=> a.chars().nth(0).unwrap()\n    });\n    \n    if vowels.len() == 0 {\n \
    \       return String::new();\n    }\n    \n    vowels[0]\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: invalid comparison operator `<=>`\n  --> /tmp/tmpe9vrlwlr.rs:15:38\n\
    \   |\n15 |         word.chars().nth(0).unwrap() <=> a.chars().nth(0).unwrap()\n\
    \   |                                      ^^^ `<=>` is not a valid comparison\
    \ operator, use `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe9vrlwlr.rs:13:40\n   |\n13 |     let mut vowels: Vec<String> = vec![\"\
    \", \"a\", \"e\", \"i\", \"o\", \"u\"];\n   |                                \
    \        ^^- help: try using a conversion method: `.to_string()`\n   |       \
    \                                 |\n   |                                    \
    \    expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe9vrlwlr.rs:15:9\n   |\n15 |         word.chars().nth(0).unwrap()\
    \ <=> a.chars().nth(0).unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().take_while( |&(_,c)| *c !=\
    \ '\\0' ).collect::<Vec<(usize, char)>>().iter().enumerate().map(|&(_,c)| *c as\
    \ char).filter(|c| *c != 'u').next().unwrap().unwrap()\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpr71vwtc8.rs:12:51\n\
    \   |\n12 |     word.chars().enumerate().take_while( |&(_,c)| *c != '\\0' ).collect::<Vec<(usize,\
    \ char)>>().iter().enumerate().map(|&(_,c)| *c as char...\n   |              \
    \                                     ^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpr71vwtc8.rs:12:120\n   |\n12 | ...:<Vec<(usize, char)>>().iter().enumerate().map(|&(_,c)|\
    \ *c as char).filter(|c| *c != 'u').next().unwrap().unwrap()\n   |           \
    \                                         ^^^^^-\n   |                       \
    \                             |    |\n   |                                   \
    \                 |    expected due to this\n   |                            \
    \                        expected tuple, found reference\n   |\n   = note:  expected\
    \ tuple `(usize, &(usize, char))`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = 0;\n    let mut consonant_index\
    \ = 0;\n    let mut is_found = false;\n    let mut min_vowel_dist = Vec::new();\n\
    \n    // Get the minimum distance from the right side of the given word (to the\
    \ closest \n    // vowel)\n    while !is_found && consonant_index < word.len()\
    \ {\n        let c = word[consonant_index];\n\n        // If the current character\
    \ is not a consonant, then break the loop\n        if !c.is_lowercase() {\n  \
    \          break;\n        }\n\n        // Check all possible combinations for\
    \ vowels and consonants\n        for vowel in &[\"a\", \"e\", \"i\", \"o\", \"\
    u\"] {\n            if vowel.chars().all(|c| word.contains(&c)) {\n          \
    \      // Found a vowel, now check it has the minimum distance from the right\n\
    \                // side of the given word (to the closest consonant)\n      \
    \          if c.is_lowercase() {\n                    min_vowel_dist.append(vowel.len()\
    \ - word[vowel_index].len());\n                }\n            }\n        }\n \
    \       \n        // Increment the index of vowel found\n        vowel_index +=\
    \ 1;\n        // Increment the index of consonant found\n        consonant_index\
    \ += 1;\n    }\n\n    // If no vowels were found, return an empty string\n   \
    \ if !is_found {\n        return String::new();\n    }\n\n    // If no consonants\
    \ were found, return the minimum distance from the right side\n    // of the given\
    \ word (to the closest vowel)\n    if consonant_index >= word.len() {\n      \
    \  return String::from(min_vowel_dist);\n    }\n\n    // If all consonants were\
    \ found, return the minimum distance from the right side \n    // of the given\
    \ word (to the closest vowel)\n    if consonant_index == word.len() {\n      \
    \  return String::from(min_vowel_dist);\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptrsegs8v.rs:20:17\n\
    \   |\n20 |         let c = word[consonant_index];\n   |                 ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n\
    \    --> /tmp/tmptrsegs8v.rs:29:52\n     |\n29   |             if vowel.chars().all(|c|\
    \ word.contains(&c)) {\n     |                                           --------\
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n     |                 \
    \                          |\n     |                                         \
    \  required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n29   |             if vowel.chars().all(|c| word.contains(*&c))\
    \ {\n     |                                                    +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmptrsegs8v.rs:33:57\n\
    \   |\n33 |                     min_vowel_dist.append(vowel.len() - word[vowel_index].len());\n\
    \   |                                                         ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = 0u;\n    let mut consonant_index\
    \ = word.length() - 1;\n    let mut consonant_vowel_index = String::new();\n\n\
    \    // find first non-vowel \n    while vowel_index < word.len() && word.chars().any(|c|\
    \ !c.is_vowel()) {\n        vowel_index += 1;\n    }\n\n    // find last non-vowel\n\
    \    while consonant_index >= 0 && word.chars().any(|c| !c.is_vowel()) {\n   \
    \     consonant_index -= 1;\n    }\n\n    while vowel_index < word.len() && consonant_index\
    \ >= 0 {\n        if word.chars()[vowel_index].is_vowel() && word.chars()[consonant_index].is_vowel()\
    \ {\n            consonant_vowel_index.push(word.chars()[consonant_index].to_uppercase());\n\
    \            consonant_index -= 1;\n        }\n        vowel_index += 1;\n   \
    \     consonant_index -= 1;\n    }\n\n    if consonant_vowel_index.is_empty()\
    \ {\n        \"\"\n    } else {\n        consonant_vowel_index.clone()\n    }\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmp40mad_fu.rs:12:27\n\
    \   |\n12 |     let mut vowel_index = 0u;\n   |                           ^^ invalid\
    \ suffix `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`,\
    \ `isize`, `f32`, etc.)\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp40mad_fu.rs:13:36\n   |\n13 | \
    \    let mut consonant_index = word.length() - 1;\n   |                      \
    \              ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0599]: no method named `is_vowel` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp40mad_fu.rs:17:63\n   |\n17 |     while vowel_index\
    \ < word.len() && word.chars().any(|c| !c.is_vowel()) {\n   |                \
    \                                               ^^^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp40mad_fu.rs:22:59\n   |\n22 |     while consonant_index\
    \ >= 0 && word.chars().any(|c| !c.is_vowel()) {\n   |                        \
    \                                   ^^^^^^^^ method not found in `char`\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp40mad_fu.rs:27:12\n\
    \   |\n27 |         if word.chars()[vowel_index].is_vowel() && word.chars()[consonant_index].is_vowel()\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `Chars<'_>`\n  --> /tmp/tmp40mad_fu.rs:27:52\n   |\n27 |   \
    \      if word.chars()[vowel_index].is_vowel() && word.chars()[consonant_index].is_vowel()\
    \ {\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp40mad_fu.rs:28:40\n\
    \   |\n28 |             consonant_vowel_index.push(word.chars()[consonant_index].to_uppercase());\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp40mad_fu.rs:36:9\n   |\n11 | fn\
    \ get_closest_vowel(word: String) -"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"A\",\"a\",\"E\"\
    ,\"e\",\"I\",\"i\",\"O\",\"o\",\"U\",\"u\"];\n    let mut word: String = word.to_string();\n\
    \    for vowel in vowels.iter() {\n        if word.contains(vowel) {\n       \
    \     let start_index = word.rindex(vowel);\n            let end_index = start_index\
    \ + 1;\n            let end_index = end_index.unwrap_or(word.len());\n       \
    \     return word.iter().take(end_index).collect::<String>().join(\"\");\n   \
    \     }\n    }\n    \"\"\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rindex` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpqldmshd0.rs:16:36\n   |\n16 |             let start_index\
    \ = word.rindex(vowel);\n   |                                    ^^^^^^ help:\
    \ there is an associated function with a similar name: `find`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpqldmshd0.rs:19:25\n   |\n19 |             return word.iter().take(end_index).collect::<String>().join(\"\
    \");\n   |                         ^^^^ method not found in `String`\n   |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n   |\n19 |             return word.chars().take(end_index).collect::<String>().join(\"\
    \");\n   |                         ~~~~~\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpqldmshd0.rs:22:5\n   |\n11 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n22 |     \"\"\n   |     ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().skip_while(|c| c == 'A' || c == 'a' ||\
    \ c == 'E' || c == 'e' || c == 'I' || c == 'i' || c == 'O' || c == 'o' || c ==\
    \ 'U' || c == 'u').fold(\"\".to_string(), |mut x, c| {\n        match x.chars().nth(0)\
    \ {\n            Some(_) => {\n                let len = c - 'A'.to_string();\n\
    \                if len < 0 {\n                    return x;\n               \
    \ } else if len < 4 {\n                    x.push(c);\n                }\n   \
    \         }\n            None => x,\n        }\n    });\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1gd9wy4s.rs:12:35\n\
    \   |\n12 |     word.chars().skip_while(|c| c == 'A' || c == 'a' || c == 'E' ||\
    \ c == 'e' || c == 'I' || c == 'i' || c == 'O' || c == 'o' || c == 'U' ...\n \
    \  |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp1gd9wy4s.rs:12:47\n   |\n12 |   \
    \  word.chars().skip_while(|c| c == 'A' || c == 'a' || c == 'E' || c == 'e' ||\
    \ c == 'I' || c == 'i' || c == 'O' || c == 'o' || c == 'U' ...\n   |         \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp1gd9wy4s.rs:12:59\n   |\n12 |   \
    \  word.chars().skip_while(|c| c == 'A' || c == 'a' || c == 'E' || c == 'e' ||\
    \ c == 'I' || c == 'i' || c == 'O' || c == 'o' || c == 'U' ...\n   |         \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp1gd9wy4s.rs:12:71\n   |\n12\
    \ |     word.chars().skip_while(|c| c == 'A' || c == 'a' || c == 'E' || c == 'e'\
    \ || c == 'I' || c == 'i' || c == 'O' || c == 'o' || c == 'U' ...\n   |      \
    \                                                                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1gd9wy4s.rs:12:83\n\
    \   |\n12 |     word.chars().skip_while(|c| c == 'A' || c == 'a' || c == 'E' ||\
    \ c == 'e' || c == 'I' || c == 'i' |"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() <= 2 {\n        return \"\";\n    }\n\
    \n    let mut vowels = vec![\"A\", \"a\", \"E\", \"e\", \"I\", \"i\", \"O\", \"\
    o\", \"U\", \"u\", \"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut word = word.to_lowercase();\n\
    \    let mut prev_vowel = 0;\n    let mut next_vowel = 0;\n    let mut pos = 0;\n\
    \    loop {\n        pos = word.rfind('a', pos);\n        if pos == 0 {\n    \
    \        return \"\";\n        }\n        let vowel = &vowels[(pos + 1) as usize];\n\
    \        // if pos > 0 || (prev_vowel == 0 && vowel == 'a') {\n        if pos\
    \ > 0 || prev_vowel == 0 {\n            if !word.starts_with(vowel) {\n      \
    \          // if prev_vowel != 0 {\n                if prev_vowel != vowel {\n\
    \                    prev_vowel = vowel;\n                }\n                continue;\n\
    \            }\n        }\n        let next_vowel = &vowels[(pos + 2) as usize];\n\
    \        let mut pos = pos + 1;\n        if next_vowel == 0 && vowel == 'a' {\n\
    \            next_vowel = 'u';\n        }\n        if next_vowel == vowel {\n\
    \            break;\n        }\n    }\n    return if word.ends_with(vowel) {\n\
    \        vowel.into()\n    } else {\n        word.chars().nth(pos + 1).unwrap_or(String::new()).into()\n\
    \    };\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpiouy32fx.rs:46:30\n\
    \   |\n46 |     return if word.ends_with(vowel) {\n   |                      \
    \        ^^^^^ help: a local variable with a similar name exists: `vowels`\n\n\
    error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpiouy32fx.rs:47:9\n\
    \   |\n47 |         vowel.into()\n   |         ^^^^^ help: a local variable with\
    \ a similar name exists: `vowels`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiouy32fx.rs:13:16\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n12\
    \ |     if word.len() <= 2 {\n13 |         return \"\";\n   |                ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                |\n\
    \   |                expected struct `String`, found `&str`\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpiouy32fx.rs:22:20\n\
    \     |\n22   |         pos = word.rfind('a', pos);\n     |                  \
    \  ^^^^^ ---  --- supplied 2 arguments\n     |                    |\n     |  \
    \                  expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiouy32fx.rs:22:15\n  \
    \ |\n20 |     let mut pos = 0;\n   |                   - expected due to this\
    \ value\n21 |     loop {\n22 |         pos = word.rfind('a', pos);\n   |     \
    \          ^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n\
    \   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\
    \nerror[E0277]: can't compare `{integer}` with `&&str`\n  --> /tmp/tmpiouy32fx.rs:31:31\n\
    \   |\n31 |                 if prev_vowel != vowel {\n   |                   \
    \            ^^ no implementation for `{integer} == &&str`\n   |\n   = help: the\
    \ trait `PartialEq<&&str>` is not implemented for `{integer}`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word[word.len()-1] == 'a' || word[word.len()-1]\
    \ == 'e' || word[word.len()-1] == 'i' || word[word.len()-1] == 'o' || word[word.len()-1]\
    \ == 'u' || word[word.len()-1] == 'A' || word[word.len()-1] == 'E' || word[word.len()-1]\
    \ == 'I' || word[word.len()-1] == 'O' || word[word.len()-1] == 'U' {\n       \
    \ return \"\".to_string();\n    }\n    \n    word.chars().enumerate().filter_map(|(idx,\
    \ char)| {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o'\
    \ || char == 'u' || char == 'A' || char == 'E' || char == 'I' || char == 'O' ||\
    \ char == 'U' {\n            Some((idx, char))\n        } else {\n           \
    \ None\n        }\n    }).enumerate().filter_map(|(idx, (idx, char))| {\n    \
    \    if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u'\
    \ || char == 'A' || char == 'E' || char == 'I' || char == 'O' || char == 'U' {\n\
    \            Some((idx, char))\n        } else {\n            None\n        }\n\
    \    }).filter_map(|(idx, (idx, char))| {\n        if char == 'a' || char == 'e'\
    \ || char == 'i' || char == 'o' || char == 'u' || char == 'A' || char == 'E' ||\
    \ char == 'I' || char == 'O' || char == 'U' {\n            Some((idx, char))\n\
    \        } else {\n            None\n        }\n    }).filter_map(|(idx, (idx,\
    \ char))| {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o'\
    \ || char == 'u' || char == 'A' || char == 'E' || char == 'I' || char == 'O' ||\
    \ char == 'U' {\n            Some((idx, char))\n        } else {\n           \
    \ None\n        }\n    }).filter_map(|(idx, (idx, char))| {\n        if char ==\
    \ 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'A'\
    \ || char == 'E' || char == 'I' || char == 'O' || char == 'U' {\n            Some((idx,\
    \ char))\n        } else {\n            None\n        }\n    }).filter_map(|(idx,\
    \ (idx, char))| {\n        if char == 'a' || char == 'e' || char == 'i' || char\
    \ == 'o' || char == 'u' || char == 'A' || char == 'E' || char == 'I' || char ==\
    \ 'O' || char == 'U' {\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnzk5rt1u.rs:65:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n46 |     }).filter_map(|(idx,\
    \ (idx, char))| {\n   |                  - unclosed delimiter  - unclosed delimiter\n\
    47 |         if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u' || char == 'A' || char == 'E' || char == 'I' || char == 'O' || char ==\
    \ 'U' {\n   |                                                                \
    \                                                                            \
    \                   - this delimiter might not be properly closed...\n48 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n65 | }\n\
    \   |   ^\n\nerror[E0415]: identifier `idx` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmpnzk5rt1u.rs:22:39\n   |\n22 |     }).enumerate().filter_map(|(idx,\
    \ (idx, char))| {\n   |                                       ^^^ used as parameter\
    \ more than once\n\nerror[E0415]: identifier `idx` is bound more than once in\
    \ this parameter list\n  --> /tmp/tmpnzk5rt1u.rs:28:27\n   |\n28 |     }).filter_map(|(idx,\
    \ (idx, char))| {\n   |                           ^^^ used as parameter more than\
    \ once\n\nerror[E0415]: identifier `idx` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmpnzk5rt1u.rs:34:27\n   |\n34 |     }).filter_map(|(idx, (idx,\
    \ char))| {\n   |                           ^^^ used as parameter more than once\n\
    \nerror[E0415]: identifier `idx` is bound more than once in this parameter list\n\
    \  --> /tmp/tmpnzk5rt1u.rs:40:27\n   |\n40 |     }).filter_map(|(idx, (idx, char))|\
    \ {\n   |                           ^^^ used as parameter more than once\n\nerror[E0415]:\
    \ identifier `idx` is bound more than once in this parameter list\n  --> /tmp/tmpnzk5rt1u.rs:46:27\n\
    \   |\n46 |     }).filter_map(|(idx, (idx, char))| {\n   |                   \
    \        ^^^ used as parameter more than once\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpnzk5rt1u.r"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = \"aeiouAEIOU\".to_string();\n    \n\
    \    for s in word.chars() {\n        let r = vowels.rfind(s).unwrap_or(word.len()\
    \ - 1);\n        if r < word.len() - 1 {\n            return vowels[r + 1 as usize\
    \ - 1];\n        }\n    }\n    return String::new();\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpebted4ge.rs:17:20\n\
    \   |\n17 |             return vowels[r + 1 as usize - 1];\n   |             \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word\n        .chars()\n        .enumerate()\n    \
    \    .filter_map(|(idx, ch)| {\n            if ch == b'a' || ch == b'e' || ch\
    \ == b'i' || ch == b'o' || ch == b'u' {\n                Some(idx)\n         \
    \   } else {\n                None\n            }\n        })\n        .take_while(|idx|\
    \ idx > 0 && idx < word.len())\n        .map(|idx| word.chars().nth(idx).unwrap())\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|ch| {\n        \
    \    if ch == b'a' || ch == b'e' || ch == b'i' || ch == b'o' || ch == b'u' {\n\
    \                ch\n            } else {\n                \"\"\n            }\n\
    \        })\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhwlqy36.rs:16:22\n   |\n\
    16 |             if ch == b'a' || ch == b'e' || ch == b'i' || ch == b'o' || ch\
    \ == b'u' {\n   |                      ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplhwlqy36.rs:16:36\n   |\n16 |             if\
    \ ch == b'a' || ch == b'e' || ch == b'i' || ch == b'o' || ch == b'u' {\n   | \
    \                                   ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplhwlqy36.rs:16:50\n   |\n16 |             if\
    \ ch == b'a' || ch == b'e' || ch == b'i' || ch == b'o' || ch == b'u' {\n   | \
    \                                                 ^^^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplhwlqy36.rs:16:64\n  \
    \ |\n16 |             if ch == b'a' || ch == b'e' || ch == b'i' || ch == b'o'\
    \ || ch == b'u' {\n   |                                                      \
    \          ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplhwlqy36.rs:16:78\n   |\n16 |             if ch == b'a' || ch ==\
    \ b'e' || ch == b'i' || ch == b'o' || ch == b'u' {\n   |                     \
    \                                                         ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplhwlqy36.rs:22:33\n\
    \   |\n22 |         .take_while(|idx| idx > 0 && idx < word.len())\n   |     \
    \                            ^\n   |                                 |\n   | \
    \                                expected `&usize`, found integer\n   |      \
    \                           help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplhwlqy36.rs:22:44\n   |\n22 |         .take_while(|idx|\
    \ idx > 0 && idx < word.len())\n   |                                         \
    \   ^^^^^^^^^^\n   |                                            |\n   |      \
    \                                      expected `&usize`, found `usize`\n   |\
    \                                            help: consider borrowing here: `&word.len()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplhwlqy36.rs:27:2"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = [\"\"];\n    for ch in word.chars()\
    \ {\n        if ch.is_uppercase() && ch.is_vowel() {\n            vowels.push(ch);\n\
    \        }\n        if ch.is_lowercase() && ch.is_vowel() {\n            vowels.push(ch);\n\
    \        }\n    }\n    let mut vowels_iter = vowels.iter().rev();\n    vowels_iter.next();\n\
    \    let vowel = vowels_iter.next().unwrap();\n    vowel\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpq49h_li8.rs:14:36\n   |\n14 |         if ch.is_uppercase()\
    \ && ch.is_vowel() {\n   |                                    ^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `push` found for array\
    \ `[&str; 1]` in the current scope\n  --> /tmp/tmpq49h_li8.rs:15:20\n   |\n15\
    \ |             vowels.push(ch);\n   |                    ^^^^ method not found\
    \ in `[&str; 1]`\n\nerror[E0599]: no method named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpq49h_li8.rs:17:36\n   |\n17 |         if\
    \ ch.is_lowercase() && ch.is_vowel() {\n   |                                 \
    \   ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `push`\
    \ found for array `[&str; 1]` in the current scope\n  --> /tmp/tmpq49h_li8.rs:18:20\n\
    \   |\n18 |             vowels.push(ch);\n   |                    ^^^^ method\
    \ not found in `[&str; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq49h_li8.rs:24:5\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    24 |     vowel\n   |     ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&&str`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    if word.len()\
    \ < 3 || word.len() > len(vowels) {\n        return \"\";\n    }\n    let mut\
    \ current_index = 0;\n    let mut vowels_iter = vowels.chars().nth(word.len()\
    \ - 1).unwrap().unwrap();\n    let mut current_vowel = vowels_iter;\n    if vowels_iter.starts_with(current_vowel)\
    \ {\n        current_vowel = vowels_iter.next();\n    }\n    for (i, ch) in word.chars().enumerate()\
    \ {\n        if vowels_iter.contains(ch) {\n            current_vowel = vowels_iter;\n\
    \            current_index = i;\n            break;\n        }\n    }\n    return\
    \ current_vowel.to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp5l5fnrii.rs:13:39\n\
    \   |\n13 |     if word.len() < 3 || word.len() > len(vowels) {\n   |        \
    \                               ^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5l5fnrii.rs:14:16\n   |\n11 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n14 |         return \"\";\n   |      \
    \          ^^- help: try using a conversion method: `.to_string()`\n   |     \
    \           |\n   |                expected struct `String`, found `&str`\n\n\
    error[E0599]: no method named `unwrap` found for type `char` in the current scope\n\
    \  --> /tmp/tmp5l5fnrii.rs:17:71\n   |\n17 |     let mut vowels_iter = vowels.chars().nth(word.len()\
    \ - 1).unwrap().unwrap();\n   |                                              \
    \                         ^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_count = 0;\n    let mut index = 0;\n\n\
    \    while index < word.len() {\n        if word[index] == 'a' || word[index]\
    \ == 'e' || word[index] == 'i' || word[index] == 'o' || word[index] == 'u' {\n\
    \            vowel_count = vowel_count + 1;\n        }\n\n        index = index\
    \ + 1;\n    }\n\n    if word.len() == vowel_count {\n        return \"\".to_string();\n\
    \    }\n\n    let mut vowel_index = vowel_count - 1;\n    while vowel_index >=\
    \ 0 {\n        if word.len() == vowel_count {\n            return \"\".to_string();\n\
    \        }\n        if word[vowel_index] == 'a' || word[vowel_index] == 'e' ||\
    \ word[vowel_index] == 'i' || word[vowel_index] == 'o' || word[vowel_index] ==\
    \ 'u' {\n            return word[vowel_index].to_string();\n        }\n      \
    \  vowel_index = vowel_index - 1;\n    }\n    return \"\".to_string();\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy0wgrxe4.rs:16:12\n\
    \   |\n16 |         if word[index] == 'a' || word[index] == 'e' || word[index]\
    \ == 'i' || word[index] == 'o' || word[index] == 'u' {\n   |            ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy0wgrxe4.rs:16:34\n   |\n16 |         if word[index] == 'a' ||\
    \ word[index] == 'e' || word[index] == 'i' || word[index] == 'o' || word[index]\
    \ == 'u' {\n   |                                  ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy0wgrxe4.rs:16:56\n   |\n16 |         if word[index] == 'a' ||\
    \ word[index] == 'e' || word[index] == 'i' || word[index] == 'o' || word[index]\
    \ == 'u' {\n   |                                                        ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as I"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = \"a\"; // a is always considered as\
    \ vowel before finding any vowel that is consonant from right side of word.\n\
    \    let mut vowel_position = word.len();\n    let mut consonant_position = word.len()\
    \ - 1;\n    let mut consonant_index = consonant_position;\n    while consonant_index\
    \ > 0 {\n        if word[consonant_index] >= 'a' && word[consonant_index] <= 'z'\
    \ {\n            vowel = &word[vowel_position - 1] as String;\n            break;\n\
    \        } else if word[consonant_index] >= 'A' && word[consonant_index] <= 'Z'\
    \ {\n            vowel = &word[vowel_position - 1] as String;\n            break;\n\
    \        }\n        consonant_index -= 1;\n    }\n\n    while consonant_position\
    \ > 0 {\n        if word[consonant_position] >= 'A' && word[consonant_position]\
    \ <= 'Z' {\n            vowel = &word[vowel_position - 1] as String;\n       \
    \     break;\n        }\n        consonant_position -= 1;\n    }\n    vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn2przgja.rs:17:12\n\
    \   |\n17 |         if word[consonant_index] >= 'a' && word[consonant_index] <=\
    \ 'z' {\n   |            ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn2przgja.rs:17:44\n   |\n17 |         if word[consonant_index]\
    \ >= 'a' && word[consonant_index] <= 'z' {\n   |                             \
    \               ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn2przgja.rs:18:21\n\
    \   |\n12 |     let mut vowel = \"a\"; // a is always considered as vowel before\
    \ finding any vowel that is consonant from right side of word.\n   |         \
    \            --- expected due to this value\n...\n18 |             vowel = &word[vowel_position\
    \ - 1] as String;\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&(&word[vowel_position\
    \ - 1] "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowel = word.chars().filter(|&i| \n        i !=\
    \ 'a' && i != 'e' && i != 'i' && i != 'o' && i != 'u').next()\n        .unwrap();\n\
    \    word.chars().skip_while(|&i| \n        i != 'a' && i != 'e' && i != 'i' &&\
    \ i != 'o' && i != 'u').take_while(|&i| \n        i != 'a' && i != 'e' && i !=\
    \ 'i' && i != 'o' && i != 'u')\n        .filter_map(|i| if i == vowel { Some(0)\
    \ } else { None })\n        .next().unwrap();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp496ow0pw.rs:11:39\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    for i in word.rsplitn(2, 'a') {\n        if vowels.contains(&i.last().unwrap())\
    \ {\n            return i.last().unwrap();\n        }\n    }\n    return \"\"\
    ;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `&str` is not an iterator\n  --> /tmp/tmpi5rjde33.rs:14:31\n\
    \   |\n14 |         if vowels.contains(&i.last().unwrap()) {\n   |           \
    \                    ^^^^ `&str` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `&str: Iterator`\n           which is required by `&mut &str: Iterator`\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `&str` is not an iterator\n  --> /tmp/tmpi5rjde33.rs:15:22\n \
    \  |\n15 |             return i.last().unwrap();\n   |                      ^^^^\
    \ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `&str: Iterator`\n\
    \           which is required by `&mut &str: Iterator`\n           `str: Iterator`\n\
    \           which is required by `&mut str: Iterator`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    let mut\
    \ word = word.to_lowercase();\n    let mut vowels_index = -1;\n    let mut vowels_char:\
    \ Char = vowels.to_lowercase()[0];\n    let mut consonants_index = -1;\n    let\
    \ mut consonants_char: Char = \"bcdhjmnpqrstvxz\".to_lowercase()[0];\n\n    while\
    \ vowels_index < vowels.len() - 1 && consonants_index < \"bcdhjmnpqrstvxz\".to_lowercase().len()\
    \ - 1 {\n        if word.chars().any(|c| c != consonants_char) {\n           \
    \ vowels_index += 1;\n            consonants_index += 1;\n        } else {\n \
    \           vowels_index += 1;\n        }\n        if word.chars().any(|c| c !=\
    \ vowels_char) {\n            consonants_index += 1;\n        } else {\n     \
    \       consonants_index += 1;\n        }\n        vowels_char = vowels.to_lowercase()[vowels_index];\n\
    \        consonants_char = consonants.to_lowercase()[consonants_index];\n    }\n\
    \    if vowels_index < vowels.len() - 1 {\n        vowels.to_lowercase()[vowels_index]\n\
    \    } else if consonants_index < \"bcdhjmnpqrstvxz\".to_lowercase().len() - 1\
    \ {\n        consonants.to_lowercase()[consonants_index]\n    } else {\n     \
    \   \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpos59q3le.rs:15:26\n\
    \   |\n15 |     let mut vowels_char: Char = vowels.to_lowercase()[0];\n   |  \
    \                        ^^^^ help: a builtin type with a similar name exists\
    \ (notice the capitalization): `char`\n\nerror[E0412]: cannot find type `Char`\
    \ in this scope\n  --> /tmp/tmpos59q3le.rs:17:30\n   |\n17 |     let mut consonants_char:\
    \ Char = \"bcdhjmnpqrstvxz\".to_lowercase()[0];\n   |                        \
    \      ^^^^ help: a builtin type with a similar name exists (notice the capitalization):\
    \ `char`\n\nerror[E0425]: cannot find value `consonants` in this scope\n  -->\
    \ /tmp/tmpos59q3le.rs:32:27\n   |\n32 |         consonants_char = consonants.to_lowercase()[consonants_index];\n\
    \   |                           ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmpos59q3le.rs:37:9\n\
    \   |\n37 |         consonants.to_lowercase()[consonants_index]\n   |        \
    \ ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmpos59q3le.rs:15:33\n   |\n15 |     let\
    \ mut vowels_char: Char = vowels.to_lowercase()[0];\n   |                    \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpos59q3le.rs:17:37\n   |\n17 |     let mut consonants_char: Char\
    \ = \"bcdhjmnpqrstvxz\".to_lowercase()[0];\n   |                             \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\".to_string();\n    let vowel\
    \ = word.chars().rev()\n        .skip_while(|c| c != 'A' || c != 'E' || c != 'I'\
    \ || c != 'O' || c != 'U')\n        .take_while(|c| c != 'a' || c != 'e' || c\
    \ != 'i' || c != 'o' || c != 'u')\n        .find(|c| vowels.contains(c.to_string()))\n\
    \        .unwrap();\n    let vowel_pos = word.chars().skip_while(|c| c != 'A'\
    \ || c != 'E' || c != 'I' || c != 'O' || c != 'U').find(|c| vowels.contains(c.to_string())).unwrap();\n\
    \    let mut vowel_left = word.chars().take_while(|c| c != 'A' || c != 'E' ||\
    \ c != 'I' || c != 'O' || c != 'U').find(|c| vowels.contains(c.to_string())).unwrap();\n\
    \    vowel_left.cmp(&vowel_pos)\n        .unwrap()\n        .unwrap_or(-1)\n \
    \       .to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3m0v94a3.rs:14:27\n\
    \   |\n14 |         .skip_while(|c| c != 'A' || c != 'E' || c != 'I' || c != 'O'\
    \ || c != 'U')\n   |                           ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp3m0v94a3.rs:14:39\n   |\n14\
    \ |         .skip_while(|c| c != 'A' || c != 'E' || c != 'I' || c != 'O' || c\
    \ != 'U')\n   |                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3m0v94a3.rs:14:51\n\
    \   |\n14 |         .skip_while(|c| c != 'A' || c != 'E' || c != 'I' || c != 'O'\
    \ || c != 'U')\n   |                                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3m0v94a3.rs:14:63\n\
    \   |\n14 |         .skip_while(|c| c != 'A' || c != 'E' || c != 'I' || c != 'O'\
    \ || c != 'U')\n   |                                                         \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3m0v94a3.rs:14:75\n\
    \   |\n14 |         .skip_while(|c| c != 'A' || c != 'E' || c != 'I' || c != 'O'\
    \ || c != 'U')\n   |                                                         \
    \                  ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&cha"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![];\n    let mut char_iter\
    \ = word.char_indices();\n    let mut letter_iter = char_iter.next();\n    while\
    \ let Some(Some(idx)) = letter_iter {\n        let char = &word[idx];\n      \
    \  if let Some(vowel) = char.chars().filter(|c| *c >= 'a' && *c <= 'z').next()\
    \ {\n            if vowels.contains(&vowel) {\n                break;\n      \
    \      }\n            vowels.push(vowel);\n            letter_iter = char_iter.next();\n\
    \        } else {\n            break;\n        }\n    }\n    vowels.sort_unstable_by_key(|&x|\
    \ *x);\n    vowels.iter().next().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmp37v6mr.rs:15:20\n   |\n\
    15 |     while let Some(Some(idx)) = letter_iter {\n   |                    ^^^^^^^^^\
    \    ----------- this expression has type `Option<(usize, char)>`\n   |      \
    \              |\n   |                    expected tuple, found enum `Option`\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found enum `Option<_>`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n    --> /tmp/tmpmp37v6mr.rs:27:33\n     |\n27   |     vowels.sort_unstable_by_key(|&x|\
    \ *x);\n     |            -------------------- ^^^^^^^ doesn't have a size known\
    \ at compile-time\n     |            |\n     |            required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable_by_key`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmp37v6mr.rs:28:5\n   |\n11 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n...\n28 |     vowels.iter().next().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |     |\n   |     expected struct `String`, found `&&str`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().filter(|c| c != 'a' && c != 'e' && c !=\
    \ 'i' && c != 'o' && c != 'u').fold(String::new(), |memo, item| {\n        let\
    \ vowel = if item == 'a' { |c| c != 'e' && c != 'i' && c != 'o' && c != 'u' }\n\
    \        else { |c| c != 'e' && c != 'i' && c != 'o' && c != 'u' }\n        memo.iter_mut().take_while(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').take(vowel.len()).collect::<String>().unwrap_or(\"\
    \")\n    })\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `memo`\n  --> /tmp/tmpmz3mnfma.rs:14:66\n  \
    \ |\n14 | ...   else { |c| c != 'e' && c != 'i' && c != 'o' && c != 'u' }\n  \
    \ |                                                                ^ help: add\
    \ `;` here\n15 | ...   memo.iter_mut().take_while(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u').take(vowel.len()).collect::<String>().unwr...\n\
    \   |       ---- unexpected token\n\nerror[E0277]: can't compare `&char` with\
    \ `char`\n  --> /tmp/tmpmz3mnfma.rs:12:31\n   |\n12 |     word.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').fold(String::new(),\
    \ |memo, item| {\n   |                               ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmz3mnfma.rs:12:43\n\
    \   |\n12 |     word.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c\
    \ != 'o' && c != 'u').fold(String::new(), |memo, item| {\n   |               \
    \                            ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpmz3mnfma.rs:12:55\n   |\n12 |     word.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').fold(String::new(),\
    \ |memo, item| {\n   |                                                       ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmz3mnfma.rs:12:67\n\
    \   |\n12 |     word.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c\
    \ != 'o' && c != 'u').fold(String::new(), |memo, item| {\n   |               \
    \                                                    ^^ no implementation for\
    \ `&char == char`\n   |\n   = help"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    // Write your code here\n    let mut vowels:\
    \ Vec<Char> = vec!['a','e','i','o','u'];\n    let mut consonants: Vec<Char> =\
    \ vec!['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z'];\n\
    \    let mut count: usize = 0;\n    word.chars().filter(|char| consonants.contains(char)).cloned().for_each(|con|\
    \ {\n        vowels.filter(|char| char == con).cloned().for_each(|vowel| {\n \
    \           if word.ends_with(vowel) {\n                count++;\n           \
    \ }\n        });\n    });\n    vowels[count - 1].to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpbv12d1p4.rs:20:22\n\
    \   |\n20 |                 count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |               \
    \  { let tmp = count; count += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n20 -                 count++;\n20 +                 count\
    \ += 1;\n   | \n\nerror[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpbv12d1p4.rs:14:25\n\
    \   |\n14 |     let mut vowels: Vec<Char> = vec!['a','e','i','o','u'];\n   | \
    \                        ^^^^\n   |\nhelp: a builtin type with a similar name\
    \ exists\n   |\n14 |     let mut vowels: Vec<char> = vec!['a','e','i','o','u'];\n\
    \   |                         ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n11 | fn get_closest_vowel<Char>(word: String) -> String {\n   |       \
    \              ++++++\n\nerror[E0412]: cannot find type `Char` in this scope\n\
    \  --> /tmp/tmpbv12d1p4.rs:15:29\n   |\n15 |     let mut consonants: Vec<Char>\
    \ = vec!['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z'];\n\
    \   |                             ^^^^\n   |\nhelp: a builtin type with a similar\
    \ name exists\n   |\n15 |     let mut consonants: Vec<char> = vec!['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z'];\n\
    \   |                             ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n11 | fn get_closest_vowel<Char>(word: String) -> String {\n   |       \
    \              ++++++\n\nerror[E0271]: type mismatch resolving `<Filter<Chars<'_>,\
    \ [closure@/tmp/tmpbv12d1p4.rs:17:25: 17:57]> as Iterator>::Item == &_`\n    -->\
    \ /tmp/tmpbv12d1p4.rs:17:59\n     |\n17   |     word.chars().filter(|char| consonants.contains(char)).cloned().for_each(|con|\
    \ {\n     |                                                           ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `for_each` exists for struct `Clo"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = ['a', 'e', 'i', 'o', 'u'];\n    let\
    \ vowels_count = word.len();\n    let mut i = word.len();\n\n    while i >= 0\
    \ {\n        if word.chars().all(|c| vowels.contains(&c)) {\n            vowels\
    \ = vowels.iter().cloned().collect();\n            vowels.retain(|c| c != 'a');\n\
    \            vowels.retain(|c| c != 'e');\n            vowels.retain(|c| c !=\
    \ 'i');\n            vowels.retain(|c| c != 'o');\n            vowels.retain(|c|\
    \ c != 'u');\n            vowels.retain(|c| c != 'A');\n            vowels.retain(|c|\
    \ c != 'E');\n            vowels.retain(|c| c != 'I');\n            vowels.retain(|c|\
    \ c != 'O');\n            vowels.retain(|c| c != 'U');\n            vowels.retain(|c|\
    \ c != 'a');\n            vowels.retain(|c| c != 'e');\n            vowels.retain(|c|\
    \ c != 'i');\n            vowels.retain(|c| c != 'o');\n            vowels.retain(|c|\
    \ c != 'u');\n            vowels.retain(|c| c != 'A');\n            vowels.retain(|c|\
    \ c != 'E');\n            vowels.retain(|c| c != 'I');\n            vowels.retain(|c|\
    \ c != 'O');\n            vowels.retain(|c| c != 'U');\n        }\n        i -=\
    \ 1;\n    }\n\n    vowels.iter().cloned().collect::<String>().to_string()\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `retain` found for array `[char; 5]` in the\
    \ current scope\n  --> /tmp/tmphb56came.rs:19:20\n   |\n19 |             vowels.retain(|c|\
    \ c != 'a');\n   |                    ^^^^^^ method not found in `[char; 5]`\n\
    \nerror[E0277]: an array of type `[char; 5]` cannot be built directly from an\
    \ iterator\n    --> /tmp/tmphb56came.rs:18:45\n     |\n18   |             vowels\
    \ = vowels.iter().cloned().collect();\n     |                                \
    \             ^^^^^^^ try collecting into a `Vec<char>`, then using `.try_into()`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `[char;\
    \ 5]`\nnote: required by a bound in `collect`\n\nerror[E0599]: no method named\
    \ `retain` found for array `[char; 5]` in the current scope\n  --> /tmp/tmphb56came.rs:20:20\n\
    \   |\n20 |             vowels.retain(|c| c != 'e');\n   |                   \
    \ ^^^^^^ method not found in `[char; 5]`\n\nerror[E0599]: no method named `retain`\
    \ found for array `[char; 5]` in the current scope\n  --> /tmp/tmphb56came.rs:21:20\n\
    \   |\n21 |             vowels.retain(|c| c != 'i');\n   |                   \
    \ ^^^^^^ method not found in `[char; 5]`\n\nerror[E0599]: no method named `retain`\
    \ found for array `[char; 5]` in the current scope\n  --> /tmp/tmphb56came.rs:22:20\n\
    \   |\n22 |             vowels.retain(|c| c != 'o');\n   |                   \
    \ ^^^^^^ method not found in `[char; 5]`\n\nerror[E0599]: no method named `retain`\
    \ found for array `[char; 5]` in the current scope\n  --> /tmp/tmphb56came.rs:23:20\n\
    \   |\n23 |             vowels.retain(|c| c != 'u');\n   |                   \
    \ ^^^^^^ method not found in `[char; 5]`\n\nerror[E0599]: no method named `retain`\
    \ found for array `[char; 5]` in the current scope\n  --> /tmp/tmphb56came.rs:24:20\n\
    \   |\n24 |             vowels.retain(|c| c != 'A');\n   |                   \
    \ ^^^^^^ method not found in `[char; 5]`\n\nerror[E0599]: no method named `retain`\
    \ found for array `[char; 5]` in the current scope\n  --> /tmp/tmphb56came.rs:25:20\n\
    \   |\n25 |             vowels.retain(|c| c != 'E');\n   |                   \
    \ ^^^^^^ met"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code here\n    let mut consonants = String::new();\n\
    \    for char in word.chars() {\n        if char == 'a' || char == 'e' || char\
    \ == 'i' || char == 'o' || char == 'u' {\n            consonants.push_str(char.to_string());\n\
    \        }\n    }\n    if consonants.len() < 2 { return String::new(); }\n   \
    \ let mut vowels = String::new();\n    for char in consonants.chars() {\n    \
    \    if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u'\
    \ {\n            vowels.push_str(char.to_string());\n        }\n    }\n    if\
    \ vowels.len() < 2 { return String::new(); }\n    if vowels.len() > 2 { return\
    \ String::new(); }\n    if vowels.len() == 1 {\n        return vowels.to_string();\n\
    \    }\n    let mut left_bound = word;\n    let mut right_bound = word;\n    let\
    \ mut i = 0;\n    for char in left_bound.chars() {\n        if char == 'a' ||\
    \ char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            left_bound\
    \ = &left_bound[..i].to_string();\n            right_bound = &right_bound[..i].to_string();\n\
    \            i += 1;\n        }\n    }\n    let mut closest_vowel: Option<String>\
    \ = None;\n    while i < left_bound.len() {\n        if left_bound[..left_bound.len()\
    \ - left_bound.len() - right_bound.len()].contains(&vowels[..vowels.len()]) {\n\
    \            closest_vowel = Some(vowels[..vowels.len()]);\n            break;\n\
    \        }\n        i += 1;\n    }\n    closest_vowel.unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplutx6set.rs:16:33\n   |\n\
    16 |             consonants.push_str(char.to_string());\n   |                \
    \                 ^^^^^^^^^^^^^^^^\n   |                                 |\n \
    \  |                                 expected `&str`, found struct `String`\n\
    \   |                                 help: consider borrowing here: `&char.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplutx6set.rs:23:29\n   |\n23 |\
    \             vowels.push_str(char.to_string());\n   |                       \
    \      ^^^^^^^^^^^^^^^^\n   |                             |\n   |            \
    \                 expected `&str`, found struct `String`\n   |               \
    \              help: consider borrowing here: `&char.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplutx6set.rs:36:26\n   |\n31 |     let mut left_bound\
    \ = word;\n   |                          ---- expected due to this value\n...\n\
    36 |             left_bound = &left_bound[..i].to_string();\n   |            \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n\
    \   |\nhelp: consider removing the borrow\n   |\n36 -             left_bound =\
    \ &left_bound[..i].to_string();\n36 +             left_bound = left_bound[..i].to_string();\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmplutx6set.rs:37:27\n  \
    \ |\n32 |     let mut right_bound = word;\n   |                           ----\
    \ expected due to this value\n...\n37 |             right_bound = &right_bound[..i].to_string();\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\nhelp: consider removing the borrow\n   |\n\
    37 -             right_bound = &right_bound[..i].to_string();\n37 +          \
    \   right_bound = right_bound[..i].to_string();\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplutx6set.rs:44:34\n   |\n44 |             closest_vowel\
    \ = Some(vowels[..vowels.len()]);\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                |\n   | "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    vowels.sort();\n    let vowel_pos = word.chars().zip(vowels.clone()).enumerate().collect::<Vec<_>>();\n\
    \    let mut last_consonant_pos = 0;\n    for (ref pos, ref consonant) in vowel_pos\
    \ {\n        if consonant != word[last_consonant_pos] {\n            last_consonant_pos\
    \ = pos;\n        }\n    }\n\n    let mut found_consonant_pos = 0;\n    let mut\
    \ min_diff = std::i32::MAX;\n    for (ref pos, ref consonant) in vowel_pos {\n\
    \        if consonant != word[found_consonant_pos] {\n            found_consonant_pos\
    \ = pos;\n        }\n        let diff = pos - found_consonant_pos;\n        if\
    \ diff < min_diff {\n            min_diff = diff;\n        }\n    }\n    vowels[min_diff]\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpedjswnsz.rs:17:25\n   |\n17 |         if consonant != word[last_consonant_pos]\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpedjswnsz.rs:18:34\n\
    \   |\n15 |     let mut last_consonant_pos = 0;\n   |                        \
    \          - expected due to this value\n...\n18 |             last_consonant_pos\
    \ = pos;\n   |                                  ^^^ expected integer, found `&usize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |             last_consonant_pos\
    \ = *pos;\n   |                                  +\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpedjswnsz.rs:25:25\n   |\n25\
    \ |         if consonant != word[found_consonant_pos] {\n   |                \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpedjswnsz.rs:26:35\n\
    \   |\n22 |     let mut found_consonant_pos = 0;\n   |                       \
    \          "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut s = String::new();\n    \n    for i in word.chars().skip(1).rev().peekable().skip(1).rev()\
    \ {\n        if let Some(vowel) = get_vowel(&i) {\n            if !s.starts_with(vowel)\
    \ {\n                s.push_str(vowel);\n            }\n        } else {\n   \
    \         break;\n        }\n    }\n    \n    s\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_vowel` in this scope\n  --> /tmp/tmp6_t64fzk.rs:15:30\n\
    \   |\n15 |         if let Some(vowel) = get_vowel(&i) {\n   |               \
    \               ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the trait bound\
    \ `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmp6_t64fzk.rs:14:35\n\
    \     |\n14   |     for i in word.chars().skip(1).rev().peekable().skip(1).rev()\
    \ {\n     |                                   ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Skip<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0599]: the\
    \ method `peekable` exists for struct `Rev<Skip<Chars<'_>>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp6_t64fzk.rs:14:41\n   |\n14 |        for i\
    \ in word.chars().skip(1).rev().peekable().skip(1).rev() {\n   |             \
    \                               ^^^^^^^^ method cannot be called on `Rev<Skip<Chars<'_>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Skip<Chars<'_>>: DoubleEndedIterator`\n   \
    \        which is required by `Rev<Skip<Chars<'_>>>: Iterator`\n           `Rev<Skip<Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut Rev<Skip<Chars<'_>>>: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Write your code here\n    let mut vowels: Vec<&str>\
    \ = Vec::new();\n    vowels.push(\"a\");\n    vowels.push(\"e\");\n    vowels.push(\"\
    i\");\n    vowels.push(\"o\");\n    vowels.push(\"u\");\n    vowels.push(\"y\"\
    );\n    vowels.push(\"A\");\n    vowels.push(\"E\");\n    vowels.push(\"I\");\n\
    \    vowels.push(\"O\");\n    vowels.push(\"U\");\n    vowels.push(\"Y\");\n \
    \   vowels.sort_unstable_by_key(|s| s.chars().count());\n    let mut res = String::new();\n\
    \    for vowel in vowels {\n        if word.contains(&vowel) {\n            word.split_whitespace().last().unwrap().to_lowercase().split_ascii_lowercase().map(|c|\
    \ c).contains(vowel).unwrap_or(false)?\n                .resize(word.len(), |i,\
    \ j| {\n                    let mut res = String::new();\n                   \
    \ res.push_str(&word[i..j]);\n                    res.push_str(vowel);\n     \
    \               res\n                })\n                .unwrap_or(&\"\")\n \
    \       } else {\n            break;\n        }\n    }\n    res.to_lowercase()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_ascii_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmps4lf4nql.rs:30:68\n   |\n30 | \
    \            word.split_whitespace().last().unwrap().to_lowercase().split_ascii_lowercase().map(|c|\
    \ c).contains(vowel).unwrap_or(false)?\n   |                                 \
    \                                   ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0277]: the `?`\
    \ operator can only be used in a function that returns `Result` or `Option` (or\
    \ another type that implements `FromResidual`)\n  --> /tmp/tmps4lf4nql.rs:30:135\n\
    \   |\n11 | / fn get_closest_vowel(word: String) -> String {\n12 | |     // Write\
    \ your code here\n13 | |     let mut vowels: Vec<&str> = Vec::new();\n14 | | \
    \    vowels.push(\"a\");\n...  |\n30 | |             word.split_whitespace().last().unwrap().to_lowercase().split_ascii_lowercase().map(|c|\
    \ c).contains(vowel).unwrap_or(false)?\n   | |                               \
    \                                                                            \
    \                            ^ cannot use the `?` operator in a function that\
    \ returns `String`\n...  |\n42 | |     res.to_lowercase()\n43 | | }\n   | |_-\
    \ this function should return `Result` or `Option` to accept `?`\n   |\n   = help:\
    \ the trait `FromResidual<_>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = String::new();\n    let vowel_set =\
    \ vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\n    for c in word.chars().rposition(|&c|\
    \ c >= 'a' && c <= 'z') {\n        if vowel_set.contains(c) {\n            vowel\
    \ += c;\n            break;\n        }\n    }\n\n    if vowel.len() == 0 {\n \
    \       vowel\n    } else {\n        vowel\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpp0cza2sq.rs:15:27\n     |\n15   |     for c in word.chars().rposition(|&c|\
    \ c >= 'a' && c <= 'z') {\n     |                           ^^^^^^^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     = help:\
    \ the following other types implement trait `ExactSizeIterator`:\n           \
    \    &mut I\n               Args\n               ArgsOs\n               ArrayChunks<'_,\
    \ T, N>\n               ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_,\
    \ T, N>\n               Box<I, A>\n               Chunks<'_, T>\n            \
    \ and 109 others\nnote: required by a bound in `rposition`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp0cza2sq.rs:15:38\n   |\n15 |     for c in word.chars().rposition(|&c|\
    \ c >= 'a' && c <= 'z') {\n   |                                      ^--\n   |\
    \                                      ||\n   |                              \
    \        |expected due to this\n   |                                      expected\
    \ `char`, found reference\n   |                                      help: did\
    \ you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp0cza2sq.rs:16:31\n\
    \   |\n16 |         if vowel_set.contains(c) {\n   |                         \
    \      ^ expected `&&str`, found `usize`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpp0cza2sq.rs:17:22\n   |\n17 |             vowel += c;\n   |    \
    \                  ^ expected `&str`, found `usize`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rposition(|&c|c == 'A' || c == 'E' ||\
    \ c == 'I' || c == 'O' || c == 'U').unwrap_or(word.len())\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpy6xldyw3.rs:12:18\n     |\n12   |     word.chars().rposition(|&c|c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U').unwrap_or(word.len())\n\
    \     |                  ^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n     |\n     = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n               &mut I\n               Args\n         \
    \      ArgsOs\n               ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_,\
    \ T, N>\n               ArrayWindows<'_, T, N>\n               Box<I, A>\n   \
    \            Chunks<'_, T>\n             and 109 others\nnote: required by a bound\
    \ in `rposition`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy6xldyw3.rs:12:29\n\
    \   |\n12 |     word.chars().rposition(|&c|c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U').unwrap_or(word.len())\n   |                          \
    \   ^--\n   |                             ||\n   |                           \
    \  |expected due to this\n   |                             expected `char`, found\
    \ reference\n   |                             help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy6xldyw3.rs:12:5\n   |\n11 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n12 |     word.chars().rposition(|&c|c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U').unwrap_or(word.len())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n\n    let mut current_consonant_pos = word.rfind('a');\n   \
    \ let mut current_vowel_pos = word.rfind('a');\n\n    let mut is_first = true;\n\
    \    loop {\n        if current_consonant_pos == word.len() {\n            break;\n\
    \        }\n        if current_vowel_pos == word.len() {\n            break;\n\
    \        }\n        if word[current_consonant_pos - 1] == vowels[current_vowel_pos\
    \ - 1] {\n            if !is_first {\n                vowels.push(&vowels[current_vowel_pos\
    \ - 1]);\n                is_first = false;\n            }\n            current_consonant_pos--;\n\
    \            current_vowel_pos--;\n        }\n        else {\n            vowels.push(&vowels[current_vowel_pos\
    \ - 1]);\n            current_vowel_pos--;\n        }\n    }\n\n    if current_consonant_pos\
    \ < word.len() {\n        vowels.push(&vowels[current_vowel_pos - 1]);\n    }\n\
    \n    if current_vowel_pos < word.len() {\n        vowels.push(&vowels[current_vowel_pos\
    \ - 1]);\n    }\n\n    if current_consonant_pos < word.len() || current_vowel_pos\
    \ < word.len() {\n        return \"\".to_string();\n    }\n\n    let mut closest_vowel\
    \ = &vowels[word.rfind('a') - 1];\n    closest_vowel.push(&vowels[word.rfind('a')\
    \ + 1]);\n    closest_vowel.push(&vowels[word.rfind('e') + 1]);\n    closest_vowel.push(&vowels[word.rfind('i')\
    \ + 1]);\n    closest_vowel.push(&vowels[word.rfind('o') + 1]);\n    closest_vowel.push(&vowels[word.rfind('u')\
    \ + 1]);\n\n    for i in 0..closest_vowel.len() {\n        closest_vowel[i] =\
    \ &closest_vowel[i][0];\n    }\n\n    closest_vowel.join()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3ksogca2.rs:30:36\n\
    \   |\n30 |             current_consonant_pos--;\n   |                       \
    \             ^ expected expression\n\nerror: expected expression, found `;`\n\
    \  --> /tmp/tmp3ksogca2.rs:35:32\n   |\n35 |             current_vowel_pos--;\n\
    \   |                                ^ expected expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3ksogca2.rs:19:37\n   |\n19 |         if current_consonant_pos\
    \ == word.len() {\n   |                                     ^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |         if current_consonant_pos == Some(word.len()) {\n   |     \
    \                                +++++          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3ksogca2.rs:22:33\n   |\n22 |         if current_vowel_pos\
    \ == word.len() {\n   |                                 ^^^^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |         if current_vowel_pos == Some(word.len()) {\n   |         \
    \                        +++++          +\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `Option<usize>`\n  --> /tmp/tmp3ksogca2.rs:25:39\n   |\n25 |         if\
    \ word[current_consonant_pos - 1] == vowels[current_vowel_pos - 1] {\n   |   \
    \              --------------------- ^ - {integer}\n   |                 |\n \
    \  |                 Option<usize>\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `Option<usize>`\n  --> /tmp/tmp3ksogca2.rs:25:72\n   |\n25 |         if\
    \ word[current_consonant_pos - 1] == vowels[current_vowel_pos - 1] {\n   |   \
    \                                                   ----------------- ^ - {integer}\n\
    \   |                                                      |\n   |           \
    \                                           Option<usize>\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmp3ksogca2.rs:"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    \n    // let len\
    \ = word.len();\n    // let word_ends_vowel = word.chars().all(|x| vowels.contains(String::from(x)));\n\
    \    // let word_starts_vowel = word.chars().any(|x| vowels.contains(String::from(x)));\n\
    \    \n    // let starts_vowel = word.chars().any(|x| vowels.contains(String::from(x)));\n\
    \    // let ends_vowel = word.chars().all(|x| vowels.contains(String::from(x)));\n\
    \    let starts_vowel = word.chars().any(|x| vowels.contains(String::from(x)));\n\
    \    let ends_vowel = word.chars().all(|x| vowels.contains(String::from(x)));\n\
    \    \n    // let starts_vowel = word.chars().any(|x| vowels.contains(String::from(x)));\n\
    \    // let ends_vowel = word.chars().all(|x| vowels.contains(String::from(x)));\n\
    \    \n    if starts_vowel && ends_vowel {\n        // find vowel position\n \
    \       let vowel_pos = word.chars().rposition(|x| vowels.contains(String::from(x)));\n\
    \        // return if vowel position is inside string\n        if vowel_pos >=\
    \ 0 && vowel_pos < word.len() {\n            word.chars().position(|x| vowels.contains(String::from(x))\
    \ && x.is_uppercase())\n        } else {\n            return \"\".to_string();\n\
    \        }\n    } else {\n        return \"\".to_string();\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpqiig0qo8.rs:20:61\n     |\n20   |     let starts_vowel = word.chars().any(|x|\
    \ vowels.contains(String::from(x)));\n     |                                 \
    \                   -------- ^^^^^^^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                                                    |\n\
    \     |                                                    required by a bound\
    \ introduced by this call\n     |\n     = note: the trait bound `String: Pattern<'_>`\
    \ is not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider borrowing here\n     |\n20   |     let starts_vowel\
    \ = word.chars().any(|x| vowels.contains(&String::from(x)));\n     |         \
    \                                                    +\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmpqiig0qo8.rs:21:59\n\
    \     |\n21   |     let ends_vowel = word.chars().all(|x| vowels.contains(String::from(x)));\n\
    \     |                                                  -------- ^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \                             |\n     |                                      \
    \            required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::contains`\nhelp: consider borrowing\
    \ here\n     |\n21   |     let ends_vowel = word.chars().all(|x| vowels.contains(&String::from(x)));\n\
    \     |                                                           +\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpqiig0qo8.rs:28:38\n\
    \     |\n28   |         let vowel_pos = word.chars().rposition(|x| vowels.contains(String::from(x)));\n\
    \     |                        "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    vowels.sort();\n    let mut vowels_idx = vec![0];\n    let mut vowels_idx\
    \ = vec![0];\n    let mut idx = word.len() - 1;\n    let mut result = \"\";\n\
    \    while idx >= 0 && idx < word.len() - 1 {\n        if word[idx] == vowels[vowels_idx[vowels_idx].clone()]\n\
    \        {\n            vowels_idx[vowels_idx.len() - 1] = idx as usize;\n   \
    \     }\n        idx -= 1;\n    }\n    if vowels_idx[0] == 0 {\n        result\
    \ = \"\";\n    } else {\n        result = vowels[vowels_idx.len() - 1];\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4j_mxx9y.rs:19:12\n\
    \   |\n19 |         if word[idx] == vowels[vowels_idx[vowels_idx].clone()]\n \
    \  |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by `Vec<{integer}>`\n\
    \  --> /tmp/tmp4j_mxx9y.rs:19:32\n   |\n19 |         if word[idx] == vowels[vowels_idx[vowels_idx].clone()]\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `Vec<{integer}>`\n   = note: required because of the\
    \ requirements on the impl of `Index<Vec<{integer}>>` for `Vec<{integer}>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4j_mxx9y.rs:30:5\n   |\n11 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n...\n30 |     result\n\
    \   |     ^^^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \   |\n   |     expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut s = String::new();\n    for &c in word {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       let mut idx = 0;\n            while idx < word.len() && word.chars().nth(idx)\
    \ != c {\n                idx += 1;\n            }\n            s.push_str(&word.chars().nth(idx));\n\
    \        } else {\n            break;\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpt_m0_joq.rs:13:15\n\
    \   |\n13 |     for &c in word {\n   |               ^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't compare `Option<char>`\
    \ with `char`\n  --> /tmp/tmpt_m0_joq.rs:14:14\n   |\n14 |         if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n   |              ^^ no implementation\
    \ for `Option<char> == char`\n   |\n   = help: the trait `PartialEq<char>` is\
    \ not implemented for `Option<char>`\n   = help: the trait `PartialEq` is implemented\
    \ for `Option<T>`\n\nerror[E0277]: can't compare `Option<char>` with `char`\n\
    \  --> /tmp/tmpt_m0_joq.rs:14:26\n   |\n14 |         if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n   |                          ^^ no implementation\
    \ for `Option<char> == char`\n   |\n   = help: the trait `PartialEq<char>` is\
    \ not implemented for `Option<char>`\n   = help: the trait `PartialEq` is implemented\
    \ for `Option<T>`\n\nerror[E0277]: can't compare `Option<char>` with `char`\n\
    \  --> /tmp/tmpt_m0_joq.rs:14:38\n   |\n14 |         if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n   |                                   \
    \   ^^ no implementation for `Option<char> == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `Option<char>`\n   = help: the trait\
    \ `PartialEq` is implemented for `Option<T>`\n\nerror[E0277]: can't compare `Option<char>`\
    \ with `char`\n  --> /tmp/tmpt_m0_joq.rs:14:50\n   |\n14 |         if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n   |                    \
    \                              ^^ no implementation for `Option<char> == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `Option<char>`\n\
    \   = help: the trait `PartialEq` is implemented for `Option<T>`\n\nerror[E0277]:\
    \ can't compare `Option<char>` with `char`\n  --> /tmp/tmpt_m0_joq.rs:14:62\n\
    \   |\n14 |    "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code here\n    word.chars().filter(|c| c.to_ascii_lowercase()\
    \ == 'a' || c.to_ascii_lowercase() == 'e' || c.to_ascii_lowercase() == 'i' ||\
    \ c.to_ascii_lowercase() == 'o' || c.to_ascii_lowercase() == 'u').fold(\"\".to_string(),\
    \ |accum, c| {\n        \n        match accum {\n            \"\" => c.to_ascii_lowercase(),\n\
    \            _ => return \"\".to_string(),\n        }\n    });\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr148hoa2.rs:16:13\n   |\n\
    15 |         match accum {\n   |               ----- this expression has type\
    \ `String`\n16 |             \"\" => c.to_ascii_lowercase(),\n   |           \
    \  ^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr148hoa2.rs:16:19\n   |\n16 |             \"\" => c.to_ascii_lowercase(),\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                   |\n   |                   expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr148hoa2.rs:11:39\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n19 |     });\n   |       - help: remove this semicolon\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut ans = String::new();\n    for v in word.chars().skip(1).rev()\
    \ {\n        let lower = v.to_lowercase();\n        if lower.chars().any(|c| {\n\
    \            !c.is_uppercase() || c == c.to_lowercase()\n        }) {\n      \
    \      ans = ans.clone();\n            return ans;\n        }\n    }\n    ans.clone()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp9ff1ooxs.rs:13:35\n     |\n13   |     for v in word.chars().skip(1).rev()\
    \ {\n     |                                   ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Skip<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]: the\
    \ trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp9ff1ooxs.rs:13:14\n\
    \   |\n13 |     for v in word.chars().skip(1).rev() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n   |\n   =\
    \ help: the following other types implement trait `ExactSizeIterator`:\n     \
    \        &mut I\n             Args\n             ArgsOs\n             ArrayChunks<'_,\
    \ T, N>\n             ArrayChunksMut<'_, T, N>\n             ArrayWindows<'_,\
    \ T, N>\n             Box<I, A>\n             Chunks<'_, T>\n           and 109\
    \ others\n   = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Skip<Chars<'_>>`\n   = note: required because of the requirements on the\
    \ impl of `Iterator` for `Rev<Skip<Chars<'_>>>`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `Rev<Skip<Chars<'_>>>`\n\n\
    error[E0599]: no method named `chars` found for struct `ToLowercase` in the current\
    \ scope\n  --> /tmp/tmp9ff1ooxs.rs:15:18\n   |\n15 |         if lower.chars().any(|c|\
    \ {\n   |                  ^^^^^ method not found in `ToLowercase`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = \"a\".to_string();\n    let mut consonant\
    \ = \"z\".to_string();\n    let mut index = 0;\n    loop {\n        index = word.rfind(&consonant,\
    \ index);\n        if index == String::npos { return vowel.to_string() }\n   \
    \     index = word.rfind(&vowel, index);\n        if index == String::npos { return\
    \ vowel.to_string() }\n        let index = word.rfind(&vowel, index);\n      \
    \  if index == String::npos { return \"\".to_string() }\n        let index = word.rfind(&consonant,\
    \ index);\n        if index == String::npos { return \"\".to_string() }\n    \
    \    vowel = vowel.to_string();\n        consonant = consonant.to_string();\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmphow9ai1_.rs:16:22\n     |\n16   |         index = word.rfind(&consonant,\
    \ index);\n     |                      ^^^^^ ----------  ----- supplied 2 arguments\n\
    \     |                      |\n     |                      expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphow9ai1_.rs:16:17\n   |\n14 |     let mut index = 0;\n   |    \
    \                 - expected due to this value\n15 |     loop {\n16 |        \
    \ index = word.rfind(&consonant, index);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmphow9ai1_.rs:17:29\n\
    \   |\n17 |         if index == String::npos { return vowel.to_string() }\n  \
    \ |                             ^^^^ function or associated item not found in\
    \ `String`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were\
    \ supplied\n    --> /tmp/tmphow9ai1_.rs:18:22\n     |\n18   |         index =\
    \ word.rfind(&vowel, index);\n     |                      ^^^^^ ------  -----\
    \ supplied 2 arguments\n     |                      |\n     |                \
    \      expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphow9ai1_.rs:18:17\n   |\n14 |  \
    \   let mut index = 0;\n   |                     - expected due to this value\n\
    ...\n18 |         index = word.rfind(&vowel, index);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmphow9ai1_.rs:19:29\n\
    \   |\n19 |         if index == String::npos { return vowel.to_string() }\n  \
    \ |                             ^^^^ function or a"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  use std::cmp::min;\n  use std::cmp::Ordering;\n  let\
    \ vowel = \"AEIOUaeiou\";\n  let vowels = &vowel[..];\n  let vowel_idx = word.chars().fold(\n\
    \      0,\n      |i, &ch| {\n        let ch: char = ch.to_lowercase();\n     \
    \   match vowels.binary_search(&ch) {\n          Some(i) => i,\n          None\
    \ => i,\n        }\n      }\n  );\n  if vowel_idx >= word.chars().len() - 1 {\n\
    \    return \"\";\n  }\n  let vowel_chars = &vowel[vowel_idx + 1..];\n  let vowel_start\
    \ = word.chars().skip(vowel_idx).last();\n  let vowel_end = word.chars().skip(vowel_idx\
    \ + 1).first();\n  if vowel_chars.contains(&vowel[vowel_idx]) {\n    return if\
    \ vowel_start.cmp(&vowel_end) < 0 {\n      vowel\n    } else {\n      vowel.chars().last().unwrap()\n\
    \    };\n  } else {\n    let mut i = 0;\n    while i != word.chars().len() - 1\
    \ {\n      let ch: char = word[i as usize];\n      if !vowel_start.contains(&ch)\
    \ && !vowel_end.contains(&ch) && ch != vowel[vowel_idx] {\n        break;\n  \
    \    }\n      i += 1;\n    }\n    word.chars().skip(i).last().unwrap()\n  }\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::min`\n  --> /tmp/tmpl9qjs5dz.rs:12:7\n\
    \   |\n12 |   use std::cmp::min;\n   |       ^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nwarning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpl9qjs5dz.rs:13:7\n\
    \   |\n13 |   use std::cmp::Ordering;\n   |       ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl9qjs5dz.rs:18:11\n   |\n18 |       |i, &ch|\
    \ {\n   |           ^---\n   |           ||\n   |           |expected due to this\n\
    \   |           expected `char`, found reference\n   |           help: did you\
    \ mean `ch`: `&char`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror[E0599]: no method named `binary_search` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpl9qjs5dz.rs:20:22\n   |\n20 |   \
    \      match vowels.binary_search(&ch) {\n   |                      ^^^^^^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `len` found for\
    \ struct `Chars` in the current scope\n  --> /tmp/tmpl9qjs5dz.rs:26:32\n   |\n\
    26 |   if vowel_idx >= word.chars().len() - 1 {\n   |                        \
    \        ^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl9qjs5dz.rs:27:12\n   |\n11 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n27 |     return \"\";\n   |            ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |            |\n   |     \
    \       expected struct `String`, found `&str`\n\nerror[E0599]: no method named\
    \ `first` found for struct `Skip` in the current scope\n  --> /tmp/tmpl9qjs5dz.rs:31:52\n\
    \   |\n31 |   let vowel_end = word.chars().skip(vowel_idx + 1).first();\n   |\
    \                                                    ^^^^^ method not found in\
    \ `Skip<Chars<'_>>`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl9qjs5dz.rs:32:28\n   |\n32 |   if vowel_chars.contains(&vowel[vowel_idx])\
    \ {\n   |                            ^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = word.len() - 1;\n    \n    let\
    \ mut vowel = String::new();\n    \n    while vowel_index >= 0 && !is_vowel(vowel_index)\
    \ {\n        vowel.push(word[vowel_index]);\n        vowel_index -= 1;\n    }\n\
    \    \n    let mut vowel_index = vowel.len();\n    \n    while vowel_index >=\
    \ 0 && !is_vowel(vowel_index) {\n        vowel.push(word[vowel_index]);\n    \
    \    vowel_index -= 1;\n    }\n    \n    vowel.into_owned()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpu4iptz7b.rs:16:32\n\
    \   |\n16 |     while vowel_index >= 0 && !is_vowel(vowel_index) {\n   |     \
    \                           ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmpu4iptz7b.rs:23:32\n\
    \   |\n23 |     while vowel_index >= 0 && !is_vowel(vowel_index) {\n   |     \
    \                           ^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu4iptz7b.rs:17:20\n\
    \   |\n17 |         vowel.push(word[vowel_index]);\n   |                    ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu4iptz7b.rs:24:20\n   |\n24 |         vowel.push(word[vowel_index]);\n\
    \   |                    ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `into_owned` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpu4iptz7b.rs:28:11\n   |\n28 |     vowel.into_owned()\n\
    \   |           ^^^^^^^^^^ method not found in"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = word.len();\n    let mut vowel_count\
    \ = 0;\n    let mut min_vowel_length = word.len();\n    let mut found_vowel =\
    \ false;\n    \n    for con in word.chars() {\n        if !found_vowel && con\
    \ == char::from('a'..'z') {\n            found_vowel = true;\n            vowel_index\
    \ = word.chars().position(|c| c == con).unwrap();\n        }\n        if found_vowel\
    \ && con == char::from('a'..'z') {\n            vowel_count += 1;\n        }\n\
    \        if found_vowel && con == char::from('A'..'Z') {\n            vowel_count\
    \ += 1;\n        }\n        if vowel_count > min_vowel_length {\n            found_vowel\
    \ = false;\n            min_vowel_length = vowel_count;\n        }\n    }\n  \
    \  \n    match vowel_index {\n        Some(i) => word.chars()[i - min_vowel_length\
    \ + 1 .. i].unwrap(),\n        None => \"\",\n    }\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `char: From<std::ops::Range<char>>` is not\
    \ satisfied\n  --> /tmp/tmpjdr11ofa.rs:18:46\n   |\n18 |         if !found_vowel\
    \ && con == char::from('a'..'z') {\n   |                                   ----------\
    \ ^^^^^^^^ the trait `From<std::ops::Range<char>>` is not implemented for `char`\n\
    \   |                                   |\n   |                              \
    \     required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `From<u8>` is implemented for `char`\n\nerror[E0277]: the trait bound `char:\
    \ From<std::ops::Range<char>>` is not satisfied\n  --> /tmp/tmpjdr11ofa.rs:22:45\n\
    \   |\n22 |         if found_vowel && con == char::from('a'..'z') {\n   |    \
    \                              ---------- ^^^^^^^^ the trait `From<std::ops::Range<char>>`\
    \ is not implemented for `char`\n   |                                  |\n   |\
    \                                  required by a bound introduced by this call\n\
    \   |\n   = help: the trait `From<u8>` is implemented for `char`\n\nerror[E0277]:\
    \ the trait bound `char: From<std::ops::Range<char>>` is not satisfied\n  -->\
    \ /tmp/tmpjdr11ofa.rs:25:45\n   |\n25 |         if found_vowel && con == char::from('A'..'Z')\
    \ {\n   |                                  ---------- ^^^^^^^^ the trait `From<std::ops::Range<char>>`\
    \ is not implemented for `char`\n   |                                  |\n   |\
    \                                  required by a bound introduced by this call\n\
    \   |\n   = help: the trait `From<u8>` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjdr11ofa.rs:35:9\n   |\n34 |     match vowel_index\
    \ {\n   |           ----------- this expression has type `usize`\n35 |       \
    \  Some(i) => word.chars()[i - min_vowel_length + 1 .. i].unwrap(),\n   |    \
    \     ^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note: expected\
    \ type `usize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjdr11ofa.rs:36:9\n   |\n34 |     match vowel_index {\n\
    \   |           ----------- this expression has type `usize`\n35 |         Some(i)\
    \ => word.chars"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    let mut vowel = String::new();\n    \n    for\
    \ vowels in word.chars().skip(1) {\n        if vowels.is_uppercase() {\n     \
    \       vowel += vowels.to_lowercase();\n        }\n    }\n    vowel += word.chars().last().unwrap().to_lowercase();\n\
    \    \n    return vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc4m_6mml.rs:17:22\n   |\n\
    17 |             vowel += vowels.to_lowercase();\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc4m_6mml.rs:20:14\n   |\n20 |     vowel += word.chars().last().unwrap().to_lowercase();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found struct `ToLowercase`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().skip_while(|c| c >= 'A' && c <= 'Z').filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').enumerate().map(|(i,\
    \ c)| (i - 1) as usize).max_by(|i| {\n        if let Some(j) = (i - 1).wrapping_add(1).wrapping_add(-2)\n\
    \            && word[j..i].chars().all(|c| c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U')\n        {\n            return i;\n        }\n       \
    \ String::new()\n    }).map(|i| (word.len() - 1) - i as usize)\n    .unwrap_or(0)\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0658]: `let` expressions in this position are unstable\n  --> /tmp/tmpax6gcfp0.rs:13:12\n\
    \   |\n13 |         if let Some(j) = (i - 1).wrapping_add(1).wrapping_add(-2)\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax6gcfp0.rs:12:38\n\
    \   |\n12 |     word.chars().skip_while(|c| c >= 'A' && c <= 'Z').filter(|c| c\
    \ != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').enumerate().ma...\n\
    \   |                                      ^^^\n   |                         \
    \             |\n   |                                      expected `&char`, found\
    \ `char`\n   |                                      help: consider borrowing here:\
    \ `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax6gcfp0.rs:12:50\n\
    \   |\n12 |     word.chars().skip_while(|c| c >= 'A' && c <= 'Z').filter(|c| c\
    \ != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').enumerate().ma...\n\
    \   |                                                  ^^^\n   |             \
    \                                     |\n   |                                \
    \                  expected `&char`, found `char`\n   |                      \
    \                            help: consider borrowing here: `&'Z'`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpax6gcfp0.rs:12:68\n   |\n12\
    \ |     word.chars().skip_while(|c| c >= 'A' && c <= 'Z').filter(|c| c != 'a'\
    \ && c != 'e' && c != 'i' && c != 'o' && c != 'u').enumerate().ma...\n   |   \
    \                                                                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpax6gcfp0.rs:12:80\n\
    \   |\n12 |     word.chars().skip_while(|c| c >= 'A' && c <= 'Z').filter(|c| c\
    \ != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').enumerate().ma...\n\
    \   |                         "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let vowel_candidates: Vec<&str> = word\n        .chars()\n\
    \        .filter(|c| c.is_uppercase())\n        .filter(|c| vowels.iter().all(|c|\
    \ c.to_lowercase() == c))\n        .filter(|c| {\n            c != 'a' && c !=\
    \ 'e' && c != 'i' && c != 'o' && c != 'u'\n        })\n        .collect();\n \
    \   vowels.iter().cloned().filter(|c| vowel_candidates.iter().any(|c| c == &c)).last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&&str`\n  --> /tmp/tmpg797okva.rs:16:60\n\
    \   |\n16 |         .filter(|c| vowels.iter().all(|c| c.to_lowercase() == c))\n\
    \   |                                                            ^^ no implementation\
    \ for `String == &&str`\n   |\n   = help: the trait `PartialEq<&&str>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&char` with `char`\n \
    \ --> /tmp/tmpg797okva.rs:18:15\n   |\n18 |             c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u'\n   |               ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpg797okva.rs:18:27\n\
    \   |\n18 |             c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n\
    \   |                           ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpg797okva.rs:18:39\n   |\n18 |           \
    \  c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n   |            \
    \                           ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpg797okva.rs:18:51\n   |\n18 |           \
    \  c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = String::new();\n    let mut vowel_start\
    \ = String::new();\n    let mut vowel_end = String::new();\n    let mut vowel_previous\
    \ = String::new();\n    let mut vowel_next = String::new();\n    let mut consonant_start\
    \ = String::new();\n    let mut consonant_previous = String::new();\n    let mut\
    \ consonant_next = String::new();\n    \n    if word.len() >= 2 {\n        for\
    \ char in word.chars().rev() {\n            if char == 'a' || char == 'e' || char\
    \ == 'i' || char == 'o' || char == 'u'{\n                vowel.push(char);\n \
    \               \n                if char == 'a' {\n                    vowel_start.push('a');\n\
    \                    vowel_previous.push('a');\n                    vowel_next.push('a');\n\
    \                }\n                if char == 'e' {\n                    vowel_start.push('e');\n\
    \                    vowel_previous.push('e');\n                    vowel_next.push('e');\n\
    \                }\n                if char == 'i' {\n                    vowel_start.push('i');\n\
    \                    vowel_previous.push('i');\n                    vowel_next.push('i');\n\
    \                }\n                if char == 'o' {\n                    vowel_start.push('o');\n\
    \                    vowel_previous.push('o');\n                    vowel_next.push('o');\n\
    \                }\n                if char == 'u' {\n                    vowel_start.push('u');\n\
    \                    vowel_previous.push('u');\n                    vowel_next.push('u');\n\
    \                }\n            }\n            if char == 'A' || char == 'E' ||\
    \ char == 'I' || char == 'O' || char == 'U' {\n                vowel.push(char);\n\
    \                \n                if char == 'A' {\n                    vowel_start.push('A');\n\
    \                    vowel_previous.push('A');\n                    vowel_next.push('A');\n\
    \                }\n                if char == 'E' {\n                    vowel_start.push('E');\n\
    \                    vowel_previous.push('E');\n                    vowel_next.push('E');\n\
    \                }\n                if char == 'I' {\n                    vowel_start.push('I');\n\
    \                    vowel_previous.push('I');\n                    vowel_next.push('I');\n\
    \                }\n                if char == 'O' {\n                    vowel_start.push('O');\n\
    \                    vowel_previous.push('O');\n                    vowel_next.push('O');\n\
    \                }\n                if char == 'U' {\n                    vowel_start.push('U');\n\
    \                    vowel_previous.push('U');\n                    vowel_next.push('U');\n\
    \                }\n            }\n\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8_cqi_lf.rs:99:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n21 |     if word.len()\
    \ >= 2 {\n   |                        - unclosed delimiter\n22 |         for char\
    \ in word.chars().rev() {\n   |                                        - this\
    \ delimiter might not be properly closed...\n...\n82 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n99 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8_cqi_lf.rs:21:24\n   |\n21 |       if word.len()\
    \ >= 2 {\n   |  ________________________^\n22 | |         for char in word.chars().rev()\
    \ {\n23 | |             if char == 'a' || char == 'e' || char == 'i' || char ==\
    \ 'o' || char == 'u'{\n24 | |                 vowel.push(char);\n...  |\n98 |\
    \ |     assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    99 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 2 {\n        return \"\".to_string();\n\
    \    }\n    let mut vowels: Vec<String> = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowel_index = word.len();\n    let mut last_vowel = word.len()\
    \ - 1;\n    let mut vowel: String;\n\n    while vowel_index >= 0 && vowel_index\
    \ < word.len() && vowels[vowel_index] != word.chars().nth(vowel_index).unwrap().to_string()\
    \ {\n        vowel_index = vowel_index - 1;\n    }\n\n    vowel_index %= word.len();\n\
    \    vowel = vowels[vowel_index];\n    last_vowel = vowels.iter().position(|v|\
    \ v == vowel).unwrap();\n\n    if vowel_index > 0 && (vowel_index <= vowel.len()\
    \ || vowel.chars().nth(vowel_index - 1).unwrap() == word.chars().nth(last_vowel).unwrap())\
    \ {\n        return vowel.clone(); // U\n    }\n\n    if vowel_index < word.len()\
    \ - 1 && vowel.chars().nth(vowel_index + 1).unwrap() == word.chars().nth(last_vowel).unwrap()\
    \ {\n        return vowel.clone(); // U\n    }\n\n    return \"\".to_string();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2jgu5j1s.rs:15:40\n   |\n\
    15 |     let mut vowels: Vec<String> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n   |                                        ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                        |\n   |\
    \                                        expected struct `String`, found `&str`\n\
    \nerror[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmp2jgu5j1s.rs:26:47\n\
    \   |\n26 |     last_vowel = vowels.iter().position(|v| v == vowel).unwrap();\n\
    \   |                                               ^^ no implementation for `&String\
    \ == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut char = word.chars().nth(index);\n\
    \    while char != word.chars().nth(index) {\n        result = match char.to_ascii_lowercase().contains(&vowels)\
    \ {\n            true => char.to_ascii_lowercase().chars().nth(0),\n         \
    \   false => \"\".to_string(),\n        };\n        index--;\n        char = word.chars().nth(index);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpz765esys.rs:21:16\n\
    \   |\n21 |         index--;\n   |                ^ expected expression\n\nerror[E0599]:\
    \ no method named `to_ascii_lowercase` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpz765esys.rs:17:29\n   |\n17 |         result = match char.to_ascii_lowercase().contains(&vowels)\
    \ {\n   |                             ^^^^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\
    \nerror[E0599]: no method named `to_ascii_lowercase` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpz765esys.rs:18:26\n   |\n18 |             true\
    \ => char.to_ascii_lowercase().chars().nth(0),\n   |                         \
    \ ^^^^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = String::new();\n    let mut consonants\
    \ = String::new();\n    let mut index = 0;\n    let mut end = word.len();\n  \
    \  while index < end {\n        if let Some(current_consonant) = word.chars().position(|c|\
    \ c == consonants[index]) {\n            let current_vowel = word.chars().position(|c|\
    \ c == vowels[index]);\n            if let Some(current_vowel) = current_vowel\
    \ {\n                vowels.push_str(&vowels[index]);\n                consonants.push_str(&consonants[current_vowel\
    \ - current_consonant]);\n            } else {\n                vowels.push_str(&vowels[current_vowel]);\n\
    \            }\n        } else {\n            consonants.push_str(&consonants[index]);\n\
    \        }\n        index += 1;\n    }\n    vowels\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8fk1i0mc.rs:17:73\n\
    \   |\n17 |         if let Some(current_consonant) = word.chars().position(|c|\
    \ c == consonants[index]) {\n   |                                            \
    \                             ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8fk1i0mc.rs:18:64\n   |\n18 |             let current_vowel = word.chars().position(|c|\
    \ c == vowels[index]);\n   |                                                 \
    \               ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8fk1i0mc.rs:20:34\n\
    \   |\n20 |                 vowels.push_str(&vowels[index]);\n   |           \
    \                       ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeF"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut counter = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut vowels_len = 8;\n    let mut vowels_idx = 0;\n   \
    \ \n    while counter != word[vowels_idx + 1] && vowels_idx < word.len() {\n \
    \       if word[vowels_idx] == vowels[vowels_len] {\n            counter.push_str(vowels[vowels_len]);\n\
    \            vowels_len -= 1;\n            vowels_idx += 1;\n        } else {\n\
    \            vowels_len += 1;\n        }\n    }\n    \n    counter += &vowels[vowels_len];\n\
    \    \n    return counter\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp7h72cfwk.rs:17:22\n   |\n17 |     while counter != word[vowels_idx +\
    \ 1] && vowels_idx < word.len() {\n   |                      ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7h72cfwk.rs:18:12\n   |\n18 |         if word[vowels_idx] == vowels[vowels_len]\
    \ {\n   |            ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp7h72cfwk.rs:18:32\n   |\n18 |         if word[vowels_idx] == vowels[vowels_len]\
    \ {\n   |                                ^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ r"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut i = 0;\n    let mut j = 0;\n    let mut best_match\
    \ = 0;\n    let mut best_match_char: char;\n    let mut vowels = \"aeiou\";\n\n\
    \    while i < word.len() {\n        let c = word[i];\n        if vowels.contains(&c)\
    \ {\n            i += 1;\n            continue;\n        }\n        while j +\
    \ 1 < word.len() {\n            let c_j = word[j];\n            if vowels.contains(&c_j)\
    \ {\n                j += 1;\n                continue;\n            }\n     \
    \       if i == 0 {\n                if c_j.to_lowercase() == c.to_lowercase()\
    \ {\n                    best_match = j;\n                    best_match_char\
    \ = c_j;\n                }\n            } else {\n                if c_j.to_lowercase()\
    \ == c.to_lowercase() && c_j != best_match_char {\n                    best_match\
    \ = j;\n                    best_match_char = c_j;\n                }\n      \
    \      }\n            j += 1;\n        }\n        i += 1;\n    }\n    if best_match\
    \ == 0 {\n        return \"\".to_string();\n    }\n    let best_match_word = word.chars().nth(best_match).unwrap();\n\
    \    if best_match_char == c {\n        return best_match_word.to_string();\n\
    \    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpobbobidm.rs:49:27\n\
    \   |\n49 |     if best_match_char == c {\n   |                           ^ help:\
    \ a local variable with a similar name exists: `i`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpobbobidm.rs:19:17\n   |\n19 |  \
    \       let c = word[i];\n   |                 ^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpobbobidm.rs:25:23\n   |\n25 |             let c_j = word[j];\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().filter(|&(k, c)| c != 'a'\
    \ && c != 'e' && c != 'i' && c != 'o' && c != 'u').fold(\"\", |acc, &(_, c)| {\n\
    \        if c.is_uppercase() {\n            if acc.ends_with(vowel::ENGLISH) {\n\
    \                acc\n            } else {\n                acc + vowel::ENGLISH\n\
    \            }\n        } else {\n            if acc.ends_with(vowel::ENGLISH)\
    \ {\n                acc\n            } else {\n                acc + \"A\"\n\
    \            }\n        }\n    })\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `vowel`\n\
    \  --> /tmp/tmp4xj5ddlj.rs:14:30\n   |\n14 |             if acc.ends_with(vowel::ENGLISH)\
    \ {\n   |                              ^^^^^ use of undeclared crate or module\
    \ `vowel`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `vowel`\n  --> /tmp/tmp4xj5ddlj.rs:17:23\n   |\n17 |                 acc + vowel::ENGLISH\n\
    \   |                       ^^^^^ use of undeclared crate or module `vowel`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `vowel`\n \
    \ --> /tmp/tmp4xj5ddlj.rs:20:30\n   |\n20 |             if acc.ends_with(vowel::ENGLISH)\
    \ {\n   |                              ^^^^^ use of undeclared crate or module\
    \ `vowel`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xj5ddlj.rs:12:110\n\
    \   |\n12 |     word.chars().enumerate().filter(|&(k, c)| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u').fold(\"\", |acc, &(_, c)| {\n   |     \
    \                                                                            \
    \                             ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                                                        \
    \                                      |\n   |                               \
    \                                                                            \
    \   expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4xj5ddlj.rs:12:120\n   |\n12 |     word.chars().enumerate().filter(|&(k,\
    \ c)| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').fold(\"\", |acc,\
    \ &(_, c)| {\n   |                                                           \
    \                                                             ^^^^^^-\n   |  \
    \                                                                            \
    \                                          |     |\n   |                     \
    \                                                                            \
    \                       |     expected due to this\n   |                     \
    \                                    "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars()\n        .filter(|&c| c.is_vowel())\n\
    \        .rposition(|c| c.is_consonant())\n        .unwrap_or(0)\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmptuyk4c4n.rs:13:24\n   |\n13 |         .filter(|&c| c.is_vowel())\n\
    \   |                        ^^^^^^^^ method not found in `char`\n\nerror[E0277]:\
    \ the trait bound `Filter<Chars<'_>, [closure@/tmp/tmptuyk4c4n.rs:13:17: 13:34]>:\
    \ ExactSizeIterator` is not satisfied\n    --> /tmp/tmptuyk4c4n.rs:14:10\n   \
    \  |\n14   |         .rposition(|c| c.is_consonant())\n     |          ^^^^^^^^^\
    \ the trait `ExactSizeIterator` is not implemented for `Filter<Chars<'_>, [closure@/tmp/tmptuyk4c4n.rs:13:17:\
    \ 13:34]>`\n     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\nnote: required by a bound in `rposition`\n\n\
    error[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmptuyk4c4n.rs:14:26\n   |\n14 |         .rposition(|c| c.is_consonant())\n\
    \   |                          ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptuyk4c4n.rs:12:5\n   |\n11 |   fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                         ------ expected\
    \ `String` because of return type\n12 | /     word.chars()\n13 | |         .filter(|&c|\
    \ c.is_vowel())\n14 | |         .rposition(|c| c.is_consonant())\n15 | |     \
    \    .unwrap_or(0)\n   | |                     ^- help: try using a conversion\
    \ method: `.to_string()`\n   | |_____________________|\n   |                 \
    \      expected struct `String`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = HashSet::new();\n    let vowel_set\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    vowels.insert(vowel_set[0]);\n    for\
    \ &letter in &word[word.len() - 1].chars() {\n        if vowels.contains(&letter)\
    \ {\n            break;\n        }\n        for vowel in vowel_set {\n       \
    \     if word[word.len() - 1] == vowel {\n                vowels.insert(vowel);\n\
    \                break;\n            }\n        }\n    }\n    if word.len() ==\
    \ 0 {\n        \"\".to_string();\n    } else {\n        vowels.iter().next().unwrap().to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmppnz4rc4x.rs:12:22\n   |\n12 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppnz4rc4x.rs:15:21\n\
    \   |\n15 |     for &letter in &word[word.len() - 1].chars() {\n   |         \
    \            ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppnz4rc4x.rs:20:16\n\
    \   |\n20 |             if word[word.len() - 1] == vowel {\n   |             \
    \   ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnz4rc4x.rs:26:24\n\
    \   |\n26 |       if word.len() == 0 {\n   |  ________________________^\n27 |\
    \ |         \"\".to_string();\n   | |                       - help: remove this\
    \ semicolon\n28 | |     } else {\n   | |_____^ expected struct `String`, found\
    \ `()`\n\nerror: aborting due to 4 previous errors\n\nSome"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return \"\";\n    }\n\n\
    \    let mut vowel = \"u\".to_string();\n    let mut current_index = 0;\n    let\
    \ mut last_index = word.len() - 1;\n    while current_index <= last_index {\n\
    \        let vowel_index = word.chars().position(|c| *c == &vowel);\n        if\
    \ vowel_index == std::option::Option::Some {\n            current_index = vowel_index.unwrap()\
    \ + 1; // add 1 to skip the vowel before 'u'\n        } else {\n            current_index\
    \ -= 1;\n        }\n\n        let first_index = word.chars().position(|c| *c ==\
    \ &'a');\n        if first_index == std::option::Option::Some {\n            last_index\
    \ = first_index.unwrap() - 1;\n        } else {\n            last_index -= 1;\n\
    \        }\n    }\n\n    vowel.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd7_dyaj3.rs:13:16\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if word.len() < 3 {\n13 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpd7_dyaj3.rs:20:53\n   |\n20 |        \
    \ let vowel_index = word.chars().position(|c| *c == &vowel);\n   |           \
    \                                          ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd7_dyaj3.rs:21:27\n   |\n21 |         if vowel_index == std::option::Option::Some\
    \ {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found fn item\n   |\n   = note: expected enum `Option<usize>`\n           found\
    \ fn item `fn(_) -> Option<_> {Option::<_>::Some}`\nhelp: use parentheses to call\
    \ this function\n   |\n21 |         if vowel_index == std::option::Option::Some(...)\
    \ {\n   |                                                    +++++\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpd7_dyaj3.rs:27:53\n   |\n\
    27 |         let first_index = word.chars().position(|c| *c == &'a');\n   |  \
    \                                                   ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd7_dyaj3.rs:28:27\n   |\n28 |         if first_index ==\
    \ std::option::Option::Some {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found fn item\n   |\n   = note: expected enum `Option<usize>`\n\
    \           found fn item `fn(_) -> Option<_> {Option::<_>::Some}`\nhelp: use\
    \ parentheses to call this function\n   |\n28 |         if first_index == std::option::Option::Some(...)\
    \ {\n   |                                                    +++++\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().filter_map(|c| match c {\n        'a'..='z'\
    \ => Some(c as i32),\n        _ => None,\n    }).skip(1).take(word.len() - 1).collect::<Vec<_>>().enumerate().find(|(i,\
    \ c)| {\n        c < word.chars().last().unwrap() - 'a' as i32\n    })?.1.to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<i32>` is not an iterator\n   --> /tmp/tmpg3ch1811.rs:15:57\n\
    \    |\n15  |       }).skip(1).take(word.len() - 1).collect::<Vec<_>>().enumerate().find(|(i,\
    \ c)| {\n    |                                                           ^^^^^^^^^\
    \ `Vec<i32>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<i32>: Iterator`\n            which is\
    \ required by `&mut Vec<i32>: Iterator`\n            `[i32]: Iterator`\n     \
    \       which is required by `&mut [i32]: Iterator`\n\nerror[E0369]: cannot subtract\
    \ `i32` from `char`\n  --> /tmp/tmpg3ch1811.rs:16:42\n   |\n16 |         c < word.chars().last().unwrap()\
    \ - 'a' as i32\n   |             ---------------------------- ^ ---------- i32\n\
    \   |             |\n   |             char\n\nerror[E0277]: the `?` operator can\
    \ only be used in a function that returns `Result` or `Option` (or another type\
    \ that implements `FromResidual`)\n  --> /tmp/tmpg3ch1811.rs:17:7\n   |\n11 |\
    \ / fn get_closest_vowel(word: String) -> String {\n12 | |     word.chars().filter_map(|c|\
    \ match c {\n13 | |         'a'..='z' => Some(c as i32),\n14 | |         _ =>\
    \ None,\n...  |\n17 | |     })?.1.to_string()\n   | |       ^ cannot use the `?`\
    \ operator in a function that returns `String`\n18 | | }\n   | |_- this function\
    \ should return `Result` or `Option` to accept `?`\n   |\n   = help: the trait\
    \ `FromResidual<_>` is not implemented for `String`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().collect::<Vec<char>>()\n        .filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u'\n            &&\
    \ *c != 'A' && *c != 'E' && *c != 'I' && *c != 'O' && *c != 'U').cloned()\n  \
    \      .clone()\n        .iter()\n        .cloned()\n        .enumerate()\n  \
    \      .cloned()\n        .filter(|(_, c)| {\n            if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U' {\n                true\n            } else {\n    \
    \            false\n            }\n        }).map(|(_, c)| {\n            match\
    \ c {\n                'a' => \"a\",\n                'e' => \"e\",\n        \
    \        'i' => \"i\",\n                'o' => \"o\",\n                'u' =>\
    \ \"u\",\n                'A' => \"a\",\n                'E' => \"e\",\n     \
    \           'I' => \"i\",\n                'O' => \"o\",\n                'U'\
    \ => \"u\",\n                _ => \"\",\n            }\n        }).collect()\n\
    \        .iter()\n        .cloned()\n        .filter(|c| c.len() > 0)\n      \
    \  .cloned()\n        .enumerate()\n        .cloned()\n        .map(|(_, c)| c.to_string())\n\
    \        .collect()\n        .cloned()\n        .iter()\n        .cloned()\n \
    \       .map(|(_, c)| c.to_ascii_lowercase()).collect()\n        .cloned()\n \
    \       .iter()\n        .cloned()\n        .map(|(_, c)| c.to_ascii_lowercase())\n\
    \        .next()\n        .clone()\n        .unwrap()\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmpr9wl1epg.rs:13:10\n\
    \    |\n13  |           .filter(|c| *c != 'a' && *c != 'e' && *c != 'i' && *c\
    \ != 'o' && *c != 'u'\n    |            ^^^^^^ `Vec<char>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>: Iterator`\n\
    \            `[char]: Iterator`\n            which is required by `&mut [char]:\
    \ Iterator`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // let mut vowel_index = HashMap::new();\n    // vowel_index.insert(vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"].iter().cloned().collect::<Vec<_>>(), 0);\n  \
    \  let mut vowel_index: HashMap<Vec<char>, u32> = HashMap::new();\n    vowel_index.insert(vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"].iter().cloned().collect::<Vec<_>>(), 0);\n  \
    \  \n    for char in word[..word.rfind('a')] {\n        if let Some(index) = vowel_index.get(char)\
    \ {\n            vowel_index.entry(index).or_insert(0)\n        } else {\n   \
    \         break;\n        }\n    }\n    let mut first_index = vowel_index.entry(\"\
    a\").or_insert(0);\n    let mut second_index = vowel_index.entry(\"e\").or_insert(0);\n\
    \    let mut third_index = vowel_index.entry(\"i\").or_insert(0);\n    let mut\
    \ fourth_index = vowel_index.entry(\"o\").or_insert(0);\n    let mut fifth_index\
    \ = vowel_index.entry(\"u\").or_insert(0);\n    \n    if first_index > second_index\
    \ && first_index > third_index && first_index > fourth_index && first_index >\
    \ fifth_index {\n        if first_index != second_index && first_index != third_index\
    \ && first_index != fourth_index && first_index != fifth_index {\n           \
    \ return char.to_string();\n        }\n    }\n    return \"\";\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpfs8985sw.rs:14:26\n\
    \   |\n14 |     let mut vowel_index: HashMap<Vec<char>, u32> = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpfs8985sw.rs:14:52\n\
    \   |\n14 |     let mut vowel_index: HashMap<Vec<char>, u32> = HashMap::new();\n\
    \   |                                                    ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0423]: expected value, found builtin type `char`\n  --> /tmp/tmpfs8985sw.rs:32:20\n\
    \   |\n32 |             return char.to_string();\n   |                    ^^^^\
    \ not a value\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \  --> /tmp/tmpfs8985sw.rs:17:17\n   |\n17 |     for char in word[..word.rfind('a')]\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `RangeTo<Option<usize>>`\n   |\n   = help: the trait `Index<RangeTo<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0412, E0423, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    // Your code goes here\n    let vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowel_count = vec![String::new(); word.len()];\n    \n    for i\
    \ in 0..word.len() {\n        vowel_count[i] = word.chars().filter(|c| vowels.contains(c.to_lowercase())).count();\n\
    \        if vowel_count[i] > 2 {\n            return String::new();\n        }\n\
    \    }\n    let mut max_i = word.len() - 1;\n    let mut max_j = word.len() -\
    \ 1;\n    while max_i >= 0 {\n        while max_j >= 0 && vowel_count[max_j] >\
    \ 2 {\n            max_j -= 1;\n        }\n        if max_j >= 0 {\n         \
    \   max_i = max_j;\n            max_j = word.len() - 1;\n        } else {\n  \
    \          return String::new();\n        }\n    }\n    \n    return word.chars().filter(|c|\
    \ vowels.contains(c.to_lowercase())).last().to_string();\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `ToLowercase`\n\
    \    --> /tmp/tmpxv3b78ni.rs:18:66\n     |\n18   |         vowel_count[i] = word.chars().filter(|c|\
    \ vowels.contains(c.to_lowercase())).count();\n     |                        \
    \                                 -------- ^^^^^^^^^^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `ToLowercase`\n     |                                       \
    \                  |\n     |                                                 \
    \        required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `FnMut<(char,)>` is not implemented for `ToLowercase`\n     = help: the\
    \ following other types implement trait `Pattern<'a>`:\n               &'b String\n\
    \               &'b [char; N]\n               &'b [char]\n               &'b str\n\
    \               &'c &'b str\n               [char; N]\n               char\n \
    \              pattern::MultiCharEqPattern<C>\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `ToLowercase`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxv3b78ni.rs:18:26\n   |\n18 |         vowel_count[i] =\
    \ word.chars().filter(|c| vowels.contains(c.to_lowercase())).count();\n   |  \
    \       --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |        \
    \        |\n   |         |                expected struct `String`, found `usize`\n\
    \   |         expected due to the type of this binding\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxv3b78ni.rs:19:29\n   |\n19 |         if vowel_count[i]\
    \ > 2 {\n   |                             ^- help: try using a conversion method:\
    \ `.to_string()`\n   |                             |\n   |                   \
    \          expected struct `String`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxv3b78ni.rs:26:50\n   |\n26 |         while max_j >= 0\
    \ && vowel_count[max_j] > 2 {\n   |                                          \
    \        ^- help: try using a conv"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = &[\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    for i in 0..word.len() - 2 {\n        let lower = word[..i + 1].chars().collect::<Vec<char>>().join(\"\
    \");\n        let upper = word[i + 2..].chars().collect::<Vec<char>>().join(\"\
    \");\n        let start = word.chars().skip_while(|c| vowels.contains(&c.to_lowercase())).count();\n\
    \        let end = word.chars().skip_while(|c| vowels.contains(&c.to_lowercase())).count();\n\
    \        \n        if start < end && start < vowels.len() && end < vowels.len()\
    \ {\n            return vowels[start..end].join(\"\");\n        }\n    }\n\n \
    \   return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `join` exists for struct `Vec<char>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpv6ae6wvb.rs:14:66\n   |\n14 |\
    \         let lower = word[..i + 1].chars().collect::<Vec<char>>().join(\"\");\n\
    \   |                                                                  ^^^^ method\
    \ cannot be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\
    \nerror[E0599]: the method `join` exists for struct `Vec<char>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpv6ae6wvb.rs:15:66\n   |\n15 |     \
    \    let upper = word[i + 2..].chars().collect::<Vec<char>>().join(\"\");\n  \
    \ |                                                                  ^^^^ method\
    \ cannot be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv6ae6wvb.rs:16:65\n   |\n16 |\
    \         let start = word.chars().skip_while(|c| vowels.contains(&c.to_lowercase())).count();\n\
    \   |                                                                 ^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `ToLowercase`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&ToLowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv6ae6wvb.rs:17:63\n   |\n17 |         let end = word.chars().skip_while(|c|\
    \ vowels.contains(&c.to_lowercase())).count();\n   |                         \
    \                                      ^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ struct `ToLowercase`\n   |\n   = note: expected reference `&&str`\n        \
    \      found reference `&ToLowercase`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv6ae6wvb.rs:24:12\n   |\n11 | fn get_closest_vowel(word: String) ->\
    \ String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n24 |     return \"\";\n   |            ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |            |\n   |     \
    \       expected struct `Stri"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iterator = vowels.iter().cloned().peekable();\n\
    \    let mut vowels_iterator_end = vowels.iter().cloned().peekable();\n    vowels_iterator.skip(word.len()\
    \ - 1).peekable();\n\n    loop {\n        let vowel_str = word[vowels_iterator];\n\
    \        let vowel_index = (word.len() - 1) - vowels_iterator;\n        if vowel_str\
    \ != word[vowel_index] {\n            counter = 0;\n        }\n\n        counter++;\n\
    \        if counter == 2 {\n            vowels_iterator_end.peekable();\n    \
    \    }\n\n        match vowel_str {\n            \"a\" => vowels_iterator.peek(),\n\
    \            \"e\" => vowels_iterator_end.peek(),\n            \"i\" => vowels_iterator_end.peek(),\n\
    \            \"o\" => vowels_iterator_end.peek(),\n            \"u\" => vowels_iterator_end.peek(),\n\
    \            _ => break,\n        }\n        vowels_iterator.next();\n    }\n\
    \    return vowels_iterator.peek().unwrap();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpwd2thquu.rs:25:16\n\
    \   |\n25 |         counter++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n25 |         { let tmp = counter; counter\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n25 -  \
    \       counter++;\n25 +         counter += 1;\n   | \n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `Peekable<Cloned<std::slice::Iter<'_, &str>>>`\n\
    \  --> /tmp/tmpwd2thquu.rs:19:25\n   |\n19 |         let vowel_str = word[vowels_iterator];\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `Peekable<Cloned<std::slice::Iter<'_, &str>>>`\n   |\n   = help: the trait\
    \ `Index<Peekable<Cloned<std::slice::Iter<'_, &str>>>>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: cannot subtract `Peekable<Cloned<std::slice::Iter<'_,\
    \ &str>>>` from `usize`\n  --> /tmp/tmpwd2thquu.rs:20:44\n   |\n20 |         let\
    \ vowel_index = (word.len() - 1) - vowels_iterator;\n   |                    \
    \                        ^ no implementation for `usize - Peekable<Cloned<std::slice::Iter<'_,\
    \ &str>>>`\n   |\n   = help: the trait `Sub<Peekable<Cloned<std::slice::Iter<'_,\
    \ &str>>>>` is not implemented for `usize`\n   = help: the following other types\
    \ implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n          \
    \   <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n            \
    \ <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a\
    \ i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize\
    \ as Sub<isize>>\n           and 48 others\n\nwarning: unreachable statement\n\
    \  --> /tmp/tmpwd2thq"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars()\n        .skip_while(|c| !c.is_letter())\n\
    \        .skip_while(|c| c.is_whitespace() || c.is_digit())\n        .collect::<Vec<Char>>()\n\
    \        .iter()\n        .take_while(|c| !c.is_uppercase())\n        .enumerate()\n\
    \        .take_while(|(_, c)| c.is_lowercase())\n        .nth(0)\n        .unwrap_or(\"\
    \")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpku715qka.rs:15:24\n\
    \   |\n15 |         .collect::<Vec<Char>>()\n   |                        ^^^^\n\
    \   |\nhelp: a builtin type with a similar name exists\n   |\n15 |         .collect::<Vec<char>>()\n\
    \   |                        ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n11 | fn get_closest_vowel<Char>(word: String) -> String {\n   |       \
    \              ++++++\n\nerror[E0599]: no method named `is_letter` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpku715qka.rs:13:28\n   |\n13 |  \
    \       .skip_while(|c| !c.is_letter())\n   |                            ^^^^^^^^^\
    \ method not found in `&char`\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmpku715qka.rs:14:48\n    |\n14 \
    \ |         .skip_while(|c| c.is_whitespace() || c.is_digit())\n    |        \
    \                                        ^^^^^^^^- supplied 0 arguments\n    |\
    \                                                |\n    |                    \
    \                            expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0412, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: HashSet<char> = HashSet::new();\n \
    \   vowels.insert('a', 'A');\n    vowels.insert('e', 'E');\n    vowels.insert('i',\
    \ 'I');\n    vowels.insert('o', 'O');\n    vowels.insert('u', 'U');\n    let mut\
    \ consonants: HashSet<char> = HashSet::new();\n    consonants.insert('b', 'B');\n\
    \    consonants.insert('d', 'D');\n    consonants.insert('f', 'F');\n    consonants.insert('k',\
    \ 'K');\n    consonants.insert('m', 'M');\n    consonants.insert('n', 'N');\n\
    \    consonants.insert('p', 'P');\n    consonants.insert('s', 'S');\n    consonants.insert('t',\
    \ 'T');\n    consonants.insert('v', 'V');\n    consonants.insert('w', 'W');\n\
    \    consonants.insert('y', 'Y');\n    \n    let mut consonants_idx: usize = 0;\n\
    \    let mut vowels_idx: usize = 0;\n    let mut vowels_len: usize = vowels.len();\n\
    \    let mut consonants_len: usize = consonants.len();\n    let mut idx: usize\
    \ = 0;\n    while consonants_idx < consonants_len && vowels_idx < vowels_len {\n\
    \        if word[idx] == 'c' && consonants.contains(word[idx + 1]) {\n       \
    \     consonants_idx += 1;\n            idx += 2;\n        } else if word[idx]\
    \ == 'u' && vowels.contains(word[idx + 1]) {\n            vowels_idx += 1;\n \
    \           idx += 2;\n        } else {\n            idx += 1;\n        }\n  \
    \  }\n    return if consonants_idx == consonants_len { \"\" } else { vowels[consonants_idx]\
    \ }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp6ss96mpj.rs:12:21\n\
    \   |\n12 |     let mut vowels: HashSet<char> = HashSet::new();\n   |        \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp6ss96mpj.rs:12:37\n\
    \   |\n12 |     let mut vowels: HashSet<char> = HashSet::new();\n   |        \
    \                             ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n  --> /tmp/tmp6ss96mpj.rs:18:25\n\
    \   |\n18 |     let mut consonants: HashSet<char> = HashSet::new();\n   |    \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp6ss96mpj.rs:18:41\n\
    \   |\n18 |     let mut consonants: HashSet<char> = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6ss96mpj.rs:38:12\n\
    \   |\n38 |         if word[idx] == 'c' && consonants.contains(word[idx + 1])\
    \ {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6ss96mpj.rs:3"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() <= 1 {\n        return \"\"\n    }\n\
    \    let mut vowels = \"aeiouAEIOU\".to_string();\n    let vowel_set = vowels.chars().collect::<HashSet<char>>();\n\
    \    let mut pos = word.len() - 1;\n    while pos >= 0 && vowel_set.contains(&word[pos])\
    \ {\n        pos -= 1;\n    }\n    if pos == -1 {\n        return \"\".to_string()\n\
    \    }\n    let mut vowel_str = \"\";\n    word.chars().for_each(|c| {\n     \
    \   match c.to_string().to_ascii_lowercase().find(|c| vowel_set.contains(&c))\
    \ {\n            Some(i) => {\n                vowel_str += &vowels[i as usize];\n\
    \            },\n            None => {\n                break\n            }\n\
    \        }\n    });\n    return vowel_str\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp5hrs1z98.rs:16:46\n\
    \   |\n16 |     let vowel_set = vowels.chars().collect::<HashSet<char>>();\n \
    \  |                                              ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0267]: `break` inside of a closure\n  --> /tmp/tmp5hrs1z98.rs:31:17\n\
    \   |\n25 |     word.chars().for_each(|c| {\n   |                           ---\
    \ enclosing closure\n...\n31 |                 break\n   |                 ^^^^^\
    \ cannot `break` inside of a closure\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5hrs1z98.rs:13:16\n   |\n11 | fn get_closest_vowel(word: String) ->\
    \ String {\n   |                                       ------ expected `String`\
    \ because of return type\n12 |     if word.len() <= 1 {\n13 |         return \"\
    \"\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5hrs1z98.rs:18:43\n\
    \   |\n18 |     while pos >= 0 && vowel_set.contains(&word[pos]) {\n   |     \
    \                                      ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmp5hrs1z98.rs:21:15\n   |\n21 |     if pos == -1 {\n   |        \
    \       ^^\n   |               |\n   |               cannot apply unary operator\
    \ `-`\n   |               help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    for vowel in vowels.iter_mut() {\n        let mut word = word;\n  \
    \      let vowel_pos = word.rfind(&vowel);\n        if vowel_pos > 0 {\n     \
    \       if vowel_pos == word.len() - 1 {\n                word.split_whitespace().for_each(|c|\
    \ {\n                    *c = c.to_lowercase();\n                    if c.is_vowel()\
    \ {\n                        vowel.remove(0);\n                    }\n       \
    \         });\n            } else {\n                word.split_whitespace().for_each(|c|\
    \ {\n                    *c = c.to_lowercase();\n                    if c.is_vowel()\
    \ {\n                        vowel.remove(0);\n                    }\n       \
    \         });\n                vowel.remove(0);\n            }\n            if\
    \ word.len() == 0 {\n                return \"\";\n            }\n        }\n\
    \    }\n    vowels.into_iter().next().unwrap().to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `&mut &str`\n  -->\
    \ /tmp/tmp9db94eta.rs:15:36\n   |\n15 |         let vowel_pos = word.rfind(&vowel);\n\
    \   |                              ----- ^^^^^^\n   |                        \
    \      |     |\n   |                              |     expected an `Fn<(char,)>`\
    \ closure, found `&mut &str`\n   |                              |     help: consider\
    \ dereferencing here: `&*vowel`\n   |                              required by\
    \ a bound introduced by this call\n   |\n   = help: the trait `Fn<(char,)>` is\
    \ not implemented for `&mut &str`\n   = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&&mut &str`\n   = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&&mut &str`\n\nerror[E0277]:\
    \ expected a `Fn<(char,)>` closure, found `str`\n  --> /tmp/tmp9db94eta.rs:15:36\n\
    \   |\n15 |         let vowel_pos = word.rfind(&vowel);\n   |                \
    \              ----- ^^^^^^\n   |                              |     |\n   | \
    \                             |     expected an `Fn<(char,)>` closure, found `str`\n\
    \   |                              |     help: consider dereferencing here: `&*vowel`\n\
    \   |                              required by a bound introduced by this call\n\
    \   |\n   = help: the trait `Fn<(char,)>` is not implemented for `str`\n   = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&str`\n\
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&&mut &str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9db94eta.rs:16:24\n\
    \   |\n16 |         if vowel_pos > 0 {\n   |                        ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |         if vowel_pos > Some(0) {\n   |                        +++++\
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9db94eta.rs:17:29\n   |\n\
    17 |             if vowel_pos == word.len() - 1 {\n   |                      \
    \       ^^^^^^^^^^^^^^ e"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_iter = word.chars().rev().skip(1).filter(|&c|\
    \ {\n        c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' && c !=\
    \ 'I' && c != 'o' && c != 'O' && c != 'u' && c != 'U'\n    });\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n    vowel_iter.next().unwrap();\n\
    \    vowel_iter.next().unwrap();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqou12g5j.rs:11:39\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    let mut index = word.len();\n    let mut min_diff:\
    \ i32 = -100;\n    let mut max_diff: i32 = 100;\n    let mut vowels = vec!['u',\
    \ 'a', 'e', 'i', 'o', 'u', 'a', 'e', 'i', 'o', 'u', 'a', 'e', 'i', 'o', 'u', 'a'];\n\
    \    \n    // check all consonants\n    while index > 0 {\n        if word.starts_with(vowels[index\
    \ - 1]) {\n            let diff = word[index - 1].chars().count() - vowels[index\
    \ - 1].chars().count();\n            if diff < min_diff {\n                min_diff\
    \ = diff;\n            }\n        }\n        index--;\n    }\n\n    // check last\
    \ consonant\n    if word.ends_with(vowels[index]) {\n        let diff = word[index].chars().count()\
    \ - vowels[index].chars().count();\n        if diff < min_diff {\n           \
    \ min_diff = diff;\n        }\n    }\n    \n    // check all vowels\n    while\
    \ index > 0 {\n        if word.starts_with(vowels[index]) {\n            let diff\
    \ = vowels.count() - word.chars().count();\n            if diff < max_diff {\n\
    \                max_diff = diff;\n            }\n        }\n        index--;\n\
    \    }\n\n    // check last vowel\n    if word.ends_with(vowels[index]) {\n  \
    \      let diff = vowels.count() - word.chars().count();\n        if diff < max_diff\
    \ {\n            max_diff = diff;\n        }\n    }\n    \n    if min_diff >=\
    \ max_diff {\n        \"\"\n    } else {\n        vowels[min_diff .. max_diff\
    \ + 1].iter().cloned().collect::<String>().cloned()\n    }\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpjn0saa43.rs:26:16\n\
    \   |\n26 |         index--;\n   |                ^ expected expression\n\nerror:\
    \ expected expression, found `;`\n  --> /tmp/tmpjn0saa43.rs:45:16\n   |\n45 |\
    \         index--;\n   |                ^ expected expression\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjn0saa43.rs:21:24\n\
    \   |\n21 |             let diff = word[index - 1].chars().count() - vowels[index\
    \ - 1].chars().count();\n   |                        ^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpjn0saa43.rs:21:76\n   |\n21 |             let\
    \ diff = word[index - 1].chars().count() - vowels[index - 1].chars().count();\n\
    \   |                                                                        \
    \    ^^^^^ method not found in `char`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpjn0saa43.rs:31:20\n   |\n31 |         let\
    \ diff = word[index].chars().count() - vowels[index].chars().count();\n   |  \
    \                  ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Ra"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  word.chars().filter_map(|c| match c {\n    'a' .. 'z'\
    \ => Some(c.to_string()),\n    _ => None,\n  }).enumerate().filter(|(_, vowel)|\
    \ word.len() > vowel.len()).min(|(_, vowel)| vowel.len()).map(|(_, vowel)| vowel).unwrap_or(\"\
    \")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp2iju_fhp.rs:13:5\n\
    \   |\n13 |     'a' .. 'z' => Some(c.to_string()),\n   |     ^^^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0282]: type annotations needed for `(_, _)`\n\
    \  --> /tmp/tmp2iju_fhp.rs:15:69\n   |\n15 |   }).enumerate().filter(|(_, vowel)|\
    \ word.len() > vowel.len()).min(|(_, vowel)| vowel.len()).map(|(_, vowel)| vowel).unwrap_or(\"\
    \")\n   |                                                                    \
    \ ^^^^^^^^^^ consider giving this closure parameter the explicit type `(_, _)`,\
    \ with the type parameters specified\n   |\n   = note: type must be known at this\
    \ point\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp2iju_fhp.rs:15:64\n     |\n15   |   }).enumerate().filter(|(_,\
    \ vowel)| word.len() > vowel.len()).min(|(_, vowel)| vowel.len()).map(|(_, vowel)|\
    \ vowel).unwrap_or(\"\")\n     |                                             \
    \                   ^^^ ------------------------ supplied 1 argument\n     | \
    \                                                               |\n     |    \
    \                                                            expected 0 arguments\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2iju_fhp.rs:15:128\n   |\n15 |   }).enumerate().filter(|(_, vowel)|\
    \ word.len() > vowel.len()).min(|(_, vowel)| vowel.len()).map(|(_, vowel)| vowel).unwrap_or(\"\
    \")\n   |                                                                    \
    \                                                            ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \                                                                            \
    \                  |\n   |                                                   \
    \                                                                            \
    \ expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut min_len = word.len() as i32;\n    let mut min_index\
    \ = 0;\n\n    let mut min_len_i = min_len;\n    let mut min_i = min_index;\n\n\
    \    let mut min_len_j = min_len;\n    let mut min_j = min_index;\n\n    let mut\
    \ min_len_k = min_len;\n    let mut min_k = min_index;\n\n    for word in word.chars().skip(1)\
    \ {\n        let mut i = 1;\n        let mut j = 1;\n        let mut k = 1;\n\
    \        if word.chars().any(|&x| x == 'a') {\n            i = 0;\n        }\n\
    \        if word.chars().any(|&x| x == 'e') {\n            j = 0;\n        }\n\
    \        if word.chars().any(|&x| x == 'i') {\n            k = 0;\n        }\n\
    \        let len = word.len() as i32;\n        if min_len_i <= len {\n       \
    \     min_len_i = len;\n            min_i = i;\n        }\n        if min_len_j\
    \ <= len {\n            min_len_j = len;\n            min_j = j;\n        }\n\
    \        if min_len_k <= len {\n            min_len_k = len;\n            min_k\
    \ = k;\n        }\n\n    }\n    if min_len == 0 {\n        return String::new();\n\
    \    }\n    let mut min_len = min_len;\n    let mut min = min_index;\n    let\
    \ mut min_i = min_i;\n    let mut min_j = min_j;\n    let mut min_k = min_k;\n\
    \n    if min_len_i > min_len_j {\n        if min_len_i > min_len_k {\n       \
    \     if min_len_i > min_i {\n                if min_len_i > min_j {\n       \
    \             min_i = min_index;\n                    min_j = min_index;\n   \
    \             }\n                min = min_index;\n            }\n           \
    \ min = min_index;\n        }\n        if min_len_i > min_k {\n            min\
    \ = min_index;\n        }\n    }\n    if min_len_j > min_len_k {\n        if min_len_j\
    \ > min_i {\n            if min_len_j > min_j {\n                min = min_index;\n\
    \                min_i = min_index;\n                min_j = min_index;\n    \
    \        }\n            min = min_index;\n        }\n        if min_len_j > min_k\
    \ {\n            min = min_index;\n        }\n    }\n    if min_len_k > min_i\
    \ {\n        if min_len_k > min_j {\n            min = min_index;\n          \
    \  min_i = min_index;\n            min_j = min_index;\n        }\n        if min_len_k\
    \ > min_k {\n            min = min_index;\n        }\n    }\n    let mut min_len\
    \ = min_len;\n    let mut min = min_index;\n\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmppjmmowfr.rs:28:17\n   |\n28 |         if word.chars().any(|&x|\
    \ x == 'a') {\n   |                 ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmppjmmowfr.rs:31:17\n\
    \   |\n31 |         if word.chars().any(|&x| x == 'e') {\n   |               \
    \  ^^^^^ method not found in `char`\n\nerror[E0599]: no method named `chars` found\
    \ for type `char` in the current scope\n  --> /tmp/tmppjmmowfr.rs:34:17\n   |\n\
    34 |         if word.chars().any(|&x| x == 'i') {\n   |                 ^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `len` found for\
    \ type `char` in the current scope\n  --> /tmp/tmppjmmowfr.rs:37:24\n   |\n37\
    \ |         let len = word.len() as i32;\n   |                        ^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjmmowfr.rs:11:39\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: HashMap<String, String> = HashMap::new();\n\
    \    vowels.insert(\"a\".to_string(), \"u\".to_string());\n    vowels.insert(\"\
    i\".to_string(), \"u\".to_string());\n    vowels.insert(\"e\".to_string(), \"\
    i\".to_string());\n    vowels.insert(\"o\".to_string(), \"u\".to_string());\n\
    \    vowels.insert(\"u\".to_string(), \"u\".to_string());\n    let mut min_distance\
    \ = std::i32::MAX;\n    let mut closest_vowel = \"\";\n    \n    for letter in\
    \ word.chars().cloned().skip(word.len()) {\n        let distance = vowels.get(&letter).unwrap().len();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            closest_vowel = letter;\n        }\n    }\n    closest_vowel\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp98db7sx8.rs:12:21\n\
    \   |\n12 |     let mut vowels: HashMap<String, String> = HashMap::new();\n  \
    \ |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp98db7sx8.rs:12:47\n\
    \   |\n12 |     let mut vowels: HashMap<String, String> = HashMap::new();\n  \
    \ |                                               ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp98db7sx8.rs:21:32\n     |\n21   |     for letter in\
    \ word.chars().cloned().skip(word.len()) {\n     |                           \
    \     ^^^^^^ expected reference, found `char`\n     |\n     = note: expected reference\
    \ `&_`\n                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `skip` exists for struct `Cloned<Chars<'_>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmp98db7sx8.rs:21:41\n   |\n21 |\
    \       for letter in word.chars().cloned().skip(word.len()) {\n   |         \
    \                                  ^^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp98db7sx8.rs:28:5\n   |\n11 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n...\n28 |     closest_vowel\n\
    \   |     ^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ du"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    let mut left = 0;\n    let mut right = word.len()\
    \ - 1;\n    \n    let mut min_dist = 0;\n    let mut min_vowel = String::new();\n\
    \    \n    loop {\n        while left < right {\n            let mut vowel = word.chars().nth(left).unwrap().to_string();\n\
    \            vowel = vowel.to_lowercase();\n            if vowel == \"a\" || vowel\
    \ == \"e\" || vowel == \"i\" || vowel == \"o\" || vowel == \"u\" {\n         \
    \       min_dist = std::cmp::min(min_dist, left - left + 1);\n               \
    \ min_vowel = vowel;\n            }\n            left += 1;\n        }\n     \
    \   \n        while left >= 0 {\n            let mut vowel = word.chars().nth(left).unwrap().to_string();\n\
    \            vowel = vowel.to_lowercase();\n            if vowel == \"a\" || vowel\
    \ == \"e\" || vowel == \"i\" || vowel == \"o\" || vowel == \"u\" {\n         \
    \       min_dist = std::cmp::min(min_dist, left - left + 1);\n               \
    \ min_vowel = vowel;\n            }\n            left -= 1;\n        }\n     \
    \   \n        right -= 1;\n        \n        if left < 0 {\n            break;\n\
    \        }\n    }\n    \n    min_vowel\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdl7t3opi.rs:37:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowel = vowels.iter().filter(|vowel| {\n        word.contains(&vowel)\n\
    \    }).next();\n    vowel.ok_or(\"No vowel found\")?;\n    word.chars().filter(|c|\
    \ {\n        vowels.iter().any(|&v| {\n            if v == c {\n             \
    \   vowel = Some(v);\n            }\n            false\n        })\n    }).next()\n\
    \        .ok_or(\"No vowel found\")?;\n    vowel.unwrap()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `str`\n    --> /tmp/tmp9hqrbm7g.rs:14:23\n\
    \     |\n14   |         word.contains(&vowel)\n     |              -------- ^^^^^^\n\
    \     |              |        |\n     |              |        expected an `Fn<(char,)>`\
    \ closure, found `str`\n     |              |        help: consider dereferencing\
    \ here: `&**vowel`\n     |              required by a bound introduced by this\
    \ call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for `str`\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&str`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&&&str`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmp9hqrbm7g.rs:16:34\n   |\n11 | / fn get_closest_vowel(word: String)\
    \ -> String {\n12 | |     let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n13 | |     let mut vowel = vowels.iter().filter(|vowel| {\n14 | |     \
    \    word.contains(&vowel)\n15 | |     }).next();\n16 | |     vowel.ok_or(\"No\
    \ vowel found\")?;\n   | |                                  ^ cannot use the `?`\
    \ operator in a function that returns `String`\n...  |\n26 | |     vowel.unwrap()\n\
    27 | | }\n   | |_- this function should return `Result` or `Option` to accept\
    \ `?`\n   |\n   = help: the trait `FromResidual<Result<Infallible, &str>>` is\
    \ not implemented for `String`\n\nerror[E0277]: can't compare `str` with `char`\n\
    \  --> /tmp/tmp9hqrbm7g.rs:19:18\n   |\n19 |             if v == c {\n   |   \
    \               ^^ no implementation for `str == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ Part"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut iter = word.rfind('a');\n    let mut vowels\
    \ = String::new();\n    let mut i = 1;\n    while iter.len() > 0 && i <= word.length\
    \ {\n        if iter.starts_with('a') {\n            vowels.push(word[i..iter.len()].to_lowercase());\n\
    \            iter = iter.into_iter().rfind('a');\n        }\n        i += 1;\n\
    \    }\n    vowels.trim().to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpxky0c4vl.rs:15:16\n   |\n15 |     while iter.len() > 0\
    \ && i <= word.length {\n   |                ^^^ method not found in `Option<usize>`\n\
    \nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpxky0c4vl.rs:15:39\n\
    \   |\n15 |     while iter.len() > 0 && i <= word.length {\n   |             \
    \                          ^^^^^^ unknown field\n\nerror[E0599]: no method named\
    \ `starts_with` found for enum `Option` in the current scope\n  --> /tmp/tmpxky0c4vl.rs:16:17\n\
    \   |\n16 |         if iter.starts_with('a') {\n   |                 ^^^^^^^^^^^\
    \ method not found in `Option<usize>`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpxky0c4vl.rs:17:38\n  \
    \ |\n17 |             vowels.push(word[i..iter.len()].to_lowercase());\n   | \
    \                                     ^^^ method not found in `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxky0c4vl.rs:17:25\n   |\n17 |\
    \             vowels.push(word[i..iter.len()].to_lowercase());\n   |         \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0277]: expected a `FnMut<(&usize,)>` closure, found `char`\n\
    \   --> /tmp/tmpxky0c4vl.rs:18:43\n    |\n18  |             iter = iter.into_iter().rfind('a');\n\
    \    |                                     ----- ^^^ expected an `FnMut<(&usize,)>`\
    \ closure, found `char`\n    |                                     |\n    |  \
    \                                   required by a bound introduced by this call\n\
    \    |\n    = help: the trait `for<'r> FnMut<(&'r usize,)>` is not implemented\
    \ for `char`\nnote: required by a bound in `rfind`\n\nerror: aborting due to 6\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut s = String::new();\n    let mut vowels = \"\
    a\" .. \"z\";\n    let mut consonants = \"A\" .. \"Z\";\n    let len = word.len();\n\
    \    for i in  0 .. word.len() - 1 {\n        if word.chars().nth(i).unwrap()\
    \ in vowels {\n            if word.chars().nth(word.len() - i - 1).unwrap() in\
    \ vowels {\n                s.push(i);\n                s.push(i);\n         \
    \   }\n            else if word.chars().nth(word.len() - i - 1).unwrap() in consonants\
    \ {\n                s.push(word.len() - i - 1);\n                s.push(word.len()\
    \ - i - 1);\n            }\n            else {\n                break;\n     \
    \       }\n        }\n    }\n    if s.len() == 0 {\n        String::new()\n  \
    \  } else {\n        s.clone()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp_awtq6r5.rs:17:41\n\
    \   |\n17 |         if word.chars().nth(i).unwrap() in vowels {\n   |        \
    \ --                              ^^ expected `{`\n   |         |\n   |      \
    \   this `if` expression has a condition, but no block\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut current_char = word.len() - 1;\n    loop {\n\
    \        let mut min_vowels = word.len();\n        let mut current_vowel: usize\
    \ = 0;\n        while current_char >= 0 {\n            let vowel_index = vowel_position(word,\
    \ current_char);\n            if vowel_index != -1 {\n                let vowel\
    \ = vowels[vowel_index];\n                if vowel.starts_with(word[current_char..current_char+vowel.len()])\
    \ {\n                    current_vowel = vowel.len();\n                }\n   \
    \         }\n            current_char--;\n        }\n        if current_vowel\
    \ < min_vowels {\n            return String::new();\n        }\n        min_vowels\
    \ = current_vowel;\n        current_vowel = 0;\n        while current_char >=\
    \ 0 {\n            let vowel_index = vowel_position(word, current_char);\n   \
    \         if vowel_index != -1 {\n                let vowel = vowels[vowel_index];\n\
    \                if vowel.starts_with(word[current_char..current_char+vowel.len()])\
    \ {\n                    current_vowel = vowel.len();\n                }\n   \
    \         }\n            current_char--;\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpvimw7fis.rs:24:27\n\
    \   |\n24 |             current_char--;\n   |                           ^ expected\
    \ expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmpvimw7fis.rs:39:27\n\
    \   |\n39 |             current_char--;\n   |                           ^ expected\
    \ expression\n\nerror[E0425]: cannot find function `vowel_position` in this scope\n\
    \  --> /tmp/tmpvimw7fis.rs:17:31\n   |\n17 |             let vowel_index = vowel_position(word,\
    \ current_char);\n   |                               ^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `vowels` in this scope\n  -->\
    \ /tmp/tmpvimw7fis.rs:19:29\n   |\n19 |                 let vowel = vowels[vowel_index];\n\
    \   |                             ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `vowel_position` in this scope\n  --> /tmp/tmpvimw7fis.rs:32:31\n\
    \   |\n32 |             let vowel_index = vowel_position(word, current_char);\n\
    \   |                               ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpvimw7fis.rs:34:29\n\
    \   |\n34 |                 let vowel = vowels[vowel_index];\n   |           \
    \                  ^^^^^^ not found in this scope\n\nerror: aborting due to 6\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![];\n    let vowels_length = word.len()\
    \ / 2;\n    let mut consonants = word.len() - vowels_length;\n    \n    for _\
    \ in 0..vowels_length {\n        vowels.push(word.chars().nth(consonants).unwrap());\n\
    \        consonants -= 1;\n    }\n    \n    for _ in 0..vowels_length {\n    \
    \    vowels.push(word.chars().nth(consonants).unwrap());\n        consonants -=\
    \ 1;\n    }\n    \n    let vowels_count = vowels.iter().filter(|&x| x.is_vowel()).count();\n\
    \    \n    if vowels_count == 0 {\n        return \"\";\n    }\n    \n    let\
    \ min_distance = word.len() + 1;\n    \n    for vowel in vowels.iter().filter(|&x|\
    \ x.is_vowel()) {\n        let distance = word.chars().zip(vowel.chars()).filter(|&(c1,\
    \ _)| c1 != x).count();\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n        }\n    }\n    \n    for _ in 0..vowels_length {\n     \
    \   vowels.remove(vowels.iter().filter(|&x| x.is_vowel()).next().unwrap());\n\
    \    }\n    \n    vowels.iter().filter(|&x| x.is_vowel()).next()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmp3up9tlae.rs:35:80\n\
    \   |\n35 |         let distance = word.chars().zip(vowel.chars()).filter(|&(c1,\
    \ _)| c1 != x).count();\n   |                                                \
    \                                ^ not found in this scope\n\nerror[E0599]: no\
    \ method named `is_vowel` found for reference `&char` in the current scope\n \
    \ --> /tmp/tmp3up9tlae.rs:26:52\n   |\n26 |     let vowels_count = vowels.iter().filter(|&x|\
    \ x.is_vowel()).count();\n   |                                               \
    \     ^^^^^^^^ method not found in `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3up9tlae.rs:29:16\n   |\n11 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n29 |         return \"\";\n   |               \
    \ ^^- help: try using a conversion method: `.to_string()`\n   |              \
    \  |\n   |                expected struct `String`, found `&str`\n\nerror[E0599]:\
    \ no method named `is_vowel` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmp3up9tlae.rs:34:46\n   |\n34 |     for vowel in vowels.iter().filter(|&x|\
    \ x.is_vowel()) {\n   |                                              ^^^^^^^^\
    \ method not found in `&char`\n\nerror[E0599]: no method named `chars` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmp3up9tlae.rs:35:47\n  \
    \ |\n35 |         let distance = word.chars().zip(vowel.chars()).filter(|&(c1,\
    \ _)| c1 != x).count();\n   |                                               ^^^^^\
    \ method not found in `&char`\n\nerror[E0599]: no method named `is_vowel` found\
    \ for reference `&char` in the current scope\n  --> /tmp/tmp3up9tlae.rs:42:51\n\
    \   |\n42 |         vowels.remove(vowels.iter().filter(|&x| x.is_vowel()).next().unwrap());\n\
    \   |                                                   ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3up9tlae.rs:42:23\n\
    \   |\n42 |         vowels.remove(vowels.iter().filter(|&x| x.is_vowel()).next().unwrap());\n\
    \   |            "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = String::new();\n\n    for i in word[1..].chars().filter(|c|\
    \ match c {\n        'A' | 'a' | 'E' | 'e' | 'I' | 'i' | 'O' | 'o' | 'U' | 'u'\
    \ => {\n            vowels += c;\n            false\n        }\n        _ => {\n\
    \            false\n        }\n    }) {\n        vowels += String::from(*i);\n\
    \    }\n\n    vowels\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps04fgz2z.rs:16:23\n   |\n\
    16 |             vowels += c;\n   |                       ^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmps04fgz2z.rs:23:32\n\
    \   |\n23 |         vowels += String::from(*i);\n   |                        \
    \        ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps04fgz2z.rs:23:19\n\
    \   |\n23 |         vowels += String::from(*i);\n   |                   ^^^^^^^^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&str`, found struct\
    \ `String`\n   |                   help: consider borrowing here: `&String::from(*i)`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut lower = word.to_indy(|c| c >= 'a' && c <= 'z');\n\
    \    lower = lower.next_to_indy(\"a\", 'z');\n\n    let mut upper = word.to_indy(|c|\
    \ c >= 'A' && c <= 'Z');\n    upper = upper.prev_to_indy(\"A\", 'Z');\n\n    if\
    \ lower.is_none() || upper.is_none() {\n        return String::new();\n    }\n\
    \n    let mut low = lower.unwrap();\n    let mut up = upper.unwrap();\n\n    while\
    \ low != up {\n        if lower.unwrap().is_some() && up.is_some() {\n       \
    \     if low.unwrap().unwrap() == up.unwrap().unwrap() {\n                return\
    \ low.unwrap().unwrap();\n            }\n        }\n        low = lower.unwrap().unwrap();\n\
    \        up = upper.unwrap().unwrap();\n    }\n\n    return String::new();\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_indy` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpx_3majd7.rs:12:26\n   |\n12 |     let mut lower\
    \ = word.to_indy(|c| c >= 'a' && c <= 'z');\n   |                          ^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `to_indy` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpx_3majd7.rs:15:26\n\
    \   |\n15 |     let mut upper = word.to_indy(|c| c >= 'A' && c <= 'Z');\n   |\
    \                          ^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut leftSideIndex = 0;\n    let mut rightSideIndex\
    \ = word.len() - 1;\n    let mut leftSide = String::new();\n    let mut rightSide\
    \ = String::new();\n    while leftSideIndex < rightSideIndex {\n        let leftChar\
    \ = word[leftSideIndex];\n        let rightChar = word[rightSideIndex];\n    \
    \    if leftChar == rightChar {\n            leftSide.push_str(&leftChar.to_lowercase());\n\
    \            rightSide.push_str(&rightChar.to_lowercase());\n            leftSideIndex\
    \ += 1;\n            rightSideIndex -= 1;\n        } else if leftChar == 'a' &&\
    \ rightChar == 'o' {\n            leftSide.push_str(\"u\");\n            rightSide.push_str(\"\
    u\");\n            leftSideIndex += 1;\n            rightSideIndex -= 1;\n   \
    \     } else if leftChar == 'a' && rightChar == 'o' && leftSideIndex == 0 {\n\
    \            leftSide.push_str(\"u\");\n            leftSideIndex += 1;\n    \
    \    } else if leftChar == 'e' && rightChar == 'i' && leftSideIndex == word.len()\
    \ - 1 {\n            leftSide.push_str(\"i\");\n            rightSide.push_str(\"\
    i\");\n            leftSideIndex += 1;\n        } else if leftChar == 'e' && rightChar\
    \ == 'i' && leftSideIndex == 0 {\n            leftSide.push_str(\"i\");\n    \
    \        leftSideIndex += 1;\n        } else if leftChar == 'i' && rightChar ==\
    \ 'o' && leftSideIndex == word.len() - 1 {\n            leftSide.push_str(\"i\"\
    );\n            rightSide.push_str(\"i\");\n            leftSideIndex += 1;\n\
    \        } else if leftChar == 'i' && rightChar == 'o' && leftSideIndex == 0 {\n\
    \            leftSide.push_str(\"i\");\n            leftSideIndex += 1;\n    \
    \    } else if leftChar == 'u' && rightChar == 'r' && leftSideIndex == word.len()\
    \ - 1 {\n            leftSide.push_str(\"r\");\n            rightSide.push_str(\"\
    r\");\n            leftSideIndex += 1;\n        } else if leftChar == 'u' && rightChar\
    \ == 'r' && leftSideIndex == 0 {\n            leftSide.push_str(\"r\");\n    \
    \        leftSideIndex += 1;\n        } else if leftChar == 'a' && rightChar ==\
    \ 'e' && leftSideIndex == word.len() - 1 && rightSideIndex == word.len() - 1 {\n\
    \            leftSide.push_str(\"e\");\n            rightSide.push_str(\"e\");\n\
    \            leftSideIndex += 1;\n        } else if leftChar == 'a' && rightChar\
    \ == 'e' && \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmbvvhtxs.rs:75:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while leftSideIndex\
    \ < rightSideIndex {\n   |                                          - this delimiter\
    \ might not be properly closed...\n...\n58 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n75 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmpmbvvhtxs.rs:58:1\n   |\n58 | }\n   | ^ expected expression\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmbvvhtxs.rs:17:24\n\
    \   |\n17 |         let leftChar = word[leftSideIndex];\n   |                \
    \        ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmbvvhtxs.rs:18:25\n\
    \   |\n18 |         let rightChar = word[rightSideIndex];\n   |              \
    \           ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmbvvhtxs.rs:11:39\n   |\n11 "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let vowel = \"AEIOU\".to_lowercase();\n  let mut pos\
    \ = word.len() - 1;\n  while pos >= 0 {\n    let vowel_positions = word.chars().skip(pos).filter(|x|\
    \ x.contains(&vowel));\n    let count = vowel_positions.count();\n    if count\
    \ == 0 {\n      return \"\";\n    }\n    pos = vowel_positions.last().unwrap().cmp(&word.chars()[pos]).unwrap().unwrap_or(pos);\n\
    \  }\n  word\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpn_wg5nj7.rs:15:63\n   |\n15 |     let vowel_positions\
    \ = word.chars().skip(pos).filter(|x| x.contains(&vowel));\n   |             \
    \                                                  ^^^^^^^^ method not found in\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn_wg5nj7.rs:18:14\n\
    \   |\n18 |       return \"\";\n   |              ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |              |\n   |              expected struct\
    \ `String`, found `&str`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmpn_wg5nj7.rs:20:48\n   |\n20 |     pos = vowel_positions.last().unwrap().cmp(&word.chars()[pos]).unwrap().unwrap_or(pos);\n\
    \   |                                                ^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `unwrap` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmpn_wg5nj7.rs:20:67\n   |\n20 |     pos = vowel_positions.last().unwrap().cmp(&word.chars()[pos]).unwrap().unwrap_or(pos);\n\
    \   |                                                                   ^^^^^^\
    \ method not found in `std::cmp::Ordering`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.chars().any(|c| c != 'a' && c != 'e' && c !=\
    \ 'i' && c != 'o' && c != 'u') {\n        return \"\";\n    }\n    let mut index\
    \ = 0;\n    let mut last_vowel_index = 0;\n    let mut vowel_index = 0;\n    let\
    \ mut cur_len = word.length();\n    loop {\n        last_vowel_index = cur_len;\n\
    \        index += 1;\n        cur_len = word[index].len_utf8();\n        if cur_len\
    \ == 0 {\n            break;\n        }\n        if cur_len == 1 {\n         \
    \   if word[index] == get_consonant_from_right(word[index]) {\n              \
    \  break;\n            }\n        }\n        if word[index] == get_consonant_from_right(word[index])\
    \ {\n            vowel_index += 1;\n        }\n    }\n    vowel_index -= 1;\n\
    \    if vowel_index > 0 {\n        word.chars().take(vowel_index).collect::<String>()\n\
    \    } else {\n        \"\"\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_consonant_from_right` in this scope\n\
    \  --> /tmp/tmp0swauzny.rs:27:31\n   |\n27 |             if word[index] == get_consonant_from_right(word[index])\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `get_consonant_from_right`\
    \ in this scope\n  --> /tmp/tmp0swauzny.rs:31:27\n   |\n31 |         if word[index]\
    \ == get_consonant_from_right(word[index]) {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0swauzny.rs:13:16\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n12\
    \ |     if word.chars().any(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u') {\n13 |         return \"\";\n   |                ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                |\n   |           \
    \     expected struct `String`, found `&str`\n\nerror[E0599]: no method named\
    \ `length` found for struct `String` in the current scope\n  --> /tmp/tmp0swauzny.rs:18:28\n\
    \   |\n18 |     let mut cur_len = word.length();\n   |                       \
    \     ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp0swauzny.rs:22:19\n\
    \   |\n22 |         cur_len = word[index].len_utf8();\n   |                  \
    \ ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"\".to_string(), \"\".to_string()];\n\
    \    for consonant in word.chars() {\n        if consonant == 'a' || consonant\
    \ == 'i' || consonant == 'o' || consonant == 'u' {\n            vowels[0] += consonant;\n\
    \        }\n        if consonant == 'e' || consonant == 'i' || consonant == 'o'\
    \ || consonant == 'u' {\n            vowels[1] += consonant;\n        }\n    }\n\
    \    let mut left_index = 0;\n    let mut right_index = 0;\n    while vowels[0]\
    \ == \"\" {\n        left_index += 1;\n    }\n    while vowels[1] == \"\" {\n\
    \        right_index -= 1;\n    }\n    let mut left_vowel_index = left_index;\n\
    \    let mut right_vowel_index = right_index;\n    if left_index < right_index\
    \ {\n        if vowels[left_index] == \"\" {\n            left_vowel_index +=\
    \ 1;\n        }\n    }\n    if left_index > right_index {\n        if vowels[right_index]\
    \ == \"\" {\n            right_vowel_index -= 1;\n        }\n    }\n    if left_index\
    \ > right_index {\n        if left_vowel_index == right_vowel_index {\n      \
    \      return vowels[left_index];\n        } else {\n            return vowels[left_index].to_string();\n\
    \        }\n    } else {\n        return vowels[right_index].to_string();\n  \
    \  }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmltcjl8u.rs:15:26\n   |\n\
    15 |             vowels[0] += consonant;\n   |                          ^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmltcjl8u.rs:18:26\n\
    \   |\n18 |             vowels[1] += consonant;\n   |                        \
    \  ^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec!['a','e','i','o','u'];\n    \n\
    \    for (i, c) in word.chars().enumerate() {\n        if vowels.iter().any(|v|\
    \ v == c) { \n            vowels.remove(i);\n        }\n    }\n    \n    if vowels.is_empty()\
    \ { \"\" }\n    else {\n        vowels.iter().next().unwrap()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4cv2jkpf.rs:15:36\n\
    \   |\n15 |         if vowels.iter().any(|v| v == c) { \n   |                \
    \                    ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4cv2jkpf.rs:20:28\n   |\n11 | fn get_closest_vowel(word: String) ->\
    \ String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n20 |     if vowels.is_empty() { \"\" }\n   |  \
    \                          ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4cv2jkpf.rs:22:9\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    22 |         vowels.iter().next().unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found `&char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().fold(\"\", |mut acc, &(idx,\
    \ _)| {\n        match idx {\n            0 => acc + \"u\",\n            word.len()\
    \ - 1 => acc + \"U\",\n            1 => acc,\n            i => match i.to_ascii_lowercase()\
    \ {\n                \"a\" => acc + \"a\",\n                \"e\" => acc + \"\
    e\",\n                \"i\" => acc + \"i\",\n                \"o\" => acc + \"\
    o\",\n                \"u\" => acc + \"u\",\n                _ => acc\n      \
    \      }\n        }\n    })\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `.`\n  --> /tmp/tmpa6jzuhu_.rs:15:17\n\
    \   |\n15 |             word.len() - 1 => acc + \"U\",\n   |                 ^\
    \ expected one of `=>`, `@`, `if`, or `|`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa6jzuhu_.rs:12:35\n   |\n12 |     word.chars().enumerate().fold(\"\
    \", |mut acc, &(idx, _)| {\n   |                                   ^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \       |\n   |                                   expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa6jzuhu_.rs:12:49\n\
    \   |\n12 |     word.chars().enumerate().fold(\"\", |mut acc, &(idx, _)| {\n \
    \  |                                                 ^^^^^^^^-\n   |         \
    \                                        |       |\n   |                     \
    \                            |       expected due to this\n   |              \
    \                                   expected tuple, found reference\n   |\n  \
    \ = note:  expected tuple `(usize, char)`\n           found reference `&_`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"A\",\"a\",\"E\",\"e\",\"I\",\"\
    i\",\"O\",\"o\",\"U\",\"u\"];\n    let mut vowels_iter = vowels.iter();\n    let\
    \ mut cur_word = word;\n    let mut cur_vowel = vowels_iter.next();\n    loop\
    \ {\n        if cur_vowel.as_str() == cur_word.as_str()[word.len()-1] &&\n   \
    \         cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        if cur_vowel.as_str() == cur_word.as_str()[word.len() - 2]\
    \ &&\n            cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        if cur_vowel.as_str() == cur_word.as_str()[word.len() - 3]\
    \ &&\n            cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        if cur_vowel.as_str() == cur_word.as_str()[word.len() - 4]\
    \ &&\n            cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        if cur_vowel.as_str() == cur_word.as_str()[word.len() - 5]\
    \ &&\n            cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        if cur_vowel.as_str() == cur_word.as_str()[word.len() - 6]\
    \ &&\n            cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        if cur_vowel.as_str() == cur_word.as_str()[word.len() - 7]\
    \ &&\n            cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        if cur_vowel.as_str() == cur_word.as_str()[word.len() - 8]\
    \ &&\n            cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        if cur_vowel.as_str() == cur_word.as_str()[word.len() - 9]\
    \ &&\n            cur_vowel == vowels_iter.next() {\n            return cur_vowel.as_str();\n\
    \        }\n        cur_word = cur_word.as_str().to_string();\n        cur_vowel\
    \ = vowels_iter.next();\n    }\n    return \"\".to_string();\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_str` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpx8z4gh3b.rs:17:22\n   |\n17 |         if cur_vowel.as_str()\
    \ == cur_word.as_str()[word.len()-1] &&\n   |                      ^^^^^^ method\
    \ not found in `Option<&&str>`\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpx8z4gh3b.rs:17:34\n   |\n17 |         if cur_vowel.as_str()\
    \ == cur_word.as_str()[word.len()-1] &&\n   |                                \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0599]:\
    \ no method named `as_str` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpx8z4gh3b.rs:19:30\n   |\n19 |             return cur_vowel.as_str();\n\
    \   |                              ^^^^^^ method not found in `Option<&&str>`\n\
    \nerror[E0599]: no method named `as_str` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpx8z4gh3b.rs:21:22\n   |\n21 |         if cur_vowel.as_str()\
    \ == cur_word.as_str()[word.len() - 2] &&\n   |                      ^^^^^^ method\
    \ not found in `Option<&&str>`\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpx8z4gh3b.rs:21:34\n   |\n21 |         if cur_vowel.as_str()\
    \ == cur_word.as_str()[word.len() - 2] &&\n   |                              \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0599]: no method named `as_str` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpx8z4gh3b.rs:23:30\n   |\n23 |             return cur_vowel.as_str();\n\
    \   |                              ^^^^^^ method not found in `Option<&&str>`\n\
    \nerror[E0599]: no m"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_start_index = String::new();\n    let\
    \ mut vowel_end_index = String::new();\n    let mut index = String::new();\n\n\
    \    for letter in word[..] {\n        if letter == ('a'..'z').contains(|c|) {\n\
    \            vowel_start_index = index;\n            index = letter;\n       \
    \ }\n        if letter == ('A'..'Z').contains(|c|) {\n            vowel_end_index\
    \ = index;\n            index = letter;\n        }\n    }\n\n    let distance\
    \ = abs(vowel_start_index - vowel_end_index);\n\n    if distance < 0 {\n     \
    \   String::new()\n    } else {\n        vowel_start_index[distance..distance].to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpo5b8_nnz.rs:17:45\n\
    \   |\n17 |         if letter == ('a'..'z').contains(|c|) {\n   |            \
    \                                 ^ expected expression\n\nerror[E0425]: cannot\
    \ find function `abs` in this scope\n  --> /tmp/tmpo5b8_nnz.rs:27:20\n   |\n27\
    \ |     let distance = abs(vowel_start_index - vowel_end_index);\n   |       \
    \             ^^^ not found in this scope\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpo5b8_nnz.rs:16:19\n\
    \   |\n16 |     for letter in word[..] {\n   |                   ^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `str`\n\nerror[E0277]: `str` is not an iterator\n\
    \  --> /tmp/tmpo5b8_nnz.rs:16:19\n   |\n16 |     for letter in word[..] {\n  \
    \ |                   ^^^^^^^^ `str` is not an iterator\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `str`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `str`\n\nerror[E0369]: cannot\
    \ subtract `String` from `String`\n  --> /tmp/tmpo5b8_nnz.rs:27:42\n   |\n27 |\
    \     let distance = abs(vowel_start_index - vowel_end_index);\n   |         \
    \               ----------------- ^ --------------- String\n   |             \
    \           |\n   |                        String\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0369, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut prev_consonant =\
    \ String::from(\"\");\n    let mut prev_vowel = String::from(\"\");\n    for c\
    \ in word.chars() {\n        if c.is_vowel() {\n            counter++;\n     \
    \       prev_consonant = c.to_lowercase();\n        } else {\n            if counter\
    \ < 2 {\n                continue;\n            }\n            prev_vowel = prev_consonant;\n\
    \            counter = 0;\n        }\n        if prev_vowel == c.to_lowercase()\
    \ {\n            return c.to_lowercase();\n        }\n    }\n    return String::from(\"\
    \");\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpqpdkzs7d.rs:17:20\n\
    \   |\n17 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    17 -             counter++;\n17 +             counter += 1;\n   | \n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpqpdkzs7d.rs:16:14\n   |\n16 |         if c.is_vowel() {\n   |      \
    \        ^^^^^^^^ method not found in `char`\n\nerror[E0277]: can't compare `String`\
    \ with `ToLowercase`\n  --> /tmp/tmpqpdkzs7d.rs:26:23\n   |\n26 |         if prev_vowel\
    \ == c.to_lowercase() {\n   |                       ^^ no implementation for `String\
    \ == ToLowercase`\n   |\n   = help: the trait `PartialEq<ToLowercase>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqpdkzs7d.rs:27:20\n\
    \   |\n27 |             return c.to_lowercase();\n   |                    ^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found struct `ToLowercase`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Convert string to character array\n    let char_array\
    \ = word.to_lowercase().chars();\n    // Find index of first vowel\n    let vowel_idx\
    \ = char_array\n        .iter()\n        .find(|&c| c == 0x4E00u && c < 0x9FFFu)\n\
    \        .expect(\"String contains invalid character\");\n    // Find index of\
    \ last consonant\n    let con_idx = char_array\n        .iter()\n        .rfind(|&c|\
    \ c == 0xFF0Fu && c < 0xFFE0u)\n        .expect(\"String contains invalid character\"\
    );\n    // Find the first vowel after the first consonant\n    let start = con_idx.wrapping_add(1).unwrap_or(vowel_idx);\n\
    \    // Find the first vowel before the second consonant\n    let end = con_idx.wrapping_sub(1).unwrap_or(vowel_idx);\n\
    \    // Return empty string if there is no vowel\n    match end {\n        0 =>\
    \ \"\",\n        _ => {\n            // Convert character array to string\n  \
    \          let mut s = String::new();\n            for (idx, char) in char_array[start..end].iter().enumerate()\
    \ {\n                // Check if current character is a vowel\n              \
    \  if char >= 0x4E00u && char <= 0x9FFFu {\n                    // If the current\
    \ character is a vowel\n                    // Add to the string only if it's\
    \ not at the end or beginning of the string\n                    if idx < char_array.len()\
    \ - 1 || idx > 0 {\n                        s.push_str(&char as char);\n     \
    \               }\n                } else {\n                    break;\n    \
    \            }\n            }\n            // Return empty string if the string\
    \ contains invalid character\n            s.into_string().expect(\"String contains\
    \ invalid character\")\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmptc8_ejpz.rs:17:25\n\
    \   |\n17 |         .find(|&c| c == 0x4E00u && c < 0x9FFFu)\n   |            \
    \             ^^^^^^^ invalid suffix `u`\n   |\n   = help: the suffix must be\
    \ one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix\
    \ `u` for number literal\n  --> /tmp/tmptc8_ejpz.rs:17:40\n   |\n17 |        \
    \ .find(|&c| c == 0x4E00u && c < 0x9FFFu)\n   |                              \
    \          ^^^^^^^ invalid suffix `u`\n   |\n   = help: the suffix must be one\
    \ of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix\
    \ `u` for number literal\n  --> /tmp/tmptc8_ejpz.rs:22:26\n   |\n22 |        \
    \ .rfind(|&c| c == 0xFF0Fu && c < 0xFFE0u)\n   |                          ^^^^^^^\
    \ invalid suffix `u`\n   |\n   = help: the suffix must be one of the numeric types\
    \ (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `u` for number literal\n\
    \  --> /tmp/tmptc8_ejpz.rs:22:41\n   |\n22 |         .rfind(|&c| c == 0xFF0Fu\
    \ && c < 0xFFE0u)\n   |                                         ^^^^^^^ invalid\
    \ suffix `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`,\
    \ `isize`, `f32`, etc.)\n\nerror: invalid suffix `u` for number literal\n  -->\
    \ /tmp/tmptc8_ejpz.rs:36:28\n   |\n36 |                 if char >= 0x4E00u &&\
    \ char <= 0x9FFFu {\n   |                            ^^^^^^^ invalid suffix `u`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `u` for number literal\n  --> /tmp/tmptc8_ejpz.rs:36:47\n\
    \   |\n36 |                 if char >= 0x4E00u && char <= 0x9FFFu {\n   |    \
    \                                           ^^^^^^^ invalid suffix `u`\n   |\n\
    \   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`,\
    \ etc.)\n\nerror[E0599]: no method named `iter` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmptc8_ejpz.rs:16:10\n   |\n16 |         .iter()\n\
    \   |          ^^^^ private field, not a method\n\nerror[E0599]: no method named\
    \ `iter` found for struct `Chars` in the current scope\n  --> /tm"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let len = word.length();\n    let mut res = String::new();\n\
    \n    for _ in 0..len {\n        let first_c = word.chars().next().unwrap();\n\
    \        let mut next = String::new();\n\n        for c in word.chars() {\n  \
    \          if c.is_uppercase() {\n                next.push(c);\n            }\
    \ else {\n                next.push(first_c.unwrap());\n                break;\n\
    \            }\n        }\n\n        if next.is_empty() {\n            continue;\n\
    \        }\n\n        let mut i = len - 1;\n        let mut found = false;\n\n\
    \        while i >= 0 && found == false {\n            if let Some(vowel) = &next[i]\
    \ {\n                if !vowel.contains('a' && 'e' && 'i' && 'o' && 'u') {\n \
    \                   found = vowel;\n                } else {\n               \
    \     next.remove(i);\n                    i -= 1;\n                }\n      \
    \      }\n\n            i -= 1;\n        }\n\n        if found == true {\n   \
    \         res.push((&found).to_string());\n        }\n    }\n\n    if res.is_empty()\
    \ {\n        return \"\";\n    }\n\n    res.chomp()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpwxifgxk4.rs:12:20\n   |\n12 |     let len = word.length();\n\
    \   |                    ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0599]: no method named `unwrap` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpwxifgxk4.rs:23:35\n   |\n23 |          \
    \       next.push(first_c.unwrap());\n   |                                   ^^^^^^\
    \ method not found in `char`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpwxifgxk4.rs:36:35\n   |\n36 |             if let\
    \ Some(vowel) = &next[i] {\n   |                                   ^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwxifgxk4.rs:37:36\n\
    \   |\n37 |                 if !vowel.contains('a' && 'e' && 'i' && 'o' && 'u')\
    \ {\n   |                                    ^^^ expected `bool`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxifgxk4.rs:37:43\n   |\n37 |\
    \                 if !vowel.contains('a' && 'e' && 'i' && 'o' && 'u') {\n   |\
    \                                           ^^^ expected `bool`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxifgxk4.rs:37:50\n   |\n37 |\
    \                 if !vowel.contains('a' && 'e' && 'i' && 'o' && 'u') {\n   |\
    \                                                  ^^^ expected `bool`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwxifgxk4.rs:37:57\n\
    \   |\n37 |                 if !vowel.contains('a' && 'e' && 'i' && 'o' && 'u')\
    \ {\n   |          "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = word.rfind('a', -1);\n    let\
    \ mut vowel_start = vowel_index;\n    let mut vowel_end = vowel_index;\n    vowel_end\
    \ = word.rfind('a', vowel_end + 1);\n\n    for vowel_index in word.rfind('a',\
    \ vowel_end).rev() {\n        vowel_start = vowel_index;\n        vowel_end =\
    \ word.rfind('a', vowel_start + 1);\n\n        if vowel_index == 0 {\n       \
    \     break\n        }\n    }\n    if vowel_start == vowel_end {\n        return\
    \ \"\".to_string();\n    }\n    if vowel_end < word.len() {\n        return word[vowel_end..].to_string();\n\
    \    }\n    word.to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpym4mqqgq.rs:12:32\n     |\n12   |     let mut vowel_index = word.rfind('a',\
    \ -1);\n     |                                ^^^^^ ---  -- supplied 2 arguments\n\
    \     |                                |\n     |                             \
    \   expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpym4mqqgq.rs:15:43\n\
    \   |\n15 |     vowel_end = word.rfind('a', vowel_end + 1);\n   |            \
    \                     --------- ^ - {integer}\n   |                          \
    \       |\n   |                                 Option<usize>\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpym4mqqgq.rs:15:22\n\
    \     |\n15   |     vowel_end = word.rfind('a', vowel_end + 1);\n     |      \
    \                ^^^^^ ---  ------------- supplied 2 arguments\n     |       \
    \               |\n     |                      expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmpym4mqqgq.rs:17:29\n     |\n17\
    \   |     for vowel_index in word.rfind('a', vowel_end).rev() {\n     |      \
    \                       ^^^^^ ---  --------- supplied 2 arguments\n     |    \
    \                         |\n     |                             expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0599]: `Option<usize>`\
    \ is not an iterator\n   --> /tmp/tmpym4mqqgq.rs:17:51\n    |\n17  |       for\
    \ vowel_index in word.rfind('a', vowel_end).rev() {\n    |                   \
    \                                  ^^^ `Option<usize>` is not an iterator\n  \
    \  |\n    = note: the following trait bounds were not satisfied:\n           \
    \ `Option<usize>: Iterator`\n            which is required by `&mut Option<usize>:\
    \ Iterator`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  -->\
    \ /tmp/tmpym4mqqgq.rs:19:49\n   |\n19 |         vowel_end = word.rfind('a', vowel_start\
    \ + 1);\n   |                    "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = String::new();\n    word.chars().filter(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n    vowels.push_str(\"\
    u\");\n    word.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').skip(1);\n    vowels.push_str(\"U\");\n    word.chars().filter(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').skip(1).skip(1);\n\
    \    vowels.push_str(\"I\");\n    word.chars().filter(|&c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').skip(1).skip(1).skip(1);\n    vowels.push_str(\"\
    O\");\n    word.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').skip(1).skip(1).skip(1).skip(1);\n    vowels.push_str(\"a\");\n\
    \    word.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u').skip(1).skip(1).skip(1).skip(1).skip(1);\n    vowels.push_str(\"e\"\
    );\n    word.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').skip(1).skip(1).skip(1).skip(1).skip(1).skip(1);\n    vowels.push_str(\"\
    i\");\n    word.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').skip(1).skip(1).skip(1).skip(1).skip(1).skip(1);\n    vowels.push_str(\"\
    o\");\n    word.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').skip(1).skip(1).skip(1).skip(1).skip(1).skip(1);\n    vowels.push_str(\"\
    u\");\n    word.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').skip(1).skip(1).skip(1).skip(1).skip(1).skip(1).skip(1);\n    vowels.push_str(\"\
    A\");\n    word.char\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `char` on type `String`\n  --> /tmp/tmpi58o6718.rs:33:10\n\
    \   |\n33 |     word.char\n   |          ^^^^ unknown field\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![ 'A', 'E', 'I', 'O', 'U' ];\n\n \
    \   let mut index = 0;\n    let mut chars = word.chars().collect::<Vec<char>>();\n\
    \    while index < chars.len() - 1 {\n        if chars[index] == chars[index +\
    \ 1] {\n            return vowels[(index + 1) % vowels.len()].to_string();\n \
    \       }\n        index += 1;\n    }\n    \"\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp3hdcf6u9.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = String::new();\n    let mut vowel_flag\
    \ = false;\n    let mut min_pos = word.len() - 1;\n    let mut max_pos = 0;\n\
    \    for (i, c) in word.chars().enumerate() {\n        if vowel_flag {\n     \
    \       if c == vowel.chars().last().unwrap() {\n                min_pos = i;\n\
    \                break;\n            } else {\n                min_pos = i;\n\
    \            }\n        } else {\n            vowel_flag = is_vowel(c);\n    \
    \    }\n        max_pos = i;\n    }\n    if min_pos == max_pos {\n        return\
    \ vowel;\n    }\n    if min_pos < max_pos {\n        vowel = String::from(word[min_pos\
    \ - 1]);\n    } else {\n        vowel = String::from(word[max_pos + 1]);\n   \
    \ }\n    return vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp4cwyukd5.rs:25:26\n\
    \   |\n25 |             vowel_flag = is_vowel(c);\n   |                      \
    \    ^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp4cwyukd5.rs:33:30\n   |\n33 |         vowel\
    \ = String::from(word[min_pos - 1]);\n   |                              ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4cwyukd5.rs:35:30\n   |\n35 |         vowel = String::from(word[max_pos\
    \ + 1]);\n   |                              ^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_start = 0;\n    let mut vowels_end = 0;\n\
    \n    let word_len = word.len();\n    if word_len > 3 {\n        let mut first_vowel_index:\
    \ usize = 0;\n        for index in 0..word_len - 2 {\n            if word[index]\
    \ == 'a' || word[index] == 'e' || word[index] == 'i' || word[index] == 'o' ||\
    \ word[index] == 'u' {\n                first_vowel_index = index;\n         \
    \       break;\n            }\n        }\n        if first_vowel_index != 0 {\n\
    \            vowels_start = first_vowel_index;\n        }\n\n        let mut last_vowel_index:\
    \ usize = 0;\n        for index in word_len - 1 {\n            if word[index]\
    \ == 'a' || word[index] == 'e' || word[index] == 'i' || word[index] == 'o' ||\
    \ word[index] == 'u' {\n                last_vowel_index = index;\n          \
    \      break;\n            }\n        }\n        if last_vowel_index != word_len\
    \ {\n            vowels_end = last_vowel_index;\n        }\n\n        if vowels_start\
    \ != 0 && vowels_end != 0 {\n            word = word.split_whitespace().collect();\n\
    \n            for index in 0..(vowels_end - vowels_start + 1) {\n            \
    \    if word[index] == &vowels[vowels_end - vowels_start - 1] {\n            \
    \        return word[vowels_start - 1];\n                }\n            }\n  \
    \      }\n    }\n\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi9n6y_vr.rs:20:16\n\
    \   |\n20 |             if word[index] == 'a' || word[index] == 'e' || word[index]\
    \ == 'i' || word[index] == 'o' || word[index] == 'u' {\n   |                ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpi9n6y_vr.rs:20:38\n   |\n20 |             if word[index] == 'a'\
    \ || word[index] == 'e' || word[index] == 'i' || word[index] == 'o' || word[index]\
    \ == 'u' {\n   |                                      ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpi9n6y_vr.rs:20:60\n   |\n20 |             if word[index] == 'a'\
    \ || word[index] == 'e' || word[index] == 'i' || word[index] == 'o' || word[index]\
    \ == 'u' {\n   |                                                            ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<String> = Vec::new();\n    let\
    \ mut index = word.len();\n    while index > 0 {\n        if index > 1 && word[index..index\
    \ + 1].chars().filter(|x| !vowels.contains(&x)).len() <= 1 {\n            vowels.push(word[index..index\
    \ + 1].chars().filter(|x| !vowels.contains(&x)).collect::<Vec<String>>()[0]);\n\
    \        }\n        index -= 1;\n    }\n    vowels.into_iter().next().cloned()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzoesv6xn.rs:15:84\n   |\n\
    15 |         if index > 1 && word[index..index + 1].chars().filter(|x| !vowels.contains(&x)).len()\
    \ <= 1 {\n   |                                                               \
    \                     ^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected reference `&String`\n              found reference `&&char`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Filter` in the current scope\n  -->\
    \ /tmp/tmpzoesv6xn.rs:15:89\n   |\n15 |         if index > 1 && word[index..index\
    \ + 1].chars().filter(|x| !vowels.contains(&x)).len() <= 1 {\n   |           \
    \                                                                            \
    \  ^^^ method not found in `Filter<Chars<'_>, [closure@/tmp/tmpzoesv6xn.rs:15:63:\
    \ 15:87]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzoesv6xn.rs:16:84\n\
    \   |\n16 |             vowels.push(word[index..index + 1].chars().filter(|x|\
    \ !vowels.contains(&x)).collect::<Vec<String>>()[0]);\n   |                  \
    \                                                                  ^^ expected\
    \ struct `String`, found `&char`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&&char`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpzoesv6xn.rs:16:89\n\
    \     |\n16   |             vowels.push(word[index..index + 1].chars().filter(|x|\
    \ !vowels.contains(&x)).collect::<Vec<String>>()[0]);\n     |                \
    \                                                                         ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: `Option<String>` is not an iterator\n\
    \   --> /tmp/tmpzoesv6xn.rs:20:31\n    |\n20  |       vowels.into_iter().next().cloned()\n\
    \    |                                 ^^^^^^ `Option<"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 2 {\n        return String::new();\n\
    \    }\n    \n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut index = 0;\n    while index < word.len() - 1 {\n        for vowel\
    \ in vowels {\n            if word.len() >= index+1 {\n                let current\
    \ = word[index].to_lowercase();\n                let next_letter = word[index+1].to_lowercase();\n\
    \                \n                if current == vowel && next_letter != vowel\
    \ {\n                    return vowel.to_string();\n                }\n      \
    \      }\n        }\n        \n        index += 1;\n    }\n    \n    return String::new();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwhz5cwyb.rs:21:31\n\
    \   |\n21 |                 let current = word[index].to_lowercase();\n   |  \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwhz5cwyb.rs:22:35\n   |\n22 |                 let next_letter =\
    \ word[index+1].to_lowercase();\n   |                                   ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut counter = word.len();\n    let mut vowels:\
    \ [Char; 4] = [' ', 'a', 'e', 'i', 'o', 'u'];\n    vowels.sort_unstable();\n \
    \   loop {\n        counter -= 1;\n        if counter < 0 {\n            break;\n\
    \        }\n        if word[counter] == '\\0' {\n            break;\n        }\n\
    \        let mut index: usize = 0;\n        let mut flag = true;\n        let\
    \ mut j = 0;\n        for (j, v) in vowels.iter().enumerate()  {\n           \
    \ if word[counter + j] != v {\n                flag = false;\n               \
    \ break;\n            }\n        }\n        if flag {\n            return word[counter];\n\
    \        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmp8b_32a63.rs:13:22\n\
    \   |\n13 |     let mut vowels: [Char; 4] = [' ', 'a', 'e', 'i', 'o', 'u'];\n\
    \   |                      ^^^^ help: a builtin type with a similar name exists\
    \ (notice the capitalization): `char`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp8b_32a63.rs:20:12\n   |\n20 |         if\
    \ word[counter] == '\\0' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8b_32a63.rs:33:20\n   |\n33 |             return word[counter];\n\
    \   |                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8b_32a63.rs:36:12\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    36 |     return \"\";\n   |            ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |            |\n   |            expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 4"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.is_empty() { return \"\"; }\n    \n    let\
    \ mut i = word.len() - 1;\n    let mut j = 0;\n    \n    while i >= 0 && j !=\
    \ word.len() {\n        let c = word[j];\n        \n        if c.is_vowel() {\n\
    \            i -= 1;\n            j += 1;\n        } else if c.is_consonant()\
    \ {\n            i -= 1;\n        } else {\n            break;\n        }\n  \
    \  }\n    \n    if i == -1 { return \"\"; }\n    \n    let c = word[j];\n    \n\
    \    if c.is_vowel() {\n        return c.to_string();\n    } else if c.is_consonant()\
    \ {\n        word.remove(j, 1);\n        return get_closest_vowel(word);\n   \
    \ }\n    \n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprdpiikko.rs:12:33\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if word.is_empty() { return \"\"; }\n   |                                 ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \               |\n   |                                 expected struct `String`,\
    \ found `&str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprdpiikko.rs:18:17\n   |\n18 |         let c = word[j];\n   |  \
    \               ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmprdpiikko.rs:30:13\n   |\n30 |     if i == -1 { return \"\"; }\n\
    \   |             ^^\n   |             |\n   |             cannot apply unary\
    \ operator `-`\n   |             help: you may have meant the maximum value of\
    \ `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprdpiikko.rs:32:13\n\
    \   |\n32 |     let c = word[j];\n   |             ^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToI"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowel_count = word.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n    let mut vowel_count\
    \ = vowel_count + 1;\n    \n    vowel_count - word.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n    \n    if vowel_count\
    \ < 2 {\n        return \"\".to_string();\n    }\n    let mut min_dist = word.len();\n\
    \    let mut vowel = String::new();\n    \n    for c in word.chars().rev() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       continue;\n        }\n        \n        let dist = c - word.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n       \
    \ \n        if dist < min_dist {\n            min_dist = dist;\n            vowel\
    \ = c\n        }\n    }\n    return vowel;\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8yhkd9z7.rs:12:49\n\
    \   |\n12 |     let vowel_count = word.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').count();\n   |                        \
    \                         ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp8yhkd9z7.rs:12:61\n   |\n12 |     let vowel_count\
    \ = word.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count();\n   |                                                     \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp8yhkd9z7.rs:12:73\n   |\n12 |     let vowel_count = word.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n   |   \
    \                                                                      ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8yhkd9z7.rs:12:85\n\
    \   |\n12 |     let vowel_count = word.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').count();\n   |                        \
    \                                                             ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8yhkd9z7.rs:12:97\n\
    \   |\n12 |     let vowel_count = word.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').count();\n   |                        \
    \                 "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = ['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut found_vowel = false;\n    let mut vowel_to_add = String::new();\n    let\
    \ mut vowel_found = false;\n    let mut index = 0;\n    \n    while !found_vowel\
    \ && index < word.len() {\n        if word[index] in vowels {\n            found_vowel\
    \ = true;\n            vowel_to_add = word[index];\n            vowel_found =\
    \ true;\n            index += 1;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    \n    if !found_vowel {\n        vowel_to_add.clear();\n\
    \    }\n    \n    if !vowel_found {\n        return vowel_to_add;\n    } else\
    \ {\n        return String::new();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpbzp4tjhg.rs:19:24\n\
    \   |\n19 |         if word[index] in vowels {\n   |         --             ^^\
    \ expected `{`\n   |         |\n   |         this `if` expression has a condition,\
    \ but no block\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let len = word.len();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut first_consonant = false;\n    let\
    \ mut last_consonant = false;\n    let mut first_vowel = false;\n    let mut last_vowel\
    \ = false;\n    for i in 0..len {\n        if word[i] == ' ' {\n            last_consonant\
    \ = false;\n            last_vowel = false;\n        }\n        if first_consonant\
    \ && word[i] == first_vowel.as_ref() {\n            last_consonant = false;\n\
    \            last_vowel = false;\n        } else {\n            if first_vowel\
    \ {\n                first_vowel = false;\n            } else {\n            \
    \    if word[i] == vowels[first_vowel.as_ref()] {\n                    first_vowel\
    \ = Some(i);\n                    first_consonant = true;\n                }\n\
    \                if word[i] != vowels[first_vowel.as_ref()] {\n              \
    \      last_consonant = true;\n                }\n            }\n            if\
    \ last_consonant {\n                last_consonant = false;\n            } else\
    \ {\n                if word[i] == vowels[last_vowel.as_ref()] {\n           \
    \         last_vowel = Some(i);\n                    last_consonant = true;\n\
    \                }\n                if word[i] != vowels[last_vowel.as_ref()]\
    \ {\n                    first_vowel = Some(i);\n                    last_consonant\
    \ = true;\n                }\n            }\n        }\n    }\n    if first_vowel.is_none()\
    \ || last_consonant.is_none() {\n        return \"\".to_string();\n    }\n   \
    \ let left = first_vowel.unwrap();\n    let right = last_vowel.unwrap();\n   \
    \ word.chars()\n        .enumerate()\n        .skip_while(|&(idx, ch)| *ch ==\
    \ ' ' || ch == ' ')\n        .filter(|&(idx, ch)| ch == 'a' || ch == 'e' || ch\
    \ == 'i' || ch == 'o' || ch == 'u')\n        .take_while(|&(idx, ch)| idx >= left\
    \ && idx <= right)\n        .next()\n        .unwrap()\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwhkgpyl9.rs:19:12\n\
    \   |\n19 |         if word[i] == ' ' {\n   |            ^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwhkgpyl9.rs:23:31\n   |\n23 |         if first_consonant && word[i]\
    \ == first_vowel.as_ref() {\n   |                               ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `as_ref` found for type `bool` in\
    \ the current scope\n  --> /tmp/tmpwhkgpyl9.rs:23:54\n   |\n23 |         if first_consonant\
    \ && word[i] == first_vowel.as_ref() {\n   |                                 \
    \                     ^^^^^^ method not found in `bool`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpwhkgpyl9.rs:30:20\n   |\n\
    30 |                 if word[i] == vowels[first_vowel.as_ref()] {\n   |      \
    \              ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<Char> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut start = 0;\n    let mut end = word.len() - 1;\n\n\
    \    while start < end {\n        if word[start].is_uppercase() && word[end].is_uppercase()\
    \ {\n            while start < end {\n                if word[start].is_uppercase()\
    \ && word[end].is_uppercase() &&\n                    vowels.contains(word[end])\
    \ {\n                    return word[end].to_string();\n                }\n  \
    \              match word[start] {\n                    let ref v = word.split_ascii_lowercase().next().get(1);\n\
    \                    let ref s = word.split_ascii_lowercase().next().get(3);\n\
    \                    let ref t = word.split_ascii_lowercase().next().get(5);\n\
    \                    let ref y = word.split_ascii_lowercase().next().get(7);\n\
    \                    let ref z = word.split_ascii_lowercase().next().get(9);\n\
    \                    let ref w = word.split_ascii_lowercase().next().get(11);\n\
    \                    let ref b = word.split_ascii_lowercase().next().get(13);\n\
    \                    let ref c = word.split_ascii_lowercase().next().get(15);\n\
    \                    let ref l = word.split_ascii_lowercase().next().get(17);\n\
    \                    let ref r = word.split_ascii_lowercase().next().get(19);\n\
    \                    let ref z = word.split_ascii_lowercase().next().get(21);\n\
    \                    let ref p = word.split_ascii_lowercase().next().get(23);\n\
    \                    let ref g = word.split_ascii_lowercase().next().get(25);\n\
    \                    let ref z = word.split_ascii_lowercase().next().get(27);\n\
    \                    let ref k = word.split_ascii_lowercase().next().get(29);\n\
    \                    let ref s = word.split_ascii_lowercase().next().get(31);\n\
    \                    let ref h = word.split_ascii_lowercase().next().get(33);\n\
    \                    let ref j = word.split_ascii_lowercase().next().get(35);\n\
    \                    let ref m = word.split_ascii_lowercase().next().get(37);\n\
    \                    let ref g = word.split_ascii_lowercase().next().get(39);\n\
    \                    let ref j = word.split_ascii_lowercase().next().get(41);\n\
    \                    let ref d = word.split_ascii_lowercase().next().get(43);\n\
    \                    let ref b = word.split_ascii_lowercase().next().get(45);\n\
    \                    let ref j = word.split_ascii_lowercase().next().get(47);\n\
    \                    let ref d = word.split_ascii_lowercase().next().get(49);\n\
    \                    let ref y = word.split_ascii_lowercase().next().get(51);\n\
    \                    let ref s = word.split_ascii_lowercase().next().get(53);\n\
    \                    let ref n = word.split_ascii_lowercase().next().get(55);\n\
    \                    let ref q = word.split_ascii_lowercase().next().get(57);\n\
    \                    let ref r = word.split_\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqdqyuc2a.rs:71:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while start\
    \ < end {\n   |                       - unclosed delimiter\n17 |         if word[start].is_uppercase()\
    \ && word[end].is_uppercase() {\n   |                                        \
    \                           - unclosed delimiter\n18 |             while start\
    \ < end {\n   |                               - unclosed delimiter\n19 |     \
    \            if word[start].is_uppercase() && word[end].is_uppercase() &&\n20\
    \ |                     vowels.contains(word[end]) {\n   |                   \
    \                             - this delimiter might not be properly closed...\n\
    21 |                     return word[end].to_string();\n22 |                 }\n\
    \   |                 - ...as it matches this but it has different indentation\n\
    ...\n71 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  -->\
    \ /tmp/tmpqdqyuc2a.rs:24:21\n   |\n24 |                     let ref v = word.split_ascii_lowercase().next().get(1);\n\
    \   |                     ^^^ expected identifier, found keyword\n\nerror: expected\
    \ one of `=>`, `@`, `if`, or `|`, found keyword `ref`\n  --> /tmp/tmpqdqyuc2a.rs:24:25\n\
    \   |\n24 |                     let ref v = word.split_ascii_lowercase().next().get(1);\n\
    \   |                         ^^^ expected one of `=>`, `@`, `if`, or `|`\n\n\
    error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpqdqyuc2a.rs:12:25\n\
    \   |\n12 |     let mut vowels: Vec<Char> = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n   |                         ^^^^\n   |\nhelp: a builtin type with a similar\
    \ name exists\n   |\n12 |     let mut vowels: Vec<char> = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n   |                         ~~~~\nhelp: you might be missing\
    \ a type parameter\n   |\n11 | fn get_closest_vowel<Char>(word: String) -> String\
    \ {\n   |                     ++++++\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpqdqyuc2a.rs:17:12\n   |\n17 |    "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_set = HashSet::new();\n    vowel_set.insert(\"\
    a\".to_string());\n    vowel_set.insert(\"i\".to_string());\n    vowel_set.insert(\"\
    e\".to_string());\n    vowel_set.insert(\"o\".to_string());\n    vowel_set.insert(\"\
    u\".to_string());\n    vowel_set.insert(\"A\".to_string());\n    vowel_set.insert(\"\
    I\".to_string());\n    vowel_set.insert(\"E\".to_string());\n    vowel_set.insert(\"\
    O\".to_string());\n    vowel_set.insert(\"U\".to_string());\n    let mut start\
    \ = word.len() - 1;\n    loop {\n        if let Some(idx) = word.rfind(|c| vowel_set.contains(c.to_string()))\
    \ {\n            return word[idx..].to_string();\n        }\n        if start\
    \ < 0 {\n            return String::new();\n        }\n        if let Some(idx)\
    \ = word.rfind(|c| vowel_set.contains(c.to_string())) {\n            start = idx;\n\
    \        } else {\n            start -= 1;\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpcuogufnu.rs:12:25\n   |\n12 |     let mut vowel_set = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = String::new();\n\n    for ch in word.rposition(|&ch|\
    \ ch >= 'A' && ch <= 'Z') {\n        for consonant in 'a' - 'A' + 1..'z' - 'A'\
    \ + 1 {\n            if ch >= consonant && (ch <= 'z' || ch >= 'Z') {\n      \
    \          vowel += consonant;\n                break;\n            }\n      \
    \  }\n    }\n\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rposition` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmphefbgpav.rs:14:20\n   |\n14 |     for ch in\
    \ word.rposition(|&ch| ch >= 'A' && ch <= 'Z') {\n   |                    ^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0369]: cannot subtract `char` from `char`\n\
    \  --> /tmp/tmphefbgpav.rs:15:30\n   |\n15 |         for consonant in 'a' - 'A'\
    \ + 1..'z' - 'A' + 1 {\n   |                          --- ^ --- char\n   |   \
    \                       |\n   |                          char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmphefbgpav.rs:15:45\n   |\n\
    15 |         for consonant in 'a' - 'A' + 1..'z' - 'A' + 1 {\n   |           \
    \                              --- ^ --- char\n   |                          \
    \               |\n   |                                         char\n\nerror[E0277]:\
    \ the trait bound `&str: Step` is not satisfied\n  --> /tmp/tmphefbgpav.rs:15:26\n\
    \   |\n15 |         for consonant in 'a' - 'A' + 1..'z' - 'A' + 1 {\n   |    \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Step` is not implemented\
    \ for `&str`\n   |\n   = help: the following other types implement trait `Step`:\n\
    \             char\n             i128\n             i16\n             i32\n  \
    \           i64\n             i8\n             isize\n             u128\n    \
    \       and 5 others\n   = note: required because of the requirements on the impl\
    \ of `Iterator` for `std::ops::Range<&str>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = String::new();\n    let mut consonants\
    \ = String::new();\n    let mut consonant_index = word.len();\n    consonants.push_str(\"\
    bBcCdDfFgGhHjJkKlLmMNnNpPqQrRsStTuUvVwWxXzZ\");\n\n    while consonant_index >\
    \ 0 {\n        consonant_index -= 1;\n        consonants.push_str(word.chars().skip_while(|c|\
    \ *c == consonants[consonant_index]))\n    }\n\n    let mut vowel_index = word.len()\
    \ - 1;\n    vowel.push_str(word.chars().skip_while(|c| {\n        vowel_index\
    \ += 1;\n        vowel_index > 0 && *c == consonants[vowel_index]\n    }).collect::<String>());\n\
    \n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6i5j6_cz.rs:19:63\n\
    \   |\n19 |         consonants.push_str(word.chars().skip_while(|c| *c == consonants[consonant_index]))\n\
    \   |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6i5j6_cz.rs:19:29\n\
    \   |\n19 |         consonants.push_str(word.chars().skip_while(|c| *c == consonants[consonant_index]))\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `SkipWhile`\n   |\n   = note: expected reference\
    \ `&str`\n                 found struct `SkipWhile<Chars<'_>, [closure@/tmp/tmp6i5j6_cz.rs:19:53:\
    \ 19:90]>`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp6i5j6_cz.rs:25:34\n   |\n25 |         vowel_index > 0 && *c == consonants[vowel_index]\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6i5j6_cz.rs:23:20\n\
    \   |"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = \"aeiou\";\n    if word.len() > 0\
    \ {\n        let vowels_from_right = word.chars().rev().filter(|&c| vowels.contains(&c)).last();\n\
    \        let vowels_from_left = word.chars().filter(|&c| vowels.contains(&c)).first();\n\
    \        if vowels_from_right.is_some() && vowels_from_left.is_some() {\n    \
    \        return word[word.len() - vowels_from_right.len() - vowels_from_left.len()..].to_string();\n\
    \        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpfgv1re6x.rs:14:80\n\
    \     |\n14   |         let vowels_from_right = word.chars().rev().filter(|&c|\
    \ vowels.contains(&c)).last();\n     |                                       \
    \                                -------- ^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n     |                                                       \
    \                |\n     |                                                   \
    \                    required by a bound introduced by this call\n     |\n   \
    \  = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n14   |         let vowels_from_right\
    \ = word.chars().rev().filter(|&c| vowels.contains(*&c)).last();\n     |     \
    \                                                                           +\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpfgv1re6x.rs:15:73\n\
    \     |\n15   |         let vowels_from_left = word.chars().filter(|&c| vowels.contains(&c)).first();\n\
    \     |                                                                --------\
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n     |                 \
    \                                               |\n     |                    \
    \                                            required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n15   |         let vowels_from_left\
    \ = word.chars().filter(|&c| vowels.contains(*&c"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\", \"A\", \"E\", \"I\", \"O\", \"U\"];\n    vowels.sort_by_key(|&v| word.chars().position(|&c|\
    \ c.to_ascii_lowercase().cmp(&v)))\n        .take(word.len() - 1).collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu833tm6n.rs:13:52\n   |\n\
    13 |     vowels.sort_by_key(|&v| word.chars().position(|&c| c.to_ascii_lowercase().cmp(&v)))\n\
    \   |                                                    ^--\n   |           \
    \                                         ||\n   |                           \
    \                         |expected due to this\n   |                        \
    \                            expected `char`, found reference\n   |          \
    \                                          help: did you mean `c`: `&char`\n \
    \  |\n   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ `()` is not an iterator\n  --> /tmp/tmpu833tm6n.rs:14:10\n   |\n14 |       \
    \  .take(word.len() - 1).collect()\n   |          ^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() == 0 {\n        return \"\".to_string();\n\
    \    }\n    let mut vowel: Option<&str> = None;\n    word.split_whitespace().rev().for_each(|c|\
    \ {\n        match c.to_lowercase().as_str() {\n            \"a\" => \"a\",\n\
    \            \"e\" => \"e\",\n            \"i\" => \"i\",\n            \"o\" =>\
    \ \"o\",\n            \"u\" => \"u\",\n            \"y\" => \"y\",\n         \
    \   _ => (),\n        }\n    });\n    for vowel in word[word.len() - 1].chars().filter_map(|c|\
    \ {\n        if c.is_uppercase() {\n            Some(c.to_string())\n        }\
    \ else if c.is_lowercase() {\n            None\n        } else {\n           \
    \ None\n        }\n    }) {\n        let index = word.index(vowel);\n        let\
    \ rest = word[index + vowel.len() + 1];\n        if rest.isalpha() {\n       \
    \     return vowel.clone();\n        }\n    }\n    \"\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpbjjuz86s.rs:24:18\n\
    \   |\n17 | /         match c.to_lowercase().as_str() {\n18 | |             \"\
    a\" => \"a\",\n19 | |             \"e\" => \"e\",\n20 | |             \"i\" =>\
    \ \"i\",\n...  |\n23 | |             \"y\" => \"y\",\n   | |                 \
    \   --- this and all prior arms are found to be of type `&str`\n24 | |       \
    \      _ => (),\n   | |                  ^^ expected `&str`, found `()`\n25 |\
    \ |         }\n   | |_________- `match` arms have incompatible types\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbjjuz86s.rs:27:18\n\
    \   |\n27 |     for vowel in word[word.len() - 1].chars().filter_map(|c| {\n \
    \  |                  ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `index` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpbjjuz86s.rs:36:26\n   |\n36 |         let\
    \ index = word.index(vowel);\n   |                          ^^^^^ method not found\
    \ in `String`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code goes here\n    let vowels = \"aeiou\"\
    .to_string();\n    let vowels_size = vowels.len();\n    let mut last_consonant\
    \ = \"\";\n    for i in word.len() - 1 {\n        if word[i] == &vowels[vowels_size\
    \ - 1] { \n            last_consonant = &vowels[vowels_size - 1];\n          \
    \  break;\n        }\n    }\n    let mut last_consonant_pos = word.len();\n  \
    \  for i in word.reverse().len() {\n        if word[last_consonant_pos] == &vowels[vowels_size\
    \ - 1] {\n            break;\n        }\n        last_consonant_pos = i;\n   \
    \ }\n    last_consonant_pos\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmp9t6zcv95.rs:16:14\n\
    \   |\n16 |     for i in word.len() - 1 {\n   |              ^^^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp9t6zcv95.rs:17:24\n   |\n17 |         if word[i] ==\
    \ &vowels[vowels_size - 1] { \n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9t6zcv95.rs:18:31\n   |\n18 |             last_consonant = &vowels[vowels_size\
    \ - 1];\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp9t6zcv95"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n\tlet vowels = vec![ 'a', 'e', 'i', 'o', 'u', 'y' ];\n\t\
    let vowels_len = vowels.len();\n\tlet vowel_counts = HashMap::new();\n\tlet vowel_iter\
    \ = word.char_indices();\n\tfor vowel in vowels {\n\t\tlet mut count = 0;\n\t\t\
    let mut curr_iter = vowel_iter;\n\t\tlet mut has_next = vowel.chars().any(|c|{\n\
    \t\t\tcurr_iter.next().unwrap_or(false)\n\t\t\t\t&& c == vowel\n\t\t});\n\t\t\
    while has_next {\n\t\t\tcurr_iter.next().unwrap_or(false)?;\n\t\t\tcount += 1;\n\
    \t\t\thas_next = vowel.chars().any(|c|{\n\t\t\t\tcurr_iter.next().unwrap_or(false)\n\
    \t\t\t\t\t&& c == vowel\n\t\t\t});\n\t\t}\n\t\tvowel_counts.insert(vowel, count);\n\
    \t}\n\tlet min_count = vowel_counts.iter().min_by(|a, b|{\n\t\t*a.key.cmp(&b.key).unwrap_or(*b.key.cmp(&a.key).unwrap_or(1))\n\
    \t}).unwrap_or(1);\n\tlet mut min_vowel = String::new();\n\tlet mut curr_iter\
    \ = vowel_iter;\n\tlet mut has_next = vowel.chars().any(|c|{\n\t\tcurr_iter.next().unwrap_or(false)\n\
    \t\t\t&& c == vowel\n\t});\n\twhile has_next {\n\t\tcurr_iter.next().unwrap_or(false)?;\n\
    \t\tlet vowel = vowels[vowels.iter().position(|&a|{\n\t\t\t*a == c\n\t\t}).unwrap().unwrap()];\n\
    \t\tlet count = vowel_counts.get(&vowel).unwrap_or(0);\n\t\tif min_count > count\
    \ {\n\t\t\tmin_count = count;\n\t\t\tmin_vowel = vowel;\n\t\t}\n\t\thas_next =\
    \ vowel.chars().any(|c|{\n\t\t\tcurr_iter.next().unwrap_or(false)\n\t\t\t\t&&\
    \ c == vowel\n\t\t});\n\t}\n\treturn min_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpgq76zej8.rs:14:21\n   |\n14 |     let vowel_counts = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `vowel` in this scope\n  --> /tmp/tmpgq76zej8.rs:38:21\n \
    \  |\n38 |     let mut has_next = vowel.chars().any(|c|{\n   |               \
    \         ^^^^^ help: a local variable with a similar name exists: `vowels`\n\n\
    error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpgq76zej8.rs:40:12\n\
    \   |\n40 |             && c == vowel\n   |                     ^^^^^ help: a\
    \ local variable with a similar name exists: `vowels`\n\nerror[E0425]: cannot\
    \ find value `c` in this scope\n  --> /tmp/tmpgq76zej8.rs:45:10\n   |\n45 |  \
    \           *a == c\n   |                   ^ help: a local variable with a similar\
    \ name exists: `a`\n\nerror[E0599]: no method named `chars` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpgq76zej8.rs:19:28\n   |\n19 |         let\
    \ mut has_next = vowel.chars().any(|c|{\n   |                                \
    \  ^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgq76zej8.rs:20:31\n\
    \   |\n20 |             curr_iter.next().unwrap_or(false)\n   |              \
    \                          ^^^^^ expected tuple, found `bool`\n   |\n   = note:\
    \ expected tuple `(usize, char)`\n               found type `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgq76zej8.rs:20:4\n   |\n20 |             curr_iter.next().unwrap_or(false)\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found tuple\n\
    \   |\n   = note: expected type `bool`\n             found tuple `(usize, char)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgq76zej8.rs:24:31\n   |\n24 |\
    \             curr_iter.next().unwrap_or(false)?;\n   |                      \
    \                  ^^^^^ expected tuple, found `bool`\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found type `bool`\n\nerror[E0277]: the\
    \ `?` oper"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut left = 0\n    let mut right = word.len() -\
    \ 1;\n\n    let mut vowels = vec!['A', 'a', 'O', 'o', 'U', 'u', 'E', 'e']\n  \
    \  .iter()\n    .filter(|&vowel| {\n        if *vowel == word[left] || word[left]\
    \ == ' ' {\n            vowel.parse::<i32>().is_err()\n        } else {\n    \
    \        false\n        }\n    });\n\n    if word[right] == 'o' || word[right]\
    \ == 'u' {\n        vowels.push(word[right]);\n    }\n\n    let mut vowel_count\
    \ = 0;\n\n    while left < right {\n        match vowels.next() {\n          \
    \  Some(vowel) => {\n                if vowel == word[right] {\n             \
    \       vowel_count += 1;\n                } else {\n                    vowel_count\
    \ = 1;\n                }\n            },\n            None => break,\n      \
    \  }\n\n        left += 1;\n    }\n\n    if vowel_count == 0 {\n        \"\".to_string()\n\
    \    } else {\n        vowels.next().unwrap().to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmphx76bx4o.rs:12:21\n\
    \   |\n12 |     let mut left = 0\n   |                     ^ help: add `;` here\n\
    13 |     let mut right = word.len() - 1;\n   |     --- unexpected token\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmphx76bx4o.rs:18:22\n\
    \   |\n18 |         if *vowel == word[left] || word[left] == ' ' {\n   |     \
    \                 ^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmphx76bx4o.rs:18:36\n   |\n18 |         if *vowel == word[left] ||\
    \ word[left] == ' ' {\n   |                                    ^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `parse` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmphx76bx4o.rs:19:19\n   |\n19 |          \
    \   vowel.parse::<i32>().is_err()\n   |                   ^^^^^ method not found\
    \ in `&char`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphx76bx4o.rs:25:8\n   |\n25 |     if word[right] == 'o' || word[right] "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 || word.len() > 5 || word[0] != word[0]\
    \ {\n        return \"\";\n    }\n    let mut vowels = Vec::new();\n    vowels.push(word[0]);\n\
    \    for c in word.clone() {\n        if c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n            || c ==\
    \ 'O' || c == 'U' {\n            vowels.push(c);\n        }\n    }\n    if vowels.len()\
    \ == 0 {\n        return \"\";\n    }\n    let mut vowels_count = vowels.len();\n\
    \    let mut next_consonant = 1;\n    let mut closest = &vowels.first();\n   \
    \ let mut next_closest = &vowels.first();\n    let mut index = 0;\n    while vowels_count\
    \ > 0 {\n        let mut distance = word.len() - vowels_count;\n        while\
    \ distance >= 0 {\n            let mut index = word.chars().rposition(|&c| c ==\
    \ next_closest).unwrap();\n            if index < word.len() && index >= 0 {\n\
    \                closest = next_closest;\n                next_closest = (&vowels)[index];\n\
    \                distance = distance - 1;\n            }\n            distance\
    \ = distance - 1;\n        }\n        index = index + 1;\n        next_closest\
    \ = (&vowels)[index];\n        vowels_count = vowels_count - 1;\n    }\n    if\
    \ closest == &vowels.first() {\n        return \"\";\n    }\n    return closest;\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp3_k20xi0.rs:12:44\n   |\n12 |     if word.len() < 3 || word.len() >\
    \ 5 || word[0] != word[0] {\n   |                                            ^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp3_k20xi0.rs:12:55\n   |\n12 |     if word.len() < 3 || word.len()\
    \ > 5 || word[0] != word[0] {\n   |                                          \
    \             ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3_k20xi0.rs:13:16\n   |\n11 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n12 |     if word.len() < 3 || word.len() >\
    \ 5 || word[0] != word[0] {\n13 |         return \"\";\n   |                ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                |\n\
    \   |                expected struct `String`, found `&str`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().skip_while(|&c| !is_vowel(c)).take_while(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').collect::<String>().cloned()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpohdacj6b.rs:12:35\n\
    \   |\n12 |     word.chars().skip_while(|&c| !is_vowel(c)).take_while(|c| *c ==\
    \ 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').collect::<St...\n \
    \  |                                   ^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `String` is not an iterator\n   --> /tmp/tmpohdacj6b.rs:12:146\n    |\n12  |\
    \   ...*c == 'u').collect::<String>().cloned()\n    |                        \
    \             ^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    // Find first vowel in the right side.\n    let\
    \ first_vowel = word.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u').next();\n    \n    // Find last vowel in the right side.\n\
    \    let last_vowel = word.chars().filter(|c| c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U').next();\n    \n    // Find the first vowel between\
    \ first_vowel and last_vowel.\n    let current_index = word.chars().rposition(|c|\
    \ c == first_vowel);\n    \n    // Find the last vowel between first_vowel and\
    \ last_vowel.\n    let next_index = word.chars().rposition(|c| c == last_vowel);\n\
    \    \n    // Check if there is at least one vowel in the right side.\n    if\
    \ current_index == Some(next_index) \n    { \n        // If the two vowels are\
    \ in the right side, then return it.\n        return String::from(first_vowel);\n\
    \    }\n    \n    // If the two vowels are not in the right side then return empty\
    \ string.\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnpn0s6p7.rs:14:49\n\
    \   |\n14 |     let first_vowel = word.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').next();\n   |                         \
    \                        ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpnpn0s6p7.rs:14:61\n   |\n14 |     let first_vowel\
    \ = word.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').next();\n   |                                                      \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnpn0s6p7.rs:14:73\n\
    \   |\n14 |     let first_vowel = word.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').next();\n   |                         \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpnpn0s6p7.rs:14:85\n   |\n14\
    \ |     let first_vowel = word.chars().filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u').next();\n   |                                 \
    \                                                    ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnpn0s6p7.rs:14:97\n\
    \   |\n14 |     let first_vowel = word.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').next();\n   |                         \
    \                     "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n\n    let mut start\
    \ = word.rfind('a', 0);\n    let mut end = word.rfind('u');\n    while start <\
    \ end {\n        let vowel = word[start + 1];\n        if vowel != \"a\" && vowel\
    \ != \"e\" && vowel != \"i\" && vowel != \"o\" && vowel != \"u\" {\n         \
    \   break;\n        }\n        start = word.rfind('a', start + 1);\n    }\n\n\
    \    if start < end {\n        result = word[start..end].to_string();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpwyd61e2k.rs:14:26\n     |\n14   |     let mut start = word.rfind('a',\
    \ 0);\n     |                          ^^^^^ ---  - supplied 2 arguments\n   \
    \  |                          |\n     |                          expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpwyd61e2k.rs:17:32\n   |\n17 |         let\
    \ vowel = word[start + 1];\n   |                          ----- ^ - {integer}\n\
    \   |                          |\n   |                          Option<usize>\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpwyd61e2k.rs:21:39\n\
    \   |\n21 |         start = word.rfind('a', start + 1);\n   |                \
    \                 ----- ^ - {integer}\n   |                                 |\n\
    \   |                                 Option<usize>\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpwyd61e2k.rs:21:22\n\
    \     |\n21   |         start = word.rfind('a', start + 1);\n     |          \
    \            ^^^^^ ---  --------- supplied 2 arguments\n     |               \
    \       |\n     |                      expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `std::ops::Range<Option<usize>>`\n  --> /tmp/tmpwyd61e2k.rs:25:18\n   |\n25\
    \ |         result = word[start..end].to_string();\n   |                  ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `std::ops::Range<Option<usize>>`\n   |\n   = help:\
    \ the trait `Index<std::ops::Range<Option<usize>>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<String> = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n\n    let word_string = word.to_lowercase();\n    for vowel\
    \ in vowels {\n        if word_string.contains(vowel) {\n            return vowel;\n\
    \        }\n    }\n    \"\"\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2u2i8l5x.rs:12:40\n   |\n\
    12 |     let mut vowels: Vec<String> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n   |                                        ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                        |\n   |\
    \                                        expected struct `String`, found `&str`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmp2u2i8l5x.rs:16:33\n\
    \     |\n16   |         if word_string.contains(vowel) {\n     |             \
    \           -------- ^^^^^ expected an implementor of trait `Pattern<'_>`\n  \
    \   |                        |\n     |                        required by a bound\
    \ introduced by this call\n     |\n     = note: the trait bound `String: Pattern<'_>`\
    \ is not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider borrowing here\n     |\n16   |         if word_string.contains(&vowel)\
    \ {\n     |                                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2u2i8l5x.rs:20:5\n   |\n11 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n20 |     \"\"\n   |     ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    for vowel in vowels.iter() {\n        if word.len() >= vowel.len()\
    \ {\n            let mut index = word.len();\n            for cons in vowels.iter().rev()\
    \ {\n                if index >= cons.len() {\n                    return vowel.to_string();\n\
    \                }\n                index = index - cons.len();\n            }\n\
    \        }\n    }\n    \"\"\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp38jc9pkb.rs:24:5\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n...\n24 |\
    \     \"\"\n   |     ^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![];\n    let mut last_consonant\
    \ = String::new();\n    for &consonant in word.as_str().rposition(|c| !c.is_ascii_letter())\
    \ {\n        if consonant.is_ascii_letter() {\n            last_consonant = consonant;\n\
    \        } else {\n            vowels.push(consonant.to_ascii_lowercase());\n\
    \        }\n    }\n\n    if vowels.len() == 0 {\n        return String::new();\n\
    \    }\n\n    let vowel_mut =  vowels.iter().take_while(|&vowel| vowel.chars().any(|c|\
    \ !c.is_ascii_letter())).cloned().collect();\n    let consonant_mut =  vowels.iter().take_while(|&consonant|\
    \ consonant.chars().any(|c| !c.is_ascii_letter())).cloned().collect();\n    let\
    \ mut vowel_next = String::new();\n    let mut consonant_next = String::new();\n\
    \n    loop {\n        if consonant_next.len() > 0 {\n            consonant_next\
    \ = consonant_next.into_lowercase();\n        } else {\n            consonant_next\
    \ = last_consonant;\n        }\n\n        if vowel_next.len() > 0 {\n        \
    \    vowel_next = vowel_next.into_lowercase();\n        } else {\n           \
    \ vowel_next = vowels.next().unwrap();\n        }\n\n        if consonant_next.chars().any(|c|\
    \ c.is_ascii_letter()) && !vowel_next.chars().any(|c| c.is_ascii_letter()) {\n\
    \            break;\n        }\n    }\n\n    vowel_next.to_ascii_lowercase()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rposition` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmprxml4mmv.rs:14:37\n   |\n14 |     for &consonant\
    \ in word.as_str().rposition(|c| !c.is_ascii_letter()) {\n   |               \
    \                      ^^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no\
    \ method named `into_lowercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmprxml4mmv.rs:33:45\n   |\n33 |             consonant_next = consonant_next.into_lowercase();\n\
    \   |                                             ^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ no method named `into_lowercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmprxml4mmv.rs:39:37\n   |\n39 |             vowel_next = vowel_next.into_lowercase();\n\
    \   |                                     ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_ascii_letter` found for type `char` in the current scope\n  --> /tmp/tmprxml4mmv.rs:44:45\n\
    \   |\n44 |         if consonant_next.chars().any(|c| c.is_ascii_letter()) &&\
    \ !vowel_next.chars().any(|c| c.is_ascii_letter()) {\n   |                   \
    \                          ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmprxml4mmv.rs:44:97\n\
    \   |\n44 |         if consonant_next.chars().any(|c| c.is_ascii_letter()) &&\
    \ !vowel_next.chars().any(|c| c.is_ascii_letter()) {\n   |                   \
    \                                                                            \
    \  ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate()\n        .enumerate()\n  \
    \      .find(|(_, c)| !c.is_uppercase())\n        .unwrap_or(word.len())\n   \
    \     .wrapping_add(1).unwrap_or_else(|| word.len())\n        .map{|i| if i >=\
    \ word.len() || !i.is_vowel() {return \"\"}; i}\n        .unwrap()\n        .wrapping_add(1).unwrap()\n\
    \        .to_string_lossy().to_string()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `.`, `::`, `;`, `?`, `}`, or an operator, found\
    \ `{`\n  --> /tmp/tmpzjhju1p3.rs:17:13\n   |\n17 |         .map{|i| if i >= word.len()\
    \ || !i.is_vowel() {return \"\"}; i}\n   |             ^ expected one of 7 possible\
    \ tokens\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars()\n        .filter(|&c| c !='A' && c !='E'\
    \ && c !='I' && c !='O' && c !='U' && c !='Y')\n        .filter(|&c| c !='a')\n\
    \        .filter(|&c| c !='e')\n        .filter(|&c| c !='i')\n        .filter(|&c|\
    \ c !='o')\n        .filter(|&c| c !='u')\n        .filter(|&c| c !='y')\n   \
    \     .last()\n        .unwrap_or(String::new())\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmb997dzy.rs:21:20\n   |\n\
    21 |         .unwrap_or(String::new())\n   |                    ^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpmb997dzy.rs:12:5\n   |\n11 |   fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                         ------ expected `String`\
    \ because of return type\n12 | /     word.chars()\n13 | |         .filter(|&c|\
    \ c !='A' && c !='E' && c !='I' && c !='O' && c !='U' && c !='Y')\n14 | |    \
    \     .filter(|&c| c !='a')\n15 | |         .filter(|&c| c !='e')\n...  |\n20\
    \ | |         .last()\n21 | |         .unwrap_or(String::new())\n   | |      \
    \                           ^- help: try using a conversion method: `.to_string()`\n\
    \   | |_________________________________|\n   |                              \
    \     expected struct `String`, found `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = \"a\";\n    let mut index = 0;\n \
    \   for c in word.chars() {\n        vowels = c.to_lowercase().chars().skip_while(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').collect::<Vec<_>>()\n\
    \            .into_iter().find(|v| *v != *c).unwrap(); // find first vowel before\
    \ current letter\n        index = *c;\n    }\n    vowels\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmpblf_6g0f.rs:15:35\n   |\n15 |         vowels\
    \ = c.to_lowercase().chars().skip_while(|c| *c != 'a' && *c != 'e' && *c != 'i'\
    \ && *c != 'o' && *c != 'u').collect::<Vec<_>>()\n   |                       \
    \            ^^^^^ method not found in `ToLowercase`\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpblf_6g0f.rs:16:41\n   |\n16 |        \
    \     .into_iter().find(|v| *v != *c).unwrap(); // find first vowel before current\
    \ letter\n   |                                         ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpblf_6g0f.rs:17:17\n   |\n17 | \
    \        index = *c;\n   |                 ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpblf_6g0f.rs:19:5\n   |\n11 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n19 |     vowels\n   |     ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut current = word.chars();\n    let mut vowel\
    \ = String::new();\n    vowel.push(0);\n\n    current.next();\n    current.next();\n\
    \    current.next();\n    current.next();\n    current.next();\n    current.next();\n\
    \n    while !current.is_empty() {\n        current.next();\n        if current\
    \ == vowel.chars() {\n            break;\n        }\n        current.next();\n\
    \    }\n\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9d052em_.rs:14:16\n   |\n\
    14 |     vowel.push(0);\n   |                ^ expected `char`, found `u8`\n\n\
    error[E0599]: no method named `is_empty` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp9d052em_.rs:23:20\n   |\n23 |     while !current.is_empty()\
    \ {\n   |                    ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0369]:\
    \ binary operation `==` cannot be applied to type `Chars<'_>`\n  --> /tmp/tmp9d052em_.rs:25:20\n\
    \   |\n25 |         if current == vowel.chars() {\n   |            ------- ^^\
    \ ------------- Chars<'_>\n   |            |\n   |            Chars<'_>\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels_found = false;\n    let mut vowel_to_search\
    \ = \"\";\n    let mut prev_pos = 0;\n    let mut i = 0;\n    while i < word.len()\
    \ {\n        let mut found = false;\n        if word[i] >= 'A' && word[i] <= 'Z'\
    \ {\n            vowel_to_search = word[i..].to_lowercase();\n            for\
    \ i in 1..word.length() - vowel_to_search.len() {\n                if word[i]\
    \ == vowel_to_search[i - 1] { found = true; }\n            }\n        } else {\n\
    \            vowel_to_search = word[i..].to_lowercase();\n            for i in\
    \ 1..word.length() - vowel_to_search.len() {\n                if word[i] == vowel_to_search\
    \ { found = true; }\n            }\n        }\n        if found {\n          \
    \  prev_pos = i;\n            vowels_found = true;\n        }\n        i = prev_pos\
    \ + 1;\n    }\n    if vowels_found {\n        vowel_to_search\n    } else {\n\
    \        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa5dl829x.rs:18:12\n\
    \   |\n18 |         if word[i] >= 'A' && word[i] <= 'Z' {\n   |            ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa5dl829x.rs:18:30\n   |\n18 |         if word[i] >= 'A' && word[i]\
    \ <= 'Z' {\n   |                              ^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa5dl829x.rs:19:31\n\
    \   |\n13 |     let mut vowel_to_search = \"\";\n   |                        \
    \       -- expected due to this value\n...\n19 |             vowel_to_search =\
    \ word[i..].to_lowercase();\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                               |\n   |                               expected\
    \ `&str`, found struct `String`\n   |                               help: consider\
    \ borrowing here: `&word[i..].to_lowercase()`\n\nerror[E0599]: no method named\
    \ `length` found for struct `String` in the current scope\n  --> /tmp/tmpa5dl829x.rs:20:30\n\
    \   |\n20 |             for i in 1..wor"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index: usize = 0;\n    let mut current_vowel:\
    \ Option<String> = None;\n    for c in word.chars() {\n        if c.to_lowercase().contains(\"\
    a\") {\n            vowel_index = word.chars().position(|c| c.to_lowercase() ==\
    \ 'a');\n            current_vowel = Some(word.chars().nth(vowel_index));\n  \
    \      }\n        if c.to_lowercase().contains(\"e\") {\n            vowel_index\
    \ = word.chars().position(|c| c.to_lowercase() == 'e');\n            current_vowel\
    \ = Some(word.chars().nth(vowel_index));\n        }\n        if c.to_lowercase().contains(\"\
    i\") {\n            vowel_index = word.chars().position(|c| c.to_lowercase() ==\
    \ 'i');\n            current_vowel = Some(word.chars().nth(vowel_index));\n  \
    \      }\n        if c.to_lowercase().contains(\"o\") {\n            vowel_index\
    \ = word.chars().position(|c| c.to_lowercase() == 'o');\n            current_vowel\
    \ = Some(word.chars().nth(vowel_index));\n        }\n        if c.to_lowercase().contains(\"\
    u\") {\n            vowel_index = word.chars().position(|c| c.to_lowercase() ==\
    \ 'u');\n            current_vowel = Some(word.chars().nth(vowel_index));\n  \
    \      }\n        if !current_vowel.is_some() {\n            if current_vowel.is_none()\
    \ {\n                return \"\";\n            } else {\n                return\
    \ current_vowel.unwrap();\n            }\n        }\n    }\n    return \"\";\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmp5361m0ta.rs:15:29\n   |\n15 |         if\
    \ c.to_lowercase().contains(\"a\") {\n   |                             ^^^^^^^^\
    \ method not found in `ToLowercase`\n\nerror[E0369]: binary operation `==` cannot\
    \ be applied to type `ToLowercase`\n  --> /tmp/tmp5361m0ta.rs:16:70\n   |\n16\
    \ |             vowel_index = word.chars().position(|c| c.to_lowercase() == 'a');\n\
    \   |                                                     ---------------- ^^\
    \ --- char\n   |                                                     |\n   | \
    \                                                    ToLowercase\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5361m0ta.rs:16:27\n   |\n12 |     let mut vowel_index:\
    \ usize = 0;\n   |                          ----- expected due to this type\n\
    ...\n16 |             vowel_index = word.chars().position(|c| c.to_lowercase()\
    \ == 'a');\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5361m0ta.rs:17:34\n   |\n17 |             current_vowel = Some(word.chars().nth(vowel_index));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<char>`\n\nerror[E0599]: no method named `contains`\
    \ found for struct `ToLowercase` in the current scope\n  --> /tmp/tmp5361m0ta.rs:19:29\n\
    \   |\n19 |         if c.to_lowercase().contains(\"e\") {\n   |              \
    \               ^^^^^^^^ method not found in `ToLowercase`\n\nerror[E0369]: binary\
    \ operation `==` cannot be applied to type `ToLowercase`\n  --> /tmp/tmp5361m0ta.rs:20:70\n\
    \   |\n20 |             vowel_index = word.chars().position(|c| c.to_lowercase()\
    \ == 'e');\n   |                                                     ----------------\
    \ ^^ --- char\n   |                                             "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut index = word.length() - 1;\n    while index >= 0\
    \ {\n        if word.chars().any(|c| vowels.contains(c.to_lowercase())) {\n  \
    \          let mut vowel_index = vowels.iter().position(|&x| x == c.to_lowercase());\n\
    \            if vowel_index != 0 {\n                let vowel = &vowels[vowel_index\
    \ - 1];\n                return vowel;\n            }\n        }\n        index\
    \ -= 1;\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp7ha5o0a9.rs:16:68\n\
    \   |\n16 |             let mut vowel_index = vowels.iter().position(|&x| x ==\
    \ c.to_lowercase());\n   |                                                   \
    \                 ^ help: a local variable with a similar name exists: `x`\n\n\
    error[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp7ha5o0a9.rs:13:26\n   |\n13 |     let mut index = word.length()\
    \ - 1;\n   |                          ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ha5o0a9.rs:15:49\n\
    \   |\n15 |         if word.chars().any(|c| vowels.contains(c.to_lowercase()))\
    \ {\n   |                                                 ^^^^^^^^^^^^^^^^ expected\
    \ `&&str`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7ha5o0a9.rs:17:31\n   |\n17 |             if vowel_index != 0 {\n  \
    \ |                               ^ expected enum `Option`, found integer\n  \
    \ |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n17 |             if vowel_index\
    \ != Some(0) {\n   |                               +++++ +\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmp7ha5o0a9.rs:18:49\n\
    \   |\n18 |                 let vowel = &vowels[vowel_index - 1];\n   |      \
    \                               ----------- ^ - {integer}\n   |              \
    \                       |\n   |                                     Option<usize>\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = Vec::new();\n    let mut\
    \ consonants: Vec<&str> = Vec::new();\n    \n    for (i, c) in word.chars().enumerate()\
    \ {\n        if c.is_upper() {\n            vowels.push(String::from(&word[i..i].to_string()));\n\
    \        } else {\n            consonants.push(String::from(&word[i..i].to_string()));\n\
    \        }\n    }\n\n    let mut left_consonant_idx = 0;\n    let mut right_consonant_idx\
    \ = word.len() - 1;\n\n    loop {\n        if vowels.len() > 0 {\n           \
    \ return vowels[0][left_consonant_idx % vowels[0].len()];\n        }\n\n     \
    \   let mut left_vowel_idx = left_consonant_idx;\n        let mut right_vowel_idx\
    \ = right_consonant_idx;\n        \n        if left_vowel_idx == left_consonant_idx\
    \ {\n            left_vowel_idx += 1;\n        }\n\n        if right_vowel_idx\
    \ == right_consonant_idx {\n            right_vowel_idx -= 1;\n        }\n\n \
    \       if right_vowel_idx <= left_vowel_idx {\n            return \"\";\n   \
    \     }\n\n        if vowels[left_vowel_idx] != \"\" {\n            let mut right_vowel\
    \ = vowels[left_vowel_idx];\n            \n            left_vowel_idx -= 1;\n\n\
    \            while right_vowel_idx > left_vowel_idx {\n                right_vowel\
    \ -= 1;\n                if right_vowel == \"\" {\n                    break;\n\
    \                }\n                right_vowel_idx -= 1;\n            }\n\n \
    \           if right_vowel_idx > left_vowel_idx {\n                right_vowel\
    \ = vowels[left_vowel_idx];\n                left_vowel_idx -= 1;\n          \
    \  }\n\n            if right_vowel_idx > left_vowel_idx {\n                right_vowel\
    \ = vowels[left_vowel_idx];\n                left_vowel_idx -= 1;\n          \
    \  }\n\n            return right_vowel[left_vowel_idx % right_vowel.len()];\n\
    \        }\n        \n        left_consonant_idx += 1;\n        right_consonant_idx\
    \ -= 1;\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpd1_4n_62.rs:16:14\n   |\n16 |         if c.is_upper() {\n\
    \   |              ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd1_4n_62.rs:17:25\n\
    \   |\n17 |             vowels.push(String::from(&word[i..i].to_string()));\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |    \
    \                     |\n   |                         expected `&str`, found struct\
    \ `String`\n   |                         help: consider borrowing here: `&String::from(&word[i..i].to_string())`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd1_4n_62.rs:19:29\n   |\n19 |\
    \             consonants.push(String::from(&word[i..i].to_string()));\n   |  \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |      \
    \                       |\n   |                             expected `&str`, found\
    \ struct `String`\n   |                             help: consider borrowing here:\
    \ `&String::from(&word[i..i].to_string())`\n\nerror[E0277]: the type `str` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpd1_4n_62.rs:28:20\n   |\n28 |         \
    \    return vowels[0][left_consonant_idx % vowels[0].len()];\n   |           \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd1_4n_62.rs:43:20\n\
    \   |\n43 |             return \"\";\n   |                    ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                    |\n   |       \
    \             expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `&str`\n  --> /tmp/tmpd1_4n_62.rs:52:17\n\
    \   |\n52 |                 right_vowel -= 1;\n   |                 -----------^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_iter = vowels.iter();\n    let vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_len = vowels.len();\n\
    \    let mut vowels_iter = vowels.iter();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmprxc_1hv9.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = \"aeiou\";\n    let mut pos = word.len();\n\
    \    let mut res = String::new();\n    \n    while pos > 0 {\n        if word.starts_with(vowels)\
    \ {\n            res.push_str(vowels.to_owned());\n            \n            word.swap(0,\
    \ 0);\n            pos = 0;\n        }\n        \n        pos-= 1;\n    }\n  \
    \  \n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiqxydrfi.rs:18:26\n   |\n\
    18 |             res.push_str(vowels.to_owned());\n   |                      \
    \    ^^^^^^^^^^^^^^^^^\n   |                          |\n   |                \
    \          expected `&str`, found struct `String`\n   |                      \
    \    help: consider borrowing here: `&vowels.to_owned()`\n\nerror[E0599]: no method\
    \ named `swap` found for struct `String` in the current scope\n  --> /tmp/tmpiqxydrfi.rs:20:18\n\
    \   |\n20 |             word.swap(0, 0);\n   |                  ^^^^ method not\
    \ found in `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel: Option<usize> = None;\n    let mut index:\
    \ usize = 0;\n    let mut last_vowel = word.rfind(\"a\", String::npos);\n    if\
    \ last_vowel == String::npos { \n        last_vowel = word.len();\n    }\n   \
    \ for con in word.rchars().skip(last_vowel).rev() {\n        if vowel == Some(index)\
    \ {\n            break;\n        }\n        if con == Some('a'..='z')  {\n   \
    \         vowel = Some(index);\n        }\n        index = con;\n    }\n    if\
    \ vowel == None {\n        return \"\";\n    }\n    word[vowel.take()]\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpiy55g5v_.rs:14:50\n   |\n14 | \
    \    let mut last_vowel = word.rfind(\"a\", String::npos);\n   |             \
    \                                     ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n    --> /tmp/tmpiy55g5v_.rs:14:31\n     |\n14   |     let mut\
    \ last_vowel = word.rfind(\"a\", String::npos);\n     |                      \
    \         ^^^^^ ---  ------------ supplied 2 arguments\n     |               \
    \                |\n     |                               expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0599]: no function or\
    \ associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpiy55g5v_.rs:15:30\n   |\n15 |     if last_vowel == String::npos\
    \ { \n   |                              ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiy55g5v_.rs:16:22\n\
    \   |\n14 |     let mut last_vowel = word.rfind(\"a\", String::npos);\n   |  \
    \                        ----------------------------- expected due to this value\n\
    15 |     if last_vowel == String::npos { \n16 |         last_vowel = word.len();\n\
    \   |                      ^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n16 |         last_vowel = Some(word.len());\n\
    \   |                      +++++          +\n\nerror[E0599]: no method named `rchars`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpiy55g5v_.rs:18:21\n\
    \   |\n18 |     for con in word.rchars().skip(last_vowel).rev() {\n   |      \
    \               ^^^^^^ help: there is an associated function with a similar name:\
    \ `chars`\n\nerror[E0277]: can't compare `usize` with `Option<RangeInclusive<char>>`\n\
    \  --> /tmp/tmpiy55g5v_.rs:22:16\n   |\n22 |         if con == Some('a'..='z')\
    \  {\n   |                ^^ no implementat"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels_stack = Vec::new();\n    let mut vowels\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = 0;\n\
    \    for c in word.chars() {\n        if vowels.contains(c) {\n            vowels_stack.push(vowels_index);\n\
    \        }\n        vowels_index += 1;\n    }\n    vowels_stack.push(-2);\n  \
    \  if vowels_stack.len() == 0 {\n        return \"\".to_string();\n    }\n   \
    \ let mut vowels_index = vowels_stack.pop().unwrap();\n    let mut consonants_stack\
    \ = Vec::new();\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"\
    g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"v\", \"w\", \"x\", \"z\"];\n    let mut consonants_index = 0;\n    for\
    \ c in word.chars() {\n        if consonants.contains(c) {\n            consonants_stack.push(consonants_index);\n\
    \        }\n        consonants_index += 1;\n    }\n    consonants_stack.push(-2);\n\
    \    if consonants_stack.len() == 0 {\n        return \"\".to_string();\n    }\n\
    \    let mut consonants_index = consonants_stack.pop().unwrap();\n    match vowels_index\
    \ - consonants_index {\n        1 => return \"\".to_string(),\n        -1 => return\
    \ \"u\".to_string(),\n        _ => {\n            match vowels_index - consonants_index\
    \ {\n                2 => return \"u\".to_string(),\n                -2 => return\
    \ \"\".to_string(),\n                _ => {\n                    match vowels_index\
    \ - consonants_index {\n                        3 => return \"i\".to_string(),\n\
    \                        -3 => return \"\".to_string(),\n                    \
    \    _ => {\n                            match vowels_index - consonants_index\
    \ {\n                                4 => return \"e\".to_string(),\n        \
    \                        -4 => return \"\".to_string(),\n                    \
    \            _ => {\n                                    match vowels_index -\
    \ consonants_index {\n                                        5 => return \"o\"\
    .to_string(),\n                                        -5 => return \"\".to_string(),\n\
    \                                        _ => {\n                            \
    \                match vowels_index - consonants_index {\n                   \
    \                             6 => return \"a\".to_string(),\n               \
    \                                 -6 => return \"\".to_string(),\n           \
    \                                     _ => {\n                               \
    \                     match vowels_index - consonants_index {\n              \
    \                                          7 => return \"e\".to_string(),\n  \
    \                                                      -7 => return \"\".to_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpukn4nel9.rs:84:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n40 |     match vowels_index\
    \ - consonants_index {\n   |                                           - unclosed\
    \ delimiter\n...\n43 |         _ => {\n   |              - unclosed delimiter\n\
    44 |             match vowels_index - consonants_index {\n   |               \
    \                                    - unclosed delimiter\n...\n47 |         \
    \        _ => {\n   |                      - unclosed delimiter\n48 |        \
    \             match vowels_index - consonants_index {\n   |                  \
    \                                         - unclosed delimiter\n...\n51 |    \
    \                     _ => {\n   |                              - unclosed delimiter\n\
    52 |                             match vowels_index - consonants_index {\n   |\
    \                                                                   - unclosed\
    \ delimiter\n...\n55 |                                 _ => {\n   |          \
    \                            - unclosed delimiter\n56 |                      \
    \               match vowels_index - consonants_index {\n   |                \
    \                                                           - unclosed delimiter\n\
    ...\n59 |                                         _ => {\n   |               \
    \                               - unclosed delimiter\n60 |                   \
    \                          match vowels_index - consonants_index {\n   |     \
    \                                                                            \
    \  - unclosed delimiter\n...\n63 |                                           \
    \      _ => {\n   |                                                      - unclosed\
    \ delimiter\n64 |                                                     match vowels_index\
    \ - consonants_index {\n   |                                                 \
    \                                          - this delimiter might not be properly\
    \ closed...\n...\n67 | }\n   | - ...as it matches t"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.is_empty() {\n        return \"\";\n    }\n\
    \n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\n    let mut\
    \ vowel_iter = word.chars().rposition(|&c| vowels.contains(&c.to_lowercase()));\n\
    \n    if vowel_iter.is_none() {\n        return \"\";\n    }\n\n    let mut cur_vowel\
    \ = 0;\n    let mut cur_consonant = 0;\n\n    for &c in vowel_iter.unwrap().unwrap().as_ref()\
    \ {\n        if c.to_lowercase() == &vowels[cur_vowel] {\n            cur_vowel\
    \ += 1;\n        } else {\n            cur_consonant += 1;\n        }\n    }\n\
    \n    if cur_consonant < cur_vowel - 1 {\n        cur_vowel -= 1;\n    }\n\n \
    \   if cur_consonant == 1 {\n        if cur_vowel == 0 {\n            return \"\
    \".to_string();\n        } else {\n            return vowels[cur_vowel].to_string();\n\
    \        }\n    }\n\n    vowels[cur_vowel].to_string()\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi6hpbmzf.rs:13:16\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if word.is_empty() {\n13 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0277]: the trait\
    \ bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpi6hpbmzf.rs:18:39\n\
    \     |\n18   |     let mut vowel_iter = word.chars().rposition(|&c| vowels.contains(&c.to_lowercase()));\n\
    \     |                                       ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi6hpbmzf.rs:18:50\n   |\n18 |     let mut vowel_iter =\
    \ word.chars().rposition(|&c| vowels.contains(&c.to_lowercase()));\n   |     \
    \                                             ^--\n   |                      \
    \                            ||\n   |                                        \
    \          |expected due to this\n   |                                       \
    \           expected `char`, found reference\n   |                           \
    \                       help: did you mean `c`: `&char`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpi6hpbmzf.rs:27:35\n\
    \   |\n27 |     for &c in vowel_iter.unwrap().unwrap().as_ref() {\n   |      \
    \                             ^^^^^^ method not found in `usize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome err"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_ending = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\n\
    \    for c in word.chars() {\n        let index = vowels.iter().position(|&x|\
    \ x.chars().any(|&y| y == c));\n        if index != None {\n            vowels_ending.remove(index);\n\
    \        } else {\n            vowels_ending.push(c);\n        }\n    }\n\n  \
    \  vowels_ending.iter().cloned().find(|&x| vowels.iter().any(|&y| x == y)).map(|x|\
    \ x.to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpopdsb7sa.rs:16:64\n   |\n\
    16 |         let index = vowels.iter().position(|&x| x.chars().any(|&y| y == c));\n\
    \   |                                                                ^--\n   |\
    \                                                                ||\n   |    \
    \                                                            |expected due to\
    \ this\n   |                                                                expected\
    \ `char`, found reference\n   |                                              \
    \                  help: did you mean `y`: `&char`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpopdsb7sa.rs:18:34\n   |\n18 |             vowels_ending.remove(index);\n\
    \   |                                  ^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpopdsb7sa.rs:20:32\n   |\n20 |\
    \             vowels_ending.push(c);\n   |                                ^ expected\
    \ `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpopdsb7sa.rs:24:5\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    24 |     vowels_ending.iter().cloned().find(|&x| vowels.iter().any(|&y| x == y)).map(|x|\
    \ x.to_string())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<String>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    let mut\
    \ vowel_index = word.chars().enumerate().cloned().collect::<Vec<_>>();\n    vowel_index.sort_by(|x,y|\
    \ x.1.cmp(&y.1).reverse());\n\n    let mut index = vowel_index.len() - 1;\n  \
    \  loop {\n        if index >= 0 {\n            if let Some(item) = vowel_index[index].1\
    \ {\n                if !vowels.contains(&item) {\n                    index =\
    \ index - 1;\n                    continue;\n                } else {\n      \
    \              break;\n                }\n            }\n        } else {\n  \
    \          return \"\";\n        }\n\n        if let Some(item) = vowel_index[index].1\
    \ {\n            if !vowels.contains(&item) {\n                break;\n      \
    \      } else {\n                return item;\n            }\n        }\n    \
    \    index = index - 1;\n    }\n\n    return \"\";\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Enumerate<Chars<'_>> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmppf0a3fn5.rs:13:52\n     |\n13   |     let mut vowel_index\
    \ = word.chars().enumerate().cloned().collect::<Vec<_>>();\n     |           \
    \                                         ^^^^^^ expected reference, found tuple\n\
    \     |\n     = note: expected reference `&_`\n                    found tuple\
    \ `(usize, char)`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<Enumerate<Chars<'_>>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmppf0a3fn5.rs:13:61\n   |\n13 |     \
    \   let mut vowel_index = word.chars().enumerate().cloned().collect::<Vec<_>>();\n\
    \   |                                                                ^^^^^^^ method\
    \ cannot be called on `Cloned<Enumerate<Chars<'_>>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Enumerate<Chars<'_>> as Iterator>::Item = &_`\n           which is\
    \ required by `Cloned<Enumerate<Chars<'_>>>: Iterator`\n           `Cloned<Enumerate<Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Enumerate<Chars<'_>>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppf0a3fn5.rs:28:20\n\
    \   |\n28 |             return \"\";\n   |                    ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                    |\n   |       \
    \             expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0271, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowel_pairs = vec![\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    let mut closest_vowel = String::new();\n    for pair in vowel_pairs\
    \ {\n        closest_vowel = word.split_matches(|c: char| c.chars().any(|v|\n\
    \            v == pair as u32 || v == pair as u16)\n        ).next().unwrap().to_string()\n\
    \    }\n    if closest_vowel == \"\" {\n        \"\"\n    } else {\n        closest_vowel\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_matches` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpncbwlzvp.rs:15:30\n   |\n15 |         closest_vowel\
    \ = word.split_matches(|c: char| c.chars().any(|v|\n   |                     \
    \         ^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `matches`\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpncbwlzvp.rs:15:56\n   |\n15 |         closest_vowel\
    \ = word.split_matches(|c: char| c.chars().any(|v|\n   |                     \
    \                                   ^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpncbwlzvp.rs:20:9\n   |\n11 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n20 |         \"\"\n   |         ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |         |\n   |        \
    \ expected struct `String`, found `&str`\n\nerror[E0606]: casting `&str` as `u32`\
    \ is invalid\n  --> /tmp/tmpncbwlzvp.rs:16:18\n   |\n16 |             v == pair\
    \ as u32 || v == pair as u16)\n   |                  ^^^^^^^^^^^\n   |\n   = help:\
    \ cast through a raw pointer first\n\nerror[E0606]: casting `&str` as `u16` is\
    \ invalid\n  --> /tmp/tmpncbwlzvp.rs:16:38\n   |\n16 |             v == pair as\
    \ u32 || v == pair as u16)\n   |                                      ^^^^^^^^^^^\n\
    \   |\n   = help: cast through a raw pointer first\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599, E0606.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n    word.chars().enumerate()\n        .find_map(|(i,\
    \ c)| {\n            match c {\n                'a' | 'e' | 'i' | 'o' | 'u' =>\
    \ Some(i),\n                _ => None,\n            }\n        })\n        .and_then(|index|\
    \ {\n            if index == 0 {\n                \"\".to_string()\n         \
    \   } else if index == word.len() - 1 {\n                get_vowel_before(word.chars().nth(index),\
    \ true)\n            } else if index == word.len() - 2 {\n                get_vowel_after(word.chars().nth(index),\
    \ true)\n            } else if index == word.len() - 3 {\n                get_vowel_before(word.chars().nth(index),\
    \ false)\n            } else {\n                get_vowel_after(word.chars().nth(index),\
    \ false)\n            }\n        })\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_vowel_before` in this scope\n \
    \ --> /tmp/tmpcceu_84e.rs:24:17\n   |\n24 |                 get_vowel_before(word.chars().nth(index),\
    \ true)\n   |                 ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_vowel_after` in this scope\n  --> /tmp/tmpcceu_84e.rs:26:17\n\
    \   |\n26 |                 get_vowel_after(word.chars().nth(index), true)\n \
    \  |                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_vowel_before` in this scope\n  --> /tmp/tmpcceu_84e.rs:28:17\n\
    \   |\n28 |                 get_vowel_before(word.chars().nth(index), false)\n\
    \   |                 ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_vowel_after` in this scope\n  --> /tmp/tmpcceu_84e.rs:30:17\n\
    \   |\n30 |                 get_vowel_after(word.chars().nth(index), false)\n\
    \   |                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcceu_84e.rs:22:17\n   |\n22 |              \
    \   \"\".to_string()\n   |                 ^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found struct `String`\n   |\n   = note: expected enum `Option<_>`\n        \
    \    found struct `String`\nhelp: try wrapping the expression in `Some`\n   |\n\
    22 |                 Some(\"\".to_string())\n   |                 +++++      \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcceu_84e.rs:13:5\n\
    \   |\n11 |   fn get_closest_vowel(word: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    12 |       \n13 | /     word.chars().enumerate()\n14 | |         .find_map(|(i,\
    \ c)| {\n15 | |             match c {\n16 | |                 'a' | 'e' | 'i'\
    \ | 'o' | 'u' => Some(i),\n...  |\n31 | |             }\n32 | |         })\n \
    \  | |__________^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an e"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    use std::cmp::Ordering;\n    use std::collections::BTreeMap;\n\
    \n    let mut vowel_map = BTreeMap::new();\n    vowel_map.insert(\"\", Ordering::Less);\n\
    \n    for &c in word.chars() {\n        if c.is_uppercase() {\n            if\
    \ let Some(previous) = vowel_map.get(&c.to_string()) {\n                vowel_map.entry(previous).insert(Ordering::GreaterOrEqual,\
    \ 1);\n            }\n        } else {\n            if let Some(previous) = vowel_map.get(&c.to_string())\
    \ {\n                vowel_map.entry(previous).insert(Ordering::Less, 1);\n  \
    \          }\n        }\n    }\n\n    // For empty input\n    if vowel_map.len()\
    \ == 0 {\n        \"\".to_string()\n    } else {\n        let max_order = vowel_map.iter().max(|a,\
    \ b| a.1.cmp(&b.1).reverse()).unwrap();\n        let max_order = max_order.1.cmp(&max_order.0).reverse();\n\
    \        vowel_map.iter().filter(|&(_, order)| order == max_order).next().unwrap().0.to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1alehxb2.rs:18:9\n   |\n\
    18 |     for &c in word.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1alehxb2.rs:21:33\n   |\n21 |  \
    \               vowel_map.entry(previous).insert(Ordering::GreaterOrEqual, 1);\n\
    \   |                                 ^^^^^^^^ expected `str`, found enum `std::cmp::Ordering`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&std::cmp::Ordering`\n\
    \nerror[E0599]: no method named `insert` found for enum `std::collections::btree_map::Entry`\
    \ in the current scope\n  --> /tmp/tmp1alehxb2.rs:21:43\n   |\n21 |          \
    \       vowel_map.entry(previous).insert(Ordering::GreaterOrEqual, 1);\n   | \
    \                                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `or_insert`\n\nerror[E0599]: no variant or associated\
    \ item named `GreaterOrEqual` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmp1alehxb2.rs:21:60\n   |\n21 |                 vowel_map.entry(previous).insert(Ordering::GreaterOrEqual,\
    \ 1);\n   |                                                            ^^^^^^^^^^^^^^\
    \ variant or associated item not found in `std::cmp::Ordering`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1alehxb2.rs:25:33\n   |\n25 |              \
    \   vowel_map.entry(previous).insert(Ordering::Less, 1);\n   |               \
    \                  ^^^^^^^^ expected `str`, found enum `std::cmp::Ordering`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&std::cmp::Ordering`\n\
    \nerror[E0599]: no method named `insert` found for enum `std::collections::btree_map::Entry`\
    \ in the current scope\n  --> /tmp/tmp1alehxb2.rs:25:43\n   |\n25 |          \
    \       vowel_map.entry(previous).insert(Ordering::Less, 1);\n   |           \
    \                   "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![];\n    let mut vowel_end_pos\
    \ = word.len() - 1;\n    let mut last_consonant_pos = word.len() - 1;\n    let\
    \ mut prev_consonant_pos = 0;\n    while prev_consonant_pos < word.len() - 1 {\n\
    \        \n        if word[prev_consonant_pos] == 'a' {\n            vowels.push(&word[prev_consonant_pos\
    \ + 1]);\n            last_consonant_pos++;\n            prev_consonant_pos++;\n\
    \            \n        } else if word[prev_consonant_pos] == 'e' {\n         \
    \   vowels.push(&word[prev_consonant_pos + 1]);\n            last_consonant_pos++;\n\
    \            prev_consonant_pos++;\n            \n        } else if word[prev_consonant_pos]\
    \ == 'i' {\n            vowels.push(&word[prev_consonant_pos + 1]);\n        \
    \    last_consonant_pos++;\n            prev_consonant_pos++;\n            \n\
    \        } else if word[prev_consonant_pos] == 'o' {\n            vowels.push(&word[prev_consonant_pos\
    \ + 1]);\n            last_consonant_pos++;\n            prev_consonant_pos++;\n\
    \            \n        } else if word[prev_consonant_pos] == 'u' {\n         \
    \   vowels.push(&word[prev_consonant_pos + 1]);\n            last_consonant_pos++;\n\
    \            prev_consonant_pos++;\n            \n        } else if word[prev_consonant_pos]\
    \ == 'A' {\n            vowels.push(&word[prev_consonant_pos + 1]);\n        \
    \    last_consonant_pos++;\n            prev_consonant_pos++;\n            \n\
    \        } else if word[prev_consonant_pos] == 'E' {\n            vowels.push(&word[prev_consonant_pos\
    \ + 1]);\n            last_consonant_pos++;\n            prev_consonant_pos++;\n\
    \            \n        } else if word[prev_consonant_pos] == 'I' {\n         \
    \   vowels.push(&word[prev_consonant_pos + 1]);\n            last_consonant_pos++;\n\
    \            prev_consonant_pos++;\n            \n        } else if word[prev_consonant_pos]\
    \ == 'O' {\n            vowels.push(&word[prev_consonant_pos + 1]);\n        \
    \    last_consonant_pos++;\n            prev_consonant_pos++;\n            \n\
    \        } else if word[prev_consonant_pos] == 'U' {\n            vowels.push(&word[prev_consonant_pos\
    \ + 1]);\n            last_consonant_pos++;\n            prev_consonant_pos\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpt6vdimpq.rs:84:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while prev_consonant_pos\
    \ < word.len() - 1 {\n   |                                               - unclosed\
    \ delimiter\n...\n63 |         } else if word[prev_consonant_pos] == 'U' {\n \
    \  |                                                   - this delimiter might\
    \ not be properly closed...\n...\n67 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n84 | }\n   |   ^\n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmpt6vdimpq.rs:20:31\n   |\n20 |            \
    \ last_consonant_pos++;\n   |                               ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |             { let tmp =\
    \ last_consonant_pos; last_consonant_pos += 1; tmp };\n   |             +++++++++++\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n20 -             last_consonant_pos++;\n\
    20 +             last_consonant_pos += 1;\n   | \n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmpt6vdimpq.rs:25:31\n   |\n25 |            \
    \ last_consonant_pos++;\n   |                               ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp =\
    \ last_consonant_pos; last_consonant_pos += 1; tmp };\n   |             +++++++++++\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n25 -             last_consonant_pos++;\n\
    25 +             last_consonant_pos += 1;\n   | \n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmpt6vdimpq.rs:30:31\n   |\n30 |            \
    \ last_consonant_pos++;\n   |                               ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |             { let tmp =\
    \ last_consonant_pos; last_consonant_pos += 1; tmp };\n   |             +++++++++++\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n30 -             last_consonant_pos++;\n\
    30 +             last_consonant_pos += 1;\n   | \n\nerror: Rust has no postfix\
    \ increme"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars()\n        .enumerate()\n        .filter(|(_,\
    \ ch)| ch.is_vowel())\n        .filter(|(_, ch)| !ch.is_lower())\n        .filter(|(_,\
    \ ch)| !ch.is_upper())\n        .next()\n        .map(|(_, ch)| ch.to_uppercase())\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpzsux8d7l.rs:14:30\n   |\n14 |         .filter(|(_,\
    \ ch)| ch.is_vowel())\n   |                              ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0599]: no method named `is_lower` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpzsux8d7l.rs:15:31\n   |\n15 |         .filter(|(_,\
    \ ch)| !ch.is_lower())\n   |                               ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_lowercase`\n\nerror[E0599]:\
    \ no method named `is_upper` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmpzsux8d7l.rs:16:31\n   |\n16 |         .filter(|(_, ch)| !ch.is_upper())\n\
    \   |                               ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_uppercase`\n\nerror[E0599]: `Option<ToUppercase>` is\
    \ not an iterator\n   --> /tmp/tmpzsux8d7l.rs:19:10\n    |\n19  |           .collect::<String>()\n\
    \    |            ^^^^^^^ `Option<ToUppercase>` is not an iterator\n    |\n  \
    \  = note: the following trait bounds were not satisfied:\n            `Option<ToUppercase>:\
    \ Iterator`\n            which is required by `&mut Option<ToUppercase>: Iterator`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    match word {\n        \"\" | \"a\" | \"e\" | \"i\"\
    \ | \"o\" | \"u\" => \"\",\n        _ => get_closest_vowel(word[1:].to_lowercase())\
    \ + \n            get_closest_vowel(word[0].to_lowercase())\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected type, found `]`\n  --> /tmp/tmp1xug9xmn.rs:14:39\n   |\n\
    14 |         _ => get_closest_vowel(word[1:].to_lowercase()) + \n   |        \
    \                              -^ expected type\n   |                        \
    \              |\n   |                                      tried to parse a type\
    \ due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1xug9xmn.rs:13:9\n\
    \   |\n12 |     match word {\n   |           ---- this expression has type `String`\n\
    13 |         \"\" | \"a\" | \"e\" | \"i\" | \"o\" | \"u\" => \"\",\n   |     \
    \    ^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1xug9xmn.rs:13:14\n   |\n12 |     match word {\n   |          \
    \ ---- this expression has type `String`\n13 |         \"\" | \"a\" | \"e\" |\
    \ \"i\" | \"o\" | \"u\" => \"\",\n   |              ^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1xug9xmn.rs:13:20\n\
    \   |\n12 |     match word {\n   |           ---- this expression has type `String`\n\
    13 |         \"\" | \"a\" | \"e\" | \"i\" | \"o\" | \"u\" => \"\",\n   |     \
    \               ^^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1xug9xmn.rs:13:26\n   |\n12 |     match word {\n   |  \
    \         ---- this expression has type `String`\n13 |         \"\" | \"a\" |\
    \ \"e\" | \"i\" | \"o\" | \"u\" => \"\",\n   |                          ^^^ expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1xug9xmn.rs:13:32\n\
    \   |\n12 |     match word {\n   |           ---- this expression has type `String`\n\
    13 |         \"\" | \"a\" | \"e\" | \"i\" | \"o\" | \"u\" => \"\",\n   |     \
    \                           ^^^ expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1xug9xmn.rs:13:38\n   |\n12 |     match word\
    \ {\n   |           ---- this expression has type `String`\n13 |         \"\"\
    \ | \"a\" | \"e\" | \"i\" | \"o\" | \"u\" => \"\",\n   |                     \
    \                 ^^^ expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1xug9xmn.rs:13:45\n   |\n11 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.to_lowercase();\n    let mut vowels:\
    \ Vec<String> = vec![];\n    let mut last_consonant: usize = 0;\n    let mut last_vowel:\
    \ usize = 0;\n    for c in word.chars() {\n        match c {\n            'a'\
    \ => vowels.push(String::from(\"a\".to_string())),\n            'e' => vowels.push(String::from(\"\
    e\".to_string())),\n            'i' => vowels.push(String::from(\"i\".to_string())),\n\
    \            'o' => vowels.push(String::from(\"o\".to_string())),\n          \
    \  'u' => vowels.push(String::from(\"u\".to_string())),\n            'y' => vowels.push(String::from(\"\
    a\".to_string())),\n            'e' => vowels.push(String::from(\"e\".to_string())),\n\
    \            _ => (),\n        }\n        last_consonant = word.len() - 1;\n \
    \   }\n    let mut first_consonant: usize = 0;\n    for c in word.chars() {\n\
    \        match c {\n            'a' => vowels.push(String::from(\"a\".to_string())),\n\
    \            'e' => vowels.push(String::from(\"e\".to_string())),\n          \
    \  'i' => vowels.push(String::from(\"i\".to_string())),\n            'o' => vowels.push(String::from(\"\
    o\".to_string())),\n            'u' => vowels.push(String::from(\"u\".to_string())),\n\
    \            'y' => vowels.push(String::from(\"a\".to_string())),\n          \
    \  'e' => vowels.push(String::from(\"e\".to_string())),\n            _ => (),\n\
    \        }\n        first_consonant = word.len() - 1;\n    }\n\n    for &vowel\
    \ in &vowels {\n        if let Some(position) = word.find(&vowel) {\n        \
    \    let current_vowel = &word[position..position + vowel.len()];\n          \
    \  let distance = current_vowel.len() - last_vowel;\n            if distance <\
    \ 0 {\n                continue;\n            }\n            if distance == 0\
    \ {\n                return vowel.to_string();\n            }\n            let\
    \ distance = current_vowel.len() - first_consonant;\n            if distance <\
    \ 0 {\n                continue;\n            }\n            if distance == 0\
    \ {\n                return vowel.to_string();\n            }\n        }\n   \
    \ }\n\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "warning: unreachable pattern\n  --> /tmp/tmpglksdchj.rs:24:13\n   |\n24\
    \ |             'e' => vowels.push(String::from(\"e\".to_string())),\n   |   \
    \          ^^^\n   |\n   = note: `#[warn(unreachable_patterns)]` on by default\n\
    \nwarning: unreachable pattern\n  --> /tmp/tmpglksdchj.rs:38:13\n   |\n38 |  \
    \           'e' => vowels.push(String::from(\"e\".to_string())),\n   |       \
    \      ^^^\n\nwarning: variable `last_consonant` is assigned to, but never used\n\
    \  --> /tmp/tmpglksdchj.rs:14:13\n   |\n14 |     let mut last_consonant: usize\
    \ = 0;\n   |             ^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_last_consonant` instead\n\nwarning:\
    \ value assigned to `last_consonant` is never read\n  --> /tmp/tmpglksdchj.rs:27:9\n\
    \   |\n27 |         last_consonant = word.len() - 1;\n   |         ^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmpglksdchj.rs:12:9\n   |\n12 |     let mut word = word.to_lowercase();\n\
    \   |         ----^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpglksdchj.rs:15:9\n   |\n15 |     let mut\
    \ last_vowel: usize = 0;\n   |         ----^^^^^^^^^^\n   |         |\n   |  \
    \       help: remove this `mut`\n\nerror[E0507]: cannot move out of a shared reference\n\
    \  --> /tmp/tmpglksdchj.rs:44:19\n   |\n44 |     for &vowel in &vowels {\n   |\
    \         ------    ^^^^^^^\n   |         ||\n   |         |data moved here\n\
    \   |         |move occurs because `vowel` has type `String`, which does not implement\
    \ the `Copy` trait\n   |         help: consider removing the `&`: `vowel`\n\n\
    error: aborting due to previous error; 6 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() > 3 {\n        let mut vowel = String::new();\n\
    \        for ch in word[..] {\n            if ch == 'a' || ch == 'e' || ch ==\
    \ 'i' || ch == 'o' || ch == 'u' {\n                vowel.push(ch);\n         \
    \   }\n        }\n        let mut consonant = String::new();\n        for ch in\
    \ word[word.len() - 3..] {\n            if ch == 'a' || ch == 'e' || ch == 'i'\
    \ || ch == 'o' || ch == 'u' {\n                consonant.push(ch);\n         \
    \   }\n        }\n        if vowel.len() != 0 {\n            return vowel.clone()\
    \ + vowel.len().to_string();\n        }\n        if consonant.len() != 0 {\n \
    \           return consonant.clone() + consonant.len().to_string();\n        }\n\
    \        return String::new();\n    }\n    String::new()\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpyyqqln7z.rs:14:19\n   |\n14 |         for ch in word[..]\
    \ {\n   |                   ^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `str`\n\nerror[E0277]:\
    \ `str` is not an iterator\n  --> /tmp/tmpyyqqln7z.rs:14:19\n   |\n14 |      \
    \   for ch in word[..] {\n   |                   ^^^^^^^^ `str` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `str`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `str`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpyyqqln7z.rs:20:19\n   |\n20 |         for ch in word[word.len()\
    \ - 3..] {\n   |                   ^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `str`\n\nerror[E0277]: `str` is not an iterator\n  --> /tmp/tmpyyqqln7z.rs:20:19\n\
    \   |\n20 |         for ch in word[word.len() - 3..] {\n   |                 \
    \  ^^^^^^^^^^^^^^^^^^^^^^ `str` is not an iterator\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `str`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyyqqln7z.rs:26:36\n   |\n26 |             return vowel.clone()\
    \ + vowel.len().to_string();\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&str`, found struct `String`\n   |                         \
    \           help: consider borrowing here: `&vowel.len().to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyyqqln7z.rs:29:40\n   |\n29 |             return\
    \ consonant.clone() + consonant.len().to_string();\n   |                     \
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowel_start = String::new();\n    let mut vowel_end = String::new();\n\
    \    let mut vowel_candidates = vec![];\n    for con in word.chars().rev() {\n\
    \        if vowels.contains(&con) {\n            vowel_start = con;\n        \
    \    break;\n        }\n    }\n    for con in word.chars().rev().rev() {\n   \
    \     if vowels.contains(&con) {\n            vowel_end = con;\n            break;\n\
    \        }\n    }\n    if vowel_start != \"\" && vowel_end != \"\" {\n       \
    \ vowel_candidates.push(vowel_start);\n        vowel_candidates.push(vowel_end);\n\
    \    }\n    vowel_candidates.iter().filter(|x| x.chars().any(|y| vowels.contains(&y)).collect::<Vec<String>>()).cloned().collect::<Vec<String>>()\n\
    \        .iter()\n        .find(|x| vowel_candidates.iter().any(|y| x.contains(&y)));\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprewp6nj0.rs:17:28\n   |\n\
    17 |         if vowels.contains(&con) {\n   |                            ^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprewp6nj0.rs:18:27\n   |\n13 |     let mut vowel_start = String::new();\n\
    \   |                           ------------- expected due to this value\n...\n\
    18 |             vowel_start = con;\n   |                           ^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \   |\n   |                           expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprewp6nj0.rs:23:28\n   |\n23 |\
    \         if vowels.contains(&con) {\n   |                            ^^^^ expected\
    \ `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n        \
    \      found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprewp6nj0.rs:24:25\n\
    \   |\n14 |     let mut vowel_end = String::new();\n   |                     \
    \    ------------- expected due to this value\n...\n24 |             vowel_end\
    \ = con;\n   |                         ^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                         |\n   |                       \
    \  expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprewp6nj0.rs:32:74\n   |\n32 |     vowel_candidates.iter().filter(|x|\
    \ x.chars().any(|y| vowels.contains(&y)).collect::<Vec<String>>()).cloned().collect::<Vec<String>>()\n\
    \   |                                                                        \
    \  ^^ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0599]: `bool` is not an iterator\n\
    \  --> /tmp/tmprewp6nj0.rs:32:79\n   |\n32 |     vowel_candidates.iter().filter(|x|\
    \ x.chars().any(|y| vowels.contains(&y)).collect::<Vec<String>>()).cloned().collect::<Vec<String>>()\n\
    \   |                                                                        \
    \       ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_found = false;\n    let mut current_vowel_index\
    \ = 1;\n    let mut current_vowel = String::new();\n    let mut words_to_match\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"];\n    let mut vowels_in_word\
    \ = 0;\n    let mut vowels_in_word2 = words_to_match.len();\n    while vowel_found\
    \ == false {\n        if current_vowel_index == words_to_match.len() {\n     \
    \       if current_vowel_index == 0 {\n                vowel_found = true;\n \
    \               current_vowel_index = 0;\n                current_vowel = String::new();\n\
    \            } else {\n                current_vowel_index += 1;\n           \
    \ }\n        } else {\n            if current_vowel_index + 1 < words_to_match.len()\
    \ {\n                let next_vowel = words_to_match[current_vowel_index + 1];\n\
    \                if next_vowel == word.chars().nth(current_vowel_index + 1).unwrap()\
    \ {\n                    vowel_found = true;\n                    current_vowel_index\
    \ += 1;\n                    current_vowel = next_vowel.to_string();\n       \
    \         } else {\n                    current_vowel_index += 1;\n          \
    \      }\n            } else {\n                current_vowel_index += 1;\n  \
    \          }\n        }\n        if vowels_in_word == 2 {\n            if vowels_in_word2\
    \ == 2 {\n                vowel_found = true;\n                current_vowel_index\
    \ = 0;\n                current_vowel = String::new();\n                vowels_in_word\
    \ = 0;\n            } else {\n                vowels_in_word += 1;\n         \
    \       current_vowel_index = 1;\n                current_vowel = words_to_match[current_vowel_index];\n\
    \            }\n        }\n    }\n    return current_vowel;\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpboyy38h1.rs:30:31\n\
    \   |\n30 |                 if next_vowel == word.chars().nth(current_vowel_index\
    \ + 1).unwrap() {\n   |                               ^^ no implementation for\
    \ `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpboyy38h1.rs:50:33\n   |\n14 |     let mut current_vowel\
    \ = String::new();\n   |                             ------------- expected due\
    \ to this value\n...\n50 |                 current_vowel = words_to_match[current_vowel_index];\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \         |\n   |                                 expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.to_lowercase().chars().collect::<Vec<&str>>();\n\
    \    let mut left = word[word.len() - 1];\n    let mut right = word[0];\n    \n\
    \    for c in word.chars() {\n        if c == 'y' || c == 'a' || c == 'e' || c\
    \ == 'i' || c == 'o' || c == 'u'{\n            let mut temp = c;\n           \
    \ while let Some(m) = word.rfind(&mut temp){\n                temp = m\n     \
    \       }\n            temp = temp.to_lowercase().chars().collect::<Vec<&str>>().len()\n\
    \            if temp > left {\n                left = temp\n            }\n  \
    \      }\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ {\n            let mut temp = c;\n            while let Some(m) = word.rfind(&mut\
    \ temp){\n                temp = m\n            }\n            temp = temp.to_lowercase().chars().collect::<Vec<&str>>().len()\n\
    \            if temp > right {\n                right = temp\n            }\n\
    \        }\n    }\n    word[word.len() - 1] = word.len()-1 - left;\n    word[0]\
    \ = word.len() - 1 - right;\n    word.iter().find(|c| c == 'u' || c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'y').unwrap_or(\"\")\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpft58m6bz.rs:22:76\n\
    \   |\n22 |             temp = temp.to_lowercase().chars().collect::<Vec<&str>>().len()\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n23 |             if temp > left {\n   |           \
    \  -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpft58m6bz.rs:32:76\n\
    \   |\n32 |             temp = temp.to_lowercase().chars().collect::<Vec<&str>>().len()\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n33 |             if temp > right {\n   |          \
    \   -- unexpected token\n\nerror[E0277]: a value of type `Vec<&str>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmpft58m6bz.rs:12:48\n\
    \     |\n12   |     let mut word = word.to_lowercase().chars().collect::<Vec<&str>>();\n\
    \     |                                                ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<&str>` in the current scope\n  --> /tmp/tmpft58m6bz.rs:16:19\n   |\n16\
    \ |     for c in word.chars() {\n   |                   ^^^^^ method not found\
    \ in `Vec<&str>`\n\nerror[E0599]: no method named `rfind` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpft58m6bz.rs:19:38\n   |\n19 |          \
    \   while let Some(m) = word.rfind(&mut temp){\n   |                         \
    \             ^^^^^ method not found in `Vec<&str>`\n\nerror[E0599]: no method\
    \ named `rfind` found for struct `Vec<&str>` in the current scope\n  --> /tmp/tmpft58m6bz.rs:29:38\n\
    \   |\n29 |             while let Some(m) = word.rfind(&mut temp){\n   |     \
    \                                 ^^^^^ method not found in `Vec<&str>`\n\nerror[E0277]:\
    \ cannot subtract `&str` from `usize`\n  --> /tmp/tmpft58m6bz."
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result: String = \"\".to_string();\n    let\
    \ mut vowels: Vec<&str> = vec![\"A\", \"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    ];\n\n    let vowel_index: usize = 0;\n\n    for consonant in word.chars().rev()\
    \ {\n        if vowels[vowel_index..vowel_index + 3].contains(&consonant) {\n\
    \            if vowel_index < vowels.len() - 2 {\n                vowel_index\
    \ += 3;\n            } else {\n                vowel_index = 0;\n            }\n\
    \        } else {\n            vowel_index += 1;\n        }\n    }\n\n    result\
    \ = vowels[vowel_index];\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcnxfjtgc.rs:18:58\n   |\n\
    18 |         if vowels[vowel_index..vowel_index + 3].contains(&consonant) {\n\
    \   |                                                          ^^^^^^^^^^ expected\
    \ `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n        \
    \      found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcnxfjtgc.rs:29:14\n\
    \   |\n12 |     let mut result: String = \"\".to_string();\n   |             \
    \        ------ expected due to this type\n...\n29 |     result = vowels[vowel_index];\n\
    \   |              ^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |              |\n   |              expected struct `String`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel: Char = '';\n    let mut len: usize =\
    \ 0;\n    let mut i: usize = 0;\n    for char in word.chars() {\n        if char.ascii_lowercase()\
    \ == 'a' || char.ascii_lowercase() == 'e' || char.ascii_lowercase() == 'i' ||\
    \ char.ascii_lowercase() == 'o' || char.ascii_lowercase() == 'u' {\n         \
    \   vowel = char;\n            len = i;\n        }\n        i += 1;\n    }\n \
    \   if len == 0 {\n        return '';\n    }\n    word.chars().skip_while(|&x|\
    \ {\n        x < &vowel && x >= &vowel\n    });\n    let mut result = '';\n  \
    \  if word.len() <= len {\n        result = &vowel;\n    } else {\n        let\
    \ mut last = word.chars().last();\n        match last {\n            None => return\
    \ result,\n            Some('e') => return result,\n            Some('i') => return\
    \ result,\n            Some('o') => return result,\n            Some('u') => {\n\
    \                result = &vowel;\n            }\n            Some('a') => {\n\
    \                result = &vowel;\n            }\n            Some('e') | Some('i')\
    \ | Some('o') | Some('u') => {\n                result = &vowel;\n           \
    \ }\n        }\n    }\n    result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmplarsb_le.rs:12:28\n   |\n\
    12 |     let mut vowel: Char = '';\n   |                            ^ empty character\
    \ literal\n\nerror: empty character literal\n  --> /tmp/tmplarsb_le.rs:23:17\n\
    \   |\n23 |         return '';\n   |                 ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmplarsb_le.rs:28:23\n   |\n28 |\
    \     let mut result = '';\n   |                       ^ empty character literal\n\
    \nerror[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmplarsb_le.rs:12:20\n\
    \   |\n12 |     let mut vowel: Char = '';\n   |                    ^^^^ help:\
    \ a builtin type with a similar name exists (notice the capitalization): `char`\n\
    \nerror[E0599]: no method named `ascii_lowercase` found for type `char` in the\
    \ current scope\n  --> /tmp/tmplarsb_le.rs:16:17\n   |\n16 | ...   if char.ascii_lowercase()\
    \ == 'a' || char.ascii_lowercase() == 'e' || char.ascii_lowercase() == 'i' ||\
    \ char.ascii_lowercase() == 'o'...\n   |               ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `ascii_lowercase` found for type `char` in the current scope\n\
    \  --> /tmp/tmplarsb_le.rs:16:50\n   |\n16 | ...e() == 'a' || char.ascii_lowercase()\
    \ == 'e' || char.ascii_lowercase() == 'i' || char.ascii_lowercase() == 'o' ||\
    \ char.ascii_lowercase(...\n   |                       ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `ascii_lowercase` found for type `char` in the current scope\n\
    \  --> /tmp/tmplarsb_le.rs:16:83\n   |\n16 | ...e() == 'e' || char.ascii_lowercase()\
    \ == 'i' || char.ascii_lowercase() == 'o' || char.ascii_lowercase() == 'u' {\n\
    \   |                       ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii_lowercase`\n\nerror[E0599]: no method named `ascii_lowercase`\
    \ found for type `char` in the current scope\n  --> /tmp/tmplarsb_le.rs:16:116\n\
    \   |\n16 | ...e() == 'i' || char.ascii_lowercase() == 'o' || char.ascii_l"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<String> = vec![\"A\", \"a\", \"\
    I\", \"i\", \"O\", \"o\", \"U\", \"u\", \"E\", \"e\"];\n    vowels.sort_by_key(|&x|\
    \ x.cmp(&word.chars().next().unwrap()));\n    vowels.iter().take_while(|&x| x.chars().count()\
    \ < word.chars().count()).next()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkf6zkvre.rs:12:40\n   |\n\
    12 |     let mut vowels: Vec<String> = vec![\"A\", \"a\", \"I\", \"i\", \"O\"\
    , \"o\", \"U\", \"u\", \"E\", \"e\"];\n   |                                  \
    \      ^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \                                |\n   |                                     \
    \   expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkf6zkvre.rs:13:35\n   |\n13 |     vowels.sort_by_key(|&x| x.cmp(&word.chars().next().unwrap()));\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkf6zkvre.rs:14:5\n   |\n11 | fn get_closest_vowel(word: String) -> String\
    \ {\n   |                                       ------ expected `String` because\
    \ of return type\n...\n14 |     vowels.iter().take_while(|&x| x.chars().count()\
    \ < word.chars().count()).next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<&String>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.is_empty() {\n        return \"\";\n    }\n\
    \n    let mut word = word.to_string();\n    let mut index = word.rfind('A');\n\
    \    let mut vowels: Vec<&str> = vec![];\n\n    while index != word.len() - 1\
    \ {\n        if index < word.len() - 1 && (*index + 2) == word[index] {\n    \
    \        vowels.push(&word[index..index + 2]);\n            word = &word[index\
    \ + 2..].to_string();\n        }\n        index -= 1;\n    }\n\n    let mut index\
    \ = word.rfind('U');\n    let mut vowels: Vec<&str> = vec![];\n\n    while index\
    \ != word.len() - 1 {\n        if index < word.len() - 1 && (*index + 2) == word[index]\
    \ {\n            vowels.push(&word[index..index + 2]);\n            word = &word[index\
    \ + 2..].to_string();\n        }\n        index -= 1;\n    }\n\n    vowels.iter().map(|s|\
    \ s.to_string()).filter(|s| !s.is_empty()).cloned().collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppuxfym22.rs:13:16\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if word.is_empty() {\n13 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppuxfym22.rs:20:20\n   |\n20 |     while index != word.len()\
    \ - 1 {\n   |                    ^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `usize`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n20 |     while\
    \ index != Some(word.len() - 1) {\n   |                    +++++             \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppuxfym22.rs:21:20\n   |\n\
    21 |         if index < word.len() - 1 && (*index + 2) == word[index] {\n   |\
    \                    ^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n  \
    \ |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n21 |         if index < Some(word.len()\
    \ - 1) && (*index + 2) == word[index] {\n   |                    +++++       \
    \       +\n\nerror[E0614]: type `Option<usize>` cannot be dereferenced\n  -->\
    \ /tmp/tmppuxfym22.rs:21:39\n   |\n21 |         if index < word.len() - 1 && (*index\
    \ + 2) == word[index] {\n   |                                       ^^^^^^\n\n\
    error[E0277]: the type `String` cannot be indexed by `Option<usize>`\n  --> /tmp/tmppuxfym22.rs:21:54\n\
    \   |\n21 |         if index < word.len() - 1 && (*index + 2) == word[index] {\n\
    \   |                                                      ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `Option<usize>`\n   |\n   = help: the trait `Index<Option<usize>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    if word.len()\
    \ < 3 || word.len() > 10 {\n        return \"\".to_string();\n    }\n\n    let\
    \ mut vowels_count = word.chars().enumerate().filter(|&(i, &c)| c.is_upper()).count();\n\
    \    let mut consonants_count = word.chars().enumerate().filter(|&(i, &c)| !c.is_upper()).count();\n\
    \    if vowels_count < 2 || consonants_count < 2 {\n        return \"\".to_string();\n\
    \    }\n\n    if vowels_count == 2 && consonants_count == 2 {\n        let mut\
    \ index = word.len();\n        if word[index].is_uppercase() {\n            index\
    \ = index - 1;\n        }\n        return word[index].to_ascii_lowercase().to_string();\n\
    \    }\n    if vowels_count > 2 {\n        word = word.to_ascii_lowercase();\n\
    \        let vowels = word.chars().enumerate().filter(|&(i, &c)| c.is_upper()).collect::<Vec<(usize,\
    \ char)>>();\n        let mut index = vowels.len() - 1;\n        if vowels[index].1.is_lowercase()\
    \ {\n            index = -1;\n        }\n        let mut vowel_len = vowels[index].0.unwrap();\n\
    \        let mut vowel_char = vowels[index].1.unwrap();\n        if vowel_char\
    \ == vowels[vowel_len-1].1.unwrap() {\n            return vowel_char.to_ascii_lowercase().to_string();\n\
    \        }\n        let mut i = vowels.len() - 1;\n        let mut vowel_len =\
    \ i;\n        let mut vowel_char = vowels.last().unwrap().1;\n        while vowels.len()\
    \ > 1 {\n            if vowels[i].1.is_lowercase() {\n                index =\
    \ i;\n            }\n            vowel_len -= 1;\n            vowel_char = vowels[vowel_len].1.unwrap();\n\
    \            if vowel_char == vowels[vowel_len+1].1.unwrap() {\n             \
    \   return vowel_char.to_ascii_lowercase().to_string();\n            }\n     \
    \       i -= 1;\n            vowel_len = i;\n            vowel_char = vowels.last().unwrap().1;\n\
    \        }\n        return vowels.last().unwrap().1.to_ascii_lowercase().to_string();\n\
    \    }\n    if consonants_count > 2 {\n        word = word.to_ascii_lowercase();\n\
    \        let consonants = word.chars().enumerate().filter(|&(i, &c)| !c.is_upper()).collect::<Vec<(usize,\
    \ char)>>();\n        let mut index = consonants.len() - 1;\n        if consonants[index].1.is_lowercase()\
    \ {\n            index = -1;\n        }\n        let mut consonant_len = consonants[index].\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8bv5xjzu.rs:85:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n60 |     if consonants_count\
    \ > 2 {\n   |                             - this delimiter might not be properly\
    \ closed...\n...\n68 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n85 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmp8bv5xjzu.rs:68:1\n\
    \   |\n68 | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp8bv5xjzu.rs:67:51\n\
    \   |\n67 |         let mut consonant_len = consonants[index].\n   |         \
    \                                          ^ help: add `;` here\n68 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bv5xjzu.rs:17:66\n\
    \   |\n17 |     let mut vowels_count = word.chars().enumerate().filter(|&(i, &c)|\
    \ c.is_upper()).count();\n   |                                               \
    \                   ^^- expected due to this\n   |                           \
    \                                       |\n   |                              \
    \                                    expected `char`, found reference\n   |  \
    \                                                                help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bv5xjzu.rs:18:70\n\
    \   |\n18 |     let mut consonants_count = word.chars().enumerate().filter(|&(i,\
    \ &c)| !c.is_upper()).count();\n   |                                         \
    \                             ^^- expected due to this\n   |                 \
    \                                                     |\n   |                \
    \                                                      expected `char`, found\
    \ reference\n   |                                                            \
    \          help: you can probably remove the explicit borrow: `c`\n   |\n   =\
    \ note:   expected type `char`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `Str"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().nth(word.len() - 1).filter(|c| !c.is_uppercase()).take_while(\
    \ |c| {\n        (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U').expect(\"String contains\
    \ English letters only - get_closest_vowel(\\\"yogurt\\\")\");\n        c != 'a'\n\
    \    }).find_mut(&mut |&c| {\n        if let Some(vowel) = find_vowel(c) {\n \
    \           vowel.next = c;\n            return true;\n        }\n        false\n\
    \    }).map(|vowel| vowel.as_str()).unwrap_or(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_vowel` in this scope\n  --> /tmp/tmppd58vaji.rs:16:30\n\
    \   |\n16 |         if let Some(vowel) = find_vowel(c) {\n   |               \
    \               ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: `Option<char>`\
    \ is not an iterator\n   --> /tmp/tmppd58vaji.rs:12:68\n    |\n12  |       word.chars().nth(word.len()\
    \ - 1).filter(|c| !c.is_uppercase()).take_while( |c| {\n    |                \
    \                                                      ^^^^^^^^^^ `Option<char>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: Iterator`\n            which is required by `&mut\
    \ Option<char>: Iterator`\n\nerror[E0599]: no method named `expect` found for\
    \ type `bool` in the current scope\n  --> /tmp/tmppd58vaji.rs:13:128\n   |\n13\
    \ | ... || c == 'E' || c == 'I' || c == 'O' || c == 'U').expect(\"String contains\
    \ English letters only - get_closest_vowel(\\\"yogurt\\\")\");\n   |         \
    \                                             ^^^^^^ method not found in `bool`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = String::new();\n    for pos in word.rposition(|&char|\
    \ char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u') {\n\
    \        res.push_str(&word[pos..pos + 1]);\n    }\n    return res.into_owned();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rposition` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpxrwpd_vo.rs:13:21\n   |\n13 |     for pos in\
    \ word.rposition(|&char| char == 'a' || char == 'e' || char == 'i' || char ==\
    \ 'o' || char == 'u') {\n   |                     ^^^^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `into_owned` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpxrwpd_vo.rs:16:16\n   |\n16 |     return\
    \ res.into_owned();\n   |                ^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"A\", \"a\", \"E\", \"e\", \"\
    I\", \"i\", \"O\", \"o\", \"U\", \"u\"];\n    let mut i = 0;\n    let mut j =\
    \ word.size() - 1;\n    loop {\n        if word[i] == word[j] {\n            if\
    \ i != j {\n                return if vowels.contains(&word[i + 2]) {\n      \
    \              String::from(vowels[vowels.iter().position(|&v| v == &word[i +\
    \ 2]).unwrap()])\n                } else {\n                    String::from(\"\
    \".to_string());\n                };\n            }\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpvyw82hbs.rs:14:22\n   |\n14 |     let mut j = word.size()\
    \ - 1;\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpvyw82hbs.rs:16:12\n\
    \   |\n16 |         if word[i] == word[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpvyw82hbs.rs:18:44\n   |\n18 |                 return if vowels.contains(&word[i\
    \ + 2]) {\n   |                                            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpvyw82hbs.rs:19:75\n   |\n19 |                     String::from(vowels[vowels.iter().position(|&v|\
    \ v == &word[i + 2]).unwrap()])\n   |                                        \
    \                                   ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemen"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n\n    let mut words: Vec<&str> = word.chars().collect();\n    let mut vowels:\
    \ Vec<&str> = vowels.iter().collect();\n\n    // 1. find all consonants\n    let\
    \ mut consonants: Vec<&str> = words.iter().filter_map(|&c| match c {\n       \
    \ 'a' => true,\n        'e' => true,\n        'i' => true,\n        'o' => true,\n\
    \        'u' => true,\n        _ => false,\n    }).collect();\n\n    // 2. find\
    \ all vowels on the right side of consonants\n    for consonant in consonants\
    \ {\n        let mut current_vowel: Vec<&str> = vowels.iter().collect();\n\n \
    \       for vowel in current_vowel {\n            if !vowel.contains(&consonant)\
    \ {\n                words.push(&vowel);\n            }\n        }\n    }\n\n\
    \    // 3. find all vowels on the left side of consonants\n    let mut consonants:\
    \ Vec<&str> = words.iter().filter_map(|&c| match c {\n        'a' => true,\n \
    \       'e' => true,\n        'i' => true,\n        'o' => true,\n        'u'\
    \ => true,\n        _ => false,\n    }).collect();\n\n    for consonant in consonants\
    \ {\n        let mut current_vowel: Vec<&str> = vowels.iter().collect();\n\n \
    \       for vowel in current_vowel {\n            if vowel.contains(&consonant)\
    \ {\n                words.push(&vowel);\n            }\n        }\n    }\n\n\
    \    // 4. find closest vowel\n    let mut closest: &str = &vowels[0];\n\n   \
    \ let mut current_vowel: Vec<&str> = vowels.iter().collect();\n\n    for vowel\
    \ in current_vowel {\n        let mut distances: Vec<i32> = words.iter().filter_map(|&w|\
    \ {\n            if w == vowel {\n                0\n            } else {\n  \
    \              word.chars().enumerate().filter_map(|(i, c)| {\n              \
    \      if c == &vowel {\n                        if i == 0 {\n               \
    \             1\n                        } else {\n                          \
    \  -1\n                        }\n                    } else {\n             \
    \           0\n                    }\n                }).collect::<Vec<_>>()\n\
    \            }\n        }).collect::<Vec<_>>();\n\n        let mut min_distance:\
    \ i32 = distances[0];\n\n        for dist in distances.iter() {\n            if\
    \ dist < min_distance {\n                min_distance = dist;\n              \
    \  closest = &vowel;\n            }\n        }\n    }\n\n\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp3_70ooiu.rs:14:45\n     |\n14\
    \   |     let mut words: Vec<&str> = word.chars().collect();\n     |         \
    \                                    ^^^^^^^ value of type `Vec<&str>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0277]: a value of type `Vec<&str>` cannot be built from\
    \ an iterator over elements of type `&&str`\n    --> /tmp/tmp3_70ooiu.rs:15:47\n\
    \     |\n15   |     let mut vowels: Vec<&str> = vowels.iter().collect();\n   \
    \  |                                               ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=&&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&&str>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3_70ooiu.rs:19:9\n\
    \   |\n18 |     let mut consonants: Vec<&str> = words.iter().filter_map(|&c| match\
    \ c {\n   |                                                                  \
    \      - this expression has type `&str`\n19 |         'a' => true,\n   |    \
    \     ^^^ expected `str`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3_70ooiu.rs:20:9\n   |\n18 |     let mut consonants: Vec<&str> = words.iter().filter_map(|&c|\
    \ match c {\n   |                                                            \
    \            - this expression has type `&str`\n19 |         'a' => true,\n20\
    \ |         'e' => true,\n   |         ^^^ expected `str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3_70ooiu.rs:21:9\n   |\n18 |     let mut consonants:\
    \ Vec<&str> = words.iter().filter_map(|&c| match c {\n   |                   \
    \                                                     - this expression has type\
    \ `&str`\n...\n21 |        "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut i = 0;\n    let mut j = word.len() - 1;\n \
    \   \n    while i <= j {\n        if word.chars()\n            .skip(i)\n    \
    \        .skip(word.len())\n            .any(|c| c.to_ascii_lowercase() != 'a'\
    \ && c.to_ascii_lowercase() != 'e' && c.to_ascii_lowercase() != 'i'\n        \
    \        && c.to_ascii_lowercase() != 'o' && c.to_ascii_lowercase() != 'u' &&\
    \ c.to_ascii_lowercase() != 'y' && c.to_ascii_lowercase() != 'a' && c.to_ascii_lowercase()\
    \ != 'e' && c.to_ascii_lowercase() != 'i' && c.to_ascii_lowercase() != 'o' &&\
    \ c.to_ascii_lowercase() != 'u' && c.to_ascii_lowercase() != 'y')) {\n       \
    \     i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    if\
    \ j > i {\n        \"\".to_string()\n    } else {\n        let mut vowel_index\
    \ = word.chars()\n            .skip(word.len() - j)\n            .skip(j)\n  \
    \          .count();\n        word.chars()\n            .skip(vowel_index)\n \
    \           .take(1)\n            .to_string()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpl06ez632.rs:38:1\n\
    \   |\n28 |     } else {\n   |            - this opening brace...\n...\n37 | \
    \    }\n   |     - ...matches this closing brace\n38 | }\n   | ^ unexpected closing\
    \ delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpl06ez632.rs:15:18\n\
    \   |\n15 | ... j {\n   |       ^ unclosed delimiter\n...\n20 | ...  && c.to_ascii_lowercase()\
    \ != 'o' && c.to_ascii_lowercase() != 'u' && c.to_ascii_lowercase() != 'y' &&\
    \ c.to_ascii_lowercase() != 'a' && c.to_ascii_lowercase() != 'e' && c.to_ascii_lowercase()\
    \ != 'i' && c.to_ascii_lowercase() != 'o' && c.to_ascii_lowercase() != 'u' &&\
    \ c.to_ascii_lowercase() != 'y')...\n   |                                    \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                       ^ mismatched closing delimiter\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\", \"y\"];\n    let mut vowel_start = word.chars().skip_while(|c| vowel.contains(c)).collect::<Vec<_>>();\n\
    \    let mut vowel_end = vowel_start.clone();\n    vowel.sort();\n    vowel_start.reverse();\n\
    \    vowel_end.sort();\n    \n    let mut vowel_index = 0;\n    for i in word.chars().skip_while(|c|\
    \ vowel.contains(c)).collect::<Vec<_>>() {\n        if vowel_index == 0 {\n  \
    \          vowel_start = vec![i];\n        } else {\n            vowel_end = vec![i];\n\
    \        }\n        vowel_index += 1;\n    }\n    if vowel_start.len() < vowel_end.len()\
    \ {\n        vowel_start.len()\n    } else {\n        vowel_end.len()\n    }\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3txikykn.rs:13:70\n   |\n\
    13 |     let mut vowel_start = word.chars().skip_while(|c| vowel.contains(c)).collect::<Vec<_>>();\n\
    \   |                                                                      ^ expected\
    \ `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n        \
    \      found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3txikykn.rs:20:57\n\
    \   |\n20 |     for i in word.chars().skip_while(|c| vowel.contains(c)).collect::<Vec<_>>()\
    \ {\n   |                                                         ^ expected `&str`,\
    \ found `char`\n   |\n   = note: expected reference `&&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3txikykn.rs:29:9\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    29 |         vowel_start.len()\n   |         ^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |         |\n   |         expected struct\
    \ `String`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3txikykn.rs:31:9\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    31 |         vowel_end.len()\n   |         ^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |         |\n   |         expected struct\
    \ `String`, found `usize`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowel_iter = word.char_indices();\n    let mut current_vowel;\n\
    \n    if vowel_iter.next().is_none() {\n        return String::new();\n    }\n\
    \n    if vowel_iter.next().unwrap().is_none() {\n        return String::new();\n\
    \    }\n\n    while vowel_iter.next().unwrap().unwrap().is_some() {\n        current_vowel\
    \ = vowels.pop().unwrap();\n        let (next, next2) = vowel_iter.peek().unwrap().unwrap().unwrap();\n\
    \n        if next < next2 {\n            return current_vowel.to_string();\n \
    \       }\n    }\n\n    vowels.push(current_vowel);\n    String::new()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_none` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmpznjr27kh.rs:20:35\n   |\n20 |     if vowel_iter.next().unwrap().is_none()\
    \ {\n   |                                   ^^^^^^^ method not found in `(usize,\
    \ char)`\n\nerror[E0599]: no method named `unwrap` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmpznjr27kh.rs:24:38\n   |\n24 |     while\
    \ vowel_iter.next().unwrap().unwrap().is_some() {\n   |                      \
    \                ^^^^^^ method not found in `(usize, char)`\n\nerror[E0599]: no\
    \ method named `peek` found for struct `CharIndices` in the current scope\n  -->\
    \ /tmp/tmpznjr27kh.rs:26:40\n   |\n26 |         let (next, next2) = vowel_iter.peek().unwrap().unwrap().unwrap();\n\
    \   |                                        ^^^^ method not found in `CharIndices<'_>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\n        \"a\",\n   \
    \     \"e\",\n        \"i\",\n        \"o\",\n        \"u\",\n    ];\n    let\
    \ vowels_r = vec![\n        \"a\",\n        \"e\",\n        \"i\",\n        \"\
    o\",\n        \"u\",\n        \"A\",\n        \"E\",\n        \"I\",\n       \
    \ \"O\",\n        \"U\",\n    ];\n\n    let mut current = word[word.len() - 1];\n\
    \    for i in 1..word.len() - 1 {\n        let c_r = if current[..1].chars().all(|c|\
    \ vowels_r.contains(&c)) {\n            vowels_r.iter().position(|&c| current[..1].chars().any(|c|\
    \ c == c))\n        } else {\n            vowels.iter().position(|&c| current[..1].chars().any(|c|\
    \ c == c))\n        };\n        let c_l = if current[..1].chars().all(|c| vowels.contains(&c))\
    \ {\n            vowels.iter().position(|&c| current[..1].chars().any(|c| c ==\
    \ c))\n        } else {\n            vowels_l.iter().position(|&c| current[..1].chars().any(|c|\
    \ c == c))\n        };\n        let c_r = current[..1];\n        let c_l = current[..1];\n\
    \n        current = if c_r < c_l {\n            current[..c_r + 3]\n        }\
    \ else {\n            current[..c_l + 3]\n        };\n    }\n    current[..word.len()]\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels_l` in this scope\n  --> /tmp/tmp5uidr8nh.rs:42:13\n\
    \   |\n42 |             vowels_l.iter().position(|&c| current[..1].chars().any(|c|\
    \ c == c))\n   |             ^^^^^^^^ help: a local variable with a similar name\
    \ exists: `vowels_r`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5uidr8nh.rs:32:23\n   |\n32 |     let mut current = word[word.len()\
    \ - 1];\n   |                       ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    vowels.sort();\n    let mut pos = 0;\n    let mut index = 0;\n\n  \
    \  while let Some(ref v) = vowels.iter().position(|v| v.as_str() == &word[pos])\
    \ {\n        pos = pos + 1;\n        index = index;\n    }\n\n    match vowels.iter().position(|v|\
    \ v.as_str() == &word[pos..]) {\n        Some(i) => {\n            vowels.swap(i,\
    \ index + 1);\n            let mut index = i;\n            let mut res = String::new();\n\
    \            while let Some(ref v) = vowels.iter().position(|v| v.as_str() ==\
    \ &word[pos..]) {\n                pos = pos + 1;\n                index = index;\n\
    \            }\n            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word[pos..]);\n\
    \            vowels[index] = String::new();\n            res.push_str(&word\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmphia8dkrj.rs:84:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n22 |     match vowels.iter().position(|v|\
    \ v.as_str() == &word[pos..]) {\n   |                                        \
    \                          - unclosed delimiter\n23 |         Some(i) => {\n \
    \  |                    - this delimiter might not be properly closed...\n...\n\
    67 | }\n   | - ...as it matches this but it has different indentation\n...\n84\
    \ | }\n   |   ^\n\nerror: expected identifier, found keyword `fn`\n  --> /tmp/tmphia8dkrj.rs:69:1\n\
    \   |\n69 | fn main() {\n   | ^^ expected identifier, found keyword\n\nerror:\
    \ expected one of `=>`, `@`, `if`, or `|`, found `main`\n  --> /tmp/tmphia8dkrj.rs:69:4\n\
    \   |\n69 | fn main() {\n   |    ^^^^ expected one of `=>`, `@`, `if`, or `|`\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmphia8dkrj.rs:66:25\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n66 |             res.push_str(&word\n   |                         ^ unclosed\
    \ delimiter\n67 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method\
    \ named `as_str` found for reference `&&str` in the current scope\n  --> /tmp/tmphia8dkrj.rs:17:58\n\
    \   |\n17 |     while let Some(ref v) = vowels.iter().position(|v| v.as_str()\
    \ == &word[pos]) {\n   |                                                     \
    \    -^^^^^^-- help: remove this method call\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmphia8dkrj.rs:17:71\n   |\n17\
    \ |     while let Some(ref v) = vowels.iter().position(|v| v.as_str() == &word[pos])\
    \ {\n   |                                                                    \
    \   ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<Range"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut last_consonant\
    \ = String::new();\n    let mut first_consonant = String::new();\n    let mut\
    \ last_vowel = String::new();\n    let mut first_vowel = String::new();\n    for\
    \ ch in word.chars() {\n        if ch.is_consonant() {\n            last_consonant\
    \ = ch;\n        } else {\n            if first_consonant.len() > 0 {\n      \
    \          first_consonant = last_consonant;\n            }\n            last_vowel\
    \ = ch;\n        }\n    }\n    if first_consonant.len() > 0 {\n        first_consonant\
    \ = first_consonant.to_string();\n        last_consonant = last_consonant.to_string();\n\
    \    }\n    for ch in word.chars() {\n        if ch.is_vowel() {\n           \
    \ last_vowel = ch;\n        } else {\n            if first_vowel.len() > 0 {\n\
    \                first_vowel = last_vowel;\n            }\n        }\n    }\n\
    \    if first_vowel.len() > 0 {\n        res.push_str(&first_vowel);\n    } else\
    \ {\n        return \"\".to_string();\n    }\n    if first_consonant.len() > 0\
    \ {\n        res.push_str(&last_consonant);\n    } else {\n        return \"\"\
    .to_string();\n    }\n    if first_vowel.len() > 0 {\n        res.push_str(&first_vowel);\n\
    \    } else {\n        return \"\".to_string();\n    }\n    if last_vowel.len()\
    \ > 0 {\n        res.push_str(&last_vowel);\n    }\n    return res.to_string();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp6xmbzgvl.rs:18:15\n   |\n18 |         if ch.is_consonant()\
    \ {\n   |               ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6xmbzgvl.rs:19:30\n   |\n13 |     let mut last_consonant\
    \ = String::new();\n   |                              ------------- expected due\
    \ to this value\n...\n19 |             last_consonant = ch;\n   |            \
    \                  ^^- help: try using a conversion method: `.to_string()`\n \
    \  |                              |\n   |                              expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xmbzgvl.rs:24:26\n\
    \   |\n15 |     let mut last_vowel = String::new();\n   |                    \
    \      ------------- expected due to this value\n...\n24 |             last_vowel\
    \ = ch;\n   |                          ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                          |\n   |                      \
    \    expected struct `String`, found `char`\n\nerror[E0599]: no method named `is_vowel`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp6xmbzgvl.rs:32:15\n\
    \   |\n32 |         if ch.is_vowel() {\n   |               ^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xmbzgvl.rs:33:26\n\
    \   |\n15 |     let mut last_vowel = String::new();\n   |                    \
    \      ------------- expected due to this value\n...\n33 |             last_vowel\
    \ = ch;\n   |                          ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                          |\n   |                      \
    \    expected struct `String`, found `char`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars()\n        .map(|c| c.to_ascii_lowercase())\n\
    \        .cloned()\n        .windows(2)\n        .filter(|v| v.chars().any(|c|\
    \ c == 'u' || c == 'i' || c == 'o' || c == 'a' || c == 'e' || c == 'u'))\n   \
    \     .map(|v| v[..].to_string())\n        .chain(())\n        .min_by(|a, b|\
    \ a.len() as i16 - b.len() as i16)\n        .unwrap()\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmplieil2p7.rs:13:14:\
    \ 13:40] as FnOnce<(char,)>>::Output == &_`\n    --> /tmp/tmplieil2p7.rs:14:10\n\
    \     |\n14   |         .cloned()\n     |          ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\n     = note: required because of the requirements on\
    \ the impl of `Iterator` for `Map<Chars<'_>, [closure@/tmp/tmplieil2p7.rs:13:14:\
    \ 13:40]>`\nnote: required by a bound in `cloned`\n\nerror[E0599]: no method named\
    \ `windows` found for struct `Cloned` in the current scope\n  --> /tmp/tmplieil2p7.rs:15:10\n\
    \   |\n15 |         .windows(2)\n   |          ^^^^^^^ method not found in `Cloned<Map<Chars<'_>,\
    \ [closure@/tmp/tmplieil2p7.rs:13:14: 13:40]>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.length() <= 2 {\n        return String::new();\n\
    \    }\n    let mut start = 0;\n    let mut end = 0;\n    let mut vowels: Vec<&str>\
    \ = vec![];\n    let mut first_cons = false;\n    let mut last_cons = false;\n\
    \    let mut cons_pos = 0;\n    let mut last_pos = 0;\n    let mut last_vowel\
    \ = String::new();\n    for c in word.chars() {\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u'{\n            vowels.push(c);\n        }\n\
    \        if c == ' ' {\n            let start = cons_pos - 1;\n            let\
    \ end = last_pos;\n            let mut vowel = String::new();\n            let\
    \ mut cons_vowel = false;\n            for i in start..end {\n               \
    \ if vowels[i] == 'a' || vowels[i] == 'e' || vowels[i] == 'i' || vowels[i] ==\
    \ 'o' || vowels[i] == 'u'{\n                    vowel = vowel.push_str(vowels[i]);\n\
    \                    cons_vowel = true;\n                }\n            }\n  \
    \          if !cons_vowel && vowel.len() != 0 {\n                last_vowel =\
    \ vowel.clone();\n            }\n            last_pos = cons_pos;\n          \
    \  last_cons = cons_vowel;\n        }\n        if c == 'b' || c == 'c' || c ==\
    \ 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l'\
    \ || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's' || c\
    \ == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'z' || c == '\\0' {\n   \
    \         last_pos = cons_pos;\n            last_cons = cons_vowel;\n        }\n\
    \        if cons_pos == 0 && c == 'a' || c == 'b' || c == 'c' || c == 'd' || c\
    \ == 'f' || c == 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l' || c == 'm'\
    \ || c == 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's' || c == 't' || c\
    \ == 'v' || c == 'w' || c == 'x' || c == 'z' || c == '\\0' {\n            cons_pos\
    \ = word.length();\n        }\n        if c == ' ' {\n            cons_pos--;\n\
    \        }\n        cons_pos++;\n    }\n    if first_cons {\n        let mut vowel\
    \ = String::new();\n        for i in start..end {\n            if vowels[i] ==\
    \ 'a' || vowels[i] == 'e' || \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptske_d3r.rs:77:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n56 |     if first_cons\
    \ {\n   |                   - unclosed delimiter\n57 |         let mut vowel =\
    \ String::new();\n58 |         for i in start..end {\n   |                   \
    \          - this delimiter might not be properly closed...\n59 |            \
    \ if vowels[i] == 'a' || vowels[i] == 'e' || \n60 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n77 | }\n   |   ^\n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmptske_d3r.rs:54:17\n   |\n54\
    \ |         cons_pos++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n54 |         { let tmp = cons_pos; cons_pos\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n54 -\
    \         cons_pos++;\n54 +         cons_pos += 1;\n   | \n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmptske_d3r.rs:60:1\n   |\n60 | }\n   | ^ expected expression\n\
    \nerror[E0425]: cannot find value `cons_vowel` in this scope\n  --> /tmp/tmptske_d3r.rs:46:25\n\
    \   |\n46 |             last_cons = cons_vowel;\n   |                        \
    \ ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmptske_d3r.rs:12:13\n\
    \   |\n12 |     if word.length() <= 2 {\n   |             ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptske_d3r.rs:25:25\n   |\n25 |             vowels.push(c);\n\
    \   |                         ^ expected `&str`, found `char`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmptske_d3r.rs:33:30\n   |\n33\
    \ |                 if vowels[i] == 'a' || vowels[i] == 'e' || vowels[i] == 'i'\
    \ || vowels[i] == 'o' || vowels[i] == 'u'{\n   |                             \
    \ ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: th"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().take(word.len() - 2).rev().map(|c|\
    \ c.to_ascii_lowercase()).find(|c| c != c.to_ascii_lowercase().to_lowercase()).expect(\"\
    cannot find any vowels\").to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp4owgv1s_.rs:12:45\n     |\n12   |     word.chars().rev().take(word.len()\
    \ - 2).rev().map(|c| c.to_ascii_lowercase()).find(|c| c != c.to_ascii_lowercase().to_lowercase()).ex...\n\
    \     |                                             ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `ExactSizeIterator`\
    \ for `Rev<Chars<'_>>`\n     = note: required because of the requirements on the\
    \ impl of `DoubleEndedIterator` for `std::iter::Take<Rev<Chars<'_>>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0599]: the method `map` exists for struct `Rev<std::iter::Take<Rev<Chars<'_>>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp4owgv1s_.rs:12:51\n \
    \  |\n12 |    ...en() - 2).rev().map(|c| c.to_ascii_lowercase()).find(|c| c !=\
    \ c.to_ascii_lowercase().to_lowercase()).expect(\"cannot find any vowels\")....\n\
    \   |                       ^^^ method cannot be called on `Rev<std::iter::Take<Rev<Chars<'_>>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `std::iter::Take<Rev<Chars<'_>>>: DoubleEndedIterator`\n\
    \           which is required by `Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n\
    \           `Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n           which\
    \ is required by `&mut Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut s = String::new();\n    let mut pos = word.len()\
    \ - 1;\n    let mut vowel_a = String::new();\n    let mut vowel_e = String::new();\n\
    \    let mut vowel_i = String::new();\n    let mut vowel_o = String::new();\n\
    \    let mut vowel_u = String::new();\n    let mut vowel_aa = String::new();\n\
    \    let mut vowel_ae = String::new();\n    let mut vowel_ai = String::new();\n\
    \    let mut vowel_ao = String::new();\n    let mut vowel_au = String::new();\n\
    \    let mut vowel_ua = String::new();\n    let mut vowel_aei = String::new();\n\
    \    let mut vowel_aou = String::new();\n    let mut vowel_auu = String::new();\n\
    \n    while pos > 0 {\n        if word[pos] == 'a' {\n            vowel_a = String::new();\n\
    \        }\n        if word[pos] == 'e' {\n            vowel_e = String::new();\n\
    \        }\n        if word[pos] == 'i' {\n            vowel_i = String::new();\n\
    \        }\n        if word[pos] == 'o' {\n            vowel_o = String::new();\n\
    \        }\n        if word[pos] == 'u' {\n            vowel_u = String::new();\n\
    \        }\n        if word[pos] == 'a' {\n            vowel_aa = String::new();\n\
    \        }\n        if word[pos] == 'e' {\n            vowel_ae = String::new();\n\
    \        }\n        if word[pos] == 'i' {\n            vowel_ai = String::new();\n\
    \        }\n        if word[pos] == 'o' {\n            vowel_ao = String::new();\n\
    \        }\n        if word[pos] == 'u' {\n            vowel_au = String::new();\n\
    \        }\n        if word[pos] == 'a' {\n            vowel_ua = String::new();\n\
    \        }\n        if word[pos] == 'e' {\n            vowel_aei = String::new();\n\
    \        }\n        if word[pos] == 'o' {\n            vowel_aou = String::new();\n\
    \        }\n        if word[pos] == 'u' {\n            vowel_auu = String::new();\n\
    \        }\n\n        if vowel_a.len() != 0 || vowel_e.len() != 0 || vowel_i.len()\
    \ != 0 || vowel_o.len() != 0 || vowel_u.len() != 0 || vowel_aa.\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptbvp7hvz.rs:91:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n29 |     while pos\
    \ > 0 {\n   |                   - this delimiter might not be properly closed...\n\
    ...\n74 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    91 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmptbvp7hvz.rs:74:1\n\
    \   |\n74 | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmptbvp7hvz.rs:74:1\n\
    \   |\n73 |         if vowel_a.len() != 0 || vowel_e.len() != 0 || vowel_i.len()\
    \ != 0 || vowel_o.len() != 0 || vowel_u.len() != 0 || vowel_aa.\n   |        \
    \ -- this `if` expression has a condition, but no block\n74 | }\n   | ^ expected\
    \ `{`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptbvp7hvz.rs:30:12\n\
    \   |\n30 |         if word[pos] == 'a' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptbvp7hvz.rs:33:12\n   |\n33 |         if word[pos] == 'e' {\n \
    \  |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut cons = word[word.len()..].chars().collect::<Vec<&str>>();\n\
    \    let mut vowel = String::new();\n\n    while cons.len() > 1 {\n        for\
    \ &con in cons.iter() {\n            if let Some(cons) = cons.iter().position(|&x|\
    \ *x == &con) {\n                vowel = con;\n                break;\n      \
    \      }\n        }\n        cons = cons.iter().collect::<Vec<&str>>();\n    }\n\
    \n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmph67ck5u_.rs:12:47\n     |\n12\
    \   |     let mut cons = word[word.len()..].chars().collect::<Vec<&str>>();\n\
    \     |                                               ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0277]: can't compare `str` with `&&str`\n  -->\
    \ /tmp/tmph67ck5u_.rs:17:62\n   |\n17 |             if let Some(cons) = cons.iter().position(|&x|\
    \ *x == &con) {\n   |                                                        \
    \      ^^ no implementation for `str == &&str`\n   |\n   = help: the trait `PartialEq<&&str>`\
    \ is not implemented for `str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph67ck5u_.rs:18:25\n\
    \   |\n13 |     let mut vowel = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n18 |                 vowel = con;\n   |   \
    \                      ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `&str`\n\nerror[E0277]: a value of type `Vec<&str>` cannot be\
    \ built from an iterator over elements of type `&&str`\n    --> /tmp/tmph67ck5u_.rs:22:28\n\
    \     |\n22   |         cons = cons.iter().collect::<Vec<&str>>();\n     |   \
    \                         ^^^^^^^ value of type `Vec<&str>` cannot be built from\
    \ `std::it"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code goes here\n    word.to_lowercase().chars().enumerate().filter(|&(_,\
    \ index)| {\n        (index > 0) || (index < word.len() - 2)\n    }).map(|(index,\
    \ char)| {\n        if char == 'a'\n            || char == 'e'\n            ||\
    \ char == 'i'\n            || char == 'o'\n            || char == 'u'\n      \
    \  {\n            char\n        } else {\n            \"\"\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps77hlxv0.rs:14:18\n   |\n\
    14 |         (index > 0) || (index < word.len() - 2)\n   |                  ^\
    \ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps77hlxv0.rs:14:33\n\
    \   |\n14 |         (index > 0) || (index < word.len() - 2)\n   |            \
    \                     ^^^^^^^^^^^^^^ expected `char`, found `usize`\n\nerror[E0308]:\
    \ `if` and `else` have incompatible types\n  --> /tmp/tmps77hlxv0.rs:24:13\n \
    \  |\n16 | /         if char == 'a'\n17 | |             || char == 'e'\n18 | |\
    \             || char == 'i'\n19 | |             || char == 'o'\n...  |\n22 |\
    \ |             char\n   | |             ---- expected because of this\n23 | |\
    \         } else {\n24 | |             \"\"\n   | |             ^^ expected `char`,\
    \ found `&str`\n25 | |         }\n   | |_________- `if` and `else` have incompatible\
    \ types\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = String::new();\n    let mut i = 0;\n\
    \    while i < word.len() {\n        if word[i] == String::from(\"A\"..=\"Z\"\
    ) {\n            i += 1;\n            if i == word.len() {\n                break;\n\
    \            }\n            vowel = match vowel.cmp(&word[i - 1..i]) {\n     \
    \           Ordering::Less => String::from(\"\"),\n                Ordering::Equal\
    \ => String::from(\"\"),\n                Ordering::Greater => String::from(\"\
    U\"),\n            };\n        } else {\n            i += 1;\n            if i\
    \ == word.len() {\n                break;\n            }\n            vowel =\
    \ match vowel.cmp(&word[i - 1..i]) {\n                Ordering::Less => String::from(\"\
    \"),\n                Ordering::Equal => String::from(\"\"),\n               \
    \ Ordering::Greater => String::from(\"u\"),\n            };\n        }\n    }\n\
    \    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp69fs_q4h.rs:21:17\n   |\n21 |                 Ordering::Less => String::from(\"\
    \"),\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp69fs_q4h.rs:22:17\n\
    \   |\n22 |                 Ordering::Equal => String::from(\"\"),\n   |     \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp69fs_q4h.rs:23:17\n\
    \   |\n23 |                 Ordering::Greater => String::from(\"U\"),\n   |  \
    \               ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp69fs_q4h.rs:31:17\n\
    \   |\n31 |                 Ordering::Less => String::from(\"\"),\n   |      \
    \           ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp69fs_q4h.rs:32:17\n\
    \   |\n32 |                 Ordering::Equal => String::from(\"\"),\n   |     \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp69fs_q4h.rs:33:17\n\
    \   |\n33 |                 Ordering::Greater => String::from(\"u\"),\n   |  \
    \               ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp69fs_q4h.rs:15:12\n\
    \   |\n15 |         if word[i] == String::from(\"A\"..=\"Z\") {\n   |        \
    \    ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\".to_string();\n    word.chars().enumerate().filter(|(_,c)|\
    \ *c >= 'a' && *c <= 'z').fold(String::new(), |acc,(_,c)| {\n        acc.push_str(vowels.chars().skip(1).take(2).find(|c|\
    \ *c == c).unwrap_or(String::new()))\n    });\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv_tpjqep.rs:14:68\n   |\n\
    14 |         acc.push_str(vowels.chars().skip(1).take(2).find(|c| *c == c).unwrap_or(String::new()))\n\
    \   |                                                                    ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |         acc.push_str(vowels.chars().skip(1).take(2).find(|c| *c == *c).unwrap_or(String::new()))\n\
    \   |                                                                    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpv_tpjqep.rs:14:81\n   |\n14 |  \
    \       acc.push_str(vowels.chars().skip(1).take(2).find(|c| *c == c).unwrap_or(String::new()))\n\
    \   |                                                                        \
    \         ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv_tpjqep.rs:14:22\n   |\n14 |         acc.push_str(vowels.chars().skip(1).take(2).find(|c|\
    \ *c == c).unwrap_or(String::new()))\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_tpjqep.rs:14:9\n\
    \   |\n14 |         acc.push_str(vowels.chars().skip(1).take(2).find(|c| *c ==\
    \ c).unwrap_or(String::new()))\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpv_tpjqep.rs:14:13\n   |\n14 |         acc.push_str(vowels.chars().skip(1).take(2).find(|c|\
    \ *c == c).unwrap_or(String::new()))\n   |         --- ^^^^^^^^ this call modifies\
    \ `acc` in-place\n   |         |\n   |         you probably want to use this value\
    \ after calling the method...\n   = note: ...instead of the `()` output of method\
    \ `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_tpjqep.rs:11:39\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n\tlet mut vowels = Vec::new();\n\tvowels.push_str(\"\"\
    .to_string());\n\tvowels.push_str(\"A\".to_string());\n\tvowels.push_str(\"E\"\
    .to_string());\n\tvowels.push_str(\"I\".to_string());\n\tvowels.push_str(\"O\"\
    .to_string());\n\tvowels.push_str(\"U\".to_string());\n\tvowels.push_str(\"a\"\
    .to_string());\n\tvowels.push_str(\"e\".to_string());\n\tvowels.push_str(\"i\"\
    .to_string());\n\tvowels.push_str(\"o\".to_string());\n\tvowels.push_str(\"u\"\
    .to_string());\n\tlet mut vowel_count = 0;\n\tlet mut vowel_start = String::new();\n\
    \tlet mut vowel_end = String::new();\n\tfor (i, char) in word.chars().enumerate()\
    \ {\n\t\tif char == 'a' || char == 'e' || char == 'i' || char == 'o' || char ==\
    \ 'u' {\n\t\t\tvowel_start = word[(i - 1)..i];\n\t\t\tvowel_end = word[i..(i +\
    \ 1)];\n\t\t\tvowel_count += 1;\n\t\t}\n\t\tif vowel_count == 2 {\n\t\t\tif vowel_start\
    \ == \"\" {\n\t\t\t\tvowel_start = String::new();\n\t\t\t}\n\t\t\tif vowel_end\
    \ == \"\" {\n\t\t\t\tvowel_end = String::new();\n\t\t\t}\n\t\t\treturn vowels[vowel_start.len()..vowel_end.len()];\
    \ // the range here will be between 0 to 3\n\t\t}\n\t}\n\t\n\treturn \"\".to_string();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push_str` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmpgbcrujgn.rs:13:9\n   |\n13 |     vowels.push_str(\"\
    \".to_string());\n   |            ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push`\n\nerror[E0599]: no method named `push_str` found\
    \ for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgbcrujgn.rs:14:9\n \
    \  |\n14 |     vowels.push_str(\"A\".to_string());\n   |            ^^^^^^^^ help:\
    \ there is an associated function with a similar name: `push`\n\nerror[E0599]:\
    \ no method named `push_str` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmpgbcrujgn.rs:15:9\n   |\n15 |     vowels.push_str(\"E\".to_string());\n\
    \   |            ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `push`\n\nerror[E0599]: no method named `push_str` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmpgbcrujgn.rs:16:9\n   |\n16 |     vowels.push_str(\"\
    I\".to_string());\n   |            ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push`\n\nerror[E0599]: no method named `push_str` found\
    \ for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgbcrujgn.rs:17:9\n \
    \  |\n17 |     vowels.push_str(\"O\".to_string());\n   |            ^^^^^^^^ help:\
    \ there is an associated function with a similar name: `push`\n\nerror[E0599]:\
    \ no method named `push_str` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmpgbcrujgn.rs:18:9\n   |\n18 |     vowels.push_str(\"U\".to_string());\n\
    \   |            ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `push`\n\nerror[E0599]: no method named `push_str` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmpgbcrujgn.rs:19:9\n   |\n19 |     vowels.push_str(\"\
    a\".to_string());\n   |            ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push`\n\nerror[E0599]: no method named `push_str` found\
    \ for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgbcrujgn.rs:20:9\n \
    \  |\n20 |     vowels.push_str(\"e\".to_string());\n   |            ^^^^^^^^ help:\
    \ there is an associated function with a"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = \"\";\n    \n    // Check if there\
    \ are consonants in the right\n    let mut consonants = word.len() - 1;\n    \n\
    \    // Check all letters until we find a vowel\n    while consonants > 0 {\n\
    \        \n        // If we have a vowel\n        if word.chars().all(|c| *c ==\
    \ 'A' || \n                         *c == 'E' || \n                         *c\
    \ == 'I' || \n                         *c == 'O' || \n                       \
    \  *c == 'U') {\n            \n            // If we found a vowel in the right\
    \ place, break\n            return String::from(&result[..consonants]);\n    \
    \    }\n        \n        // If not and we found a vowel in the left place, break\n\
    \        if consonants > 0 && word.chars().any(|c| *c == 'a' || \n           \
    \                                  *c == 'e' || \n                           \
    \                  *c == 'i' || \n                                           \
    \  *c == 'o' || \n                                             *c == 'u') {\n\
    \            \n            consonants -= 1;\n        }\n        \n        // If\
    \ we found a consonant in the right place, break\n        if consonants > 0 &&\
    \ word.chars().any(|c| *c == 'B' || \n                                       \
    \      *c == 'G' || \n                                             *c == 'J' ||\
    \ \n                                             *c == 'M' || \n             \
    \                                *c == 'P' || \n                             \
    \                *c == 'S' || \n                                             *c\
    \ == 'V') {\n            \n            consonants -= 1;\n        }\n    }\n  \
    \  \n    // We didn't find any vowels\n    \"\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:21:33\n\
    \   |\n21 |         if word.chars().all(|c| *c == 'A' || \n   |              \
    \                   ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n \
    \ --> /tmp/tmpze2rpzwj.rs:22:26\n   |\n22 |                          *c == 'E'\
    \ || \n   |                          ^^\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmpze2rpzwj.rs:23:26\n   |\n23 |                  \
    \        *c == 'I' || \n   |                          ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:24:26\n   |\n24 | \
    \                         *c == 'O' || \n   |                          ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:25:26\n\
    \   |\n25 |                          *c == 'U') {\n   |                      \
    \    ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:32:51\n\
    \   |\n32 |         if consonants > 0 && word.chars().any(|c| *c == 'a' || \n\
    \   |                                                   ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:33:46\n   |\n33 | ...\
    \                   *c == 'e' || \n   |                       ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:34:46\n   |\n\
    34 | ...                   *c == 'i' || \n   |                       ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:35:46\n   |\n\
    35 | ...                   *c == 'o' || \n   |                       ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:36:46\n   |\n\
    36 | ...                   *c == 'u') {\n   |                       ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:42:51\n   |\n\
    42 |         if consonants > 0 && word.chars().any(|c| *c == 'B' || \n   |   \
    \                                                ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpze2rpzwj.rs:43:46\n   |\n43 | ...    \
    \               *c == 'G' || \n   |                       ^^"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel: Option<&str> = None;\n    let mut idx\
    \ = 0;\n    for ch in word.chars() {\n        if idx % 2 == 0 {\n            if\
    \ ch >= 'a' && ch <= 'z' {\n                vowel = Some(&word[idx..idx+3]);\n\
    \                break;\n            }\n        } else {\n            if ch >=\
    \ 'A' && ch <= 'Z' {\n                vowel = Some(&word[idx..idx+3]);\n     \
    \           break;\n            }\n        }\n        idx += 1;\n    }\n    match\
    \ vowel {\n        None => \"\",\n        Some(v) => v,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk14atooz.rs:29:17\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n...\n29 |\
    \         None => \"\",\n   |                 ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                 |\n   |                 expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel: String;\n    let mut vowel_start = word.chars().position(|c|\
    \ c >= 'a' && c <= 'z');\n    let mut vowel_end = word.chars().position(|c| c\
    \ >= 'A' && c <= 'Z');\n    if vowel_start.is_none() {\n        vowel = word.chars().position(|c|\
    \ c >= 'a' && c <= 'z').unwrap();\n    } else if vowel_end.is_none() {\n     \
    \   vowel = word.chars().position(|c| c >= 'A' && c <= 'Z').unwrap();\n    } else\
    \ {\n        vowel = word.chars().position(|c| c >= 'a' && c <= 'z')\n       \
    \     .unwrap()\n            .take_while(|c| c != 'A' || c != 'a'|| c != 'E' ||\
    \ c != 'e' || \n            c!= 'I' || c != 'i' || c != 'O' || c != 'o' || c!=\
    \ 'U' || c != 'u'\n        ).unwrap()\n    }\n    \n    vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplb4xtn3a.rs:16:17\n   |\n\
    12 |     let mut vowel: String;\n   |                    ------ expected due to\
    \ this type\n...\n16 |         vowel = word.chars().position(|c| c >= 'a' && c\
    \ <= 'z').unwrap();\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                 |\n\
    \   |                 expected struct `String`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplb4xtn3a.rs:18:17\n   |\n12 |     let mut vowel:\
    \ String;\n   |                    ------ expected due to this type\n...\n18 |\
    \         vowel = word.chars().position(|c| c >= 'A' && c <= 'Z').unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                 |\n\
    \   |                 expected struct `String`, found `usize`\n\nerror[E0599]:\
    \ `usize` is not an iterator\n  --> /tmp/tmplb4xtn3a.rs:22:14\n   |\n22 |    \
    \         .take_while(|c| c != 'A' || c != 'a'|| c != 'E' || c != 'e' || \n  \
    \ |              ^^^^^^^^^^ `usize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `usize: Iterator`\n           which\
    \ is required by `&mut usize: Iterator`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code goes here\n    let vowels = \"AEIOUaeiou\"\
    .to_string();\n    let vowel_set = vowels.chars().collect::<HashSet<char>>();\n\
    \    word.chars().for_each(|c|{\n        if vowel_set.contains(&c) {\n       \
    \     vowel_set.insert(c);\n        }\n    });\n    let mut res = \"\";\n    let\
    \ mut s = word;\n    while !vowel_set.contains(&s[s.len()-1]) && s.len() > 0 {\n\
    \        res = &mut s[0..s.len()-1];\n        s.remove(s.len()-1);\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpt92f1548.rs:14:46\n\
    \   |\n14 |     let vowel_set = vowels.chars().collect::<HashSet<char>>();\n \
    \  |                                              ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpt92f1548.rs:22:32\n\
    \   |\n22 |     while !vowel_set.contains(&s[s.len()-1]) && s.len() > 0 {\n  \
    \ |                                ^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt92f1548.rs:26:5\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    26 |     res\n   |     ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_count: usize = 0;\n    \n    for letter\
    \ in word[1..] {\n        if letter >= 'a' && letter <= 'z' {\n            vowel_count\
    \ = vowel_count + 1;\n        }\n    }\n    \n    let mut vowel_range: Vec<usize>\
    \ = vec![vowel_count, vowel_count];\n    vowel_range.sort();\n    \n    let vowel:\
    \ usize = (vowel_range[1] + vowel_range[0]) / 2;\n    let mut current_char: char;\n\
    \    \n    for c in word.rposition(|c| c >= 'a' && c <= 'z') {\n        if let\
    \ Some(pos) = word.rindex(c) {\n            let pos_range: Vec<usize> = vec![pos\
    \ - 1, pos];\n            pos_range.sort();\n            let mut cur_vowel: usize\
    \ = (pos_range[1] + pos_range[0]) / 2;\n            \n            if cur_vowel\
    \ == vowel {\n                current_char = c\n            }\n        }\n   \
    \ }\n    \n    if let Some(current) = current_char {\n        return current\n\
    \    }\n    \n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmppwf7i9bk.rs:14:19\n   |\n14 |     for letter in word[1..]\
    \ {\n   |                   ^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `str`\n\nerror[E0277]:\
    \ `str` is not an iterator\n  --> /tmp/tmppwf7i9bk.rs:14:19\n   |\n14 |     for\
    \ letter in word[1..] {\n   |                   ^^^^^^^^^ `str` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `str`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `str`\n\
    \nerror[E0599]: no method named `rposition` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmppwf7i9bk.rs:26:19\n   |\n26 |     for c in word.rposition(|c|\
    \ c >= 'a' && c <= 'z') {\n   |                   ^^^^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `rindex` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmppwf7i9bk.rs:27:33\n   |\n27 |         if\
    \ let Some(pos) = word.rindex(c) {\n   |                                 ^^^^^^\
    \ help: there is an associated function with a similar name: `find`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppwf7i9bk.rs:38:12\n   |\n38 |     if let Some(current)\
    \ = current_char {\n   |            ^^^^^^^^^^^^^   ------------ this expression\
    \ has type `char`\n   |            |\n   |            expected `char`, found enum\
    \ `Option`\n   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
