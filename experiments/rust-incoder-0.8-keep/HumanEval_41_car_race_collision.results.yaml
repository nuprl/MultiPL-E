name: HumanEval_41_car_race_collision
language: rust
results:
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n    for _ in 0..n {\n        let\
    \ mut j = 1;\n        while j > 0 {\n            if j % 2 == 0 {\n           \
    \     counter += 1;\n                j -= 1;\n            } else {\n         \
    \       j += 2;\n            }\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to add with overflow', /tmp/tmp7yfb33dq.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Initialize number of collisions\n    let mut collisions\
    \ = 0;\n    // Initialize a speed vector of length n\n    let mut speed = vec![0.0,\
    \ 0.0, 0.0, 0.0];\n    // Initialize vector for collisions\n    let mut collisions_vec\
    \ = vec![false; n];\n    // Initialize vector for car positions\n    let mut car_positions\
    \ = vec![0.0, 0.0, 0.0, 0.0];\n    // Initialize vector for car velocities\n \
    \   let mut car_velocities = vec![0.0, 0.0, 0.0, 0.0];\n    // Initialize vector\
    \ for car headings\n    let mut car_headings = vec![0.0, 0.0, 0.0, 0.0];\n   \
    \ // Initialize vector for car accelerations\n    let mut car_accelerations =\
    \ vec![0.0, 0.0, 0.0, 0.0];\n\n    // Set initial velocity (random)\n    speed[0]\
    \ = rand::random::<f32>() - 0.2;\n    speed[1] = rand::random::<f32>() - 0.2;\n\
    \    speed[2] = rand::random::<f32>() - 0.2;\n    speed[3] = rand::random::<f32>()\
    \ - 0.2;\n\n    // Set initial position (random)\n    car_positions[0] = rand::random::<f32>()\
    \ - 0.2;\n    car_positions[1] = rand::random::<f32>() - 0.2;\n    car_positions[2]\
    \ = rand::random::<f32>() - 0.2;\n    car_positions[3] = rand::random::<f32>()\
    \ - 0.2;\n\n    // Set initial heading\n    car_headings[0] = rand::random::<f32>()\
    \ - 0.2;\n\n    // Set initial acceleration (random)\n    car_accelerations[0]\
    \ = rand::random::<f32>() - 0.2;\n    car_accelerations[1] = rand::random::<f32>()\
    \ - 0.2;\n    car_accelerations[2] = rand::random::<f32>() - 0.2;\n    car_accelerations[3]\
    \ = rand::random::<f32>() - 0.2;\n\n    // For each iteration\n    for _ in 0..n\
    \ {\n        // Increment number of collisions\n        collisions++;\n      \
    \  // Increment vector of velocities\n        car_velocities[0] += speed[0] *\
    \ dt;\n        car_velocities[1] += speed[1] * dt;\n        car_velocities[2]\
    \ += speed[2] * dt;\n        car_velocities[3] += speed[3] * dt;\n        // Update\
    \ car position\n        car_positions[0] += car_velocities[0] * dt;\n        car_positions[1]\
    \ += car_veloci\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcy__45at.rs:67:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n47 |     for _ in 0..n {\n\
    \   |                   - this delimiter might not be properly closed...\n...\n\
    58 | }\n   | - ...as it matches this but it has different indentation\n...\n67\
    \ | }\n   |   ^\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpcy__45at.rs:49:19\n\
    \   |\n49 |         collisions++;\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n49 |         { let tmp = collisions;\
    \ collisions += 1; tmp };\n   |         +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    49 -         collisions++;\n49 +         collisions += 1;\n   | \n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpcy__45at.rs:26:16\n\
    \   |\n26 |     speed[0] = rand::random::<f32>() - 0.2;\n   |                ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpcy__45at.rs:27:16\n\
    \   |\n27 |     speed[1] = rand::random::<f32>() - 0.2;\n   |                ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpcy__45at.rs:28:16\n\
    \   |\n28 |     speed[2] = rand::random::<f32>() - 0.2;\n   |                ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpcy__45at.rs:29:16\n\
    \   |\n29 |     speed[3] = rand::random::<f32>() - 0.2;\n   |                ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpcy__45at.rs:32:24\n\
    \   |\n32 |     car_positions[0] = rand::random::<f32>() - 0.2;\n   |        \
    \                ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpcy__45at.rs:33:24\n\
    \   |\n33 |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n\n    // let mut collisions:\
    \ Vec<isize> = vec![];\n\n    for _ in 0..n {\n        let mut direction = Vec::new();\n\
    \        let mut speed = Vec::new();\n\n        for _ in 0..n {\n            direction.push(0);\n\
    \            speed.push(0);\n        }\n\n        let mut speed = Vec::new();\n\
    \        let mut direction = Vec::new();\n\n        for _ in 0..n {\n        \
    \    direction.push(0);\n            speed.push(0);\n        }\n\n        // let\
    \ mut direction = vec![1, 1, 1];\n        // let mut speed = vec![1, 1, 1];\n\n\
    \        // for _ in 0..n {\n        //     direction.push(1);\n        //   \
    \  speed.push(1);\n        // }\n\n        // let mut direction = vec![-1, -1,\
    \ -1];\n        // let mut speed = vec![-1, -1, -1];\n\n        // for _ in 0..n\
    \ {\n        //     direction.push(-1);\n        //     speed.push(-1);\n    \
    \    // }\n\n        // let mut direction = vec![1, 2, 1];\n        // let mut\
    \ speed = vec![1, 2, 1];\n\n        // for _ in 0..n {\n        //     direction.push(-1);\n\
    \        //     speed.push(2);\n        // }\n\n        // let mut direction =\
    \ vec![2, 2, 2];\n        // let mut speed = vec![2, 2, 2];\n\n        // for\
    \ _ in 0..n {\n        //     direction.push(1);\n        //     speed.push(2);\n\
    \        // }\n\n        let mut direction = vec![-1, 1, 1];\n        let mut\
    \ speed = vec![-1, 1, 1];\n\n        for _ in 0..n {\n            direction.push(1);\n\
    \            speed.push(1);\n        }\n\n        let mut direction = vec![-2,\
    \ 2, 2];\n        let mut speed = vec![-2, 2, 2];\n\n        for _ in 0..n {\n\
    \            direction.push(1);\n            speed.push(2);\n        }\n\n   \
    \     let mut direction = vec![-1, 1, 1];\n        let mut speed = vec![-1, 1,\
    \ 1];\n\n        for _ in 0..n {\n            direction.push(1);\n           \
    \ speed.push(1);\n        }\n\n        let mut direction = vec![-1, 1, 1];\n \
    \       let mut speed = vec![-1, 1, 1];\n\n        for _ in 0..n {\n         \
    \   direction.push(1);\n            speed.push(1);\n        }\n\n        let mut\
    \ direction = vec![-1, 1, 1];\n        let mut speed = vec![-1, 1, 1];\n\n   \
    \     for _ in 0..n {\n            direction.push(1);\n            \n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpd_faqr2o.rs:110:3\n\
    \    |\n9   | fn car_race_collision(n: isize) -> isize {\n    |              \
    \                            - unclosed delimiter\n...\n14  |     for _ in 0..n\
    \ {\n    |                   - unclosed delimiter\n...\n98  |         for _ in\
    \ 0..n {\n    |                       - this delimiter might not be properly closed...\n\
    ...\n101 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n110 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpd_faqr2o.rs:14:5\n\
    \    |\n9   |   fn car_race_collision(n: isize) -> isize {\n    |            \
    \                          ----- expected `isize` because of return type\n...\n\
    14  | /     for _ in 0..n {\n15  | |         let mut direction = Vec::new();\n\
    16  | |         let mut speed = Vec::new();\n17  | |\n...   |\n109 | |     assert_eq!(candidate(10),\
    \ 100);\n110 | | }\n    | |__^ expected `isize`, found `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    let mut speed = 2.0\n   \
    \ for _ in range(n) {\n        collisions += car_collision(&mut speed, 1)\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpq434bsoi.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     let mut speed = 2.0\n   |     --- unexpected token\n\n\
    error: expected `;`, found keyword `for`\n  --> /tmp/tmpq434bsoi.rs:11:24\n  \
    \ |\n11 |     let mut speed = 2.0\n   |                        ^ help: add `;`\
    \ here\n12 |     for _ in range(n) {\n   |     --- unexpected token\n\nerror[E0425]:\
    \ cannot find function `range` in this scope\n  --> /tmp/tmpq434bsoi.rs:12:14\n\
    \   |\n12 |     for _ in range(n) {\n   |              ^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n\
    \   |\n\nerror[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpq434bsoi.rs:13:23\n   |\n13 |         collisions += car_collision(&mut\
    \ speed, 1)\n   |                       ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut c = 2;\n    while\
    \ c < n {\n        collisions += 1;\n        // For each pair of colliding cars,\
    \ check if they overlap.\n        // If they do, increment c; otherwise decrement\
    \ c.\n        for car_1 in 0..(c-1) { // ***\n            for car_2 in (c+1)..(c+c)\
    \ { // ***\n                // The two cars are guaranteed to collide if and only\
    \ if:\n                // both cars move in the same direction.\n            \
    \    let c1 = (car_1 + car_2)/2;\n                if c > 1 && c1 == c {\n    \
    \                continue;\n                }\n                let c2 = (car_1\
    \ + car_2 - car_2*(c-1))/2;\n                if c == c1 && c2 != c2 {\n      \
    \              c += 1;\n                }\n                else {\n          \
    \          c -= 1;\n                }\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpljovn3jg.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    debug_assert!(n >= 3);\n    let speed: isize = (*MAX_VELOCITY\
    \ * n) as isize;\n    let distance: isize = -(*MAX_VELOCITY * n) as isize;\n \
    \   let mut collisions = 0;\n    let mut last_collision_time = time::now();\n\
    \    let mut car_distance = 0;\n    // let mut car_speed = 0;\n    let mut current_time\
    \ = time::now();\n    for _ in 0..n {\n        let now = time::now();\n      \
    \  let dt = now - last_collision_time;\n        last_collision_time = now;\n \
    \       collisions += (\n            (distance - car_distance) as isize\n    \
    \            + (dt as isize) * (speed as isize)\n                / (*MAX_CAR_VELOCITY\
    \ * n as isize)\n        );\n        // car_speed += dt * (speed as isize);\n\
    \        car_distance += speed as isize;\n        // current_time += dt;\n   \
    \ }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `time`\n\
    \  --> /tmp/tmpoqhpo977.rs:14:35\n   |\n14 |     let mut last_collision_time =\
    \ time::now();\n   |                                   ^^^^ use of undeclared\
    \ crate or module `time`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `time`\n  --> /tmp/tmpoqhpo977.rs:17:28\n   |\n17 |     let\
    \ mut current_time = time::now();\n   |                            ^^^^ use of\
    \ undeclared crate or module `time`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared crate or module `time`\n  --> /tmp/tmpoqhpo977.rs:19:19\n   |\n19\
    \ |         let now = time::now();\n   |                   ^^^^ use of undeclared\
    \ crate or module `time`\n\nerror[E0425]: cannot find value `MAX_VELOCITY` in\
    \ this scope\n  --> /tmp/tmpoqhpo977.rs:11:26\n   |\n11 |     let speed: isize\
    \ = (*MAX_VELOCITY * n) as isize;\n   |                          ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_VELOCITY` in\
    \ this scope\n  --> /tmp/tmpoqhpo977.rs:12:30\n   |\n12 |     let distance: isize\
    \ = -(*MAX_VELOCITY * n) as isize;\n   |                              ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_CAR_VELOCITY`\
    \ in this scope\n  --> /tmp/tmpoqhpo977.rs:25:21\n   |\n25 |                 /\
    \ (*MAX_CAR_VELOCITY * n as isize)\n   |                     ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nwarning: unnecessary parentheses around assigned\
    \ value\n  --> /tmp/tmpoqhpo977.rs:22:23\n   |\n22 |           collisions += (\n\
    \   |  _______________________^\n23 | |             (distance - car_distance)\
    \ as isize\n   | |____________^\n24 |                   + (dt as isize) * (speed\
    \ as isize)\n25 |                   / (*MAX_CAR_VELOCITY * n as isize)\n   | \
    \ ___________________________________________________^\n26 | |         );\n  \
    \ | |_________^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n22 ~         collisions += (distance - car_distance)\
    \ as isize\n23 |                 + (dt as isize) * (speed as isize)\n24 ~    \
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut min_car_x =\
    \ -1.0;\n    let mut max_car_x = 1.0;\n\n    for i in 0..n {\n        // Pick\
    \ a random car x coordinate\n        let mut x = min_car_x + rand::random::<f64>()\
    \ * (max_car_x - min_car_x);\n        let mut car_y: f64 = rand::random::<f64>()\
    \ * (-10.0 - 10.0) + 10.0;\n\n        // Now move that car towards another random\
    \ car\n        while car_y > -10.0 {\n            x += 1;\n            car_y =\
    \ rand::random::<f64>() * (-10.0 - 10.0) + 10.0;\n        }\n\n        // Now\
    \ move the car towards another random car\n        while car_y < 10.0 {\n    \
    \        x -= 1;\n            car_y = rand::random::<f64>() * (-10.0 - 10.0) +\
    \ 10.0;\n        }\n\n        // Now move the car a random amount, but make sure\
    \ it's within our bounds\n        if car_y > 10.0 {\n            x += rand::random::<f64>()\
    \ * (max_car_x - min_car_x);\n        } else {\n            x -= rand::random::<f64>()\
    \ * (max_car_x - min_car_x);\n        }\n\n        // Now check if that car collides\
    \ with any others\n        for j in 0..n {\n            // The car might have\
    \ moved a little bit in the last iteration, so check\n            // again with\
    \ the new position.\n            if j == i {\n                continue;\n    \
    \        }\n\n            let collided_x = x + rand::random::<f64>() * (max_car_x\
    \ - min_car_x);\n            let collided_y = car_y + rand::random::<f64>() *\
    \ (-10.0 - 10.0) + 10.0;\n\n            if collided_x == 0.0 || collided_y ==\
    \ 0.0 {\n                continue;\n            }\n\n            // If the cars\
    \ are in the same position, the car has collided.\n            // Increment the\
    \ count and move on.\n            if ((j > i) && (car_y > collided_y)) || ((j\
    \ < i) && (car_y < collided_y)) {\n                collision_count += 1;\n   \
    \         }\n        }\n        min_car_x = x;\n        max_car_x = x;\n    }\n\
    \    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpme27qax0.rs:16:33\n   |\n16 |         let mut x = min_car_x + rand::random::<f64>()\
    \ * (max_car_x - min_car_x);\n   |                                 ^^^^ use of\
    \ undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared crate or module `rand`\n  --> /tmp/tmpme27qax0.rs:17:30\n   |\n17\
    \ |         let mut car_y: f64 = rand::random::<f64>() * (-10.0 - 10.0) + 10.0;\n\
    \   |                              ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpme27qax0.rs:22:21\n   |\n22 |             car_y = rand::random::<f64>()\
    \ * (-10.0 - 10.0) + 10.0;\n   |                     ^^^^ use of undeclared crate\
    \ or module `rand`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `rand`\n  --> /tmp/tmpme27qax0.rs:28:21\n   |\n28 |             car_y\
    \ = rand::random::<f64>() * (-10.0 - 10.0) + 10.0;\n   |                     ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpme27qax0.rs:33:18\n\
    \   |\n33 |             x += rand::random::<f64>() * (max_car_x - min_car_x);\n\
    \   |                  ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpme27qax0.rs:35:18\n\
    \   |\n35 |             x -= rand::random::<f64>() * (max_car_x - min_car_x);\n\
    \   |                  ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpme27qax0.rs:46:34\n\
    \   |\n46 |             let collided_x = x + rand::random::<f64>() * (max_car_x\
    \ - min_car_x);\n   |                                  ^^^^ use of undeclared\
    \ crate or module `rand`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `rand`\n  --> /tmp/tmpme27qax0.rs:47:38\n   |\n47 |        \
    \     let collided_y = car_y + rand::random::<f64>() * (-10.0 - 10.0) + 10.0;"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n\n    let mut speed = Vec::with_capacity(n);\n\
    \n    let mut left_to_right = Vec::with_capacity(n);\n\n    for car_i in range(n)\
    \ {\n        let car_j = car_i as usize;\n        left_to_right.push(false);\n\
    \        speed[car_i] = 0;\n    }\n\n    for car_i in range(n) {\n        let\
    \ car_j = car_i as usize;\n        for car_k in range(car_i + 1, n) {\n      \
    \      let car_k = car_k as usize;\n\n            assert!(left_to_right[car_j]\
    \ && left_to_right[car_k]);\n\n            let leftmost_car = left_to_right[car_j]\
    \ ? car_j : car_k;\n            let rightmost_car = left_to_right[car_j] ? car_k\
    \ : car_j;\n\n            if speed[leftmost_car] > speed[rightmost_car] {\n  \
    \              collision_count = collision_count + 1;\n                left_to_right[leftmost_car]\
    \ = true;\n                speed[leftmost_car] = speed[rightmost_car];\n     \
    \       }\n        }\n    }\n\n    collision_count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `car_j`\n\
    \  --> /tmp/tmptbfd50im.rs:29:55\n   |\n29 |             let leftmost_car = left_to_right[car_j]\
    \ ? car_j : car_k;\n   |                                                     \
    \  ^^^^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]:\
    \ cannot find function `range` in this scope\n  --> /tmp/tmptbfd50im.rs:16:18\n\
    \   |\n16 |     for car_i in range(n) {\n   |                  ^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::slice::range;\n   |\n\nerror[E0425]: cannot find function `range` in this\
    \ scope\n  --> /tmp/tmptbfd50im.rs:22:18\n   |\n22 |     for car_i in range(n)\
    \ {\n   |                  ^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]:\
    \ cannot find function `range` in this scope\n  --> /tmp/tmptbfd50im.rs:24:22\n\
    \   |\n24 |         for car_k in range(car_i + 1, n) {\n   |                 \
    \     ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::slice::range;\n   |\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmptbfd50im.rs:12:40\n   |\n12 |     let mut speed = Vec::with_capacity(n);\n\
    \   |                                        ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     let mut speed = Vec::with_capacity(n.try_into().unwrap());\n\
    \   |                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptbfd50im.rs:14:48\n   |\n14 |     let mut left_to_right\
    \ = Vec::with_capacity(n);\n   |                                             \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n14 |     let\
    \ mut left_to_right = Vec::with_capacity(n.try_into().unwrap());\n   |       \
    \                                          ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nSo"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n\n    for i in 0..n {\n       \
    \ for j in (i + 1)..n {\n            if car_collision(i, j) && car_collision(j,\
    \ i) {\n                counter += 2;\n            }\n        }\n    }\n\n   \
    \ counter\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpmt_ot1yt.rs:14:16\n   |\n14 |             if car_collision(i, j) &&\
    \ car_collision(j, i) {\n   |                ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `car_collision` in this scope\n  --> /tmp/tmpmt_ot1yt.rs:14:39\n\
    \   |\n14 |             if car_collision(i, j) && car_collision(j, i) {\n   |\
    \                                       ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![];\n    let mut cars_right =\
    \ vec![];\n\n    for i in 1..n {\n        // Left car\n        let left = Car::new();\n\
    \        left.x = -100.0;\n        left.y = 0.0;\n        left.speed = 10.0;\n\
    \        cars_left.push(left);\n\n        // Right car\n        let right = Car::new();\n\
    \        right.x = 100.0;\n        right.y = 0.0;\n        right.speed = 10.0;\n\
    \        cars_right.push(right);\n    }\n\n    for left_car in cars_left {\n \
    \       for right_car in cars_right {\n            if left_car.collides_with_right_car(right_car)\
    \ {\n                println!(\"Car {} collides with car {}\", left_car.id, right_car.id);\n\
    \            }\n        }\n    }\n\n    cars_left.len() + cars_right.len()\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmp4gl1e6de.rs:15:20\n\
    \   |\n15 |         let left = Car::new();\n   |                    ^^^ use of\
    \ undeclared type `Car`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Car`\n  --> /tmp/tmp4gl1e6de.rs:22:21\n   |\n22 |         let right =\
    \ Car::new();\n   |                     ^^^ use of undeclared type `Car`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut collision_points:\
    \ Vec<&[u8]> = Vec::new();\n\n    // Initialize the collision points as points\
    \ on the road.\n    for i in 0..n {\n        collision_points.push((&[0; 128]).to_owned());\n\
    \    }\n\n    for left in 0..n {\n        for right in 0..n {\n            if\
    \ left == right {\n                continue;\n            }\n\n            //\
    \ Find a collision point by testing which point is furthest between\n        \
    \    // the two points.\n            let left_point = collision_points[left];\n\
    \            let right_point = collision_points[right];\n            let mut max_distance\
    \ = std::cmp::max::<u8>(\n                left_point[0] - right_point[0],\n  \
    \              left_point[1] - right_point[1],\n            );\n\n           \
    \ // Check whether the two points are near enough to create a collision.\n   \
    \         let mut point = vec![0; 2];\n            if left_point[0] + max_distance\
    \ > right_point[0] {\n                point[0] = left_point[0] + max_distance;\n\
    \            } else {\n                point[0] = right_point[0] - max_distance;\n\
    \            }\n            if left_point[1] + max_distance > right_point[1] {\n\
    \                point[1] = left_point[1] + max_distance;\n            } else\
    \ {\n                point[1] = right_point[1] - max_distance;\n            }\n\
    \            let mut collision_point = (&point, max_distance);\n            collision_points.push(collision_point);\n\
    \        }\n    }\n\n    // If any collisions were found, then there are two cars\
    \ that\n    // are colliding.  There can be many more collisions, but we'll only\n\
    \    // output a collision count if there are more than 10 collisions.\n    collisions.iter().filter(|(_,\
    \ distance)| distance > 10.0).count()\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6xbtrhq8.rs:15:31\n   |\n\
    15 |         collision_points.push((&[0; 128]).to_owned());\n   |            \
    \                   ^^^^^^^^^^^^^^^^^^^^^^\n   |                             \
    \  |\n   |                               expected `&[u8]`, found array `[{integer};\
    \ 128]`\n   |                               help: consider borrowing here: `&(&[0;\
    \ 128]).to_owned()`\n\nerror[E0277]: the type `[&[u8]]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp6xbtrhq8.rs:26:30\n   |\n26 |             let left_point = collision_points[left];\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&[u8]]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<&[u8]>`\n\nerror[E0277]: the type `[&[u8]]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6xbtrhq8.rs:27:31\n   |\n27 |            \
    \ let right_point = collision_points[right];\n   |                           \
    \    ^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[&[u8]]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<&[u8]>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6xbtrhq8.rs:46:35\n   |\n46 |\
    \             collision_points.push(collision_point);\n   |                  \
    \                 ^^^^^^^^^^^^^^^ expected `&[u8]`, found tuple\n   |\n   = note:\
    \ expected reference `&[u8]`\n                  found tuple `(&Vec<{integer}>,\
    \ u8)`\n\nerror[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp6xbtrhq8.rs:53:16\n   |\n53 |     collisions.iter().filter(|(_,\
    \ distance)| distance > 10.0).count()\n   |                ^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ e"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n\n    let mut cur_left_road_length\
    \ = 1;\n    let mut cur_right_road_length = 1;\n\n    while cur_left_road_length\
    \ > 0 || cur_right_road_length > 0 {\n        if cur_left_road_length == 0 {\n\
    \            collisions += n * (n - 1);\n        }\n\n        if cur_right_road_length\
    \ == 0 {\n            collisions += n * (n - 1);\n        }\n\n        cur_left_road_length\
    \ -= 1;\n        cur_right_road_length -= 1;\n\n        if cur_left_road_length\
    \ <= 0 {\n            cur_left_road_length += 1;\n        }\n\n        if cur_right_road_length\
    \ <= 0 {\n            cur_right_road_length += 1;\n        }\n    }\n\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut speeds = Vec::new();\n\
    \    for _ in 0..n {\n        let speed = rand::random();\n        collisions\
    \ += speeds.iter().enumerate().any(|(i, s)| s > speed);\n        speeds.push(speed);\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpx67h21ho.rs:13:21\n   |\n13 |         let speed = rand::random();\n\
    \   |                     ^^^^ use of undeclared crate or module `rand`\n\nerror[E0277]:\
    \ cannot add-assign `bool` to `{integer}`\n  --> /tmp/tmpx67h21ho.rs:14:20\n \
    \  |\n14 |         collisions += speeds.iter().enumerate().any(|(i, s)| s > speed);\n\
    \   |                    ^^ no implementation for `{integer} += bool`\n   |\n\
    \   = help: the trait `AddAssign<bool>` is not implemented for `{integer}`\n \
    \  = help: the following other types implement trait `AddAssign<Rhs>`:\n     \
    \        <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n         \
    \    <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16 as\
    \ AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    for _ in 0..n {\n      \
    \  // let mut collisions = 0;\n        for _ in 0..n {\n            let xa = vehicle.x;\n\
    \            let ya = vehicle.y;\n            let va = vehicle.v;\n          \
    \  let xb = vehicle.x + direction.x.abs();\n            let yb = vehicle.y + direction.y.abs();\n\
    \            let vb = vehicle.v + direction.v.abs();\n            let xc = vehicle.x\
    \ - direction.x.abs();\n            let yc = vehicle.y - direction.y.abs();\n\
    \            let vc = vehicle.v - direction.v.abs();\n            // println!(\"\
    xa={:?}, ya={:?}, va={:?}, xb={:?}, yb={:?}, vb={:?}, xc={:?}, yc={:?}, vc={:?}\"\
    , xa, ya, va, xb, yb, vb, xc, yc, vc);\n            // println!(\"xa={:?}, ya={:?},\
    \ va={:?}, xb={:?}, yb={:?}, vb={:?}, xc={:?}, yc={:?}, vc={:?}\", vehicle.x,\
    \ vehicle.y, vehicle.v, vehicle.x + direction.x.abs(), vehicle.y + direction.y.abs(),\
    \ vehicle.v + direction.v.abs(), vehicle.x - direction.x.abs(), vehicle.y - direction.y.abs(),\
    \ vehicle.v - direction.v.abs());\n            if xa < xb && ya < yb && va < vb\
    \ {\n                if xa < xc {\n                    collisions += 1;\n    \
    \            } else if xa < xb {\n                    collisions += 2;\n     \
    \           }\n            } else if xa < xc && ya < yc && va < vc {\n       \
    \         if xa < xb {\n                    collisions += 1;\n               \
    \ } else if xa < xc {\n                    collisions += 2;\n                }\n\
    \            } else if xa < xb && ya > yb && va < vb {\n                if xa\
    \ < xc {\n                    collisions += 1;\n                } else if xa <\
    \ xb {\n                    collisions += 2;\n                }\n            }\
    \ else if xa < xc && ya > yc && va < vc {\n                if xa < xb {\n    \
    \                collisions += 1;\n                } else if xa < xc {\n     \
    \               collisions += 2;\n                }\n\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpk6m6_pk8.rs:59:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n10 |     let mut collisions =\
    \ 1;\n11 |     for _ in 0..n {\n   |                   - unclosed delimiter\n\
    12 |         // let mut collisions = 0;\n13 |         for _ in 0..n {\n   |  \
    \                     - unclosed delimiter\n...\n43 |             } else if xa\
    \ < xc && ya > yc && va < vc {\n   |                                         \
    \            - this delimiter might not be properly closed...\n...\n50 | }\n \
    \  | - ...as it matches this but it has different indentation\n...\n59 | }\n \
    \  |   ^\n\nerror[E0425]: cannot find value `vehicle` in this scope\n  --> /tmp/tmpk6m6_pk8.rs:14:22\n\
    \   |\n14 |             let xa = vehicle.x;\n   |                      ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `vehicle` in this\
    \ scope\n  --> /tmp/tmpk6m6_pk8.rs:15:22\n   |\n15 |             let ya = vehicle.y;\n\
    \   |                      ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `vehicle` in this scope\n  --> /tmp/tmpk6m6_pk8.rs:16:22\n   |\n\
    16 |             let va = vehicle.v;\n   |                      ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `vehicle` in this scope\n \
    \ --> /tmp/tmpk6m6_pk8.rs:17:22\n   |\n17 |             let xb = vehicle.x + direction.x.abs();\n\
    \   |                      ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `direction` in this scope\n  --> /tmp/tmpk6m6_pk8.rs:17:34\n   |\n\
    17 |             let xb = vehicle.x + direction.x.abs();\n   |               \
    \                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `vehicle` in this scope\n  --> /tmp/tmpk6m6_pk8.rs:18:22\n   |\n\
    18 |             let yb = vehicle.y + direction.y.abs();\n   |               \
    \       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `direction`\
    \ in this scope\n  --> /tmp/tmpk6m6_pk8.rs:18:34\n   |\n18 |             let yb\
    \ = vehicle.y + direction.y.abs();\n   | "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for x in 0..n {\n        for\
    \ y in 0..n {\n            if *car_race_point(x, y) != *car_race_point(n - 1 -\
    \ x, n - 1 - y) {\n                count += 1;\n            }\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_point` in this scope\n  -->\
    \ /tmp/tmp1h19w1lj.rs:13:17\n   |\n13 |             if *car_race_point(x, y) !=\
    \ *car_race_point(n - 1 - x, n - 1 - y) {\n   |                 ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_race_point`\
    \ in this scope\n  --> /tmp/tmp1h19w1lj.rs:13:42\n   |\n13 |             if *car_race_point(x,\
    \ y) != *car_race_point(n - 1 - x, n - 1 - y) {\n   |                        \
    \                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut c = 1;\n    while\
    \ n > 0 {\n        for _ in 0..n {\n            if c&1 == 0 {\n              \
    \  c >>= 1;\n                continue;\n            }\n            collisions\
    \ += 1;\n            c <<= 1;\n        }\n        n >>= 1;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpa9yzsf7y.rs:21:9\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut n`\n...\n21 |      \
    \   n >>= 1;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    let mut\
    \ collision_count = 0;\n    let mut collision_total = 0;\n    let mut left_car_pos\
    \ = 0;\n    let mut right_car_pos = n - 1;\n\n    // While there are unfinished\
    \ collisions, check which ones intersect with the\n    // current car.\n    loop\
    \ {\n        // Find the intersections between the current car and the cars on\
    \ the left\n        let left_intersection_count = find_intersections(left_car_pos,\
    \ right_car_pos, n);\n        left_car_pos += left_intersection_count;\n\n   \
    \     // Find the intersections between the current car and the cars on the right\n\
    \        let right_intersection_count = find_intersections(left_car_pos, right_car_pos,\
    \ n);\n        right_car_pos -= right_intersection_count;\n\n        // Add up\
    \ the number of intersections found\n        collision_count += left_intersection_count\
    \ + right_intersection_count;\n        collision_total += left_car_pos + right_car_pos;\n\
    \n        // If we have found all collisions, exit the loop and return the result.\n\
    \        if left_car_pos + right_car_pos == n {\n            return collision_count;\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_intersections` in this scope\n\
    \  --> /tmp/tmp8faqj2hh.rs:23:39\n   |\n23 |         let left_intersection_count\
    \ = find_intersections(left_car_pos, right_car_pos, n);\n   |                \
    \                       ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `find_intersections` in this scope\n  --> /tmp/tmp8faqj2hh.rs:27:40\n\
    \   |\n27 |         let right_intersection_count = find_intersections(left_car_pos,\
    \ right_car_pos, n);\n   |                                        ^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    for _ in 0..n {\n      \
    \  let mut collisions = 0;\n        for _ in 0..n {\n            if !car_collision()\
    \ && !car_collision() {\n                collisions += 1;\n            }\n   \
    \     }\n        collisions += 1;\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpmungmeps.rs:14:17\n   |\n14 |             if !car_collision() && !car_collision()\
    \ {\n   |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmpmungmeps.rs:14:37\n\
    \   |\n14 |             if !car_collision() && !car_collision() {\n   |      \
    \                               ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    for _ in 0..n {\n      \
    \  let mut collisions = 1;\n        for _ in 0..n {\n            let x = rand::random::<f64>()\
    \ - 0.5;\n            let y = rand::random::<f64>() - 0.5;\n            let z\
    \ = (rand::random::<f64>() - 0.5) * 0.1;\n\n            if x ** 2 + y ** 2 < z\
    \ ** 2 {\n                collisions += 1;\n            }\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpbddgvkpu.rs:14:21\n   |\n14 |             let x = rand::random::<f64>()\
    \ - 0.5;\n   |                     ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpbddgvkpu.rs:15:21\n   |\n15 |             let y = rand::random::<f64>()\
    \ - 0.5;\n   |                     ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpbddgvkpu.rs:16:22\n   |\n16 |             let z = (rand::random::<f64>()\
    \ - 0.5) * 0.1;\n   |                      ^^^^ use of undeclared crate or module\
    \ `rand`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpbddgvkpu.rs:18:19\n\
    \   |\n18 |             if x ** 2 + y ** 2 < z ** 2 {\n   |                  \
    \ ^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpbddgvkpu.rs:18:28\n\
    \   |\n18 |             if x ** 2 + y ** 2 < z ** 2 {\n   |                  \
    \          ^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  -->\
    \ /tmp/tmpbddgvkpu.rs:18:37\n   |\n18 |             if x ** 2 + y ** 2 < z **\
    \ 2 {\n   |                                     ^^^\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome errors have detailed explanations: E0433, E0614.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).fold(1, |acc, i| {\n        acc + car_race_collision(n\
    \ - i)\n    })\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwhwc74__.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collides: usize = 0;\n    loop {\n        if\
    \ n == 0 {\n            return collides;\n        }\n        let mut car_left:\
    \ usize = 0;\n        let mut car_right: usize = 0;\n        loop {\n        \
    \    car_left += 1;\n            car_right += 1;\n            if car_left == n\
    \ && car_right == n {\n                // collision\n                car_left\
    \ = 0;\n                car_right = 0;\n                collides += 1;\n     \
    \       } else {\n                break;\n            }\n        }\n        n\
    \ -= 1;\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_pdr7nh.rs:13:20\n   |\n\
    13 |             return collides;\n   |                    ^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n13 |             return collides.try_into().unwrap();\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0_pdr7nh.rs:20:28\n   |\n20 |             if car_left ==\
    \ n && car_right == n {\n   |                            ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |             if car_left == n.try_into().unwrap()\
    \ && car_right == n {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0_pdr7nh.rs:20:46\n   |\n20 |\
    \             if car_left == n && car_right == n {\n   |                     \
    \                         ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n20 |             if car_left == n && car_right == n.try_into().unwrap()\
    \ {\n   |                                               ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The number of intersections at each point on the path\n\
    \    let mut intersections = (0..n)\n        .map(|_| {\n            let mut intersections\
    \ = vec![false; n];\n            intersections[1..n].resize(n + 1, false);\n \
    \           intersections\n        })\n        .collect();\n    intersections.iter_mut().for_each(|&mut\
    \ intersection| {\n        // Iterate through all intersections, setting the intersections\
    \ to true\n        let mut i = 1;\n        for _ in 0..n {\n            intersection[i..n].iter_mut().for_each(|&mut\
    \ bool| {\n                if bool {\n                    bool = true;\n     \
    \               i += 1;\n                }\n            });\n        }\n    });\n\
    \n    // The number of collisions over the length of the path\n    let mut collisions\
    \ = (0..n)\n        .map(|_| {\n            let mut collisions = vec![false; n];\n\
    \            collisions[1..n].resize(n + 1, false);\n            collisions\n\
    \        })\n        .collect();\n    collisions.iter_mut().for_each(|&mut collision|\
    \ {\n        // Iterate through all collisions, setting the collisions to true\n\
    \        let mut i = 1;\n        for _ in 0..n {\n            collision[i..n].iter_mut().for_each(|&mut\
    \ bool| {\n                if bool {\n                    bool = true;\n     \
    \               i += 1;\n                }\n            });\n        }\n    });\n\
    \n    intersections.iter().filter(|&i| i).count()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp40tvotwm.rs:13:49\n   |\n\
    13 |             let mut intersections = vec![false; n];\n   |               \
    \                                  ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n13 |             let mut intersections = vec![false; n.try_into().unwrap()];\n\
    \   |                                                  ++++++++++++++++++++\n\n\
    error[E0277]: the type `[bool]` cannot be indexed by `std::ops::Range<isize>`\n\
    \  --> /tmp/tmp40tvotwm.rs:14:13\n   |\n14 |             intersections[1..n].resize(n\
    \ + 1, false);\n   |             ^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `std::ops::Range<isize>`\n   = help: the following other\
    \ types implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize>\
    \ as SliceIndex<[T]>>\n             <std::ops::Range<usize> as SliceIndex<str>>\n\
    \   = note: required because of the requirements on the impl of `Index<std::ops::Range<isize>>`\
    \ for `Vec<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40tvotwm.rs:34:46\n\
    \   |\n34 |             let mut collisions = vec![false; n];\n   |           \
    \                                   ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n34 |             let mut collisions = vec![false; n.try_into().unwrap()];\n\
    \   |                                               ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmp40tvotwm.rs:35:13\n\
    \   |\n35 |             collisions[1..n].resize(n + 1, false);\n   |         \
    \    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceI"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).filter(|i| {\n        let mut collision = false;\n\
    \        let mut last_collision = -1;\n        let mut curr_collision = -1;\n\
    \        for i in (1..n).filter(|&i| {\n            collision = true;\n      \
    \      curr_collision = -1;\n            last_collision = i;\n        }) {\n \
    \           if collision {\n                collision = false;\n             \
    \   curr_collision = i;\n            }\n            if curr_collision == i {\n\
    \                collision = false;\n                curr_collision = i;\n   \
    \         }\n        }\n        collision\n    }).count()\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_w539dm.rs:14:37\n   |\n\
    14 |           for i in (1..n).filter(|&i| {\n   |  _____________________________________^\n\
    15 | |             collision = true;\n16 | |             curr_collision = -1;\n\
    17 | |             last_collision = i;\n18 | |         }) {\n   | |_________^\
    \ expected `bool`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0_w539dm.rs:10:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n10 | /\
    \     (1..n).filter(|i| {\n11 | |         let mut collision = false;\n12 | | \
    \        let mut last_collision = -1;\n13 | |         let mut curr_collision =\
    \ -1;\n...  |\n28 | |         collision\n29 | |     }).count()\n   | |______________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n29 |     }).count().try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut sum = 0;\n    let mut speed = 100.0;\n    let\
    \ mut xmin = 0.0;\n    let mut xmax = 100.0;\n    let mut ymin = 0.0;\n    let\
    \ mut ymax = 100.0;\n    for i in 0..n {\n        xmin = std::fmin(speed + xmax,\
    \ xmin);\n        ymin = std::fmin(speed + ymax, ymin);\n        xmax = std::fmax(speed\
    \ + xmin, xmax);\n        ymax = std::fmax(speed + ymin, ymax);\n        speed\
    \ += 100.0;\n        sum += 1;\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `fmin` in crate `std`\n  --> /tmp/tmp7crm7_0n.rs:17:21\n\
    \   |\n17 |         xmin = std::fmin(speed + xmax, xmin);\n   |              \
    \       ^^^^ not found in `std`\n\nerror[E0425]: cannot find function `fmin` in\
    \ crate `std`\n  --> /tmp/tmp7crm7_0n.rs:18:21\n   |\n18 |         ymin = std::fmin(speed\
    \ + ymax, ymin);\n   |                     ^^^^ not found in `std`\n\nerror[E0425]:\
    \ cannot find function `fmax` in crate `std`\n  --> /tmp/tmp7crm7_0n.rs:19:21\n\
    \   |\n19 |         xmax = std::fmax(speed + xmin, xmax);\n   |              \
    \       ^^^^ not found in `std`\n\nerror[E0425]: cannot find function `fmax` in\
    \ crate `std`\n  --> /tmp/tmp7crm7_0n.rs:20:21\n   |\n20 |         ymax = std::fmax(speed\
    \ + ymin, ymax);\n   |                     ^^^^ not found in `std`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n\n    for i in 0..n {\n    \
    \    let x = i * 1.0;\n        let right = 2.0 * x;\n        let left = -2.0 *\
    \ x;\n\n        for j in i..n {\n            let y = j * 1.0;\n            let\
    \ top = 2.0 * y;\n            let bottom = -2.0 * y;\n\n            let leftSideVec\
    \ = &left + &right;\n            let rightSideVec = &right + &left;\n\n      \
    \      let leftSideSideVec = &leftSideVec + &top + &bottom;\n            let rightSideSideVec\
    \ = &rightSideVec + &top + &bottom;\n\n            for (left, right, top, bottom)\
    \ in &[\n                &leftSideSideVec,\n                &rightSideSideVec,\n\
    \                &leftSideVec,\n                &rightSideVec,\n            ]\
    \ {\n                if left >= right || top >= bottom || left <= right || bottom\
    \ <= top {\n                    collisions += 1;\n                }\n        \
    \    }\n        }\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `isize` by `{float}`\n  --> /tmp/tmpe7335i3_.rs:13:19\n\
    \   |\n13 |         let x = i * 1.0;\n   |                   ^ no implementation\
    \ for `isize * {float}`\n   |\n   = help: the trait `Mul<{float}>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0277]: cannot multiply `isize` by `{float}`\n  --> /tmp/tmpe7335i3_.rs:18:23\n\
    \   |\n18 |             let y = j * 1.0;\n   |                       ^ no implementation\
    \ for `isize * {float}`\n   |\n   = help: the trait `Mul<{float}>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0277]: cannot add `&_` to `&(_, _, _, _)`\n  --> /tmp/tmpe7335i3_.rs:26:50\n\
    \   |\n26 |             let rightSideSideVec = &rightSideVec + &top + &bottom;\n\
    \   |                                                  ^ no implementation for\
    \ `&(_, _, _, _) + &_`\n   |\n   = help: the trait `Add<&_>` is not implemented\
    \ for `&(_, _, _, _)`\n\nerror[E0277]: cannot add `&_` to `&(_, _, _, _)`\n  -->\
    \ /tmp/tmpe7335i3_.rs:25:48\n   |\n25 |             let leftSideSideVec = &leftSideVec\
    \ + &top + &bottom;\n   |                                                ^ no\
    \ implementation for `&(_, _, _, _) + &_`\n   |\n   = help: the trait `Add<&_>`\
    \ is not implemented for `&(_, _, _, _)`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut car_speed = 1.0;\n\
    \    let mut car_width = 0.0;\n    for i in 0..n {\n        // Move left and right\
    \ to collide.\n        car_speed += -0.4;\n        car_width += 1.0;\n       \
    \ if car_speed <= 0.0 {\n            // We're no longer colliding.\n         \
    \   collisions += 1;\n            car_speed = 1.0;\n            car_width = 0.0;\n\
    \        }\n        car_speed += -0.4;\n        car_width += 1.0;\n        if\
    \ car_speed <= 0.0 {\n            // We're no longer colliding.\n            collisions\
    \ += 1;\n            car_speed = 1.0;\n            car_width = 0.0;\n        }\n\
    \        car_speed += -0.4;\n        car_width += 1.0;\n        if car_speed <=\
    \ 0.0 {\n            // We're no longer colliding.\n            collisions +=\
    \ 1;\n            car_speed = 1.0;\n            car_width = 0.0;\n        }\n\
    \        // Move right and left to collide.\n        car_speed += -0.4;\n    \
    \    car_width += 1.0;\n        if car_speed <= 0.0 {\n            // We're no\
    \ longer colliding.\n            collisions += 1;\n            car_speed = 1.0;\n\
    \            car_width = 0.0;\n        }\n        car_speed += -0.4;\n       \
    \ car_width += 1.0;\n        if car_speed <= 0.0 {\n            // We're no longer\
    \ colliding.\n            collisions += 1;\n            car_speed = 1.0;\n   \
    \         car_width = 0.0;\n        }\n        car_speed += -0.4;\n        car_width\
    \ += 1.0;\n        if car_speed <= 0.0 {\n            // We're no longer colliding.\n\
    \            collisions += 1;\n            car_speed = 1.0;\n            car_width\
    \ = 0.0;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `9`', /tmp/tmpn9ejkf96.rs:71:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let num_collisions = (0..n)\n        .enumerate()\n \
    \       .filter(|(_, index)| {\n            let right = if index % 2 == 0 {\n\
    \                let left = n - index - 1;\n                left < 0 || left ==\
    \ right || left + 1 == right\n            } else {\n                let left =\
    \ n - index;\n                left < 0 || left == right || left + 1 == right\n\
    \            };\n            right\n        })\n        .count();\n    num_collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpuured2r8.rs:15:37\n\
    \   |\n15 |                 left < 0 || left == right || left + 1 == right\n \
    \  |                                     ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpuured2r8.rs:15:58\n \
    \  |\n15 |                 left < 0 || left == right || left + 1 == right\n  \
    \ |                                                          ^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpuured2r8.rs:18:37\n\
    \   |\n18 |                 left < 0 || left == right || left + 1 == right\n \
    \  |                                     ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpuured2r8.rs:18:58\n \
    \  |\n18 |                 left < 0 || left == right || left + 1 == right\n  \
    \ |                                                          ^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuured2r8.rs:23:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n23 | \
    \    num_collisions\n   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     num_collisions.try_into().unwrap()\n   | \
    \                  ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    // For each of the n cars,\
    \ pick a random number between 0 and n-1.\n    let mut rng = thread_rng();\n \
    \   for i in 0..n {\n        let r1 = rng.gen_range(0, n as usize);\n        if\
    \ r1 < n {\n            let r2 = rng.gen_range(0, n as usize);\n            if\
    \ r2 < n && r1 != r2 {\n                collisions += 1;\n            }\n    \
    \    }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `thread_rng` in this scope\n  --> /tmp/tmpcfc6nkil.rs:12:19\n\
    \   |\n12 |     let mut rng = thread_rng();\n   |                   ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (2..=n).filter(|i| i % 2).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr6m09e5m.rs:10:24\n   |\n\
    10 |     (2..=n).filter(|i| i % 2).count() as isize\n   |                    \
    \    ^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    for _ in 0..n {\n       \
    \ for j in 0..n {\n            let mut collision_found = false;\n            for\
    \ k in 0..n {\n                if k != j {\n                    let x = i / n\
    \ * j;\n                    let y = i / n * k;\n                    let dist =\
    \ sqrt((x - i)*(x - i) + (y - i)*(y - i));\n                    if dist < i /\
    \ n {\n                        collision_found = true;\n                     \
    \   break;\n                    }\n                }\n            }\n        \
    \    if collision_found {\n                collisions += 1;\n                break;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpwz8djlfk.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     for _ in 0..n {\n   |     --- unexpected token\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmpwz8djlfk.rs:16:29\n   |\n\
    16 |                     let x = i / n * j;\n   |                            \
    \ ^ help: a local variable with a similar name exists: `j`\n\nerror[E0425]: cannot\
    \ find value `i` in this scope\n  --> /tmp/tmpwz8djlfk.rs:17:29\n   |\n17 |  \
    \                   let y = i / n * k;\n   |                             ^ help:\
    \ a local variable with a similar name exists: `j`\n\nerror[E0425]: cannot find\
    \ function `sqrt` in this scope\n  --> /tmp/tmpwz8djlfk.rs:18:32\n   |\n18 | \
    \                    let dist = sqrt((x - i)*(x - i) + (y - i)*(y - i));\n   |\
    \                                ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmpwz8djlfk.rs:18:42\n   |\n\
    18 |                     let dist = sqrt((x - i)*(x - i) + (y - i)*(y - i));\n\
    \   |                                          ^ help: a local variable with a\
    \ similar name exists: `j`\n\nerror[E0425]: cannot find value `i` in this scope\n\
    \  --> /tmp/tmpwz8djlfk.rs:18:50\n   |\n18 |                     let dist = sqrt((x\
    \ - i)*(x - i) + (y - i)*(y - i));\n   |                                     \
    \             ^ help: a local variable with a similar name exists: `j`\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmpwz8djlfk.rs:18:60\n   |\n\
    18 |                     let dist = sqrt((x - i)*(x - i) + (y - i)*(y - i));\n\
    \   |                                                            ^ help: a local\
    \ variable with a similar name exists: `j`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpwz8djlfk.rs:18:68\n   |\n18 |             \
    \        let dist = sqrt((x - i)*(x - i) + (y - i)*(y - i));\n   |           \
    \                                                         ^ help: a local variable\
    \ with a similar name exists: `j`\n\nerror[E0425]: cannot find "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n - 1) * (n - 2) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpbkaajmsg.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut last_x = 0;\n  \
    \  let mut last_y = 0;\n    let mut current_x = n;\n    let mut current_y = n;\n\
    \    let mut current_direction = 1;\n    let mut last_direction = 1;\n    while\
    \ current_x >= current_y {\n        last_x = current_x;\n        last_y = current_y;\n\
    \        last_direction = current_direction;\n        current_x = current_x +\
    \ (current_direction + last_direction) as isize;\n        current_y = current_y\
    \ + (last_direction - current_direction) as isize;\n        current_direction\
    \ = current_direction * (-1);\n        if current_x == last_x {\n            collisions\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    fn step(car_left:\
    \ isize, car_right: isize, dist: isize) -> isize {\n        if dist >= 0 && dist\
    \ < car_right {\n            return 1;\n        }\n        if dist <= 0 && dist\
    \ > car_left {\n            return 1;\n        }\n        if dist == 0 {\n   \
    \         return 0;\n        }\n        if dist < 0 {\n            if dist < car_right\
    \ {\n                return 1;\n            }\n        } else {\n            if\
    \ dist > car_left {\n                return 1;\n            }\n        }\n   \
    \     return 0;\n    }\n\n    // The first and last point in the line (distance\
    \ zero)\n    let first_point = 0;\n    let last_point = (n - 1);\n    let left_to_right\
    \ = (last_point + first_point) / 2;\n    let right_to_left = (first_point + last_point)\
    \ / 2;\n\n    // The distance to move left or right for each point in the line\n\
    \    let mut dists: Vec<isize> = Vec::with_capacity(n);\n    for i in 0..n {\n\
    \        dists.push(0);\n    }\n\n    for i in 0..n {\n        let left_collision\
    \ = step(first_point, left_to_right, (n - 1) - i);\n        let right_collision\
    \ = step(left_to_right, right_to_left, i);\n        let collision = left_collision\
    \ + right_collision;\n\n        // The collision will happen when we are moving\
    \ from the left to the right,\n        // or when we are moving from the right\
    \ to the left; we only want to\n        // count each of those collisions.\n \
    \       if i == left_to_right {\n            dists[i] += collision;\n        }\
    \ else {\n            dists[right_to_left] += collision;\n        }\n    }\n\n\
    \    dists.iter().filter(|x| *x > 0).count()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpfq9kgu4a.rs:37:22\n\
    \   |\n37 |     let last_point = (n - 1);\n   |                      ^     ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n37 -     let last_point = (n - 1);\n37 +     let last_point = n - 1;\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfq9kgu4a.rs:42:52\n  \
    \ |\n42 |     let mut dists: Vec<isize> = Vec::with_capacity(n);\n   |       \
    \                                             ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n42 |     let mut dists: Vec<isize> = Vec::with_capacity(n.try_into().unwrap());\n\
    \   |                                                     ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfq9kgu4a.rs:56:13\n\
    \   |\n56 |             dists[i] += collision;\n   |             ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfq9kgu4a.rs:58:13\n   |\n58 |  \
    \           dists[right_to_left] += collision;\n   |             ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfq9kgu4a.rs:62:34\n   |\n62 |     dists.iter().filter(|x|\
    \ *x > 0).count()\n   |                                  ^\n   |             \
    \                     |\n   |                                  expected `&isize`,\
    \ found integer\n   |                         "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n_collisions = 0.;\n    for m in 0..n {\n   \
    \     if m > 0 {\n            for i in 1..m {\n                let x_left = n\
    \ - i;\n                let x_right = m - i;\n                let y_left = car_y(&(x_left,0),\
    \ &(x_right,0));\n                let y_right = car_y(&(x_right,0), &(x_left,0));\n\
    \                let distance = y_left - y_right;\n                if distance\
    \ > 0.0 {\n                    if car_collision(&(x_left,0), &(x_right,0), &(y_left,0),\
    \ &(y_right,0)) == true {\n                        n_collisions += 1.;\n     \
    \                   break;\n                    }\n                }\n       \
    \     }\n        }\n    }\n    n_collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_y` in this scope\n  --> /tmp/tmp4ezsle7z.rs:16:30\n\
    \   |\n16 |                 let y_left = car_y(&(x_left,0), &(x_right,0));\n \
    \  |                              ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_y` in this scope\n  --> /tmp/tmp4ezsle7z.rs:17:31\n\
    \   |\n17 |                 let y_right = car_y(&(x_right,0), &(x_left,0));\n\
    \   |                               ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmp4ezsle7z.rs:20:24\n\
    \   |\n20 |                     if car_collision(&(x_left,0), &(x_right,0), &(y_left,0),\
    \ &(y_right,0)) == true {\n   |                        ^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `n_collisions`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4ezsle7z.rs:28:5\n   |\n9  | fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n28 |     n_collisions\n   |     ^^^^^^^^^^^^ expected `isize`,\
    \ found floating-point number\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    let mut cur_x = 0;\n    let\
    \ mut cur_y = 0;\n    let mut x_speed = -1.0; // current speed of moving right\n\
    \    let mut y_speed = -1.0;\n\n    // Loop through cars, counting the number\
    \ of collisions.\n    for (i, c) in (0 .. n).enumerate() {\n        let old_x\
    \ = c.x;\n        let old_y = c.y;\n        let new_x = (c.x + x_speed) % 1.0;\n\
    \        let new_y = (c.y + y_speed) % 1.0;\n\n        // New collision detected:\n\
    \        if new_x == old_x && new_y == old_y {\n            collisions += 1;\n\
    \        }\n\n        // New collision will occur:\n        x_speed = x_speed\
    \ + (new_x - old_x); // x speed\n        y_speed = y_speed + (new_y - old_y);\
    \ // y speed\n    }\n\n    return collisions;\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsy7thtpf.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     let mut cur_x = 0;\n   |     --- unexpected token\n\n\
    error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpsy7thtpf.rs:18:23\n   |\n18 |         let old_x = c.x;\n   |  \
    \                     ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpsy7thtpf.rs:19:23\n   |\n19 |         let\
    \ old_y = c.y;\n   |                       ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpsy7thtpf.rs:20:24\n  \
    \ |\n20 |         let new_x = (c.x + x_speed) % 1.0;\n   |                   \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpsy7thtpf.rs:21:24\n   |\n21 |         let new_y = (c.y\
    \ + y_speed) % 1.0;\n   |                        ^\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0610`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut counter\
    \ = 1;\n    let mut first_collision = false;\n    let mut collision_counter =\
    \ 1;\n\n    for i in 1..n {\n        for j in 1..n {\n            if i == j {\n\
    \                continue;\n            }\n            match collision_counter\
    \ {\n                1 => first_collision = true,\n                _ => {}\n \
    \           }\n            let car_collision = match first_collision {\n     \
    \           true => {\n                    collision_counter++;\n            \
    \        collision_counter;\n                    1\n                }\n      \
    \          _ => {\n                    collision_counter = 1;\n              \
    \      1\n                }\n            };\n            if car_collision > 1\
    \ && i != j {\n                counter += car_race_collision(n - i - 1);\n   \
    \         }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpyl64iwwk.rs:28:38\n\
    \   |\n28 |                     collision_counter++;\n   |                   \
    \                   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n28 |                     { let tmp = collision_counter; collision_counter\
    \ += 1; tmp };\n   |                     +++++++++++                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    28 -                     collision_counter++;\n28 +                     collision_counter\
    \ += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut car_speed = (2.0\
    \ * PI * PI) / (n + 1) as f32;\n    let mut first_collision_time = std::time::Instant::now();\n\
    \    let mut first_collision_point = Point::new(0.0, 0.0, 0.0);\n    let mut last_collision_point\
    \ = Point::new(0.0, 0.0, 0.0);\n\n    while car_speed > 0.01 {\n        let next_collision_time\
    \ = std::time::Instant::now();\n\n        let mut collision_point = Point::new(0.0,\
    \ 0.0, 0.0);\n        let mut collision_radius = 0.0\n            .sqrt()\n  \
    \          / 2.0\n            .powf(2.0 * collision_speed)\n            .exp();\n\
    \n        // move cars apart, to give them more chances to collide\n        for\
    \ _ in 0..n {\n            // move each car away from each other\n           \
    \ collision_point.x += collision_radius;\n            collision_point.y += collision_radius;\n\
    \            collision_point.z += collision_radius;\n            // only move\
    \ a small amount for stability.  This is what makes\n            // the cars go\
    \ very slowly.\n            collision_radius -= collision_speed;\n           \
    \ // if the cars overlap, replace their positions with the collision point\n \
    \           if collision_point.distance_sqr_to(first_collision_point) > collision_radius\
    \ {\n                collision_point.x = first_collision_point.x;\n          \
    \      collision_point.y = first_collision_point.y;\n                collision_point.z\
    \ = first_collision_point.z;\n            }\n        }\n\n        // record where\
    \ we started the first time we collided.\n        if collision_point.distance_sqr_to(first_collision_point)\
    \ > collision_radius {\n            first_collision_point.x = collision_point.x;\n\
    \            first_collision_point.y = collision_point.y;\n            first_collision_point.z\
    \ = collision_point.z;\n        }\n\n        // if we're colliding with the cars\
    \ that just moved, then we must have\n        // collided with the cars that just\
    \ moved again\n        if collision_point.distance_sqr_to(last_collision_point)\
    \ > collision_radius {\n            collisions += 1;\n            last_collision_point.x\
    \ = collision_point.x;\n            last_collision_point.y = collision_point.y;\n\
    \            last_collision_point.z = collision_point.z;\n        }\n\n      \
    \  // update the car speed.\n        let current_time = next_collision_time -\
    \ first_collision_time;\n        let dt_seconds = current_time.sub(*first_collision_time).unwrap();\n\
    \        car_speed -= dt_seconds * 0.1;\n        first_collision_time = next_collision_time;\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Point`\n  -->\
    \ /tmp/tmpbzq6rq7x.rs:13:37\n   |\n13 |     let mut first_collision_point = Point::new(0.0,\
    \ 0.0, 0.0);\n   |                                     ^^^^^ use of undeclared\
    \ type `Point`\n\nerror[E0433]: failed to resolve: use of undeclared type `Point`\n\
    \  --> /tmp/tmpbzq6rq7x.rs:14:36\n   |\n14 |     let mut last_collision_point\
    \ = Point::new(0.0, 0.0, 0.0);\n   |                                    ^^^^^\
    \ use of undeclared type `Point`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Point`\n  --> /tmp/tmpbzq6rq7x.rs:19:35\n   |\n19 |         let mut collision_point\
    \ = Point::new(0.0, 0.0, 0.0);\n   |                                   ^^^^^ use\
    \ of undeclared type `Point`\n\nerror[E0425]: cannot find value `PI` in this scope\n\
    \  --> /tmp/tmpbzq6rq7x.rs:11:32\n   |\n11 |     let mut car_speed = (2.0 * PI\
    \ * PI) / (n + 1) as f32;\n   |                                ^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::f32::consts::PI;\n   |\n1  | use std::f64::consts::PI;\n   |\n\nerror[E0425]:\
    \ cannot find value `PI` in this scope\n  --> /tmp/tmpbzq6rq7x.rs:11:37\n   |\n\
    11 |     let mut car_speed = (2.0 * PI * PI) / (n + 1) as f32;\n   |         \
    \                            ^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::f32::consts::PI;\n   |\n1\
    \  | use std::f64::consts::PI;\n   |\n\nerror[E0425]: cannot find value `collision_speed`\
    \ in this scope\n  --> /tmp/tmpbzq6rq7x.rs:23:25\n   |\n23 |             .powf(2.0\
    \ * collision_speed)\n   |                         ^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `collision_point`\n\nerror[E0425]: cannot\
    \ find value `collision_speed` in this scope\n  --> /tmp/tmpbzq6rq7x.rs:34:33\n\
    \   |\n34 |             collision_radius -= collision_speed;\n   |           \
    \                      ^^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `collision_point`\n\nerror[E0689]: can't call method `sqrt` on ambiguous\
    \ numeric type `{float}`\n  --> /t"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..n).rfold(0, |acc, _| {\n        let mut collisions\
    \ = acc;\n        for j in (isize::MAX + 1).step_by(n) {\n            collisions\
    \ += car_collision(j, acc);\n        }\n        collisions\n    })\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmp_khf17_z.rs:13:27\n   |\n13 |             collisions += car_collision(j,\
    \ acc);\n   |                           ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: `isize` is not an iterator\n  --> /tmp/tmp_khf17_z.rs:12:35\n\
    \   |\n12 |         for j in (isize::MAX + 1).step_by(n) {\n   |             \
    \                      ^^^^^^^ `isize` is not an iterator\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `isize: Iterator`\n \
    \          which is required by `&mut isize: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter: usize = 0;\n    let mut first_collision\
    \ = false;\n    fn one_collision(x: f64, y: f64, i: isize) -> bool {\n       \
    \ let dx = (x - x_origin[i]).abs();\n        let dy = (y - y_origin[i]).abs();\n\
    \        if (dx < 2.0 * pi || dy < 2.0 * pi) {\n            counter++;\n     \
    \       return true;\n        }\n        false\n    }\n    for i in 0..n {\n \
    \       fn next_position(x: f64, y: f64, i: isize) -> f64 {\n            (x +\
    \ x_velocity[i]).sqrt()\n                * (2.0 * pi)\n                / x_frequency\n\
    \                + y_velocity[i]\n        }\n        if (i > 0) {\n          \
    \  if !(one_collision(x_origin[i], y_origin[i], i)) {\n                counter\
    \ += 1;\n                first_collision = true;\n            }\n        }\n \
    \       if !(first_collision && one_collision(x_origin[i], y_origin[i], n)) {\n\
    \            let dx = x_origin[i] - x_origin[n];\n            let dy = y_origin[i]\
    \ - y_origin[n];\n            if ((dx * dx + dy * dy) < 1.0 * pi) {\n        \
    \        counter += 1;\n                first_collision = true;\n            }\n\
    \        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpaa_y06zv.rs:16:20\n\
    \   |\n16 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    16 -             counter++;\n16 +             counter += 1;\n   | \n\nerror[E0425]:\
    \ cannot find value `x_origin` in this scope\n  --> /tmp/tmpaa_y06zv.rs:13:23\n\
    \   |\n13 |         let dx = (x - x_origin[i]).abs();\n   |                  \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `y_origin`\
    \ in this scope\n  --> /tmp/tmpaa_y06zv.rs:14:23\n   |\n14 |         let dy =\
    \ (y - y_origin[i]).abs();\n   |                       ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `pi` in this scope\n  --> /tmp/tmpaa_y06zv.rs:15:24\n\
    \   |\n15 |         if (dx < 2.0 * pi || dy < 2.0 * pi) {\n   |              \
    \          ^^ help: a local variable with a similar name exists: `i`\n\nerror[E0425]:\
    \ cannot find value `pi` in this scope\n  --> /tmp/tmpaa_y06zv.rs:15:41\n   |\n\
    15 |         if (dx < 2.0 * pi || dy < 2.0 * pi) {\n   |                     \
    \                    ^^ help: a local variable with a similar name exists: `i`\n\
    \nerror[E0425]: cannot find value `x_velocity` in this scope\n  --> /tmp/tmpaa_y06zv.rs:23:18\n\
    \   |\n23 |             (x + x_velocity[i]).sqrt()\n   |                  ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `pi` in this scope\n\
    \  --> /tmp/tmpaa_y06zv.rs:24:26\n   |\n24 |                 * (2.0 * pi)\n  \
    \ |                          ^^ help: a local variable with a similar name exists:\
    \ `i`\n\nerror[E0425]: cannot find value `x_frequency` in this scope\n  --> /tmp/tmpaa_y06zv.rs:25:19\n\
    \   |\n25 |                 / x_frequency\n   |                   ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `y_velocity` in this\
    \ scope\n  --> /tmp/tmpaa_y06zv.rs:26:19\n   |\n26 |                 + y_velocity[i]\n\
    \   |                   ^^^^^^^^^^ not found in this scop"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 2 || n == 3 {\n        return 1;\n    }\n   \
    \ if n < 5 {\n        return n * car_race_collision(n - 1);\n    }\n    car_race_collision(n\
    \ - 5) + car_race_collision(n - 4);\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmuku3wm.rs:9:36\n   |\n\
    9  | fn car_race_collision(n: isize) -> isize {\n   |    ------------------  \
    \            ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n16 |     car_race_collision(n\
    \ - 5) + car_race_collision(n - 4);\n   |                                    \
    \                      - help: remove this semicolon\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n\n    for _ in 0..n {\n\
    \        for j in (0..n).rev() {\n            if i != j && car_collision(i, j,\
    \ &mut collisions) {\n                collisions += 1;\n            }\n      \
    \  }\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmppfk42ak9.rs:14:16\n\
    \   |\n14 |             if i != j && car_collision(i, j, &mut collisions) {\n\
    \   |                ^ help: a local variable with a similar name exists: `j`\n\
    \nerror[E0425]: cannot find function `car_collision` in this scope\n  --> /tmp/tmppfk42ak9.rs:14:26\n\
    \   |\n14 |             if i != j && car_collision(i, j, &mut collisions) {\n\
    \   |                          ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmppfk42ak9.rs:14:40\n   |\n\
    14 |             if i != j && car_collision(i, j, &mut collisions) {\n   |   \
    \                                     ^ help: a local variable with a similar\
    \ name exists: `j`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).fold(0, |i, _| {\n        (0..i).fold(0, |j, _|\
    \ {\n            let speed = (1..n).min(i + j + 1).min(i / (i + 1) + j / (j +\
    \ 1));\n            let v = (speed*speed).min(speed / speed);\n            let\
    \ a = speed*(i + j + 1);\n            let b = speed*(i + j);\n            if v*v\
    \ > a*b {\n                (i, j) + i\n            } else {\n                (i,\
    \ j) + j\n            }\n        })\n    })\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp1_a8vah2.rs:12:32\n     |\n12   |             let speed = (1..n).min(i\
    \ + j + 1).min(i / (i + 1) + j / (j + 1));\n     |                           \
    \     ^^^ --------- supplied 1 argument\n     |                              \
    \  |\n     |                                expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1_a8vah2.rs:12:51\n\
    \   |\n12 |             let speed = (1..n).min(i + j + 1).min(i / (i + 1) + j\
    \ / (j + 1));\n   |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n12 |             let speed = (1..n).min(i + j + 1).min(Some(i / (i + 1)\
    \ + j / (j + 1)));\n   |                                                   +++++\
    \                         +\n\nerror[E0369]: cannot multiply `Option<isize>` by\
    \ `Option<isize>`\n  --> /tmp/tmp1_a8vah2.rs:13:27\n   |\n13 |             let\
    \ v = (speed*speed).min(speed / speed);\n   |                      -----^-----\
    \ Option<isize>\n   |                      |\n   |                      Option<isize>\n\
    \nerror[E0369]: cannot divide `Option<isize>` by `Option<isize>`\n  --> /tmp/tmp1_a8vah2.rs:13:45\n\
    \   |\n13 |             let v = (speed*speed).min(speed / speed);\n   |      \
    \                                 ----- ^ ----- Option<isize>\n   |          \
    \                             |\n   |                                       Option<isize>\n\
    \nerror[E0369]: cannot multiply `Option<isize>` by `isize`\n  --> /tmp/tmp1_a8vah2.rs:14:26\n\
    \   |\n14 |             let a = speed*(i + j + 1);\n   |                     -----^-----------\
    \ isize\n   |                     |\n   |                     Option<isize>\n\n\
    error[E0369]: cannot multiply `Option<isize>` by `isize`\n  --> /tmp/tmp1_a8vah2.rs:15:26\n\
    \   |\n15 |             let b = speed*(i + j);\n   |                     -----^-------\
    \ isize\n   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // write your code here\n    if n < 2 {\n        return\
    \ 0;\n    }\n    let mut car_1 = vec![2 * (n - 1)..2 * n];\n    let mut car_2\
    \ = vec![0 .. 2 * n - 1];\n    let mut collision = 0;\n    for j in 0 .. n {\n\
    \        for (i, v) in car_1.iter().enumerate() {\n            let collision_v\
    \ = car_2.iter_mut().filter(|&b| b <= v).count();\n            if collision_v\
    \ != 0 {\n                collision += 1;\n                let mut index = i *\
    \ (2 * n - 1) + j;\n                car_2[index] = v;\n                car_1[index]\
    \ = v;\n            }\n        }\n        for (i, v) in car_2.iter().enumerate()\
    \ {\n            let collision_v = car_1.iter_mut().filter(|&b| b <= v).count();\n\
    \            if collision_v != 0 {\n                collision += 1;\n        \
    \        let mut index = i * (2 * n - 1) + j;\n                car_1[index] =\
    \ v;\n                car_2[index] = v;\n            }\n        }\n    }\n   \
    \ collision\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3uz_t5tg.rs:19:65\n   |\n\
    19 |             let collision_v = car_2.iter_mut().filter(|&b| b <= v).count();\n\
    \   |                                                                 ^ types\
    \ differ in mutability\n   |\n   = note: expected mutable reference `&mut _`\n\
    \                      found reference `&std::ops::Range<isize>`\n\nerror[E0369]:\
    \ binary operation `<=` cannot be applied to type `&mut std::ops::Range<isize>`\n\
    \  --> /tmp/tmp3uz_t5tg.rs:19:62\n   |\n19 |             let collision_v = car_2.iter_mut().filter(|&b|\
    \ b <= v).count();\n   |                                                     \
    \       - ^^ - &mut _\n   |                                                  \
    \          |\n   |                                                           \
    \ &mut std::ops::Range<isize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3uz_t5tg.rs:22:37\n\
    \   |\n22 |                 let mut index = i * (2 * n - 1) + j;\n   |       \
    \                              ^^^^^^^^^^^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot multiply `usize` by `isize`\n  --> /tmp/tmp3uz_t5tg.rs:22:35\n\
    \   |\n22 |                 let mut index = i * (2 * n - 1) + j;\n   |       \
    \                            ^ no implementation for `usize * isize`\n   |\n \
    \  = help: the trait `Mul<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Mul<Rhs>`:\n             <&'a f32 as\
    \ Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n\
    \             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n    \
    \         <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n          \
    \   <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3uz_t5tg.rs:22:51\n   |\n22 |                 let mut index\
    \ = i * (2 * n - 1) + j;\n   |                                               \
    \    ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to\
    \ `usize`\n  --> /tmp/tmp3uz_t5tg.rs:22:49\n   |\n22 |                 let mut\
    \ index = i * (2 * n - 1) + j;\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    use crate::geometry::{Point, Rect};\n    use crate::geometry::{Point,\
    \ Vec2};\n    use std::cmp::min;\n\n    // Start with the number of cars we already\
    \ have colliding.\n    let mut colliding_cars = n;\n    // Start with a set of\
    \ all cars moving left.\n    let mut colliding_set: Vec2<isize> = (0..n).collect();\n\
    \    // Move the cars left to right, one at a time, until the cars collide.\n\
    \    for (i, left_car) in colliding_set.iter_mut().enumerate() {\n        // The\
    \ right car moves one space to the right.\n        left_car += 1;\n        //\
    \ We have found a collision, if our movement left and right is equal we found\
    \ a collision.\n        if left_car == colliding_set[min(i, n - 1)] {\n      \
    \      colliding_cars += 1;\n            // Remove the collision.\n          \
    \  colliding_set[i] = n - 1;\n            // Move the car to the other side.\n\
    \            colliding_set[n - 1] = left_car;\n        }\n    }\n    colliding_cars\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `crate::geometry`\n  --> /tmp/tmp5pwn6jzi.rs:10:16\n\
    \   |\n10 |     use crate::geometry::{Point, Rect};\n   |                ^^^^^^^^\
    \ maybe a missing crate `geometry`?\n\nerror[E0432]: unresolved import `crate::geometry`\n\
    \  --> /tmp/tmp5pwn6jzi.rs:11:16\n   |\n11 |     use crate::geometry::{Point,\
    \ Vec2};\n   |                ^^^^^^^^ maybe a missing crate `geometry`?\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let max_speed = n /\
    \ 2;\n\n    for speed in 0..n {\n        let speed = speed * max_speed;\n    \
    \    for direction in Directions::all() {\n            let dir = direction.to_vec();\n\
    \            let dir = dir.normalize();\n\n            let v1 = dir * speed +\
    \ Vec::new();\n            let v2 = dir * speed + Vec::new();\n            v1.normalize();\n\
    \            v2.normalize();\n            let collision = cross(v2, v1).is_zero();\n\
    \            if !collision {\n                collision_count++;\n           \
    \ }\n        }\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp4yzdf05p.rs:25:32\n\
    \   |\n25 |                 collision_count++;\n   |                         \
    \       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    25 |                 { let tmp = collision_count; collision_count += 1; tmp };\n\
    \   |                 +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    25 -                 collision_count++;\n25 +                 collision_count\
    \ += 1;\n   | \n\nerror[E0433]: failed to resolve: use of undeclared type `Directions`\n\
    \  --> /tmp/tmp4yzdf05p.rs:15:26\n   |\n15 |         for direction in Directions::all()\
    \ {\n   |                          ^^^^^^^^^^ use of undeclared type `Directions`\n\
    \nerror[E0425]: cannot find function `cross` in this scope\n  --> /tmp/tmp4yzdf05p.rs:23:29\n\
    \   |\n23 |             let collision = cross(v2, v1).is_zero();\n   |       \
    \                      ^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // # of collisions\n    // The\
    \ line that defines the \"race\" is infinitely long (hence the infinite loop)\n\
    \    let mut race = vec![]; // The line that defines the \"race\"\n    let mut\
    \ speed = vec![]; // The speed of each car\n    let mut movement_counter = vec![];\
    \ // Counter for number of moves\n    // The first car starts at the left side\n\
    \    race.push(vec![-1.0, 0.0]);\n    speed.push(1.0);\n    movement_counter.push(0);\n\
    \    // For each car in the race...\n    for _ in 0..n {\n        // Compute the\
    \ collision -- do NOT move the car!  Instead, compute where the\n        // car\
    \ should be next time based on its current speed and movement counter.\n     \
    \   let next_move = race[movement_counter.len() - 1] + speed[movement_counter.len()\
    \ - 1];\n        // The collision condition is: If the car is moving right to\
    \ left and collides with\n        // the left edge of the line, then it moves\
    \ right to left (move in the opposite\n        // direction).\n        if race[movement_counter.len()\
    \ - 1] < 0.0 && race[movement_counter.len() - 1] > -100.0 {\n            collisions\
    \ += 1;\n            race[movement_counter.len() - 1] = next_move;\n        }\
    \ else {\n            race[movement_counter.len() - 1] = next_move;\n        }\n\
    \        // Increment the movement counter\n        movement_counter.push(movement_counter.len()\
    \ - 1);\n    }\n    return collisions;\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{float}` to `Vec<{float}>`\n  --> /tmp/tmp2lpnd539.rs:23:58\n\
    \   |\n23 |         let next_move = race[movement_counter.len() - 1] + speed[movement_counter.len()\
    \ - 1];\n   |                         -------------------------------- ^ ---------------------------------\
    \ {float}\n   |                         |\n   |                         Vec<{float}>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2lpnd539.rs:27:47\n   |\n27 |\
    \         if race[movement_counter.len() - 1] < 0.0 && race[movement_counter.len()\
    \ - 1] > -100.0 {\n   |                                               ^^^ expected\
    \ struct `Vec`, found floating-point number\n   |\n   = note: expected struct\
    \ `Vec<{float}>`\n                found type `{float}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2lpnd539.rs:27:89\n   |\n27 |         if race[movement_counter.len()\
    \ - 1] < 0.0 && race[movement_counter.len() - 1] > -100.0 {\n   |            \
    \                                                                            \
    \ ^^^^^^ expected struct `Vec`, found floating-point number\n   |\n   = note:\
    \ expected struct `Vec<{float}>`\n                found type `{float}`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n = 0;\n    let mut collisions = 0;\n    let\
    \ mut speed = 1;\n    let mut position = 1;\n    let mut speeds = vec![position];\n\
    \    let mut positions = vec![position];\n    let mut speeds_copy = speeds;\n\
    \    let mut positions_copy = positions;\n    for i in 0..n {\n        for j in\
    \ 0..n {\n            let mut collision = true;\n            while collision {\n\
    \                if position == positions[speeds_copy.len() - 1] {\n         \
    \           collision = false;\n                }\n                position +=\
    \ speed * j;\n                speed = speed * 2;\n                if speed ==\
    \ speed {\n                    speeds.push(position);\n                    positions.push(position);\n\
    \                    speeds_copy = speeds;\n                    positions_copy\
    \ = positions;\n                }\n            }\n        }\n        collisions\
    \ += 1;\n        speed = 1;\n        position += 1\n    }\n    collisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "warning: variable `positions_copy` is assigned to, but never used\n  -->\
    \ /tmp/tmpjj1zz27y.rs:17:13\n   |\n17 |     let mut positions_copy = positions;\n\
    \   |             ^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_positions_copy` instead\n\nwarning:\
    \ unused variable: `i`\n  --> /tmp/tmpjj1zz27y.rs:18:9\n   |\n18 |     for i in\
    \ 0..n {\n   |         ^ help: if this is intentional, prefix it with an underscore:\
    \ `_i`\n\nwarning: value assigned to `positions_copy` is never read\n  --> /tmp/tmpjj1zz27y.rs:31:21\n\
    \   |\n31 |                     positions_copy = positions;\n   |            \
    \         ^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: unused\
    \ variable: `n`\n --> /tmp/tmpjj1zz27y.rs:9:23\n  |\n9 | fn car_race_collision(n:\
    \ isize) -> isize {\n  |                       ^ help: if this is intentional,\
    \ prefix it with an underscore: `_n`\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmpjj1zz27y.rs:10:9\n   |\n10 |     let mut n = 0;\n   |\
    \         ----^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `positions`\n  --> /tmp/tmpjj1zz27y.rs:22:32\n   |\n15 |     let mut\
    \ positions = vec![position];\n   |         ------------- move occurs because\
    \ `positions` has type `Vec<i32>`, which does not implement the `Copy` trait\n\
    16 |     let mut speeds_copy = speeds;\n17 |     let mut positions_copy = positions;\n\
    \   |                              --------- value moved here\n...\n22 |     \
    \            if position == positions[speeds_copy.len() - 1] {\n   |         \
    \                       ^^^^^^^^^ value borrowed here after move\n\nerror[E0382]:\
    \ borrow of moved value: `speeds`\n  --> /tmp/tmpjj1zz27y.rs:28:21\n   |\n14 |\
    \     let mut speeds = vec![position];\n   |         ---------- move occurs because\
    \ `speeds` has type `Vec<i32>`, which does not implement the `Copy` trait\n15\
    \ |     let mut positions = vec![position];\n16 |     l"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    debug_assert!(n == 1);\n    let mut collision_count =\
    \ 0;\n    let mut start = vec![];\n    let mut end = vec![];\n    for (index,\
    \ dir) in 0..(n-1).iter().enumerate() {\n        start.push(vec![dir]);\n    \
    \    end.push(vec![dir]);\n    }\n    let start = start.iter().cloned().collect::<Vec<_>>();\n\
    \    let end = end.iter().cloned().collect::<Vec<_>>();\n    for (index, dir)\
    \ in 0..(n-1).iter().enumerate() {\n        let mut collision = false;\n     \
    \   for (car_dir, _) in start.iter().enumerate() {\n            if dir == car_dir\
    \ {\n                collision = true;\n                break;\n            }\n\
    \        }\n        if collision {\n            for (other_dir, _) in end.iter().enumerate()\
    \ {\n                if dir == other_dir {\n                    collision = true;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if !collision {\n            collision_count += 1;\n        }\n    }\n \
    \   collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmprojo81ul.rs:14:34\n   |\n14 |     for (index, dir) in 0..(n-1).iter().enumerate()\
    \ {\n   |                                  ^^^^ method not found in `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprojo81ul.rs:14:9\n   |\n14 |   \
    \  for (index, dir) in 0..(n-1).iter().enumerate() {\n   |         ^^^^^^^^^^^^\
    \    --------------------------- this expression has type `Option<{integer}>`\n\
    \   |         |\n   |         expected integer, found tuple\n   |\n   = note:\
    \ expected type `{integer}`\n             found tuple `(_, _)`\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmprojo81ul.rs:20:34\n\
    \   |\n20 |     for (index, dir) in 0..(n-1).iter().enumerate() {\n   |      \
    \                            ^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprojo81ul.rs:20:9\n   |\n20 |     for (index,\
    \ dir) in 0..(n-1).iter().enumerate() {\n   |         ^^^^^^^^^^^^    ---------------------------\
    \ this expression has type `Option<{integer}>`\n   |         |\n   |         expected\
    \ integer, found tuple\n   |\n   = note: expected type `{integer}`\n         \
    \    found tuple `(_, _)`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for i in 0..n {\n\
    \        // the cars in this group are all equally likely to move\n        //\
    \ left to right, so let's start by ensuring that they are all\n        // close\
    \ enough to start in that position\n        let mut pos = Vec::new();\n      \
    \  for _ in 0..i {\n            pos.push(0);\n        }\n        pos.push(0);\n\
    \        // Now let's find the distance from each other car to the\n        //\
    \ current position.  To do that, we're going to find the\n        // distance\
    \ from the current position to the next point\n        // the car is currently\
    \ at.\n        for j in (i + 1)..n {\n            let curr_to_curr_dist = pos[j]\
    \ - pos[i];\n            if curr_to_curr_dist > CAR_RADIUS {\n               \
    \ collisions += 1;\n            }\n        }\n        pos.push(0);\n    }\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `CAR_RADIUS` in this scope\n  --> /tmp/tmpk1wkm27a.rs:26:36\n\
    \   |\n26 |             if curr_to_curr_dist > CAR_RADIUS {\n   |            \
    \                        ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpk1wkm27a.rs:25:37\n\
    \   |\n25 |             let curr_to_curr_dist = pos[j] - pos[i];\n   |       \
    \                              ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpk1wkm27a.rs:25:46\n   |\n25 |             let curr_to_curr_dist\
    \ = pos[j] - pos[i];\n   |                                              ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for _ in range(n -\
    \ 1) {\n        // Generate all possible pairs of cars colliding.\n        for\
    \ car1 in (0..n).step_by(2) {\n            for car2 in car1.step_by(2) {\n   \
    \             let mut race_direction = car1.right_car.right_car.right_car.right_car;\n\
    \                let mut current_speed = car1.right_car.right_car.right_car.right_car;\n\
    \                if car1 != car2 {\n                    race_direction = car1.right_car.right_car;\n\
    \                    current_speed = car1.right_car.right_car;\n             \
    \   }\n                // This conditional is needed to prevent a car\n      \
    \          // from repeatedly moving too fast.\n                if current_speed\
    \ == car1.right_car.right_car.right_car.right_car\n                    || current_speed\
    \ == car1.right_car.right_car.right_car\n                || current_speed == car1.right_car.right_car.right_car\n\
    \                    || current_speed == car1.right_car.right_car.right_car\n\
    \                || current_speed == car1.right_car.right_car.right_car\n    \
    \                || current_speed == car1.right_car.right_car.right_car\n    \
    \            || current_speed == car1.right_car.right_car.right_car\n        \
    \            || current_speed == car1.right_car.right_car.right_car\n        \
    \        || current_speed == car1.right_car.right_car.right_car\n            \
    \        || current_speed == car1.right_car.right_car.right_car\n            \
    \    || current_speed == car1.right_car.right_car.right_car\n                ||\
    \ current_speed == car1.right_car.right_car.right_car\n                    ||\
    \ current_speed == car1.right_car.right_car.right_car\n                || current_speed\
    \ == car1.right_car.right_car.right_car\n                || current_speed == car1.right_car.right_car.right_car\n\
    \                    || current_speed == car1.right_car.right_car.right_car\n\
    \                || current_speed == car1.right_car.right_car.right_car\n    \
    \                || current_speed == car1.right_car.right_car.right_car\n    \
    \            || current_speed == car1.right_car.right_car.right_car\n        \
    \        || current_speed == car1.right_car.right_car.right_car\n            \
    \        || current_speed == car1.right_car.right_car.right_car\n            \
    \    || current_speed == car1.right_car.right_car.right_car\n                \
    \    || current_speed == car1.right_car.right_car.right_car\n\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppt8jmkwv.rs:56:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n10 |     let mut collision_count\
    \ = 0;\n11 |     for _ in range(n - 1) {\n   |                           - unclosed\
    \ delimiter\n12 |         // Generate all possible pairs of cars colliding.\n\
    13 |         for car1 in (0..n).step_by(2) {\n   |                           \
    \            - unclosed delimiter\n14 |             for car2 in car1.step_by(2)\
    \ {\n   |                                         - this delimiter might not be\
    \ properly closed...\n...\n47 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n56 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  -->\
    \ /tmp/tmppt8jmkwv.rs:47:1\n   |\n23 |                 if current_speed == car1.right_car.right_car.right_car.right_car\n\
    \   |                 -- this `if` expression has a condition, but no block\n\
    ...\n47 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot find function `range`\
    \ in this scope\n  --> /tmp/tmppt8jmkwv.rs:11:14\n   |\n11 |     for _ in range(n\
    \ - 1) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0599]:\
    \ `isize` is not an iterator\n  --> /tmp/tmppt8jmkwv.rs:14:30\n   |\n14 |    \
    \         for car2 in car1.step_by(2) {\n   |                              ^^^^^^^\
    \ `isize` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `isize: Iterator`\n           which is required by\
    \ `&mut isize: Iterator`\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmppt8jmkwv.rs:15:47\n   |\n15 |           \
    \      let mut race_direction = car1.right_car.right_car.right_car.right_car;\n\
    \   |                                               ^^^^^^^^^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmppt8jmkwv.rs:16:46\n\
    \   |\n16 |                 let mut current_speed = car1.right_car.right_car.right_car"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: For this problem, you may assume that n cars\
    \ are being inserted into a binary search tree of n elements.\n    // You don't\
    \ have to do this.  You can use any data structure to keep track of the cars being\
    \ inserted.\n\n    // TODO: When you've finished the function declaration, move\
    \ down to the code section labeled \"// TODO: For this problem, you may assume\
    \ that n cars are being inserted into a binary search tree of n elements.\" and\
    \ insert your solution to Problem 1.\n\n    let mut collisions = 0\n\n    for\
    \ i in 0..n {\n        let mut collision_counter = 0\n        let mut collision_end_index\
    \ = 0\n        let mut collision_end_point = 0\n\n        let mut left_index =\
    \ i\n        let mut right_index = left_index\n        let mut left_point = CarCoords::new(0,\
    \ 0)\n        let mut right_point = CarCoords::new(0, -10.0)\n\n        loop {\n\
    \            collision_counter += collision_helper(left_index, right_index, left_point,\
    \ right_point,\n                                                &collisions, &collision_end_index,\
    \ &collision_end_point);\n            if collision_counter > 0 {\n           \
    \     let left_index = left_index - 1;\n                let right_index = right_index\
    \ + 1;\n                left_point = CarCoords::new(0, -10.0);\n             \
    \   right_point = CarCoords::new(0, -10.0);\n                collision_counter\
    \ += collision_helper(left_index, right_index, left_point, right_point,\n    \
    \                                                &collisions, &collision_end_index,\
    \ &collision_end_point);\n            }\n            if collision_counter == 0\
    \ && left_index == 0 {\n                collision_end_index = i;\n           \
    \     collision_end_point = left_point;\n            }\n            if collision_counter\
    \ == 0 && right_index == n {\n                collision_end_index = i;\n     \
    \           collision_end_point = right_point;\n            }\n            if\
    \ collision_counter > 0 {\n                break;\n            }\n        }\n\n\
    \    }\n\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpsg41qsbu.rs:15:27\n\
    \   |\n15 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n16 | \n17 |     for i in 0..n {\n   |     --- unexpected token\n\
    \nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsg41qsbu.rs:18:38\n\
    \   |\n18 |         let mut collision_counter = 0\n   |                      \
    \                ^ help: add `;` here\n19 |         let mut collision_end_index\
    \ = 0\n   |         --- unexpected token\n\nerror: expected `;`, found keyword\
    \ `let`\n  --> /tmp/tmpsg41qsbu.rs:19:40\n   |\n19 |         let mut collision_end_index\
    \ = 0\n   |                                        ^ help: add `;` here\n20 |\
    \         let mut collision_end_point = 0\n   |         --- unexpected token\n\
    \nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsg41qsbu.rs:20:40\n\
    \   |\n20 |         let mut collision_end_point = 0\n   |                    \
    \                    ^ help: add `;` here\n21 | \n22 |         let mut left_index\
    \ = i\n   |         --- unexpected token\n\nerror: expected `;`, found keyword\
    \ `let`\n  --> /tmp/tmpsg41qsbu.rs:22:31\n   |\n22 |         let mut left_index\
    \ = i\n   |                               ^ help: add `;` here\n23 |         let\
    \ mut right_index = left_index\n   |         --- unexpected token\n\nerror: expected\
    \ `;`, found keyword `let`\n  --> /tmp/tmpsg41qsbu.rs:23:41\n   |\n23 |      \
    \   let mut right_index = left_index\n   |                                   \
    \      ^ help: add `;` here\n24 |         let mut left_point = CarCoords::new(0,\
    \ 0)\n   |         --- unexpected token\n\nerror: expected `;`, found keyword\
    \ `let`\n  --> /tmp/tmpsg41qsbu.rs:24:50\n   |\n24 |         let mut left_point\
    \ = CarCoords::new(0, 0)\n   |                                               \
    \   ^ help: add `;` here\n25 |         let mut right_point = CarCoords::new(0,\
    \ -10.0)\n   |         --- unexpected token\n\nerror: expected `;`, found keyword\
    \ `loop`\n  --> /tmp/tmpsg41qsbu.rs:25:55\n   |\n25 |         let mut right_point\
    \ = CarCoords::new(0, -10.0)\n   |                                           \
    \       "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = Vec::new();\n    for _ in 0..n {\n\
    \        collisions.push(0);\n    }\n    let mut max_v = Vec::new();\n    let\
    \ mut min_v = Vec::new();\n    for (j, c) in collisions.iter().enumerate() {\n\
    \        for (_, c2) in collisions.iter().enumerate() {\n            if c == c2\
    \ {\n                collisions[j] += 1;\n                if max_v[j] < min_v[j]\
    \ {\n                    max_v[j] = c;\n                }\n                if\
    \ min_v[j] > max_v[j] {\n                    min_v[j] = c;\n                }\n\
    \            }\n        }\n    }\n    for (i, c) in collisions.iter().enumerate()\
    \ {\n        if c != 0 {\n            collisions[i] -= 1;\n        }\n    }\n\
    \    collisions.iter().filter_map(|e| e > 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&{integer}` with `{integer}`\n  --> /tmp/tmps2n3v252.rs:30:14\n\
    \   |\n30 |         if c != 0 {\n   |              ^^ no implementation for `&{integer}\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2n3v252.rs:34:42\n\
    \   |\n34 |     collisions.iter().filter_map(|e| e > 0).count()\n   |        \
    \                                  ^\n   |                                   \
    \       |\n   |                                          expected reference, found\
    \ integer\n   |                                          help: consider borrowing\
    \ here: `&0`\n   |\n   = note: expected reference `&_`\n                   found\
    \ type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2n3v252.rs:34:38\n\
    \   |\n34 |     collisions.iter().filter_map(|e| e > 0).count()\n   |        \
    \                              ^^^^^ expected enum `Option`, found `bool`\n  \
    \ |\n   = note: expected enum `Option<_>`\n              found type `bool`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n34 |     collisions.iter().filter_map(|e|\
    \ Some(e > 0)).count()\n   |                                      +++++     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps2n3v252.rs:34:5\n   |\n9  | fn\
    \ car_race_collision(n: isize) -> isize {\n   |                              \
    \      ----- expected `isize` because of return type\n...\n34 |     collisions.iter().filter_map(|e|\
    \ e > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n34 |     collisions.iter().filter_map(|e|\
    \ e > 0).count().try_into().unwrap()\n   |                                   \
    \                 ++++++++++++++++++++\n\nerror: aborting "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for _ in 0..n {\n      \
    \  let mut collision_counter = 0;\n        for _ in 0..n {\n            if !in_collision(\n\
    \                &mut collision_counter,\n                &mut collisions,\n \
    \               &[\n                    (n - 1, n - 1),\n                    (1,\
    \ n - 1),\n                    (n - 1, 1),\n                    (1, 1),\n    \
    \            ],\n            ) {\n                collisions += 1;\n         \
    \   }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `in_collision` in this scope\n  -->\
    \ /tmp/tmpwbaxue97.rs:14:17\n   |\n14 |             if !in_collision(\n   |  \
    \               ^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `collisions`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut cur_car = car::leftmost();\n    let mut cur_direction = car::leftmost();\n\
    \    loop {\n        for car in car::rightmost_until(car.next()) {\n         \
    \   if car_collides(&cur_car, &car) {\n                count += 1;\n         \
    \   }\n            let direction = car_direction(&cur_car, &car);\n          \
    \  if direction != cur_direction {\n                cur_direction = direction;\n\
    \            }\n        }\n        if cur_car.next() == car::none {\n        \
    \    break;\n        }\n        cur_car = car::rightmost();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `car`\n\
    \  --> /tmp/tmplrd9aqk5.rs:14:23\n   |\n14 |     let mut cur_car = car::leftmost();\n\
    \   |                       ^^^ use of undeclared crate or module `car`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `car`\n  --> /tmp/tmplrd9aqk5.rs:15:29\n\
    \   |\n15 |     let mut cur_direction = car::leftmost();\n   |               \
    \              ^^^ use of undeclared crate or module `car`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `car`\n  --> /tmp/tmplrd9aqk5.rs:17:20\n\
    \   |\n17 |         for car in car::rightmost_until(car.next()) {\n   |      \
    \              ^^^ use of undeclared crate or module `car`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `car`\n  --> /tmp/tmplrd9aqk5.rs:26:30\n\
    \   |\n26 |         if cur_car.next() == car::none {\n   |                   \
    \           ^^^ use of undeclared crate or module `car`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `car`\n  --> /tmp/tmplrd9aqk5.rs:29:19\n\
    \   |\n29 |         cur_car = car::rightmost();\n   |                   ^^^ use\
    \ of undeclared crate or module `car`\n\nerror[E0425]: cannot find value `car`\
    \ in this scope\n  --> /tmp/tmplrd9aqk5.rs:17:41\n   |\n17 |         for car in\
    \ car::rightmost_until(car.next()) {\n   |                                   \
    \      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `car_collides`\
    \ in this scope\n  --> /tmp/tmplrd9aqk5.rs:18:16\n   |\n18 |             if car_collides(&cur_car,\
    \ &car) {\n   |                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_direction` in this scope\n  --> /tmp/tmplrd9aqk5.rs:21:29\n\
    \   |\n21 |             let direction = car_direction(&cur_car, &car);\n   | \
    \                            ^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `cur_direction`\n\nerror: aborting due to 8 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Set up the collision matrix\n    let mut collisions:\
    \ Vec<Vec<bool>> = Vec::new();\n    for i in 0..n {\n        collisions.push(vec![false;\
    \ n]);\n    }\n\n    // Set up the distance matrix\n    let mut dist: Vec<isize>\
    \ = vec![0; n];\n\n    // Set up the initial speeds\n    let mut speeds: Vec<isize>\
    \ = vec![0; n];\n\n    // Set up the initial positions\n    let mut positions:\
    \ Vec<isize> = vec![0; n];\n\n    // Set up the initial directions\n    let mut\
    \ directions: Vec<isize> = vec![0; n];\n\n    // Set up the initial velocities\n\
    \    let mut velocities: Vec<isize> = vec![0; n];\n\n    // Set up the initial\
    \ accelerations\n    let mut accelerations: Vec<isize> = vec![0; n];\n\n    //\
    \ Set up the initial collision flags\n    let mut collision_flags: Vec<bool> =\
    \ vec![false; n];\n\n    // Set up the initial collision positions\n    let mut\
    \ collision_positions: Vec<isize> = vec![0; n];\n\n    let mut collision_flag\
    \ = vec![false; n];\n\n    // Set the initial collision state\n    for i in 0..n\
    \ {\n        positions[i] = i;\n        collision_flag[i] = false;\n    }\n\n\
    \    let mut max_distance: isize = 0;\n\n    while let Some(collision) = collisions.iter().next()\
    \ {\n        max_distance = 0;\n        for idx in 0..n {\n            let distance\
    \ = positions[idx] - i;\n            if distance > max_distance {\n          \
    \      max_distance = distance;\n            }\n        }\n        if max_distance\
    \ > i {\n            for i in 0..n {\n                collision_flag[i] = false;\n\
    \            }\n            return collisions.iter().next().unwrap().len();\n\
    \        }\n    }\n\n    for i in 0..n {\n        collisions[i] = vec![false;\
    \ n];\n    }\n\n    for i in 0..n {\n        collision_positions[i] = i;\n   \
    \ }\n\n    for i in 0..n {\n        speeds[i] = 1;\n        dist[i] = i;\n   \
    \     accelerations[i] = 0;\n        velocities[i] = 0;\n    }\n\n    for i in\
    \ 0..n {\n        collisions[i] = vec![false; n];\n    }\n\n    for i in 0..n\
    \ {\n        collision_flag[i] = true;\n        collision_positions[i] = i;\n\
    \    }\n\n    for i in 0..n {\n        collisions[i] = vec![false; n];\n    }\n\
    \n    for i in 0..n {\n        collision_positions[i] = i;\n        collisions[i]\
    \ = vec\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpeff2mo7b.rs:106:3\n\
    \    |\n9   | fn car_race_collision(n: isize) -> isize {\n    |              \
    \                            - unclosed delimiter\n...\n94  |     for i in 0..n\
    \ {\n    |                   - this delimiter might not be properly closed...\n\
    ...\n97  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n106 | }\n    |   ^\n\nerror[E0425]: cannot find value `i` in this scope\n\
    \  --> /tmp/tmpeff2mo7b.rs:53:45\n   |\n53 |             let distance = positions[idx]\
    \ - i;\n   |                                             ^ help: a local variable\
    \ with a similar name exists: `n`\n\nerror[E0425]: cannot find value `i` in this\
    \ scope\n  --> /tmp/tmpeff2mo7b.rs:58:27\n   |\n58 |         if max_distance >\
    \ i {\n   |                           ^ help: a local variable with a similar\
    \ name exists: `n`\n\nerror[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpeff2mo7b.rs:96:25\n\
    \   |\n96 |         collisions[i] = vec\n   |                         ^^^ not\
    \ a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeff2mo7b.rs:13:37\n\
    \   |\n13 |         collisions.push(vec![false; n]);\n   |                   \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |         collisions.push(vec![false; n.try_into().unwrap()]);\n   |      \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeff2mo7b.rs:17:40\n   |\n17 |     let mut dist: Vec<isize>\
    \ = vec![0; n];\n   |                                        ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     let mut dist: Vec<isize>\
    \ = vec![0; n.try_into().unwrap()];\n   |                                    \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeff2mo7b.rs:20:42\n\
    \   |\n20 |     let mut speeds: Vec<isize> = vec![0; n];\n   |               \
    \                           ^ expect"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0\n    for i in 0..n {\n        let mut\
    \ j = n - i;\n        while j >= 0 {\n            if car_collision(i, j, &mut\
    \ count) == 1 {\n                count += 1;\n            }\n            j -=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpf3vf4fjg.rs:10:22\n\
    \   |\n10 |     let mut count = 0\n   |                      ^ help: add `;` here\n\
    11 |     for i in 0..n {\n   |     --- unexpected token\n\nerror[E0425]: cannot\
    \ find function `car_collision` in this scope\n  --> /tmp/tmpf3vf4fjg.rs:14:16\n\
    \   |\n14 |             if car_collision(i, j, &mut count) == 1 {\n   |      \
    \          ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for _ in 0..n {\n      \
    \  let mut collision_found = false;\n        for _ in 0..n {\n            collision_found\
    \ |= !car_collision(n - 1, n - 2);\n        }\n        if collision_found {\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpwy3dxofi.rs:14:33\n   |\n14 |             collision_found |= !car_collision(n\
    \ - 1, n - 2);\n   |                                 ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0usize;\n    let mut speed_a = 1.0;\n\
    \    let mut speed_b = 1.0;\n    let mut timestep_a = 0.0;\n    let mut timestep_b\
    \ = 0.0;\n    let mut left_time = 0.0;\n    let mut right_time = 0.0;\n    let\
    \ mut left_dist = 100.0;\n    let mut right_dist = 100.0;\n\n    while n != 0\
    \ {\n        n -= 1;\n        let timestep_a = timestep_b * speed_b;\n       \
    \ let timestep_b = timestep_a * speed_a;\n        let timestep_c = timestep_a\
    \ + timestep_b;\n        let timestep_d = timestep_a + timestep_b + timestep_c;\n\
    \n        let distance = timestep_d * speed_b * 1.0;\n        if distance >= right_dist\
    \ {\n            collisions += 1;\n            right_dist = distance;\n      \
    \  }\n        if distance >= left_dist {\n            collisions += 1;\n     \
    \       left_dist = distance;\n        }\n\n        if timestep_c < timestep_c\
    \ {\n            speed_b -= 1.0;\n        } else {\n            speed_b += 1.0;\n\
    \        }\n\n        if timestep_b < timestep_b {\n            speed_a -= 1.0;\n\
    \        } else {\n            speed_a += 1.0;\n        }\n\n        if timestep_a\
    \ < timestep_a {\n            timestep_b = 0.0;\n        } else {\n          \
    \  timestep_a = timestep_a;\n        }\n\n        if timestep_a < timestep_b {\n\
    \            timestep_b = timestep_b;\n        } else {\n            timestep_a\
    \ = timestep_a;\n        }\n    }\n\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbcfpbiy.rs:62:5\n   |\n\
    9  | fn car_race_collision(n: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n62 |     collisions\n\
    \   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    62 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0.;\n\n    for _ in 0..n {\n   \
    \     for _ in 0..n {\n            collisions += 1;\n        }\n    }\n\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmp52b5m40p.rs:14:24\n\
    \   |\n14 |             collisions += 1;\n   |                        ^^ no implementation\
    \ for `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp52b5m40p.rs:18:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n18 | \
    \    collisions\n   |     ^^^^^^^^^^ expected `isize`, found floating-point number\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let start_cars = (0..n).collect::<Vec<_>>();\n\
    \    let end_cars = (0..n).map(|i| i + 1).collect::<Vec<_>>();\n    // let start_cars\
    \ = (0..n).map(|i| i as isize);\n    // let end_cars = (0..n).map(|i| i + 1);\n\
    \    for i in start_cars {\n        for j in end_cars {\n            collision_count\
    \ += 1 //\n                if ((i) == (j))\n                    || ((j) == (n\
    \ - i)) //\n                    || ((j) == (i - n)) //\n                    ||\
    \ ((i) == (n - j)) //\n                    || ((i - n) == (j)) //\n          \
    \          || ((i - n) == (n - j)) //\n                    || ((j) == (n - i));\n\
    \        }\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpn1y7oxlf.rs:17:33\n\
    \   |\n17 |             collision_count += 1 //\n   |                        \
    \         ^ help: add `;` here\n18 |                 if ((i) == (j))\n   |   \
    \              -- unexpected token\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpn1y7oxlf.rs:24:40\n\
    \   |\n18 |                 if ((i) == (j))\n   |                 -- this `if`\
    \ expression has a condition, but no block\n...\n24 |                     || ((j)\
    \ == (n - i));\n   |                                        ^ expected `{`\n\n\
    error: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..=n)\n        .filter(|x| *x % 2 != 0)\n        .filter(|x|\
    \ *x % 4 != 0)\n        .filter(|x| *x % 8 != 0)\n        .filter(|x| *x % 16\
    \ != 0)\n        .filter(|x| *x % 32 != 0)\n        .filter(|x| *x % 64 != 0)\n\
    \        .filter(|x| *x % 128 != 0)\n        .filter(|x| *x % 256 != 0)\n    \
    \    .filter(|x| *x % 512 != 0)\n        .filter(|x| *x % 1024 != 0)\n       \
    \ .filter(|x| *x % 2048 != 0)\n        .filter(|x| *x % 4096 != 0)\n        .filter(|x|\
    \ *x % 8192 != 0)\n        .filter(|x| *x % 16384 != 0)\n        .filter(|x| *x\
    \ % 32768 != 0)\n        .filter(|x| *x % 65536 != 0)\n        .filter(|x| *x\
    \ % 131072 != 0)\n        .filter(|x| *x % 262144 != 0)\n        .filter(|x| *x\
    \ % 524288 != 0)\n        .filter(|x| *x % 1048576 != 0)\n        .filter(|x|\
    \ *x % 2097152 != 0)\n        .filter(|x| *x % 4194304 != 0)\n        .filter(|x|\
    \ *x % 8388608 != 0)\n        .filter(|x| *x % 16777216 != 0)\n        .filter(|x|\
    \ *x % 33554432 != 0)\n        .filter(|x| *x % 67108864 != 0)\n        .filter(|x|\
    \ *x % 134217728 != 0)\n        .filter(|x| *x % 268435456 != 0)\n        .filter(|x|\
    \ *x % 536870912 != 0)\n        .filter(|x| *x % 1073741824 != 0)\n        .filter(|x|\
    \ *x % 2147483648 != 0)\n        .filter(|x| *x % 4294967296 != 0)\n        .filter(|x|\
    \ *x % 8589934592 != 0)\n        .filter(|x| *x % 17179869184 != 0)\n        .filter(|x|\
    \ *x % 34359738368 != 0)\n        .filter(|x| *x % 68719476736 != 0)\n       \
    \ .filter(|x| *x \n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp0y515n6f.rs:47:16\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - closing delimiter possibly meant for this\n...\n47\
    \ |         .filter(|x| *x \n   |                ^ unclosed delimiter\n48 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0y515n6f.rs:47:21\n   |\n47 |         .filter(|x| *x \n   |        \
    \             ^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0y515n6f.rs:10:5\n   |\n9  |   fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                      ----- expected `isize`\
    \ because of return type\n10 | /     (1..=n)\n11 | |         .filter(|x| *x %\
    \ 2 != 0)\n12 | |         .filter(|x| *x % 4 != 0)\n13 | |         .filter(|x|\
    \ *x % 8 != 0)\n...  |\n47 | |         .filter(|x| *x \n48 | | }\n   | |_^ expected\
    \ `isize`, found struct `Filter`\n   |\n   = note: expected type `isize`\n   \
    \         found struct `Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<Filter<RangeInclusive<isize>,\
    \ [closure@/tmp/tmp0y515n6f.rs:11:17: 11:32]>, [closure@/tmp/tmp0y515n6f.rs:12:17:\
    \ 12:32]>, [closure@/tmp/tmp0y515n6f.rs:13:17: 13:32]>, [closure@/tmp/tmp0y515n6f.rs:14:17:\
    \ 14:33]>, [closure@/tmp/tmp0y515n6f.rs:15:17: 15:33]>, [closure@/tmp/tmp0y515n6f.rs:16:17:\
    \ 16:33]>, [closure@/tmp/tmp0y515n6f.rs:17:17: 17:34]>, [closure@/tmp/tmp0y515n6f.rs:18:17:\
    \ 18:34]>, [closure@/tmp/tmp0y515n6f.rs:19:17: 19:34]>, [closure@/tmp/tmp0y515n6f.rs:20:17:\
    \ 20:35]>, [closure@/tmp/tmp0y515n6f.rs:21:17: 21:35]>, [closure@/tmp/tmp0y515n6f.rs:22:17:\
    \ 22:35]>, [closure@/tmp/tmp0y515n6f.rs:23:17: 23:35]>, [closure@/tmp/tmp0y515n6f.rs:24:17:\
    \ 24:36]>, [closure@/tmp/tmp0y515n6f.rs:25:17: 25:36]>, [closure@/tmp/tmp0y515n6f.rs:26:17:\
    \ 26:36]>, [closure@/tmp/tmp0y515n6f.rs:27:17: 27:37]>, [closu"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    fn race_collision(n: isize, left_to_right: isize, right_to_left:\
    \ isize) -> isize {\n        // The first car on the right side of the race will\
    \ be the first to go through the \n        // right side of the race line.  This\
    \ is because there cannot be any cars on that \n        // side of the race line\
    \ that are right of it.  \n        let right_car = if n == 0 {\n            left_to_right\n\
    \        } else {\n            left_to_right - n - 1 \n        };\n        let\
    \ left_car = if n == 0 {\n            right_to_left\n        } else {\n      \
    \      right_to_left + n - 1 \n        };\n        if left_car == right_car {\n\
    \            return 0;\n        }\n        // The cars stop at either end of the\
    \ race line, each one will be at the race \n        // line length from that side\
    \ of the race line.  This ensures that cars will never\n        // collide with\
    \ each other.\n        if left_to_right - right_car > left_to_left - right_car\
    \ {\n            return race_collision(n - 1, left_to_right, right_car);\n   \
    \     }\n        return race_collision(n - 1, left_car, right_to_left);\n    }\n\
    \    race_collision(n, n, n)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `left_to_left` in this scope\n  --> /tmp/tmppi8qoxwk.rs:30:40\n\
    \   |\n30 |         if left_to_right - right_car > left_to_left - right_car {\n\
    \   |                                        ^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `left_to_right`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_collides = 0;\n\n    for a in 0..n {\n  \
    \      for b in 0..n {\n            if a == b {\n                continue;\n \
    \           }\n            car_collides += count_car_collisions(&[a], &[b], &[n]);\n\
    \            car_collides += count_car_collisions(&[b], &[a], &[n]);\n       \
    \ }\n    }\n\n    car_collides\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_car_collisions` in this scope\n\
    \  --> /tmp/tmpfpvamngl.rs:17:29\n   |\n17 |             car_collides += count_car_collisions(&[a],\
    \ &[b], &[n]);\n   |                             ^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `count_car_collisions` in\
    \ this scope\n  --> /tmp/tmpfpvamngl.rs:18:29\n   |\n18 |             car_collides\
    \ += count_car_collisions(&[b], &[a], &[n]);\n   |                           \
    \  ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n\n    for _ in 0..n {\n     \
    \   // If this returns true, there is a collision.\n        if car_race_collide(&mut\
    \ collisions) {\n            collisions += 1\n        }\n    }\n\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpr5zsuhu1.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 | \n12 |     for _ in 0..n {\n   |     --- unexpected token\n\
    \nerror[E0425]: cannot find function `car_race_collide` in this scope\n  --> /tmp/tmpr5zsuhu1.rs:14:12\n\
    \   |\n14 |         if car_race_collide(&mut collisions) {\n   |            ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for _ in 0..n {\n\
    \        let mut current = std::mem::replace(&mut collisions, 0);\n        let\
    \ mut collision = std::mem::replace(&mut collisions, 0);\n        for _ in 0..n\
    \ {\n            // The current car is moving left to right.\n            if current\
    \ == 0 {\n                // The current car is moving right to left.\n      \
    \          if collision >= n {\n                    current += 1;\n          \
    \          collision += n;\n                } else {\n                    current\
    \ += 1;\n                    collision += 1;\n                }\n            }\
    \ else {\n                // The current car is moving left to right.\n      \
    \          if collision >= n {\n                    current += 1;\n          \
    \          collision += n;\n                } else {\n                    current\
    \ += 1;\n                    collision += 1;\n                }\n            }\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpc74yymej.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for _ in 0..n {\n\
    \        let mut car_x = 0.0;\n        let mut car_y = 0.0;\n        while car_x\
    \ + CAR_WIDTH / 2.0 > CAR_WIDTH {\n            car_x += CAR_WIDTH / 2.0;\n   \
    \         collisions += 1;\n        }\n        while car_x - CAR_WIDTH / 2.0 <\
    \ 0.0 {\n            car_x -= CAR_WIDTH / 2.0;\n            collisions += 1;\n\
    \        }\n        while car_y + CAR_HEIGHT / 2.0 > CAR_HEIGHT {\n          \
    \  car_y += CAR_HEIGHT / 2.0;\n            collisions += 1;\n        }\n     \
    \   while car_y - CAR_HEIGHT / 2.0 < 0.0 {\n            car_y -= CAR_HEIGHT /\
    \ 2.0;\n            collisions += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `CAR_WIDTH` in this scope\n  --> /tmp/tmpub9q1rz2.rs:14:23\n\
    \   |\n14 |         while car_x + CAR_WIDTH / 2.0 > CAR_WIDTH {\n   |        \
    \               ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `CAR_WIDTH` in this scope\n  --> /tmp/tmpub9q1rz2.rs:14:41\n   |\n14 |\
    \         while car_x + CAR_WIDTH / 2.0 > CAR_WIDTH {\n   |                  \
    \                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAR_WIDTH` in this scope\n  --> /tmp/tmpub9q1rz2.rs:15:22\n   |\n\
    15 |             car_x += CAR_WIDTH / 2.0;\n   |                      ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `CAR_WIDTH` in this\
    \ scope\n  --> /tmp/tmpub9q1rz2.rs:18:23\n   |\n18 |         while car_x - CAR_WIDTH\
    \ / 2.0 < 0.0 {\n   |                       ^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `CAR_WIDTH` in this scope\n  --> /tmp/tmpub9q1rz2.rs:19:22\n\
    \   |\n19 |             car_x -= CAR_WIDTH / 2.0;\n   |                      ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `CAR_HEIGHT` in this\
    \ scope\n  --> /tmp/tmpub9q1rz2.rs:22:23\n   |\n22 |         while car_y + CAR_HEIGHT\
    \ / 2.0 > CAR_HEIGHT {\n   |                       ^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `CAR_HEIGHT` in this scope\n  --> /tmp/tmpub9q1rz2.rs:22:42\n\
    \   |\n22 |         while car_y + CAR_HEIGHT / 2.0 > CAR_HEIGHT {\n   |      \
    \                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAR_HEIGHT` in this scope\n  --> /tmp/tmpub9q1rz2.rs:23:22\n\
    \   |\n23 |             car_y += CAR_HEIGHT / 2.0;\n   |                     \
    \ ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `CAR_HEIGHT`\
    \ in this scope\n  --> /tmp/tmpub9q1rz2.rs:26:23\n   |\n26 |         while car_y\
    \ - CAR_HEIGHT / 2.0 < 0.0 {\n   |                       ^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `CAR_HEIGHT` in this scope\n\
    \  --> /tmp/tmpub9q1rz2.rs:27:22\n   |\n27 |             car_y -= CAR_HE"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    trace!(\"car_race_collision(n = {})\", n);\n    let mut\
    \ collisions = 0;\n    for _ in 0..n {\n        let xr = 2 * rand::random::<f32>()\
    \ - 1;\n        let yr = 2 * rand::random::<f32>() - 1;\n        let vr = 2 *\
    \ rand::random::<f32>() - 1;\n        for _ in 0..n {\n            let x = xr;\n\
    \            let y = yr;\n            let v = vr;\n            if (((x != 0 ||\
    \ y != 0 || v != 0) && (v != 0 || x != 0 || y != 0)) ||\n                (x !=\
    \ 0 || y != 0 || v != 0 && y != 0)) {\n                collisions += 1;\n    \
    \            break;\n            }\n        }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `trace` in this scope\n  --> /tmp/tmp4szsddql.rs:10:5\n\
    \   |\n10 |     trace!(\"car_race_collision(n = {})\", n);\n   |     ^^^^^\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n  -->\
    \ /tmp/tmp4szsddql.rs:13:22\n   |\n13 |         let xr = 2 * rand::random::<f32>()\
    \ - 1;\n   |                      ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp4szsddql.rs:14:22\n   |\n14 |         let yr = 2 * rand::random::<f32>()\
    \ - 1;\n   |                      ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp4szsddql.rs:15:22\n   |\n15 |         let vr = 2 * rand::random::<f32>()\
    \ - 1;\n   |                      ^^^^ use of undeclared crate or module `rand`\n\
    \nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4szsddql.rs:20:16\n\
    \   |\n20 |             if (((x != 0 || y != 0 || v != 0) && (v != 0 || x != 0\
    \ || y != 0)) ||\n   |                ^\n21 |                 (x != 0 || y !=\
    \ 0 || v != 0 && y != 0)) {\n   |                                            \
    \           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n20 ~             if ((x != 0 || y != 0 || v\
    \ != 0) && (v != 0 || x != 0 || y != 0)) ||\n21 ~                 (x != 0 || y\
    \ != 0 || v != 0 && y != 0) {\n   |\n\nerror: aborting due to 4 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n\n    // Iterate through\
    \ each pair\n    for i in 0..n / 2 {\n        let j = i + 1;\n\n        // Skip\
    \ over the collision that would happen in the next iteration\n        if j >=\
    \ n {\n            j -= n;\n        }\n\n        let collision = car_race_collision(i,\
    \ j);\n\n        collisions += collision;\n\n        // If the cars collide, break\
    \ out of the loop\n        if collision > 0 {\n            break;\n        }\n\
    \    }\n\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpgotvrq4c.rs:21:25\n   |\n21 |         let collision = car_race_collision(i,\
    \ j);\n   |                         ^^^^^^^^^^^^^^^^^^ -  - supplied 2 arguments\n\
    \   |                         |\n   |                         expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpgotvrq4c.rs:9:4\n   |\n9  |\
    \ fn car_race_collision(n: isize) -> isize {\n   |    ^^^^^^^^^^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cnt = 0;\n    for _ in 0..n {\n        let mut\
    \ a = random::<i32>();\n        let mut b = random::<i32>();\n        a += b as\
    \ u16;\n        while a >= 0x10000 {\n            a = random::<i32>();\n     \
    \       b += a as i32;\n        }\n        let mut c = random::<i32>();\n    \
    \    let mut d = random::<i32>();\n        c += d as i32;\n        while c >=\
    \ 0x1000 {\n            c = random::<i32>();\n            d += c as i32;\n   \
    \     }\n        cnt += if a + b == c as i32 { 1 } else { 0 };\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `random` in this scope\n  --> /tmp/tmpns3j8ud3.rs:12:21\n\
    \   |\n12 |         let mut a = random::<i32>();\n   |                     ^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `random` in this\
    \ scope\n  --> /tmp/tmpns3j8ud3.rs:13:21\n   |\n13 |         let mut b = random::<i32>();\n\
    \   |                     ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `random` in this scope\n  --> /tmp/tmpns3j8ud3.rs:16:17\n   |\n\
    16 |             a = random::<i32>();\n   |                 ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `random` in this scope\n  -->\
    \ /tmp/tmpns3j8ud3.rs:19:21\n   |\n19 |         let mut c = random::<i32>();\n\
    \   |                     ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `random` in this scope\n  --> /tmp/tmpns3j8ud3.rs:20:21\n   |\n\
    20 |         let mut d = random::<i32>();\n   |                     ^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `random` in this scope\n\
    \  --> /tmp/tmpns3j8ud3.rs:23:17\n   |\n23 |             c = random::<i32>();\n\
    \   |                 ^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 6 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ncars = n;\n    let mut collides = 0;\n    let\
    \ mut collides_right = 0;\n    let mut collides_left = 0;\n    let mut collides_diag\
    \ = 0;\n    let mut collides_diag_right = 0;\n    let mut collides_diag_left =\
    \ 0;\n\n    let mut speed = 2.0;\n    let mut speed2 = 0.5;\n\n    // the cars\
    \ that collide with each other\n    let mut collisions = Vec::new();\n    // the\
    \ cars going left to right\n    let mut collisions_right = Vec::new();\n    //\
    \ the cars going right to left\n    let mut collisions_left = Vec::new();\n  \
    \  // the cars going diagonally up\n    let mut collisions_diag = Vec::new();\n\
    \    // the cars going diagonally up\n    let mut collisions_diag_right = Vec::new();\n\
    \    // the cars going diagonally down\n    let mut collisions_diag_left = Vec::new();\n\
    \n    for _ in 0..(ncars - 1) {\n        // the cars that collide with each other\n\
    \        collisions.push(0);\n        collisions_right.push(0);\n        collisions_left.push(0);\n\
    \        collisions_diag.push(0);\n        collisions_diag_right.push(0);\n  \
    \      collisions_diag_left.push(0);\n\n        for _ in 0..(ncars - 1) {\n  \
    \          // the cars going left to right\n            let mut collides_left\
    \ = 0;\n            // the cars going right to left\n            let mut collides_right\
    \ = 0;\n            // the cars going diagonally up\n            let mut collides_diag\
    \ = 0;\n            // the cars going diagonally down\n            let mut collides_diag_left\
    \ = 0;\n            // the cars going diagonally down\n            let mut collides_diag_right\
    \ = 0;\n            \n            collisions_left.push(collides_left);\n     \
    \       collisions_right.push(collides_right);\n            collisions_diag_left.push(collides_diag_left);\n\
    \            collisions_diag_right.push(collides_diag_right);\n            collisions_diag.push(collides_diag);\n\
    \n            let x = speed * sin((2 * n + 1) * M_PI / ncars);\n            let\
    \ y = speed * cos((2 * n + 1) * M_PI / ncars);\n            // the cars start\
    \ at x = speed * sin(2 * n), y = speed * cos(2 * n).\n            speed2 += 0.5;\n\
    \n            // move the cars left and right\n            for _ in 0.\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpq8x5r8o_.rs:77:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n34 |     for _ in 0..(ncars\
    \ - 1) {\n   |                             - unclosed delimiter\n...\n43 |   \
    \      for _ in 0..(ncars - 1) {\n   |                                 - this\
    \ delimiter might not be properly closed...\n...\n68 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n77 | }\n   |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpq8x5r8o_.rs:68:1\n   |\n68 | }\n   | ^ expected\
    \ `{`\n\nerror[E0425]: cannot find function `sin` in this scope\n  --> /tmp/tmpq8x5r8o_.rs:61:29\n\
    \   |\n61 |             let x = speed * sin((2 * n + 1) * M_PI / ncars);\n   |\
    \                             ^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `M_PI` in this scope\n  --> /tmp/tmpq8x5r8o_.rs:61:47\n   |\n61 |\
    \             let x = speed * sin((2 * n + 1) * M_PI / ncars);\n   |         \
    \                                      ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `cos` in this scope\n  --> /tmp/tmpq8x5r8o_.rs:62:29\n\
    \   |\n62 |             let y = speed * cos((2 * n + 1) * M_PI / ncars);\n   |\
    \                             ^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `M_PI` in this scope\n  --> /tmp/tmpq8x5r8o_.rs:62:47\n   |\n62 |\
    \             let y = speed * cos((2 * n + 1) * M_PI / ncars);\n   |         \
    \                                      ^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq8x5r8o_.rs:34:5\n   |\n9  |   fn car_race_collision(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n34 | /     for _ in 0..(ncars - 1) {\n\
    35 | |         // the cars that collide with each other\n36 | |         collisions.push(0);\n\
    37 | |         collisions_right.push(0);\n...  |\n76 | |     assert_eq!(candidate(10),\
    \ 100);\n77 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to 7 previous errors\n\nSome "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut collision_count\
    \ = 0;\n    for i in 0..n {\n        for j in i..n {\n            if i != j {\n\
    \                collision_count += (car_race_collision(n - 1)) * car_race_collision(n\
    \ - 2);\n            }\n        }\n    }\n    collision_count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpwere4fyx.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 1 {\n        return 1\n    } else {\n       \
    \ let mut collisions: isize = 0;\n        for car1 in 0..n {\n            for\
    \ car2 in (car1 + 1)..n {\n                // Car 1 travels left to right; Car\
    \ 2 travels right to left\n                // So that means they never collide.\n\
    \                assert!(\n                    (car1 != car2 && car2 != car1)\
    \ ||\n                        (car1 == 0 && car2 == n),\n                    \"\
    This shouldn't happen.  There should have been a collision.\",\n             \
    \   );\n                // Collision: Car 1 travels left to right, Car 2 travels\
    \ right to left\n                // So that means they never collide.\n      \
    \          collisions += car_race_collision(n);\n            }\n        }\n  \
    \      collisions\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    let mut car_positions:\
    \ Vec<(isize, u8)> = Vec::new();\n    car_positions.push((0, 0));\n    car_positions.push((1,\
    \ 0));\n    car_positions.push((0, 1));\n    car_positions.push((1, 1));\n   \
    \ let mut collisions = 0;\n    let mut prev_collisions = -1;\n    let mut car_distance\
    \ = 1;\n    let mut car_positions_prev = Vec::new();\n    while car_positions_prev.len()\
    \ < car_position.len() {\n        prev_collisions = collisions;\n        car_positions_prev.clear();\n\
    \        for (i, &position) in car_positions.iter().enumerate() {\n          \
    \  let (car_position, car_direction) = position;\n            if let Some((car_position2,\
    \ car_direction2)) = car_positions_prev.iter().find(|&(pos_2, _)| pos_2 == car_position)\
    \ {\n                if car_position == car_position2 {\n                    continue;\n\
    \                }\n                let dist = distance(car_position, car_position2);\n\
    \                let next_collisions = collisions + car_race_collision(dist -\
    \ car_distance);\n                if next_collisions > prev_collisions {\n   \
    \                 collisions += 1;\n                }\n                let mut\
    \ car_positions_new = ((car_position, car_direction), (car_position2, car_direction2));\n\
    \                car_positions.push(car_positions_new);\n                car_positions_prev.push(car_positions_new);\n\
    \            }\n        }\n        car_distance++;\n    }\n    collisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7oz0eq9t.rs:41:21\n\
    \   |\n41 |         car_distance++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n41 |         { let tmp = car_distance;\
    \ car_distance += 1; tmp };\n   |         +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    41 -         car_distance++;\n41 +         car_distance += 1;\n   | \n\nerror[E0425]:\
    \ cannot find value `car_position` in this scope\n  --> /tmp/tmp7oz0eq9t.rs:22:38\n\
    \   |\n22 |     while car_positions_prev.len() < car_position.len() {\n   |  \
    \                                    ^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `car_positions`\n\nerror[E0425]: cannot find function\
    \ `distance` in this scope\n  --> /tmp/tmp7oz0eq9t.rs:31:28\n   |\n31 |      \
    \           let dist = distance(car_position, car_position2);\n   |          \
    \                  ^^^^^^^^ not found in this scope\n\nerror[E0277]: can't compare\
    \ `&_` with `isize`\n  --> /tmp/tmp7oz0eq9t.rs:27:111\n   |\n27 |            \
    \ if let Some((car_position2, car_direction2)) = car_positions_prev.iter().find(|&(pos_2,\
    \ _)| pos_2 == car_position) {\n   |                                         \
    \                                                                      ^^ no implementation\
    \ for `&_ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7oz0eq9t.rs:28:36\n\
    \   |\n28 |                 if car_position == car_position2 {\n   |         \
    \                           ^^^^^^^^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\nhelp:\
    \ consider dereferencing the borrow\n   |\n28 |                 if car_position\
    \ == *car_position2 {\n   |                                    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7oz0eq9t.rs:37:36\n   |\n37 |              \
    \   car_positions.push(car_positions_new);\n   |                             \
    \       ^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ tuple `(isize"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut seen: HashSet<isize> = HashSet::new();\n    let\
    \ mut collisions = 0;\n    for i in 1..n {\n        let left_road_start = i;\n\
    \        let right_road_start = n - i;\n        for j in left_road_start..right_road_start\
    \ {\n            let left = i - j;\n            let right = i + j;\n         \
    \   if seen & {left, right}.contains(&0) {\n                collisions += 1;\n\
    \                break;\n            }\n            seen.insert(i);\n        \
    \    seen.insert(j);\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this is a block expression, not an array\n  --> /tmp/tmp1zdu5fzi.rs:18:23\n\
    \   |\n18 |             if seen & {left, right}.contains(&0) {\n   |         \
    \              ^^^^^^^^^^^^^\n   |\nhelp: to make an array, use square brackets\
    \ instead of curly braces\n   |\n18 |             if seen & [left, right].contains(&0)\
    \ {\n   |                       ~           ~\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n  --> /tmp/tmp1zdu5fzi.rs:10:19\n   |\n10 |     let\
    \ mut seen: HashSet<isize> = HashSet::new();\n   |                   ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmp1zdu5fzi.rs:10:36\n   |\n10 |  \
    \   let mut seen: HashSet<isize> = HashSet::new();\n   |                     \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: usize = 0;\n    for _ in 0..n {\n\
    \        for _ in 0..n {\n            // Move the car a random amount in the direction\
    \ of the\n            // collision.\n            collisions += 1;\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps7vrbllq.rs:18:5\n   |\n\
    9  | fn car_race_collision(n: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n18 |     collisions\n\
    \   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    18 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    let mut\
    \ collisions = 1;\n    let mut c = (n - 1) / 2;\n    while c > 0 {\n        if\
    \ ((n - 1 - c) % 2 == 0) {\n            collisions += car_race_collision(c - 1);\n\
    \        } else {\n            collisions += car_race_collision(c - 2);\n    \
    \    }\n        c /= 2;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpz_lvtye7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    let mut car_array: Vec<_>\
    \ = Vec::new();\n    for i in 0..n {\n        let mut temp_array: Vec<_> = Vec::new();\n\
    \        for j in 0..n {\n            if i != j {\n                temp_array.push(j*j);\n\
    \            }\n        }\n        car_array.push(temp_array);\n    }\n    for\
    \ (car_set, collision) in car_array.iter().zip(collision_check(car_array)) {\n\
    \        if collision {\n            collisions += 1;\n        }\n    }\n    return\
    \ collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmphhs3wnn5.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     let mut car_array: Vec<_> = Vec::new();\n   |     ---\
    \ unexpected token\n\nerror[E0425]: cannot find function `collision_check` in\
    \ this scope\n  --> /tmp/tmphhs3wnn5.rs:21:54\n   |\n21 |     for (car_set, collision)\
    \ in car_array.iter().zip(collision_check(car_array)) {\n   |                \
    \                                      ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for _ in 0..n {\n      \
    \  if let Some(other_car) = rng.next_double() {\n            if let Some(collision)\
    \ = car_race_collision(n - 1) {\n                collisions += collision;\n  \
    \              other_car.bump(collision);\n            } else {\n            \
    \    other_car.bump(1);\n                collisions += 1;\n            }\n   \
    \     } else {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `rng` in this scope\n  --> /tmp/tmplw7k4rl6.rs:12:34\n\
    \   |\n12 |         if let Some(other_car) = rng.next_double() {\n   |       \
    \                           ^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplw7k4rl6.rs:13:20\n   |\n13 |             if let Some(collision)\
    \ = car_race_collision(n - 1) {\n   |                    ^^^^^^^^^^^^^^^   -------------------------\
    \ this expression has type `isize`\n   |                    |\n   |          \
    \          expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut rng = rand::thread_rng();\n\
    \    let mut left_to_right = rng.gen::<bool>();\n    let mut right_to_left = !left_to_right;\n\
    \    while left_to_right && right_to_left {\n        let mut car_collisions =\
    \ n;\n        for _ in 0..n {\n            let direction = rng.gen::<isize>();\n\
    \            let left_car_pos = left_to_right ? left_car_pos_1 + direction : left_car_pos_1\
    \ - direction;\n            let right_car_pos = right_to_left ? right_car_pos_1\
    \ - direction : right_car_pos_1 + direction;\n            let collide = left_to_right\
    \ && right_to_left ? left_car_collision(left_car_pos) && right_car_collision(right_car_pos)\
    \ : !left_to_right && !right_to_left && left_car_collision(left_car_pos) && right_car_collision(right_car_pos);\n\
    \            if collide {\n                car_collisions--;\n            }\n\
    \        }\n        if left_to_right {\n            right_to_left = true;\n  \
    \      } else {\n            left_to_right = true;\n        }\n        if right_to_left\
    \ {\n            left_to_right = false;\n        } else {\n            right_to_left\
    \ = false;\n        }\n        if car_collisions == 0 {\n            collisions++;\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `left_car_pos_1`\n\
    \  --> /tmp/tmptqyd1nt_.rs:18:48\n   |\n18 |             let left_car_pos = left_to_right\
    \ ? left_car_pos_1 + direction : left_car_pos_1 - direction;\n   |           \
    \                                     ^^^^^^^^^^^^^^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmptqyd1nt_.rs:36:23\n   |\n36 |             collisions++;\n   | \
    \                      ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n36 |             { let tmp = collisions; collisions += 1; tmp\
    \ };\n   |             +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n36 -  \
    \           collisions++;\n36 +             collisions += 1;\n   | \n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmptqyd1nt_.rs:11:19\n\
    \   |\n11 |     let mut rng = rand::thread_rng();\n   |                   ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collides = 0;\n\n    for _i in 0..n {\n     \
    \   // Find two cars that start out moving toward the same place\n        let\
    \ start = vec![((_i + 1) % n, 0);\n                          ((_i + 2) % n, 1)];\n\
    \        let directions = vec![vec![(1,0), (-1, 0), (0, 1),\n                \
    \              (-1, 1), (0, 1), (1, 0), (-1, -1)]];\n\n        for j in 0..4 {\n\
    \            for (dir, car) in directions.iter_mut().zip(start) {\n          \
    \      let next_car = if j == 3 {\n                    vec![(car[0] + dir[0],\
    \ car[1] + dir[1])]\n                } else {\n                    vec![(car[0]\
    \ + dir[0], car[1] + dir[1]),\n                           (car[0] + dir[0], car[1]\
    \ + dir[1])]\n                };\n\n                // If the next car is within\
    \ the same lane, then the cars collide\n                if next_car[0] <= n &&\
    \ next_car[0] >= 0 && next_car[1] < n &&\n                   next_car[1] >= 0\
    \ {\n                    collides += 1;\n                }\n            }\n  \
    \      }\n    }\n\n    // If every car collides, then there's a car racing.\n\
    \    if collides == n - 1 {\n        return 1\n    }\n\n    // If this point had\
    \ collided, then the car race is over.\n    if collides > n - 1 {\n        return\
    \ 0\n    }\n\n    // Otherwise, there are collisions.\n    return collides\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4plsp8c4.rs:15:27\n   |\n\
    15 |                           ((_i + 2) % n, 1)];\n   |                     \
    \      ^^^^^^^^^^^^^^^^^ expected `usize`, found tuple\n   |\n   = note: expected\
    \ type `usize`\n             found tuple `(isize, {integer})`\n\nerror[E0608]:\
    \ cannot index into a value of type `(isize, {integer})`\n  --> /tmp/tmp4plsp8c4.rs:22:27\n\
    \   |\n22 |                     vec![(car[0] + dir[0], car[1] + dir[1])]\n   |\
    \                           ^^^^^^ help: to access tuple elements, use: `car.0`\n\
    \nerror[E0608]: cannot index into a value of type `(isize, {integer})`\n  -->\
    \ /tmp/tmp4plsp8c4.rs:22:44\n   |\n22 |                     vec![(car[0] + dir[0],\
    \ car[1] + dir[1])]\n   |                                            ^^^^^^ help:\
    \ to access tuple elements, use: `car.1`\n\nerror[E0608]: cannot index into a\
    \ value of type `(isize, {integer})`\n  --> /tmp/tmp4plsp8c4.rs:24:27\n   |\n\
    24 |                     vec![(car[0] + dir[0], car[1] + dir[1]),\n   |      \
    \                     ^^^^^^ help: to access tuple elements, use: `car.0`\n\n\
    error[E0608]: cannot index into a value of type `(isize, {integer})`\n  --> /tmp/tmp4plsp8c4.rs:24:44\n\
    \   |\n24 |                     vec![(car[0] + dir[0], car[1] + dir[1]),\n   |\
    \                                            ^^^^^^ help: to access tuple elements,\
    \ use: `car.1`\n\nerror[E0608]: cannot index into a value of type `(isize, {integer})`\n\
    \  --> /tmp/tmp4plsp8c4.rs:25:29\n   |\n25 | ...                   (car[0] + dir[0],\
    \ car[1] + dir[1])]\n   |                        ^^^^^^ help: to access tuple\
    \ elements, use: `car.0`\n\nerror[E0608]: cannot index into a value of type `(isize,\
    \ {integer})`\n  --> /tmp/tmp4plsp8c4.rs:25:46\n   |\n25 | ...               \
    \    (car[0] + dir[0], car[1] + dir[1])]\n   |                               \
    \          ^^^^^^ help: to access tuple elements, use: `car.1`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for row in 0..n {\n    \
    \    for col in 0..n {\n            let mut i1 = row + 2;\n            let mut\
    \ i2 = row - 1;\n            let mut j1 = col + 2;\n            let mut j2 = col\
    \ - 1;\n            while i1 < n && i2 < n && j1 < n && j2 < n {\n           \
    \     if ((i1 > 0 && j1 > 0) || (i1 < n && j1 > 0)\n                    || (i1\
    \ > 0 && j1 < n) || (i1 < n && j1 < n)) {\n                    i1 += 1;\n    \
    \                j1 += 1;\n                }\n                else if ((i2 > 0\
    \ && j2 > 0) || (i2 < n && j2 > 0)\n                    || (i2 > 0 && j2 < n)\
    \ || (i2 < n && j2 < n)) {\n                    i2 -= 1;\n                   \
    \ j2 -= 1;\n                }\n                else {\n                    collisions\
    \ += 1;\n                }\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpvnnc4zy7.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ncollisions = 0;\n    let mut x = 0;\n    let\
    \ mut y = 0;\n    let mut z = 0;\n    let mut v_x = 0.;\n    let mut v_y = 0.;\n\
    \    let mut v_z = 0.;\n    for _ in 0..n {\n        x += 1.;\n        y += 1.;\n\
    \        z += 1.;\n        v_x -= 2.;\n        v_y -= 2.;\n        v_z -= 2.;\n\
    \        if x != 0..n || y != 0..n || z != 0..n || v_x != 0. || v_y != 0. || v_z\
    \ != 0.\n        {\n            if x != 0..n {\n                if v_x != 0..n\
    \ {\n                    if ((x % 2) == (v_x % 2)) {\n                       \
    \ ncollisions += 1;\n                    }\n                }\n            }\n\
    \            if y != 0..n {\n                if v_y != 0..n {\n              \
    \      if ((y % 2) == (v_y % 2)) {\n                        ncollisions += 1;\n\
    \                    }\n                }\n            }\n            if z !=\
    \ 0..n {\n                if v_z != 0..n {\n                    if ((z % 2) ==\
    \ (v_z % 2)) {\n                        ncollisions += 1;\n                  \
    \  }\n                }\n            }\n        }\n    }\n    ncollisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `..`\n  --> /tmp/tmpwbzxckku.rs:24:31\n   |\n\
    24 |         if x != 0..n || y != 0..n || z != 0..n || v_x != 0. || v_y != 0.\
    \ || v_z != 0.\n   |         --                    ^^ expected `{`\n   |     \
    \    |\n   |         this `if` expression has a condition, but no block\n   |\n\
    help: try placing this code inside a block\n   |\n24 |         if x != 0..n ||\
    \ y != 0{ ..n || z != 0 }..n || v_x != 0. || v_y != 0. || v_z != 0.\n   |    \
    \                           +               +\n\nerror[E0277]: cannot add-assign\
    \ `{float}` to `{integer}`\n  --> /tmp/tmpwbzxckku.rs:18:11\n   |\n18 |      \
    \   x += 1.;\n   |           ^^ no implementation for `{integer} += {float}`\n\
    \   |\n   = help: the trait `AddAssign<{float}>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0277]: cannot add-assign `{float}` to `{integer}`\n  --> /tmp/tmpwbzxckku.rs:19:11\n\
    \   |\n19 |         y += 1.;\n   |           ^^ no implementation for `{integer}\
    \ += {float}`\n   |\n   = help: the trait `AddAssign<{float}>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot add-assign `{float}` to `{integer}`\n  -->\
    \ /tmp/tmpwbzxckku.rs:20:11\n   |\n20 |         z += 1.;\n   |           ^^ no\
    \ implementation for `{integer} += {float}`\n   |\n   = help: the trait `AddAssign<{float}>`\
    \ is not implemented for `{integer}`\n   = help: th"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Return the number of distinct starting points where\
    \ n cars race (from left\n    // to right) infinitely long ways.\n    (1..(n *\
    \ n)).filter(|&x| x <= n).count()\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnacpek6b.rs:12:5\n   |\n\
    9  | fn car_race_collision(n: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n12 |     (1..(n\
    \ * n)).filter(|&x| x <= n).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     (1..(n\
    \ * n)).filter(|&x| x <= n).count().try_into().unwrap()\n   |                \
    \                             ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let num_collisions = n * (n - 1) / 2;\n    let mut sum\
    \ = 0;\n    for i in 1..num_collisions {\n        sum += i;\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpmzw0997p.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n * 2 * n) as isize\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `4`', /tmp/tmp2fx2_byi.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut total = 0;\n    for i in 0..n {\n        let\
    \ mut j = 0;\n        while j < (n - i + 1) {\n            let mut k = 0;\n  \
    \          while k < i {\n                total += j + k;\n                k +=\
    \ 1;\n            }\n            j += 1;\n        }\n    }\n    total\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpxl_yn4vh.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collides = 1;\n    let mut num_cars = n;\n  \
    \  for i in (0..n).rev() {\n        let mut j = i;\n        while j > 0 && num_cars\
    \ > 0 {\n            if car_collision(i, j) == 1 {\n                collides +=\
    \ 1;\n                num_cars -= 1;\n            }\n            j -= 1;\n   \
    \     }\n    }\n    return collides;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpfoj46oau.rs:15:16\n   |\n15 |             if car_collision(i, j) ==\
    \ 1 {\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collided = 0;\n    let mut speeds = vec![n];\n\
    \n    for s in speeds.iter_mut() {\n        *s = 25;\n    }\n\n    for s in speeds.iter_mut()\
    \ {\n        let next_s = s + 1;\n        let collision = if *next_s > n {\n \
    \           *next_s - n\n        } else {\n            *s\n        };\n\n    \
    \    *s = *next_s;\n        collided += *collision;\n    }\n\n    return collided;\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `&mut isize`\n  --> /tmp/tmprbigvmrl.rs:18:24\n\
    \   |\n18 |         let next_s = s + 1;\n   |                      - ^ - {integer}\n\
    \   |                      |\n   |                      &mut isize\n   |\nhelp:\
    \ `+` can be used on `isize`, you can dereference `s`\n   |\n18 |         let\
    \ next_s = *s + 1;\n   |                      +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ncars = n;\n    let mut collisions: isize = 0;\n\
    \n    while ncars > 0 {\n        let left_car = rand::random::<usize>() % ncars;\n\
    \        let right_car = rand::random::<usize>() % ncars;\n\n        let left_speed\
    \ = car_speed(left_car);\n        let right_speed = car_speed(right_car);\n  \
    \      let left_collision = is_collision(left_car, right_car, left_speed, right_speed);\n\
    \        let right_collision = is_collision(left_car, right_car, right_speed,\
    \ left_speed);\n\n        if left_collision && right_collision {\n           \
    \ ncars -= 2;\n            collisions += 1;\n        }\n\n        if !left_collision\
    \ && !right_collision {\n            ncars -= 1;\n        }\n    }\n\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpq6rdhr4s.rs:14:24\n   |\n14 |         let left_car = rand::random::<usize>()\
    \ % ncars;\n   |                        ^^^^ use of undeclared crate or module\
    \ `rand`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `rand`\n  --> /tmp/tmpq6rdhr4s.rs:15:25\n   |\n15 |         let right_car =\
    \ rand::random::<usize>() % ncars;\n   |                         ^^^^ use of undeclared\
    \ crate or module `rand`\n\nerror[E0425]: cannot find function `car_speed` in\
    \ this scope\n  --> /tmp/tmpq6rdhr4s.rs:17:26\n   |\n17 |         let left_speed\
    \ = car_speed(left_car);\n   |                          ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `car_speed` in this scope\n\
    \  --> /tmp/tmpq6rdhr4s.rs:18:27\n   |\n18 |         let right_speed = car_speed(right_car);\n\
    \   |                           ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_collision` in this scope\n  --> /tmp/tmpq6rdhr4s.rs:19:30\n\
    \   |\n19 |         let left_collision = is_collision(left_car, right_car, left_speed,\
    \ right_speed);\n   |                              ^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `collisions`\n\nerror[E0425]: cannot find\
    \ function `is_collision` in this scope\n  --> /tmp/tmpq6rdhr4s.rs:20:31\n   |\n\
    20 |         let right_collision = is_collision(left_car, right_car, right_speed,\
    \ left_speed);\n   |                               ^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `collisions`\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if i != j {\n                if car_collision(i, j,\
    \ &mut count) {\n                    return count;\n                }\n      \
    \      }\n        }\n    }\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmplsd283pu.rs:14:20\n   |\n14 |                 if car_collision(i, j,\
    \ &mut count) {\n   |                    ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collide = 0usize;\n    let mut speed = 1usize;\n\
    \    for _ in 0..n {\n        let x = 0usize;\n        let y = 0usize;\n     \
    \   let dx = (x - (-y + 1) / speed).abs() as isize;\n        let dy = (y + (-x\
    \ + 1) / speed).abs() as isize;\n        if dx < n\n            && dy < n\n  \
    \          && dx + dy <= 2 * n\n        {\n            collide += 1;\n       \
    \ }\n        speed *= 2;\n    }\n    collide\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpz7jjfufr.rs:15:24\n\
    \   |\n15 |         let dx = (x - (-y + 1) / speed).abs() as isize;\n   |    \
    \                    ^^ cannot apply unary operator `-`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0599]: no method named `abs` found for type\
    \ `usize` in the current scope\n  --> /tmp/tmpz7jjfufr.rs:15:41\n   |\n15 |  \
    \       let dx = (x - (-y + 1) / speed).abs() as isize;\n   |                \
    \                         ^^^ method not found in `usize`\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `usize`\n  --> /tmp/tmpz7jjfufr.rs:16:24\n\
    \   |\n16 |         let dy = (y + (-x + 1) / speed).abs() as isize;\n   |    \
    \                    ^^ cannot apply unary operator `-`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0599]: no method named `abs` found for type\
    \ `usize` in the current scope\n  --> /tmp/tmpz7jjfufr.rs:16:41\n   |\n16 |  \
    \       let dy = (y + (-x + 1) / speed).abs() as isize;\n   |                \
    \                         ^^^ method not found in `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz7jjfufr.rs:25:5\n   |\n9  | fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n25 |     collide\n   |     ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |     collide.try_into().unwrap()\n  \
    \ |            ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_collisions: isize = 0;\n    for _ in 0..n\
    \ {\n        for _ in 0..n {\n            car_collisions += 1;\n        }\n  \
    \  }\n    car_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    fn collides(x: isize,\
    \ y: isize) -> bool {\n        x < n && y < n && x * (x + 1) == y * (y + 1)\n\
    \    }\n    for i in 1..n {\n        for j in 1..n {\n            if collides(i\
    \ - 1, j) || collides(i, j - 1) {\n                collisions += 1;\n        \
    \    }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmphyua69uv.rs:12:13\n\
    \   |\n12 |         x < n && y < n && x * (x + 1) == y * (y + 1)\n   |       \
    \      ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]:\
    \ can't capture dynamic environment in a fn item\n  --> /tmp/tmphyua69uv.rs:12:22\n\
    \   |\n12 |         x < n && y < n && x * (x + 1) == y * (y + 1)\n   |       \
    \               ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0434`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    // This inner loop\
    \ will count the number of collisions between two cars. Since a collision happens\n\
    \    // whenever the speed of one car goes above the speed of the other, the number\
    \ of collisions\n    // is equal to the number of cars whose speeds are equal.\n\
    \    for _ in 0..n {\n        let mut speed: isize = 0;\n        for _ in 0..n\
    \ {\n            speed += 1;\n            collision_count += speed != 2;\n   \
    \     }\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `bool` to `{integer}`\n  --> /tmp/tmp1v7fwynt.rs:18:29\n\
    \   |\n18 |             collision_count += speed != 2;\n   |                 \
    \            ^^ no implementation for `{integer} += bool`\n   |\n   = help: the\
    \ trait `AddAssign<bool>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // Track how many times we get\
    \ a collision\n    let mut race_vector = [0; n];\n    let mut collided = false;\
    \ // Track whether we got one\n    let mut left = false;\n\n    for i in 1..n\
    \ {\n        // Move one car to the right\n        race_vector[n - 1 - i] = 0;\n\
    \        // Move one car to the left\n        race_vector[n - 1 - i] += 1;\n\n\
    \        // Move the other car to the right\n        race_vector[n - 1 - i] =\
    \ 0;\n        // Move the other car to the left\n        race_vector[n - 1 - i]\
    \ -= 1;\n\n        if !collided && check_collision(race_vector[n - 1 - i], race_vector[n\
    \ - 1 - i]) {\n            collisions += 1;\n            collided = true;\n  \
    \      }\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpy4a9qf_w.rs:11:31\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n10 |     let\
    \ mut collisions = 0; // Track how many times we get a collision\n11 |     let\
    \ mut race_vector = [0; n];\n   |                               ^\n\nerror[E0425]:\
    \ cannot find function `check_collision` in this scope\n  --> /tmp/tmpy4a9qf_w.rs:26:25\n\
    \   |\n26 |         if !collided && check_collision(race_vector[n - 1 - i], race_vector[n\
    \ - 1 - i]) {\n   |                         ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0435.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The number of collisions is exactly the number of\
    \ ways n of cars will collide.\n    let mut collisions: isize = 0;\n    for i\
    \ in 0..n {\n        for j in (i + 1)..n {\n            if i != j {\n        \
    \        collisions += ((n - i) * (n - j)) + (i * j);\n            }\n       \
    \ }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn8_scac9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count: usize = 0;\n\n    // A car that\
    \ has moved left to right is considered \"colliding\" with another car that has\n\
    \    // moved right to left if and only if these two cars are both moving right.\n\
    \    // For any pair where one car is moving left to right and the other is moving\
    \ right\n    // to left, they will collide, since they will both hit the same\
    \ car at the same time.\n    for a in 0..n {\n        let mut is_colliding = false;\n\
    \        for b in 0..n {\n            if b < a { continue }\n            let collision\
    \ = collision_checker(a, b, &mut is_colliding);\n            if collision { collision_count\
    \ += 1 }\n        }\n    }\n\n    collision_count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `collision_checker` in this scope\n\
    \  --> /tmp/tmpn8do7176.rs:20:29\n   |\n20 |             let collision = collision_checker(a,\
    \ b, &mut is_colliding);\n   |                             ^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8do7176.rs:25:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n25 | \
    \    collision_count\n   |     ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |     collision_count.try_into().unwrap()\n   |\
    \                    ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let num_cars = 2 * n - 1;\n    let mut collisions = 0;\
    \ // number of collisions\n    let speed = 1.0;\n    for car_number in 0..num_cars\
    \ {\n        let a = car_number % 2 * 1.0;\n        let b = car_number % n * 2.0;\n\
    \        let x = speed * a;\n        let y = speed * b;\n        if fabs(x) >\
    \ fabs(y) {\n            // collision occurs -- right to left collision\n    \
    \        collisions += 1;\n        }\n        if fabs(x) < fabs(y) {\n       \
    \     // collision occurs -- left to right collision\n            collisions +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `fabs` in this scope\n  --> /tmp/tmp_os5rclo.rs:18:12\n\
    \   |\n18 |         if fabs(x) > fabs(y) {\n   |            ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `fabs` in this scope\n  -->\
    \ /tmp/tmp_os5rclo.rs:18:22\n   |\n18 |         if fabs(x) > fabs(y) {\n   | \
    \                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `fabs` in this scope\n  --> /tmp/tmp_os5rclo.rs:22:12\n   |\n22 | \
    \        if fabs(x) < fabs(y) {\n   |            ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `fabs` in this scope\n  --> /tmp/tmp_os5rclo.rs:22:22\n\
    \   |\n22 |         if fabs(x) < fabs(y) {\n   |                      ^^^^ not\
    \ found in this scope\n\nerror[E0277]: cannot multiply `isize` by `{float}`\n\
    \  --> /tmp/tmp_os5rclo.rs:14:32\n   |\n14 |         let a = car_number % 2 *\
    \ 1.0;\n   |                                ^ no implementation for `isize * {float}`\n\
    \   |\n   = help: the trait `Mul<{float}>` is not implemented for `isize`\n  \
    \ = help: the following other types implement trait `Mul<Rhs>`:\n            \
    \ <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0277]:\
    \ cannot multiply `isize` by `{float}`\n  --> /tmp/tmp_os5rclo.rs:15:32\n   |\n\
    15 |         let b = car_number % n * 2.0;\n   |                             \
    \   ^ no implementation for `isize * {float}`\n   |\n   = help: the trait `Mul<{float}>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut car_collision_count\
    \ = 0;\n    let mut collision_sum = 0;\n    for i in 0..n {\n        let left_car\
    \ = i;\n        let right_car = (n - 1) - i;\n        if left_car == right_car\
    \ {\n            continue;\n        }\n        // If the left and right cars are\
    \ colliding, the sum will be non-zero.\n        collision_sum += collision(left_car,\
    \ right_car);\n        // The collision count is incremented by the number of\
    \ times the collision occured.\n        car_collision_count += 1;\n    }\n   \
    \ // Return the number of collisions.\n    car_collision_count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `collision` in this scope\n  --> /tmp/tmp1vuak1z0.rs:22:26\n\
    \   |\n22 |         collision_sum += collision(left_car, right_car);\n   |   \
    \                       ^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n\n    let mut c1 = rand::random::<i32>();\n\
    \    let mut c2 = rand::random::<i32>();\n\n    for _ in 0..n {\n        if c1\
    \ < c2 {\n            collisions += 1;\n            c1 += 1;\n        } else {\n\
    \            collisions += 1;\n            c2 -= 1;\n        }\n    }\n\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpa8cvagg7.rs:12:18\n   |\n12 |     let mut c1 = rand::random::<i32>();\n\
    \   |                  ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpa8cvagg7.rs:13:18\n\
    \   |\n13 |     let mut c2 = rand::random::<i32>();\n   |                  ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    fn add_collision(a:\
    \ &Vec<Vec<isize>>, b: &Vec<Vec<isize>>) {\n        let mut collision = collisions;\n\
    \        for a_vec of a {\n            for b_vec of b {\n                collision\
    \ += a_vec[*a_vec.len()..*a_vec.len() + a_vec.len() - 1].iter().cloned().count();\n\
    \                collision += b_vec[*b_vec.len()..*b_vec.len() + b_vec.len() -\
    \ 1].iter().cloned().count();\n            }\n        }\n        collisions +=\
    \ collision;\n    }\n    let mut car_a = Vec::new();\n    let mut car_b = Vec::new();\n\
    \    let mut car_c = Vec::new();\n    car_a.push(vec![1, 2, 3, 4, 5]);\n    car_b.push(vec![5,\
    \ 4, 3, 2, 1]);\n    add_collision(&car_a, &car_b);\n    add_collision(&car_a,\
    \ &car_c);\n    add_collision(&car_c, &car_b);\n    add_collision(&car_c, &car_a);\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpdursdr99.rs:13:19\n  \
    \ |\n13 |         for a_vec of a {\n   |                   ^^ help: try using\
    \ `in` here instead\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpdursdr99.rs:14:23\n\
    \   |\n14 |             for b_vec of b {\n   |                       ^^ help:\
    \ try using `in` here instead\n\nerror[E0434]: can't capture dynamic environment\
    \ in a fn item\n  --> /tmp/tmpdursdr99.rs:12:29\n   |\n12 |         let mut collision\
    \ = collisions;\n   |                             ^^^^^^^^^^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmpdursdr99.rs:19:9\n   |\n19 |       \
    \  collisions += collision;\n   |         ^^^^^^^^^^\n   |\n   = help: use the\
    \ `|| { ... }` closure form instead\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpdursdr99.rs:15:36\n   |\n15 |                 collision += a_vec[*a_vec.len()..*a_vec.len()\
    \ + a_vec.len() - 1].iter().cloned().count();\n   |                          \
    \          ^^^^^^^^^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpdursdr99.rs:15:50\n   |\n15 |                 collision += a_vec[*a_vec.len()..*a_vec.len()\
    \ + a_vec.len() - 1].iter().cloned().count();\n   |                          \
    \                        ^^^^^^^^^^^^\n\nerror[E0614]: type `usize` cannot be\
    \ dereferenced\n  --> /tmp/tmpdursdr99.rs:16:36\n   |\n16 |                 collision\
    \ += b_vec[*b_vec.len()..*b_vec.len() + b_vec.len() - 1].iter().cloned().count();\n\
    \   |                                    ^^^^^^^^^^^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmpdursdr99.rs:16:50\n   |\n16 |        \
    \         collision += b_vec[*b_vec.len()..*b_vec.len() + b_vec.len() - 1].iter().cloned().count();\n\
    \   |                                                  ^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 8 previous errors\n\nSome errors have detailed explanations:\
    \ E0434, E0614.\nFor more information about an error, try `rustc --explain E0434`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut collisions\
    \ = 1;\n    let mut max_time = 0;\n    // If the cars are travelling left to right,\
    \ we will see a collision\n    // if the cars are travelling right to left.\n\
    \    for _ in 0..n {\n        let speed = MAX_VELOCITY * 0.1;\n        collisions\
    \ += car_collision(n, speed);\n        if collisions > MAX_COLLISIONS {\n    \
    \        return MAX_COLLISIONS;\n        }\n        if collisions == MAX_COLLISIONS\
    \ {\n            return collisions;\n        }\n        // We don't have to worry\
    \ about collisions when a car is\n        // moving left to right, but we still\
    \ need to worry about collisions\n        // when we're moving left to right AND\
    \ right to left.\n        if n % 2 == 0 {\n            max_time = if n % 4 !=\
    \ 0 {\n                speed / MAX_VELOCITY * 4\n            } else {\n      \
    \          speed / MAX_VELOCITY * 2\n            };\n        } else {\n      \
    \      max_time = if n % 4 != 0 {\n                speed / MAX_VELOCITY * 4\n\
    \            } else if n % 2 == 0 {\n                speed / MAX_VELOCITY * 2\n\
    \            } else {\n                speed / MAX_VELOCITY * 3\n            };\n\
    \        }\n    }\n    return collisions;\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_VELOCITY` in this scope\n  --> /tmp/tmpc63reme7.rs:18:21\n\
    \   |\n18 |         let speed = MAX_VELOCITY * 0.1;\n   |                    \
    \ ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `car_collision`\
    \ in this scope\n  --> /tmp/tmpc63reme7.rs:19:23\n   |\n19 |         collisions\
    \ += car_collision(n, speed);\n   |                       ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `MAX_COLLISIONS` in this scope\n\
    \  --> /tmp/tmpc63reme7.rs:20:25\n   |\n20 |         if collisions > MAX_COLLISIONS\
    \ {\n   |                         ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_COLLISIONS` in this scope\n  --> /tmp/tmpc63reme7.rs:21:20\n\
    \   |\n21 |             return MAX_COLLISIONS;\n   |                    ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_COLLISIONS`\
    \ in this scope\n  --> /tmp/tmpc63reme7.rs:23:26\n   |\n23 |         if collisions\
    \ == MAX_COLLISIONS {\n   |                          ^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `MAX_VELOCITY` in this scope\n\
    \  --> /tmp/tmpc63reme7.rs:31:25\n   |\n31 |                 speed / MAX_VELOCITY\
    \ * 4\n   |                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_VELOCITY` in this scope\n  --> /tmp/tmpc63reme7.rs:33:25\n\
    \   |\n33 |                 speed / MAX_VELOCITY * 2\n   |                   \
    \      ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `MAX_VELOCITY` in this scope\n  --> /tmp/tmpc63reme7.rs:37:25\n   |\n37 |  \
    \               speed / MAX_VELOCITY * 4\n   |                         ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_VELOCITY` in\
    \ this scope\n  --> /tmp/tmpc63reme7.rs:39:25\n   |\n39 |                 speed\
    \ / MAX_VELOCITY * 2\n   |                         ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `MAX_VELOCITY` in this scope\n  -->\
    \ /tmp/tmpc63reme7.rs:41:25\n   |\n41 |                 speed / MAX_VELOCITY * "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    let mut collision_start_time\
    \ = 0;\n    let mut collision_end_time = 0;\n    let mut collision_time_left =\
    \ 0;\n    let mut collision_time_left_start = 0;\n    let mut collision_time_left_end\
    \ = 0;\n\n    for _ in 0..n {\n        // Find the collision time.\n        let\
    \ collision_time = collision_start_time + collision_time_left;\n\n        // Find\
    \ the total time it took between collisions.\n        let collision_time_total\
    \ = collision_time - collision_end_time;\n\n        // Find the number of collisions.\n\
    \        if collision_time_total < collision_time_total {\n            num_collisions\
    \ += 1;\n        }\n\n        // Find the start time.\n        if collision_time_total\
    \ == collision_time_total {\n            collision_time_start = collision_time;\n\
    \        }\n\n        // Find the end time.\n        if collision_time_total ==\
    \ collision_time_total + collision_time_left {\n            collision_end_time\
    \ = collision_time;\n        }\n\n        // Find the time left until the next\
    \ collision.\n        collision_time_left -= collision_time_total;\n    }\n\n\
    \    num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `collision_time_start` in this scope\n\
    \  --> /tmp/tmpoka8s61_.rs:31:13\n   |\n31 |             collision_time_start\
    \ = collision_time;\n   |             ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `collision_time_left`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut seen: HashMap<usize, isize> = HashMap::new();\n\
    \    let mut collisions: isize = 0;\n\n    for _ in 0..n {\n        let mut v\
    \ = random_uniform(&mut seen);\n        while !seen.contains_key(&v) {\n     \
    \       v = random_uniform(&mut seen);\n        }\n        seen.insert(v, 1);\n\
    \        if seen[v] == 1 {\n            collisions += 1;\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmptj7qyezp.rs:10:19\n\
    \   |\n10 |     let mut seen: HashMap<usize, isize> = HashMap::new();\n   |  \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmptj7qyezp.rs:10:43\n\
    \   |\n10 |     let mut seen: HashMap<usize, isize> = HashMap::new();\n   |  \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find function `random_uniform` in this scope\n \
    \ --> /tmp/tmptj7qyezp.rs:14:21\n   |\n14 |         let mut v = random_uniform(&mut\
    \ seen);\n   |                     ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `random_uniform` in this scope\n  --> /tmp/tmptj7qyezp.rs:16:17\n\
    \   |\n16 |             v = random_uniform(&mut seen);\n   |                 ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0412, E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count_collisions = 0;\n    for _ in 0..n {\n\
    \        let mut collide = false;\n        for _ in 0..n {\n            if collide\
    \ {\n                count_collisions += 1;\n                break 2;\n      \
    \      } else {\n                collide = true;\n            }\n        }\n \
    \   }\n    count_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0571]: `break` with value from a `for` loop\n  --> /tmp/tmpkis73usq.rs:16:17\n\
    \   |\n13 |         for _ in 0..n {\n   |         ------------- you can't `break`\
    \ with a value in a `for` loop\n...\n16 |                 break 2;\n   |     \
    \            ^^^^^^^ can only break with a value inside `loop` or breakable block\n\
    \   |\nhelp: use `break` on its own without a value inside this `for` loop\n \
    \  |\n16 |                 break;\n   |                 ~~~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0571`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..n).fold(0, |n, _| if n % 2 == 0 { n*n } else { n*(n+1)/2\
    \ })\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpk8g9q6_m.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..n).map(|x| {\n        0..n\n            .into_iter()\n\
    \            .map(|y| {\n                (0..n).map(|_| ())\n            })\n\
    \            .flatten()\n            .filter(|&i| i != x)\n            .count()\
    \ + i\n    }).sum()\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpcg78nlia.rs:18:24\n\
    \   |\n18 |             .count() + i\n   |                        ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0599]: `isize` is not an\
    \ iterator\n  --> /tmp/tmpcg78nlia.rs:12:14\n   |\n12 |             .into_iter()\n\
    \   |              ^^^^^^^^^ `isize` is not an iterator\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `isize: Iterator`\n \
    \          which is required by `isize: IntoIterator`\n           `&isize: Iterator`\n\
    \           which is required by `&isize: IntoIterator`\n           `&mut isize:\
    \ Iterator`\n           which is required by `&mut isize: IntoIterator`\n\nerror[E0277]:\
    \ the trait bound `isize: Sum<std::ops::Range<{integer}>>` is not satisfied\n\
    \    --> /tmp/tmpcg78nlia.rs:19:8\n     |\n19   |     }).sum()\n     |       \
    \ ^^^ the trait `Sum<std::ops::Range<{integer}>>` is not implemented for `isize`\n\
    \     |\n     = help: the following other types implement trait `Sum<A>`:\n  \
    \             <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n           \
    \    <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n               <i128\
    \ as Sum<&'a i128>>\n               <i128 as Sum>\n               <i16 as Sum<&'a\
    \ i16>>\n               <i16 as Sum>\n             and 20 others\nnote: required\
    \ by a bound in `std::iter::Iterator::sum`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n % 2 == 1 {\n        return 1;\n    }\n\n    // The\
    \ first collision occurs on the left, and the last collision occurs on the right\n\
    \    let mut collision = 0;\n\n    // Set up a table of distances.\n    // The\
    \ table will look like:\n    // [\n    //     [1, 2],\n    //     [3, 4],\n  \
    \  //     ...\n    // ]\n    // where each element of the array represents a path\
    \ from i to j.\n    let mut distances = vec![];\n\n    // Set up a table of cars\
    \ who are currently colliding.\n    // Each element in the vector represents the\
    \ set of people who are colliding.\n    let mut colliding_set = vec![];\n\n  \
    \  for i in 0..n {\n        // Initialize the distance to 0 for each person.\n\
    \        distances.push(vec![0i32; n]);\n    }\n\n    // Travel along the path,\
    \ starting from the leftmost person.\n    for j in 0..n {\n        // If the person\
    \ on the left has reached an intersection, increment the distance\n        //\
    \ count for that intersection.\n        if distances[j][i - 1] == 0 {\n      \
    \      collision += 1;\n        }\n\n        // Otherwise, check if anyone is\
    \ currently colliding.\n        if collision > 0 {\n            // If so, set\
    \ the cars colliding to the empty set.\n            colliding_set.clear();\n\n\
    \            // Then continue traveling along the other path.\n            continue;\n\
    \        }\n\n        // Otherwise, increment the distance count for the person\
    \ in the intersection and\n        // set the colliding set.\n        collision\
    \ += 1;\n        distances[j][i - 1] += 1;\n        colliding_set.push(i - 1);\n\
    \    }\n\n    // If none of the cars is colliding anymore, there's an even number\
    \ of collisions.\n    if collision == 0 {\n        return collision;\n    }\n\n\
    \    // Otherwise, the number of collisions is the number of people who are colliding.\n\
    \    return colliding_set.len();\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpm75k5qba.rs:40:25\n\
    \   |\n40 |         if distances[j][i - 1] == 0 {\n   |                      \
    \   ^ help: a local variable with a similar name exists: `j`\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmpm75k5qba.rs:56:22\n   |\n\
    56 |         distances[j][i - 1] += 1;\n   |                      ^ help: a local\
    \ variable with a similar name exists: `j`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpm75k5qba.rs:57:28\n   |\n57 |         colliding_set.push(i\
    \ - 1);\n   |                            ^ help: a local variable with a similar\
    \ name exists: `j`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm75k5qba.rs:33:35\n\
    \   |\n33 |         distances.push(vec![0i32; n]);\n   |                     \
    \              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    33 |         distances.push(vec![0i32; n.try_into().unwrap()]);\n   |        \
    \                            ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<i32>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpm75k5qba.rs:40:12\n   |\n40 |  \
    \       if distances[j][i - 1] == 0 {\n   |            ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<i32>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<i32>>`\n\nerror[E0277]: the type `[Vec<i32>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpm75k5qba.rs:56:9\n   |\n56 |         distances[j][i\
    \ - 1] += 1;\n   |         ^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<i32>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<i32>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm75"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Initialize variables to hold our cars.  We have no\
    \ cars initially so this is the\n    // same as 0.\n    let mut cars = Vec::new();\n\
    \    // Initialize the collided counter as zero.\n    let mut collided = 0.0;\n\
    \    // Now iterate through every car and check for a collision.\n    for i in\
    \ 0..n {\n        // Randomly pick a direction (either left or right)\n      \
    \  let direction = rand::random() < 0.5 ? -1 : 1;\n        // Add the new car\
    \ to the list of cars.\n        cars.push(Car::new(i, direction));\n        //\
    \ For each car, add itself to the list of cars it collides with.\n        cars.iter_mut().for_each(|c|\
    \ {\n            c.collisions.insert(c);\n        });\n        // Count the number\
    \ of collisions by iterating through the list of collisions.\n        collided\
    \ += cars.iter().filter_map(|c| c.collisions).filter(|c| c.is_some()).count();\n\
    \        // Remove the car from the list of cars it collides with.\n        cars\
    \ = cars.iter_mut().filter(|c| !c.collisions.contains(c)).collect();\n    }\n\
    \    // Return the number of collisions.  We expect this to be exactly n.\n  \
    \  collided\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `1`\n  --> /tmp/tmpqbcy6tyx.rs:18:53\n   |\n\
    18 |         let direction = rand::random() < 0.5 ? -1 : 1;\n   |            \
    \                                       - ^ expected type\n   |              \
    \                                     |\n   |                                \
    \                   tried to parse a type due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqbcy6tyx.rs:31:5\n   |\n9  | fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n31 |     collided\n   |     ^^^^^^^^ expected `isize`,\
    \ found floating-point number\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut left = true;\n\
    \    let mut right = true;\n\n    let mut left_car = left_car();\n    let mut\
    \ right_car = right_car();\n\n    for i in 0..n {\n        collisions += if left\
    \ && right_car.distance(&left_car) > 100 {\n            1\n        } else if !left\
    \ && left_car.distance(&right_car) > 100 {\n            1\n        } else {\n\
    \            0\n        };\n\n        if i == n - 1 {\n            left = false;\n\
    \        }\n        if i == 0 {\n            right = false;\n        }\n\n   \
    \     // Move the cars and check for collisions.\n        left_car.move();\n \
    \       right_car.move();\n        if left && right_car.collide(&left_car) {\n\
    \            collisions += 1;\n        }\n        if !left && left_car.collide(&right_car)\
    \ {\n            collisions += 1;\n        }\n    }\n\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `move`\n  --> /tmp/tmpa0wdb4fl.rs:34:18\n\
    \   |\n34 |         left_car.move();\n   |                  ^^^^ expected identifier,\
    \ found keyword\n   |\nhelp: escape `move` to use it as an identifier\n   |\n\
    34 |         left_car.r#move();\n   |                  ++\n\nerror: expected identifier,\
    \ found keyword `move`\n  --> /tmp/tmpa0wdb4fl.rs:35:19\n   |\n35 |         right_car.move();\n\
    \   |                   ^^^^ expected identifier, found keyword\n   |\nhelp: escape\
    \ `move` to use it as an identifier\n   |\n35 |         right_car.r#move();\n\
    \   |                   ++\n\nerror[E0425]: cannot find function `left_car` in\
    \ this scope\n  --> /tmp/tmpa0wdb4fl.rs:14:24\n   |\n14 |     let mut left_car\
    \ = left_car();\n   |                        ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `right_car` in this scope\n  --> /tmp/tmpa0wdb4fl.rs:15:25\n\
    \   |\n15 |     let mut right_car = right_car();\n   |                       \
    \  ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 2 {\n        return 0;\n    }\n    let mut collisions:\
    \ isize = 0;\n    let mut collide = 0;\n    for _ in 0..n {\n        let mut collide:\
    \ usize = 1;\n        for _ in 0..n {\n            if collide == n {\n       \
    \         break;\n            }\n            let mut collide = collide + 1;\n\
    \            if collide == n {\n                break;\n            }\n      \
    \  }\n        collisions = collisions + 1;\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpte2wwjri.rs:18:27\n   |\n\
    18 |             if collide == n {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |             if collide\
    \ == n.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpte2wwjri.rs:22:27\n   |\n22 |\
    \             if collide == n {\n   |                           ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |             if collide == n.try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut collisions\
    \ = 0;\n    for (left, right) in CAR_RACE_COLLISIONS.iter() {\n        if left\
    \ + 1 == right {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `CAR_RACE_COLLISIONS` in this scope\n \
    \ --> /tmp/tmpznje0vrm.rs:14:26\n   |\n14 |     for (left, right) in CAR_RACE_COLLISIONS.iter()\
    \ {\n   |                          ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collides = 0\n    for _ in 0..n {\n        for\
    \ _ in 0..n {\n            if car_collides(&mut collides) {\n                collides\
    \ += 1;\n                break;\n            }\n        }\n    }\n    collides\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpw9jjk3h1.rs:10:25\n\
    \   |\n10 |     let mut collides = 0\n   |                         ^ help: add\
    \ `;` here\n11 |     for _ in 0..n {\n   |     --- unexpected token\n\nerror[E0425]:\
    \ cannot find function `car_collides` in this scope\n  --> /tmp/tmpw9jjk3h1.rs:13:16\n\
    \   |\n13 |             if car_collides(&mut collides) {\n   |               \
    \ ^^^^^^^^^^^^ help: a local variable with a similar name exists: `collides`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for (i, &a) in a.iter().zip(b)\
    \ {\n        collisions += if (i == 0 || i == n) 1 else 0;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `1`\n  --> /tmp/tmpelxmsyx3.rs:12:45\n   |\n\
    12 |         collisions += if (i == 0 || i == n) 1 else 0;\n   |             \
    \          --                    ^ expected `{`\n   |                       |\n\
    \   |                       this `if` expression has a condition, but no block\n\
    \   |\nhelp: try placing this code inside a block\n   |\n12 |         collisions\
    \ += if (i == 0 || i == n) { 1 } else 0;\n   |                               \
    \              +   +\n\nerror[E0425]: cannot find value `a` in this scope\n  -->\
    \ /tmp/tmpelxmsyx3.rs:11:20\n   |\n11 |     for (i, &a) in a.iter().zip(b) {\n\
    \   |                    ^ help: a local variable with a similar name exists:\
    \ `n`\n\nerror[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpelxmsyx3.rs:11:33\n\
    \   |\n11 |     for (i, &a) in a.iter().zip(b) {\n   |                       \
    \          ^ help: a local variable with a similar name exists: `n`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut race_collisions: Vec<usize> = Vec::new();\n \
    \   for _ in 0..n {\n        // Simulate the first car.\n        // First move\
    \ right and left at the same time.\n        // Do this n times.\n        for _\
    \ in 0..n {\n            // Move left and right at the same time.\n          \
    \  // Do this n times.\n            for _ in 0..n {\n                // Move left\
    \ and right at the same time.\n                // Do this n times.\n         \
    \       for _ in 0..n {\n                    // Move left and right at the same\
    \ time.\n                    // Do this n times.\n                    for _ in\
    \ 0..n {\n                        // Move left and right at the same time.\n \
    \                       // Do this n times.\n                        let mut collision_counter\
    \ = 0;\n                        for _ in 0..n {\n                            let\
    \ x = rand::random::<i32>();\n                            let y = rand::random::<i32>();\n\
    \                            if x == y {\n                                collision_counter++;\n\
    \                            }\n                        }\n                  \
    \      if collision_counter > 1 {\n                            race_collisions.push(collision_counter);\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    race_collisions.iter().filter(|&x| x > 1).count()\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpa2n0jcfp.rs:32:50\n\
    \   |\n32 | ...                   collision_counter++;\n   |                 \
    \                       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n32 |                                 { let tmp = collision_counter;\
    \ collision_counter += 1; tmp };\n   |                                 +++++++++++\
    \                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n32 -                     \
    \            collision_counter++;\n32 +                                 collision_counter\
    \ += 1;\n   | \n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `rand`\n  --> /tmp/tmpa2n0jcfp.rs:29:37\n   |\n29 | ...             \
    \      let x = rand::random::<i32>();\n   |                               ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpa2n0jcfp.rs:30:37\n\
    \   |\n30 | ...                   let y = rand::random::<i32>();\n   |       \
    \                        ^^^^ use of undeclared crate or module `rand`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa2n0jcfp.rs:43:44\n   |\n43 |     race_collisions.iter().filter(|&x|\
    \ x > 1).count()\n   |                                            ^\n   |    \
    \                                        |\n   |                             \
    \               expected `&usize`, found integer\n   |                       \
    \                     help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa2n0jcfp.rs:43:5\n   |\n9  | fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n43 |     race_collisions.iter().filter(|&x| x > 1).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n43 |     race_collisions.iter().filter(|&x|\
    \ x > 1).count().try_into().unwrap()\n   |                                   \
    \              "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0\n\n    // For each pair of cars, figure\
    \ out how far the cars are from each other.\n    for i in 0..n {\n        // Cars\
    \ 0 and 1 are at the same position, because cars 0 and 2 are at positions 0 and\
    \ 2.\n        let car_0 = i / n;\n        let car_1 = (i + 1) / n;\n        let\
    \ car_2 = (i + 2) / n;\n\n        // For cars 0 and 2, compare them to see how\
    \ far they are from each other.\n        if car_1 == car_2 {\n            continue;\n\
    \        }\n\n        let distance = car_0 - car_1;\n\n        // The speed at\
    \ which cars 0 and 2 are moving together is less than the\n        // speed at\
    \ which cars 1 and 2 are moving together.\n        if distance < car_2 {\n   \
    \         count += 1;\n        }\n    }\n\n    return count;\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpjiuvc2yq.rs:10:22\n\
    \   |\n10 |     let mut count = 0\n   |                      ^ help: add `;` here\n\
    ...\n13 |     for i in 0..n {\n   |     --- unexpected token\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n * (n + 1)) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp2vtlp0v5.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut previous_speed:\
    \ f32 = 200.;\n\n    for i in 0..n {\n        let mut speed = previous_speed;\n\
    \        previous_speed += 100.;\n\n        // if there is a car that is in the\
    \ middle of colliding with another,\n        // then we have a collision.\n  \
    \      if speed > previous_speed {\n            collisions += 1;\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmprg7tlprz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpcj84d5xn.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let n = n as u32;\n\n    let mut collision_count = 0isize;\n\
    \n    // let mut collision_count: isize = 0;\n    // let collision_count: isize\
    \ = 100;\n\n    for _ in 0..n {\n        let mut is_collided = true;\n\n     \
    \   for _ in 0..n {\n            // if collision_count == n {\n            //\
    \     collision_count = 0isize;\n            //     is_collided = false;\n   \
    \         // }\n\n            // if collision_count > n {\n            //    \
    \ collision_count = 0;\n            //     is_collided = false;\n            //\
    \ }\n\n            // if collision_count == 0 {\n            //     collision_count\
    \ = 1;\n            //     is_collided = false;\n            // }\n\n        \
    \    // if collision_count == n - 1 {\n            //     collision_count = n\
    \ + 1;\n            //     is_collided = false;\n            // }\n\n        \
    \    if is_collided {\n                collision_count = collision_count + 1;\n\
    \                break;\n            }\n        }\n    }\n\n    // if collision_count\
    \ == n {\n    //     collision_count = 0isize;\n    // }\n\n    // return collision_count;\n\
    \n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx0b_5_pc.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut i = 0;\n    while\
    \ i < n {\n        let j = i + 1;\n        while j < n {\n            let mut\
    \ collision_count = 1;\n            while collision_count > 0 {\n            \
    \    let mut j: usize = 0;\n                while j < n && car_collision(&mut\
    \ i, &mut j, &mut collision_count) {\n                    j += 1;\n          \
    \          collision_count += 1;\n                }\n                j += 1;\n\
    \            }\n            collisions += collision_count;\n            i += 1;\n\
    \        }\n        i += 1;\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmp48qja_py.rs:18:32\n   |\n18 |                 while j < n && car_collision(&mut\
    \ i, &mut j, &mut collision_count) {\n   |                                ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp48qja_py.rs:18:27\n\
    \   |\n18 |                 while j < n && car_collision(&mut i, &mut j, &mut\
    \ collision_count) {\n   |                           ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |                 while j < n.try_into().unwrap()\
    \ && car_collision(&mut i, &mut j, &mut collision_count) {\n   |             \
    \               ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut collisions\
    \ = 0;\n    for _ in 0..n {\n        let mut cars = [0; n];\n        for &mut\
    \ i in 0..n {\n            cars[i] = i;\n        }\n        // find out which\
    \ car collides with which car\n        for &i in &mut cars.iter_mut() {\n    \
    \        for &j in &mut cars.iter_mut() {\n                if i != j && j != i\
    \ {\n                    if car_collision(&i, &j, &mut cars) == 1 {\n        \
    \                collisions += 1;\n                    }\n                }\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpcd8e0263.rs:15:28\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n...\n15 | \
    \        let mut cars = [0; n];\n   |                            ^\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmpcd8e0263.rs:23:24\n\
    \   |\n23 |                     if car_collision(&i, &j, &mut cars) == 1 {\n \
    \  |                        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcd8e0263.rs:16:13\n   |\n16 |         for &mut\
    \ i in 0..n {\n   |             ^^^^^^    ---- this expression has type `Option<isize>`\n\
    \   |             |\n   |             expected `isize`, found `&mut _`\n   | \
    \            help: you can probably remove the explicit borrow: `i`\n   |\n  \
    \ = note:           expected type `isize`\n           found mutable reference\
    \ `&mut _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcd8e0263.rs:20:13\n\
    \   |\n20 |         for &i in &mut cars.iter_mut() {\n   |             ^^    --------------------\
    \ this expression has type `Option<&mut {integer}>`\n   |             |\n   |\
    \             types differ in mutability\n   |             help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note: expected mutable reference\
    \ `&mut {integer}`\n                      found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcd8e0263.rs:21:17\n   |\n21 |             for\
    \ &j in &mut cars.iter_mut() {\n   |                 ^^    --------------------\
    \ this expression has type `Option<&mut {integer}>`\n   |                 |\n\
    \   |                 types differ in mutability\n   |                 help: you\
    \ can probably remove the explicit borrow: `j`\n   |\n   = note: expected mutable\
    \ reference `&mut {integer}`\n                      found reference `&_`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0435.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut positions = [0;\
    \ n];\n    let mut speeds = [0; n];\n\n    for car in 0..n {\n        // Initialize\
    \ the position and speed.\n        positions[car] = 0.0;\n        speeds[car]\
    \ = 0.0;\n\n        // Keep simulating to a steady state.\n        loop {\n  \
    \          // Calculate the new position and speed.\n            for index in\
    \ 0..(car + 1) - n {\n                positions[index] += speeds[index];\n   \
    \         }\n            let new_speed = positions[car].copy();\n            for\
    \ index in 0..(car + 1) - n {\n                speeds[index] += (positions[index]\
    \ - new_speed);\n            }\n            // Check if we've hit our goal (no\
    \ collision).\n            if positions[car].abs() > 100 {\n                collisions\
    \ += 1;\n                break;\n            }\n            // Check if we've\
    \ hit the wall (collision).\n            if speeds[car].abs() > 100.0 * 9.8 {\n\
    \                collisions += 1;\n                break;\n            }\n   \
    \     }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpb0dqc7hw.rs:11:29\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n10 |     let\
    \ mut collisions = 0;\n11 |     let mut positions = [0; n];\n   |            \
    \                 ^\n\nerror[E0435]: attempt to use a non-constant value in a\
    \ constant\n  --> /tmp/tmpb0dqc7hw.rs:12:26\n   |\n9  | fn car_race_collision(n:\
    \ isize) -> isize {\n   |                       - this would need to be a `const`\n\
    ...\n12 |     let mut speeds = [0; n];\n   |                          ^\n\nwarning:\
    \ unnecessary parentheses around assigned value\n  --> /tmp/tmpb0dqc7hw.rs:27:34\n\
    \   |\n27 |                 speeds[index] += (positions[index] - new_speed);\n\
    \   |                                  ^                            ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n27 -                 speeds[index] += (positions[index] - new_speed);\n\
    27 +                 speeds[index] += positions[index] - new_speed;\n   | \n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0435`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for m in 0..n {\n\
    \        for n in 0..n {\n            let mut collision = true;\n            if\
    \ m < n {\n                // If this car has moved left to the right side of\
    \ the other car, collide\n                if m > 0 && m+1 < n {\n            \
    \        collision = car_collision(&mut m, &mut n, &mut n, &mut n);\n        \
    \        }\n            }\n            if n > m {\n                // If this\
    \ car has moved right to the left side of the other car, collide\n           \
    \     if n > 0 && n-1 < m {\n                    collision = car_collision(&mut\
    \ n, &mut m, &mut n, &mut n);\n                }\n            }\n            if\
    \ collision {\n                // One car has collided with another car in the\
    \ previous iteration\n                collisions += 1;\n            }\n      \
    \  }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpechyp58c.rs:17:33\n   |\n17 |                     collision = car_collision(&mut\
    \ m, &mut n, &mut n, &mut n);\n   |                                 ^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `collision`\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmpechyp58c.rs:23:33\n\
    \   |\n23 |                     collision = car_collision(&mut n, &mut m, &mut\
    \ n, &mut n);\n   |                                 ^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `collision`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![Car::new(); n];\n    let mut collided_left\
    \ = 0;\n    let mut collided_right = 0;\n    let mut collided_total = 0;\n   \
    \ let mut collisions = 0;\n    // Simulate the road for n iterations, starting\
    \ with cars moving left to\n    // right\n    for _ in 0..n {\n        for (car_index,\
    \ car) in cars.iter_mut().enumerate() {\n            let collided = car.collide(&mut\
    \ cars);\n            if !collided {\n                cars[car_index] = Car::new();\n\
    \                collisions += 1;\n                continue;\n            }\n\
    \            if car.x > cars[car_index].x {\n                cars[car_index].x\
    \ += 1;\n            }\n            if car.x < cars[car_index].x {\n         \
    \       cars[car_index].x -= 1;\n            }\n            collided_total +=\
    \ 1;\n            if car.x > cars[car_index].x {\n                collided_left\
    \ += 1;\n            }\n            if car.x < cars[car_index].x {\n         \
    \       collided_right += 1;\n            }\n        }\n    }\n    collided_total\
    \ += collided_left + collided_right;\n    collided_total\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmp__ci8e0m.rs:10:25\n\
    \   |\n10 |     let mut cars = vec![Car::new(); n];\n   |                    \
    \     ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Car`\n  --> /tmp/tmp__ci8e0m.rs:21:35\n   |\n21 |      \
    \           cars[car_index] = Car::new();\n   |                              \
    \     ^^^ use of undeclared type `Car`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp__ci8e0m.rs:10:37\n   |\n10 |     let mut cars = vec![Car::new(); n];\n\
    \   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n10 |     let mut cars = vec![Car::new(); n.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Compute the distance between the two sets.\n    let\
    \ mut min_x = 10000;\n    let mut max_x = -10000; // Assume no cars collide\n\
    \    for car in 0..n {\n        let x = car_x_distance(car);\n        if min_x\
    \ < x {\n            min_x = x;\n        }\n        if max_x > x {\n         \
    \   max_x = x;\n        }\n    }\n\n    // Compute the largest distance car can\
    \ move and divide it by the distance\n    // of one car in the other set.\n  \
    \  let mut movement_radius = max_x / n;\n    if movement_radius < MIN_SPEED*2\
    \ {\n        // Can't move any further.\n        return 0;\n    }\n    movement_radius\
    \ = movement_radius / n;\n\n    // Move each car as far as possible within the\
    \ allowed speed.\n    let mut collisions = 0;\n    for car in 0..n {\n       \
    \ // Start at far left of car and move to the right until no collision.\n    \
    \    let x = car_x_distance(car) * movement_radius;\n        while car_x_distance(car)\
    \ + x < min_x {\n            x += car_x_distance(car);\n        }\n        while\
    \ car_x_distance(car) + x > max_x {\n            x -= car_x_distance(car);\n \
    \       }\n        car.x = x;\n        if car_collide(car, n - 1) {\n        \
    \    collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_x_distance` in this scope\n  -->\
    \ /tmp/tmpsnt4eo2o.rs:14:17\n   |\n14 |         let x = car_x_distance(car);\n\
    \   |                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MIN_SPEED` in this scope\n  --> /tmp/tmpsnt4eo2o.rs:26:26\n\
    \   |\n26 |     if movement_radius < MIN_SPEED*2 {\n   |                     \
    \     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `car_x_distance` in this scope\n  --> /tmp/tmpsnt4eo2o.rs:36:17\n   |\n36 |\
    \         let x = car_x_distance(car) * movement_radius;\n   |               \
    \  ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `car_x_distance` in this scope\n  --> /tmp/tmpsnt4eo2o.rs:37:15\n   |\n37 |\
    \         while car_x_distance(car) + x < min_x {\n   |               ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_x_distance`\
    \ in this scope\n  --> /tmp/tmpsnt4eo2o.rs:38:18\n   |\n38 |             x +=\
    \ car_x_distance(car);\n   |                  ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `car_x_distance` in this scope\n\
    \  --> /tmp/tmpsnt4eo2o.rs:40:15\n   |\n40 |         while car_x_distance(car)\
    \ + x > max_x {\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `car_x_distance` in this scope\n  --> /tmp/tmpsnt4eo2o.rs:41:18\n\
    \   |\n41 |             x -= car_x_distance(car);\n   |                  ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_collide`\
    \ in this scope\n  --> /tmp/tmpsnt4eo2o.rs:44:12\n   |\n44 |         if car_collide(car,\
    \ n - 1) {\n   |            ^^^^^^^^^^^ not found in this scope\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpsnt4eo2o.rs:43:13\n\
    \   |\n43 |         car.x = x;\n   |             ^\n\nerror: aborting due to 9\
    \ previous errors\n\nSome errors have detailed explanations: E0425, E0610.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut n\
    \ = 0;\n    let mut max_speed = 1_000_000_000.0;\n    let mut min_speed = 0.0;\n\
    \    let mut last_collision_x = -1;\n    let mut last_collision_y = -1;\n\n  \
    \  for x in 1..n {\n        for y in 1..n {\n            let distance = std::f64::sqrt((x\
    \ - last_collision_x) * (x - last_collision_x) + (y - last_collision_y) * (y -\
    \ last_collision_y));\n            if distance > max_speed {\n               \
    \ max_speed = distance;\n            }\n            if distance < min_speed {\n\
    \                min_speed = distance;\n            }\n        }\n    }\n    min_speed\
    \ = std::f64::sqrt(min_speed);\n    for x in 1..n {\n        for y in 1..n {\n\
    \            let distance = std::f64::sqrt((x - last_collision_x) * (x - last_collision_x)\
    \ + (y - last_collision_y) * (y - last_collision_y));\n            if distance\
    \ < min_speed {\n                n += 1;\n            }\n        }\n    }\n  \
    \  n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in module `std::f64`\n  --> /tmp/tmpy6hzoxiv.rs:21:38\n\
    \   |\n21 | ...   let distance = std::f64::sqrt((x - last_collision_x) * (x -\
    \ last_collision_x) + (y - last_collision_y) * (y - last_collision_y));\n   |\
    \                                ^^^^ not found in `std::f64`\n\nerror[E0425]:\
    \ cannot find function `sqrt` in module `std::f64`\n  --> /tmp/tmpy6hzoxiv.rs:30:27\n\
    \   |\n30 |     min_speed = std::f64::sqrt(min_speed);\n   |                 \
    \          ^^^^ not found in `std::f64`\n\nerror[E0425]: cannot find function\
    \ `sqrt` in module `std::f64`\n  --> /tmp/tmpy6hzoxiv.rs:33:38\n   |\n33 | ...\
    \   let distance = std::f64::sqrt((x - last_collision_x) * (x - last_collision_x)\
    \ + (y - last_collision_y) * (y - last_collision_y));\n   |                  \
    \              ^^^^ not found in `std::f64`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).filter(|&i| i % 2 == 0).count() + 2 * (n - 1)\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnt4uyri.rs:10:46\n   |\n\
    10 |     (1..n).filter(|&i| i % 2 == 0).count() + 2 * (n - 1)\n   |          \
    \                                    ^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxnt4uyri.rs:10:5\n   |\n9  | fn\
    \ car_race_collision(n: isize) -> isize {\n   |                              \
    \      ----- expected `isize` because of return type\n10 |     (1..n).filter(|&i|\
    \ i % 2 == 0).count() + 2 * (n - 1)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     ((1..n).filter(|&i|\
    \ i % 2 == 0).count() + 2 * (n - 1)).try_into().unwrap()\n   |     +         \
    \                                           +++++++++++++++++++++\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmpxnt4uyri.rs:10:44\n   |\n10 | \
    \    (1..n).filter(|&i| i % 2 == 0).count() + 2 * (n - 1)\n   |              \
    \                              ^ no implementation for `usize + isize`\n   |\n\
    \   = help: the trait `Add<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // For simplicity, our code assumes there is a single\
    \ direction that's not changing\n    // during the course of the race.\n    //\
    \ For example: if the two cars are driving right to left, the\n    // first car\
    \ can move right and collide with the second car which moves left.\n    // This\
    \ is not realistic.  But for this demonstration, we'll assume there is only one\n\
    \    // direction.\n    let mut collision_count = 0;\n    let collision_directions\
    \ = vec![];\n    let mut collided_with = vec![];\n\n    // For each possible starting\
    \ position of two cars, find the distance between them.\n    for i in 0..n {\n\
    \        let start_position = vec![i as u8, (i + 1) as u8];\n        let end_position\
    \ = vec![i as u8, (i + n + 1) as u8];\n        let start_pos = Position::from_u8_slice((start_position\
    \ as *const u8).to_vec());\n        let end_pos = Position::from_u8_slice((end_position\
    \ as *const u8).to_vec());\n        let start_dir = Direction::from_u8_slice((start_position\
    \ as *const u8).to_vec());\n        let end_dir = Direction::from_u8_slice((end_position\
    \ as *const u8).to_vec());\n        let start_pos_dir = Position::from_u8_slice((start_dir\
    \ as *const u8).to_vec());\n        let end_pos_dir = Position::from_u8_slice((end_dir\
    \ as *const u8).to_vec());\n        let distance = start_pos.distance(end_pos);\n\
    \        let distance_dir = start_pos_dir.distance(end_pos_dir);\n        collision_count\
    \ += distance + distance_dir;\n        collision_directions.push(start_dir);\n\
    \        collision_directions.push(end_dir);\n        collided_with.push(i);\n\
    \        collided_with.push(i + n);\n    }\n\n    // If any of the possible starting\
    \ positions moves more than 5 pixels from\n    // their original positions (i.e.\
    \ the two cars collide), then we know that the\n    // race is over.\n    for\
    \ pos in collision_directions.iter() {\n        if *pos == Direction::Down ||\
    \ \n            *pos == Direction::Up ||\n            *pos == Direction::Right\
    \ || \n            *pos == Direction::Left {\n            collision_count += 5;\n\
    \        }\n    }\n\n    // Now that we have a count of how many cars collide,\
    \ check whether any of them are also \n    // colliding with the cars that started\
    \ the race (to ensure we don't have more than \n    // one car in the same position\
    \ at the same time).\n    // If the race is over and none of them are colliding\
    \ with the cars that started the race,\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Position`\n  -->\
    \ /tmp/tmp6ottjq68.rs:24:25\n   |\n24 |         let start_pos = Position::from_u8_slice((start_position\
    \ as *const u8).to_vec());\n   |                         ^^^^^^^^ use of undeclared\
    \ type `Position`\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n\
    \  --> /tmp/tmp6ottjq68.rs:25:23\n   |\n25 |         let end_pos = Position::from_u8_slice((end_position\
    \ as *const u8).to_vec());\n   |                       ^^^^^^^^ use of undeclared\
    \ type `Position`\n\nerror[E0433]: failed to resolve: use of undeclared type `Direction`\n\
    \  --> /tmp/tmp6ottjq68.rs:26:25\n   |\n26 |         let start_dir = Direction::from_u8_slice((start_position\
    \ as *const u8).to_vec());\n   |                         ^^^^^^^^^ use of undeclared\
    \ type `Direction`\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `Direction`\n  --> /tmp/tmp6ottjq68.rs:27:23\n   |\n27 |         let end_dir\
    \ = Direction::from_u8_slice((end_position as *const u8).to_vec());\n   |    \
    \                   ^^^^^^^^^ use of undeclared type `Direction`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Position`\n  --> /tmp/tmp6ottjq68.rs:28:29\n\
    \   |\n28 |         let start_pos_dir = Position::from_u8_slice((start_dir as\
    \ *const u8).to_vec());\n   |                             ^^^^^^^^ use of undeclared\
    \ type `Position`\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n\
    \  --> /tmp/tmp6ottjq68.rs:29:27\n   |\n29 |         let end_pos_dir = Position::from_u8_slice((end_dir\
    \ as *const u8).to_vec());\n   |                           ^^^^^^^^ use of undeclared\
    \ type `Position`\n\nerror[E0433]: failed to resolve: use of undeclared type `Direction`\n\
    \  --> /tmp/tmp6ottjq68.rs:43:20\n   |\n43 |         if *pos == Direction::Down\
    \ || \n   |                    ^^^^^^^^^ use of undeclared type `Direction`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmp6ottjq68.rs:44:21\n\
    \   |\n44 |             *pos == Direction::Up ||\n   |                     ^^^^^^^^^\
    \ use of undeclared type `D"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0\n    }\n\n    let mut collision\
    \ = 0\n    let mut cars = vec![];\n    for _ in range(n) {\n        let new_car\
    \ = generate_car()\n            .unwrap()\n            .clone()\n            .into_iter()\n\
    \            .cloned()\n            .collect();\n        cars.push(new_car);\n\
    \        collision += car_race_collision(&new_car).unwrap();\n    }\n    collision\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp57egb2x5.rs:14:26\n\
    \   |\n14 |     let mut collision = 0\n   |                          ^ help: add\
    \ `;` here\n15 |     let mut cars = vec![];\n   |     --- unexpected token\n\n\
    error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmp57egb2x5.rs:16:14\n\
    \   |\n16 |     for _ in range(n) {\n   |              ^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n\
    \   |\n\nerror[E0425]: cannot find function `generate_car` in this scope\n  -->\
    \ /tmp/tmp57egb2x5.rs:17:23\n   |\n17 |         let new_car = generate_car()\n\
    \   |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp57egb2x5.rs:24:41\n   |\n24 |         collision\
    \ += car_race_collision(&new_car).unwrap();\n   |                            \
    \             ^^^^^^^^ expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\nhelp: consider removing the borrow\n\
    \   |\n24 -         collision += car_race_collision(&new_car).unwrap();\n24 +\
    \         collision += car_race_collision(new_car).unwrap();\n   | \n\nerror[E0599]:\
    \ no method named `unwrap` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp57egb2x5.rs:24:51\n   |\n24 |         collision += car_race_collision(&new_car).unwrap();\n\
    \   |                                                   ^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    while i <\
    \ n {\n        let car_right = i / n;\n        let car_left = i - car_right;\n\
    \        if car_left == car_right {\n            count += 1;\n        }\n    \
    \    if car_right - car_left <= 2 {\n            count += 1;\n        }\n    \
    \    i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpt8ggmrwn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut car_collisions\
    \ = 0;\n    let mut car_speeds = vec![1.0_f64; n];\n    let mut car_angles = vec![0.0_f64;\
    \ n];\n    let mut car_angle_diffs = vec![0.0_f64; n];\n    let mut car_angle_prev\
    \ = 0.0_f64;\n\n    for i in 0..n {\n        car_speeds[i] = 2.0_f64;\n      \
    \  car_angles[i] = 0.0_f64;\n        car_angle_diffs[i] = 0.0_f64;\n    }\n\n\
    \    while car_collisions < n {\n        // Find the two car with the smallest\
    \ absolute angle difference.\n        let min_idx = car_angle_diffs.iter().min_unwrap_or(n\
    \ - 1);\n        assert!(min_idx != -1);\n        let min_diff = car_angle_diffs[min_idx];\n\
    \        let min_idx = min_idx % n;\n        let min_angle = car_angles[min_idx];\n\
    \        let min_angle_diff = car_angle_diffs[min_idx];\n        let min_speed\
    \ = car_speeds[min_idx];\n\n        let speed = min_speed * 2.0_f64;\n\n     \
    \   for i in 0..n {\n            let diff = (2.0_f64 * f64::from(min_angle_diff)\
    \ + 1.0_f64 * f64::from(min_speed)) - 2.0_f64 * f64::from(min_angle);\n      \
    \      car_angle_diffs[i] = diff * f64::from(min_diff) + 1.0_f64 * f64::from(speed);\n\
    \n            if i != min_idx {\n                // If this doesn't work, the\
    \ cars collide.\n                let angle = min_angle + car_angle_diffs[i] -\
    \ min_angle;\n                if f64::from(angle) > f64::from(0.0_f64) {\n   \
    \                 car_collisions += 1;\n                }\n            }\n   \
    \     }\n        car_angle_prev = 0.0_f64;\n        for i in 0..n {\n        \
    \    let angle = (min_angle + car_angle_diffs[i]) - min_angle;\n            car_angle_prev\
    \ += car_angles[i];\n            if f64::from(angle) > f64::from(0.0_f64) {\n\
    \                car_collisions += 1;\n            }\n        }\n    }\n\n   \
    \ car_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpirzyldap.rs:14:40\n   |\n\
    14 |     let mut car_speeds = vec![1.0_f64; n];\n   |                        \
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    14 |     let mut car_speeds = vec![1.0_f64; n.try_into().unwrap()];\n   |    \
    \                                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpirzyldap.rs:15:40\n   |\n15 |     let mut car_angles =\
    \ vec![0.0_f64; n];\n   |                                        ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |     let mut car_angles = vec![0.0_f64;\
    \ n.try_into().unwrap()];\n   |                                         ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpirzyldap.rs:16:45\n   |\n16 |\
    \     let mut car_angle_diffs = vec![0.0_f64; n];\n   |                      \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n16 |     let mut car_angle_diffs = vec![0.0_f64; n.try_into().unwrap()];\n\
    \   |                                              ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[f64]` cannot be indexed by `isize`\n  --> /tmp/tmpirzyldap.rs:20:9\n\
    \   |\n20 |         car_speeds[i] = 2.0_f64;\n   |         ^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[f64]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpirzyldap.rs:21:9\n   |\n21 |   \
    \      car_angles[i] = 0.0_f64;\n   |         ^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>`\
    \ is not implemented for "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut previous =\
    \ -1;\n    let mut distance = 0;\n    let mut first_collision = true;\n    let\
    \ mut last_collision = true;\n\n    for _ in 0..n {\n        let mut new_distance\
    \ = distance;\n        // Find the next car to collide with\n        for car in\
    \ 0..n {\n            // If the car is moving left to right, find it moving right\
    \ to left\n            if new_distance > distance {\n                if previous\
    \ == car - 1 {\n                    new_distance += 100;\n                   \
    \ continue;\n                }\n                if last_collision && first_collision\
    \ {\n                    collision_count++;\n                    new_distance\
    \ = distance;\n                    last_collision = false;\n                 \
    \   first_collision = true;\n                }\n            }\n            //\
    \ If the car is moving right to left, find it moving left to right\n         \
    \   if new_distance < distance {\n                if previous == car + 1 {\n \
    \                   new_distance -= 100;\n                    continue;\n    \
    \            }\n                if first_collision && last_collision {\n     \
    \               collision_count++;\n                    new_distance = distance;\n\
    \                    first_collision = false;\n                    last_collision\
    \ = true;\n                }\n            }\n        }\n        // Find the car\
    \ furthest away\n        if distance < new_distance {\n            distance =\
    \ new_distance;\n        }\n        previous = -1;\n    }\n\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfcliq9h2.rs:27:36\n\
    \   |\n27 |                     collision_count++;\n   |                     \
    \               ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n27 |                     { let tmp = collision_count; collision_count +=\
    \ 1; tmp };\n   |                     +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    27 -                     collision_count++;\n27 +                     collision_count\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpfcliq9h2.rs:40:36\n\
    \   |\n40 |                     collision_count++;\n   |                     \
    \               ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n40 |                     { let tmp = collision_count; collision_count +=\
    \ 1; tmp };\n   |                     +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    40 -                     collision_count++;\n40 +                     collision_count\
    \ += 1;\n   | \n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = n;\n    for _ in 0..n {\n      \
    \  let mut collisions = 1;\n        for _ in 0..n {\n            // if one car\
    \ has collided with the next car then both of the\n            // cars are colliding\
    \ at this time so increment the collisions by\n            // 1\n            if\
    \ collisions == 1 {\n                collisions += 1;\n            }\n       \
    \ }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwypalmh8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n    let mut n = n;\n    let mut\
    \ collision = false;\n    while n != 0 {\n        let collision = collision ||\
    \ car_race_collision_aux(n);\n        if collision {\n            counter++;\n\
    \            n -= 1;\n        }\n        n += 1;\n    }\n    counter\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp5zgqcfb7.rs:16:20\n\
    \   |\n16 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    16 -             counter++;\n16 +             counter += 1;\n   | \n\nerror[E0425]:\
    \ cannot find function `car_race_collision_aux` in this scope\n  --> /tmp/tmp5zgqcfb7.rs:14:38\n\
    \   |\n14 |         let collision = collision || car_race_collision_aux(n);\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n = 0;\n    for k in 0..n {\n        let j =\
    \ k + n;\n        let mut c = false;\n        for i in 0..n {\n            if\
    \ i != j {\n                if distance_from_start(&i, &j) == distance_from_start(&i,\
    \ &k) + distance_from_start(&j, &k) {\n                    c = true;\n       \
    \             break;\n                }\n            }\n        }\n        if\
    \ c {\n            n = j;\n        }\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `distance_from_start` in this scope\n\
    \  --> /tmp/tmpul9di6dz.rs:16:20\n   |\n16 |                 if distance_from_start(&i,\
    \ &j) == distance_from_start(&i, &k) + distance_from_start(&j, &k) {\n   |   \
    \                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `distance_from_start` in this scope\n  --> /tmp/tmpul9di6dz.rs:16:51\n\
    \   |\n16 |                 if distance_from_start(&i, &j) == distance_from_start(&i,\
    \ &k) + distance_from_start(&j, &k) {\n   |                                  \
    \                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `distance_from_start` in this scope\n  --> /tmp/tmpul9di6dz.rs:16:81\n\
    \   |\n16 |                 if distance_from_start(&i, &j) == distance_from_start(&i,\
    \ &k) + distance_from_start(&j, &k) {\n   |                                  \
    \                                               ^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n\n    for _ in 0..n {\n\
    \        let collision_count = if n <= 1 {\n            collision_count + 1\n\
    \        } else {\n            collision_count + car_race_collision(n - 1)\n \
    \       };\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpqmh4pkpl.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 1;\n    let mut collisions = 0;\n   \
    \ let mut speed_left = 0;\n    let mut speed_right = 0;\n    let mut left_car:\
    \ Option<&mut Car> = None;\n    let mut right_car: Option<&mut Car> = None;\n\
    \    while count < n {\n        let left_car = left_car.take().expect(\"left car\
    \ not found\");\n        let right_car = right_car.take().expect(\"right car not\
    \ found\");\n        let speed_left = left_car.speed();\n        let speed_right\
    \ = right_car.speed();\n        if speed_left < speed_right {\n            left_car.speed(speed_left\
    \ + 1);\n            right_car.speed(speed_right - 1);\n        } else {\n   \
    \         right_car.speed(speed_right + 1);\n            left_car.speed(speed_left\
    \ - 1);\n        }\n        if speed_left > speed_right {\n            if left_car.collide(right_car)\
    \ {\n                left_car.speed(speed_right + 1);\n                right_car.speed(speed_left\
    \ - 1);\n                collisions += 1;\n            } else if right_car.collide(left_car)\
    \ {\n                left_car.speed(speed_left - 1);\n                right_car.speed(speed_right\
    \ + 1);\n                collisions += 1;\n            }\n        }\n        count\
    \ += 1;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Car` in this scope\n  --> /tmp/tmp7bfa5oei.rs:14:35\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \     - help: you might be missing a type parameter: `<Car>`\n...\n14 |     let\
    \ mut left_car: Option<&mut Car> = None;\n   |                               \
    \    ^^^ not found in this scope\n\nerror[E0412]: cannot find type `Car` in this\
    \ scope\n  --> /tmp/tmp7bfa5oei.rs:15:36\n   |\n9  | fn car_race_collision(n:\
    \ isize) -> isize {\n   |                      - help: you might be missing a\
    \ type parameter: `<Car>`\n...\n15 |     let mut right_car: Option<&mut Car> =\
    \ None;\n   |                                    ^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The number of times the cars will race against each\
    \ other before they stop.\n    let mut races = 0..(n - 1);\n    // The number\
    \ of times the cars will collide once they stop moving.\n    let mut collisions\
    \ = 0..(n - 1);\n    // The total number of cars that will collide this many times\
    \ to get through\n    // the race.\n    let mut cars = 0..(n - 1);\n    // The\
    \ number of cars that have collided this many times to get through the race.\n\
    \    let mut cars_colliding = 0..(n - 1);\n\n    // Set the starting positions\
    \ of all the cars.\n    for _ in 0..n {\n        cars_colliding.push(0);\n   \
    \ }\n\n    // Start a race with cars in the first column.\n    let race_length\
    \ = n - 2;\n    let mut current_cars = 0..(n - 1);\n\n    // The index of the\
    \ car in the next column to start the race.\n    let mut next_car = n - 1;\n\n\
    \    // Keep track of which cars are colliding against each other.\n    let mut\
    \ colliding_cars = 0..(n - 1);\n\n    // Keep track of how many cars are colliding\
    \ against each other and not\n    // moving in that direction.\n    let mut cars_not_colliding\
    \ = 0..(n - 1);\n\n    // Keep track of how many cars are colliding against each\
    \ other and moving\n    // in that direction.\n    let mut cars_moving_right =\
    \ 0..(n - 1);\n\n    // Keep track of how many cars are colliding against each\
    \ other and moving\n    // in that direction.\n    let mut cars_moving_left =\
    \ 0..(n - 1);\n\n    // Keep track of how many cars are colliding against each\
    \ other and moving\n    // in the opposite direction.\n    let mut cars_moving_right_opposite\
    \ = 0..(n - 1);\n\n    // Keep track of how many cars are colliding against each\
    \ other and moving\n    // in the opposite direction.\n    let mut cars_moving_left_opposite\
    \ = 0..(n - 1);\n\n    // The index of the car in the column immediately to the\
    \ right of the race\n    // that finishes last.\n    let mut last_car = n - 1;\n\
    \n    // The current set of cars being race with.\n    let mut cars_start = 0..(n\
    \ - 1);\n\n    // Keep track of whether we are still inside the race.\n    let\
    \ mut inside_race = true;\n\n    while inside_race {\n        // Iterate through\
    \ the cars one at a time, colliding with the current\n        // car and moving\
    \ to the opposite direction.\n        for current_car in 0..current_cars {\n \
    \           // If the current car has collided \n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmy__freg.rs:79:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n65 |     while inside_race\
    \ {\n   |                       - unclosed delimiter\n...\n68 |         for current_car\
    \ in 0..current_cars {\n   |                                            - this\
    \ delimiter might not be properly closed...\n69 |             // If the current\
    \ car has collided \n70 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n79 | }\n   |   ^\n\nerror[E0599]: no method named `push` found\
    \ for struct `std::ops::Range` in the current scope\n  --> /tmp/tmpmy__freg.rs:22:24\n\
    \   |\n22 |         cars_colliding.push(0);\n   |                        ^^^^\
    \ method not found in `std::ops::Range<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmy__freg.rs:68:31\n   |\n68 |         for current_car in 0..current_cars\
    \ {\n   |                               ^^^^^^^^^^^^ expected integer, found struct\
    \ `std::ops::Range`\n   |\n   = note: expected type `{integer}`\n            found\
    \ struct `std::ops::Range<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmy__freg.rs:65:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n65\
    \ | /     while inside_race {\n66 | |         // Iterate through the cars one\
    \ at a time, colliding with the current\n67 | |         // car and moving to the\
    \ opposite direction.\n68 | |         for current_car in 0..current_cars {\n...\
    \  |\n78 | |     assert_eq!(candidate(10), 100);\n79 | | }\n   | |__^ expected\
    \ `isize`, found `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    use rand::thread_rng;\n    use std::cmp::Ordering;\n\
    \    use std::iter::repeat;\n\n    // generate a list of unique random pairs of\
    \ points\n    let mut rng = thread_rng();\n    let mut pairs = Vec::new();\n \
    \   for _ in 0..n {\n        let (x, y) = (rng.gen(), rng.gen());\n        if\
    \ !pairs.contains(&(x * n + y)) {\n            pairs.push((x, y));\n        }\n\
    \    }\n\n    let mut collisions: isize = 0;\n    for x in pairs {\n        for\
    \ y in pairs.iter().skip(1) {\n            let x_dist = std::fabs(x[0] - y[0]);\n\
    \            let y_dist = std::fabs(x[1] - y[1]);\n            if x_dist > y_dist\
    \ {\n                if x_dist < 100 {\n                    collisions += 1;\n\
    \                }\n            }\n        }\n    }\n\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `rand`\n  --> /tmp/tmpu5y_jg0w.rs:10:9\n\
    \   |\n10 |     use rand::thread_rng;\n   |         ^^^^ maybe a missing crate\
    \ `rand`?\n\nerror[E0425]: cannot find function `fabs` in crate `std`\n  --> /tmp/tmpu5y_jg0w.rs:27:31\n\
    \   |\n27 |             let x_dist = std::fabs(x[0] - y[0]);\n   |           \
    \                    ^^^^ not found in `std`\n\nerror[E0425]: cannot find function\
    \ `fabs` in crate `std`\n  --> /tmp/tmpu5y_jg0w.rs:28:31\n   |\n28 |         \
    \    let y_dist = std::fabs(x[1] - y[1]);\n   |                              \
    \ ^^^^ not found in `std`\n\nwarning: unused import: `std::cmp::Ordering`\n  -->\
    \ /tmp/tmpu5y_jg0w.rs:11:9\n   |\n11 |     use std::cmp::Ordering;\n   |     \
    \    ^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\
    \nwarning: unused import: `std::iter::repeat`\n  --> /tmp/tmpu5y_jg0w.rs:12:9\n\
    \   |\n12 |     use std::iter::repeat;\n   |         ^^^^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `(_, _)`\n  --> /tmp/tmpu5y_jg0w.rs:27:36\n\
    \   |\n27 |             let x_dist = std::fabs(x[0] - y[0]);\n   |           \
    \                         ^^^^ help: to access tuple elements, use: `x.0`\n\n\
    error[E0608]: cannot index into a value of type `&(_, _)`\n  --> /tmp/tmpu5y_jg0w.rs:27:43\n\
    \   |\n27 |             let x_dist = std::fabs(x[0] - y[0]);\n   |           \
    \                                ^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `(_, _)`\n  --> /tmp/tmpu5y_jg0w.rs:28:36\n   |\n28 |             let\
    \ y_dist = std::fabs(x[1] - y[1]);\n   |                                    ^^^^\
    \ help: to access tuple elements, use: `x.1`\n\nerror[E0608]: cannot index into\
    \ a value of type `&(_, _)`\n  --> /tmp/tmpu5y_jg0w.rs:28:43\n   |\n28 |     \
    \        let y_dist = std::fabs(x[1] - y[1]);\n   |                          \
    \                 ^^^^\n\nerror: aborting due to 7 previous errors; 2 warnings\
    \ emitted\n\nSome errors have detailed explanations: E0425, E0432, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n\n    let mut car_1 =\
    \ vec![\n        vec![(0.0, 0.4, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n\
    \        vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n  \
    \      vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n    \
    \    vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n      \
    \  vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0,\
    \ 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0,\
    \ 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0,\
    \ 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n\
    \        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n  \
    \      vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n    \
    \    vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n      \
    \  vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0,\
    \ 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0,\
    \ 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4,\
    \ 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n\
    \        vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n  \
    \      vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n    \
    \    vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n      \
    \  vec![(0.0, 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0,\
    \ 0.0, 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0,\
    \ 0.0, 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0,\
    \ 0.0)],\n        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n\
    \        vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n  \
    \      vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n    \
    \    vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)],\n      \
    \  vec![(0.0, 0.0, 0.4, 0.0)],\n        vec![(0.0, 0.0, 0.0, 0.0)\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpwo7njlt9.rs:67:13\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - closing delimiter possibly meant for this\n...\n67\
    \ |         vec![(0.0, 0.0, 0.0, 0.0)\n   |             ^ unclosed delimiter\n\
    68 | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `.`, `;`,\
    \ `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpwo7njlt9.rs:68:1\n   |\n\
    68 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 1;\n    for _ in 0..n {\n  \
    \      let mut last_car_direction = vec2::zero();\n        let mut first_car_direction\
    \ = vec2::zero();\n        // Each time through the loop, we find the direction\
    \ of the car that is\n        // moving left to right.\n        let mut car_direction_left:\
    \ Vec2 = vec2::zero();\n        for _ in 0..n {\n            car_direction_left\
    \ += vec2::random();\n        }\n        // Each time through the loop, we find\
    \ the direction of the car that is\n        // moving right to left.\n       \
    \ let mut car_direction_right: Vec2 = vec2::zero();\n        for _ in 0..n {\n\
    \            car_direction_right += vec2::random();\n        }\n        // Calculate\
    \ the first car direction vector from the last car_direction_left\n        //\
    \ and car_direction_right vectors.\n        // The vector is orthogonal to the\
    \ two previous car_direction_left\n        // and car_direction_right vectors.\n\
    \        let mut first_car_direction: Vec2 = car_direction_left.cross(car_direction_right);\n\
    \        // The dot product of first_car_direction and car_direction_right is\
    \ zero.\n        // This implies that car_direction_right is orthogonal to both\
    \ first_car_direction\n        // and car_direction_left\n        if car_direction_right.dot(&first_car_direction)\
    \ != 0 {\n            // If the dot product is zero, then car_direction_right\
    \ is not\n            // orthogonal to first_car_direction.\n            // The\
    \ vectors are not parallel, so there can be no collisions.\n            continue;\n\
    \        }\n        // The vectors are parallel, there can be collisions.\n  \
    \      // Find a vector that's perpendicular to both first_car_direction\n   \
    \     // and car_direction_right and also orthogonal to both first_car_direction\n\
    \        // and car_direction_left\n        let mut second_car_direction: Vec2\
    \ = first_car_direction.cross(&car_direction_right);\n        // Find a vector\
    \ that's perpendicular to both first_car_direction\n        // and car_direction_left\
    \ and also orthogonal to both first_car_direction\n        // and car_direction_right.\n\
    \        // Find the distance between these two vectors.\n        let mut distance_between\
    \ = second_car_direction.mag();\n        if first_car_direction.dot(&second_car_direction)\
    \ != 0 {\n            // If the dot product is zero, then first_car_direction\
    \ is not orthogonal to\n            // second_car_\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprya1dr7a.rs:62:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n10 |     let mut num_collisions\
    \ = 1;\n11 |     for _ in 0..n {\n   |                   - unclosed delimiter\n\
    ...\n50 |         if first_car_direction.dot(&second_car_direction) != 0 {\n \
    \  |                                                                - this delimiter\
    \ might not be properly closed...\n...\n53 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n62 | }\n   |   ^\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `vec2`\n  --> /tmp/tmprya1dr7a.rs:12:38\n\
    \   |\n12 |         let mut last_car_direction = vec2::zero();\n   |         \
    \                             ^^^^ use of undeclared crate or module `vec2`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `vec2`\n  -->\
    \ /tmp/tmprya1dr7a.rs:13:39\n   |\n13 |         let mut first_car_direction =\
    \ vec2::zero();\n   |                                       ^^^^ use of undeclared\
    \ crate or module `vec2`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `vec2`\n  --> /tmp/tmprya1dr7a.rs:16:44\n   |\n16 |        \
    \ let mut car_direction_left: Vec2 = vec2::zero();\n   |                     \
    \                       ^^^^ use of undeclared crate or module `vec2`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `vec2`\n  --> /tmp/tmprya1dr7a.rs:18:35\n\
    \   |\n18 |             car_direction_left += vec2::random();\n   |          \
    \                         ^^^^ use of undeclared crate or module `vec2`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `vec2`\n  --> /tmp/tmprya1dr7a.rs:22:45\n\
    \   |\n22 |         let mut car_direction_right: Vec2 = vec2::zero();\n   |  \
    \                                           ^^^^ use of undeclared crate or module\
    \ `vec2`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `vec2`\n  --> /tmp/tmprya1dr7a.rs:24:36\n   |\n24 |             car_direction_right\
    \ += vec"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for _ in 0..n {\n\
    \        let mut collision_distance: isize = 0;\n        for _ in 0..n {\n   \
    \         if !is_colliding(&mut collision_distance) {\n                collisions\
    \ += 1;\n                break;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_colliding` in this scope\n  -->\
    \ /tmp/tmp7ok2_hzm.rs:14:17\n   |\n14 |             if !is_colliding(&mut collision_distance)\
    \ {\n   |                 ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision = 0;\n    let mut c = n - 1;\n    while\
    \ c > 0 {\n        if c % 2 == 0 {\n            collision += 1;\n        }\n \
    \       c /= 2;\n    }\n    collision\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpkjsw391i.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The distance between any two cars who collide is sqrt(2)\
    \ * 2n.\n    // The car that travels the least distance will win.\n    let distance\
    \ = (2 * n).sqrt();\n    let mut count = 0;\n    let mut i = n;\n    while i >\
    \ 0) {\n        if i / 2 % 2 == 1 {\n            i += 1;\n        } else {\n \
    \           i -= 1;\n        }\n\n        if i / 2 % 2 == 0 {\n            i +=\
    \ 1;\n        } else {\n            i -= 1;\n        }\n\n        if i / 2 % 2\
    \ == 0 {\n            i += 1;\n        } else {\n            i -= 1;\n       \
    \ }\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpmdcs_jxr.rs:36:1\n\
    \   |\n15 |     while i > 0) {\n   |                  - this opening brace...\n\
    ...\n34 |     }\n   |     - ...matches this closing brace\n35 |     count\n36\
    \ | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter:\
    \ `)`\n  --> /tmp/tmpmdcs_jxr.rs:9:42\n   |\n9  | fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                          ^ unclosed delimiter\n\
    ...\n15 |     while i > 0) {\n   |                ^ mismatched closing delimiter\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (2.0 * (n ** 3.0) - n * n * (n - 1.0) * (n - 2.0))\n\
    \        / (n - 1.0) * (n - 2.0) + n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `{float}` cannot be dereferenced\n  --> /tmp/tmpwz_22nn7.rs:10:16\n\
    \   |\n10 |     (2.0 * (n ** 3.0) - n * n * (n - 1.0) * (n - 2.0))\n   |     \
    \           ^^^^^\n\nerror[E0277]: cannot multiply `{float}` by `isize`\n  -->\
    \ /tmp/tmpwz_22nn7.rs:10:10\n   |\n10 |     (2.0 * (n ** 3.0) - n * n * (n - 1.0)\
    \ * (n - 2.0))\n   |          ^ no implementation for `{float} * isize`\n   |\n\
    \   = help: the trait `Mul<isize>` is not implemented for `{float}`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0277]: cannot\
    \ subtract `{float}` from `isize`\n  --> /tmp/tmpwz_22nn7.rs:10:36\n   |\n10 |\
    \     (2.0 * (n ** 3.0) - n * n * (n - 1.0) * (n - 2.0))\n   |               \
    \                     ^ no implementation for `isize - {float}`\n   |\n   = help:\
    \ the trait `Sub<{float}>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: cannot\
    \ subtract `{float}` from `isize`\n  --> /tmp/tmpwz_22nn7.rs:10:48\n   |\n10 |\
    \     (2.0 * (n ** 3.0) - n * n * (n - 1.0) * (n - 2.0))\n   |               \
    \                                 ^ no implementation for `isize - {float}`\n\
    \   |\n   = help: the trait `Sub<{float}>` is not implemented for `isize`\n  \
    \ = help: the following other types implement trait `Sub<Rhs>`:\n            \
    \ <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut collide = false;\n\
    \    for _i in 0..n {\n        let mut collide = false;\n        if collide ==\
    \ true {\n            collisions += 1;\n        } else {\n            for _j in\
    \ (n - _i).min(n - 1) { }\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpy9sqnwo3.rs:17:23\n\
    \   |\n17 |             for _j in (n - _i).min(n - 1) { }\n   |              \
    \         ^^^^^^^^^^^^^^^^^^^ `isize` is not an iterator\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `isize`\n   = note: if you want to iterate\
    \ between `start` until a value `end`, use the exclusive range syntax `start..end`\
    \ or the inclusive range syntax `start..=end`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut collision_count:\
    \ usize = 1;\n    for car_1_xc in 1..n {\n        for car_2_xc in 1..n {\n   \
    \         if car_2_xc > car_1_xc {\n                continue;\n            }\n\
    \            if car_1_xc == car_2_xc {\n                continue;\n          \
    \  }\n            let mut collision_found = false;\n            for car_3_xc in\
    \ car_2_xc..car_1_xc {\n                if car_3_xc < car_1_xc {\n           \
    \         continue;\n                }\n                collision_found |= (\n\
    \                    car_1_xc > car_3_xc && car_2_xc > car_3_xc\n            \
    \    );\n            }\n            if collision_found {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collision_count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpxfba1e6h.rs:25:36\n\
    \   |\n25 |                    collision_found |= (\n   |   ____________________________________^\n\
    26 |  |                     car_1_xc > car_3_xc && car_2_xc > car_3_xc\n   | \
    \ |____________________^__________________________________________^\n   | ||____________________|\n\
    \   | |\n27 | |                  );\n   | |__________________^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    25 -                 collision_found |= (\n25 +                 collision_found\
    \ |= car_1_xc > car_3_xc && car_2_xc > car_3_xc;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxfba1e6h.rs:34:5\n   |\n9  | fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n34 |     collision_count\n   |     ^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n34 |     collision_count.try_into().unwrap()\n\
    \   |                    ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for i in 0..n {\n\
    \        for j in (i + 1)..n {\n            if i != j && cars_collide(&i, &j)\
    \ {\n                collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `cars_collide` in this scope\n  -->\
    \ /tmp/tmpgbnczi2_.rs:13:26\n   |\n13 |             if i != j && cars_collide(&i,\
    \ &j) {\n   |                          ^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut max_speed\
    \ = 2.0 * f32::consts::PI / n;\n    for i in 0..n {\n        let mut cur_speed\
    \ = 2.0 * f32::consts::PI / n;\n        if i == 7 {\n            cur_speed = cur_speed\
    \ * max_speed / 10.0;\n        }\n        collisions += if cur_speed > max_speed\
    \ {\n            0\n        } else {\n            let mut x = 2.0 * f32::consts::PI\
    \ / n;\n            while x > (2.0 * f32::consts::PI / n) + cur_speed {\n    \
    \            if x < max_speed {\n                    x + cur_speed\n         \
    \       } else {\n                    x\n                }\n            }\n  \
    \          x\n        };\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0223]: ambiguous associated type\n  --> /tmp/tmpst5bymeo.rs:11:31\n\
    \   |\n11 |     let mut max_speed = 2.0 * f32::consts::PI / n;\n   |         \
    \                      ^^^^^^^^^^^\n   |\nhelp: you are looking for the module\
    \ in `std`, not the primitive type\n   |\n11 |     let mut max_speed = 2.0 * std::f32::consts::PI\
    \ / n;\n   |                               ~~~~~~~~~~~~~~~~\n\nerror[E0277]: cannot\
    \ divide `{float}` by `isize`\n  --> /tmp/tmpst5bymeo.rs:11:47\n   |\n11 |   \
    \  let mut max_speed = 2.0 * f32::consts::PI / n;\n   |                      \
    \                         ^ no implementation for `{float} / isize`\n   |\n  \
    \ = help: the trait `Div<isize>` is not implemented for `{float}`\n   = help:\
    \ the following other types implement trait `Div<Rhs>`:\n             <&'a f32\
    \ as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as\
    \ Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n\
    \             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n      \
    \       <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0223]: ambiguous\
    \ associated type\n  --> /tmp/tmpst5bymeo.rs:13:35\n   |\n13 |         let mut\
    \ cur_speed = 2.0 * f32::consts::PI / n;\n   |                               \
    \    ^^^^^^^^^^^\n   |\nhelp: you are looking for the module in `std`, not the\
    \ primitive type\n   |\n13 |         let mut cur_speed = 2.0 * std::f32::consts::PI\
    \ / n;\n   |                                   ~~~~~~~~~~~~~~~~\n\nerror[E0277]:\
    \ cannot divide `{float}` by `isize`\n  --> /tmp/tmpst5bymeo.rs:13:51\n   |\n\
    13 |         let mut cur_speed = 2.0 * f32::consts::PI / n;\n   |            \
    \                                       ^ no implementation for `{float} / isize`\n\
    \   |\n   = help: the trait `Div<isize>` is not implemented for `{float}`\n  \
    \ = help: the following other types implement trait `Div<Rhs>`:\n            \
    \ <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n          "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut last_collision_x\
    \ = std::i32::MAX;\n    let mut last_collision_y = std::i32::MAX;\n\n    let mut\
    \ last_x = std::i32::MIN;\n    let mut last_y = std::i32::MIN;\n\n    let mut\
    \ last_speed_x: isize = 0;\n    let mut last_speed_y: isize = 0;\n\n    let mut\
    \ last_speed_x_square: isize = 0;\n    let mut last_speed_y_square: isize = 0;\n\
    \n    for _ in 0..n {\n        let x = rand::thread_rng().gen_range(1, std::i32::MAX);\n\
    \        let y = rand::thread_rng().gen_range(1, std::i32::MAX);\n\n        let\
    \ curr_speed_x: isize = x * (x - last_x) / std::i32::MAX;\n        let curr_speed_y:\
    \ isize = y * (y - last_y) / std::i32::MAX;\n        let curr_speed_x_square:\
    \ isize = x * (x - last_x) * (x - last_x) / std::i32::MAX;\n        let curr_speed_y_square:\
    \ isize = y * (y - last_y) * (y - last_y) / std::i32::MAX;\n\n        last_x =\
    \ x; last_y = y;\n\n        if last_speed_x != 0 && curr_speed_x != last_speed_x\
    \ {\n            collision_count += 1;\n        }\n        last_speed_x = curr_speed_x;\n\
    \        if last_speed_x_square != 0 && curr_speed_x_square != last_speed_x_square\
    \ {\n            collision_count += 1;\n        }\n        last_speed_x_square\
    \ = curr_speed_x_square;\n\n        if last_speed_y != 0 && curr_speed_y != last_speed_y\
    \ {\n            collision_count += 1;\n        }\n        last_speed_y = curr_speed_y;\n\
    \        if last_speed_y_square != 0 && curr_speed_y_square != last_speed_y_square\
    \ {\n            collision_count += 1;\n        }\n        last_speed_y_square\
    \ = curr_speed_y_square;\n    }\n    collision_count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpwm4oav_x.rs:24:17\n   |\n24 |         let x = rand::thread_rng().gen_range(1,\
    \ std::i32::MAX);\n   |                 ^^^^ use of undeclared crate or module\
    \ `rand`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `rand`\n  --> /tmp/tmpwm4oav_x.rs:25:17\n   |\n25 |         let y = rand::thread_rng().gen_range(1,\
    \ std::i32::MAX);\n   |                 ^^^^ use of undeclared crate or module\
    \ `rand`\n\nerror[E0271]: type mismatch resolving `<i32 as Div>::Output == isize`\n\
    \  --> /tmp/tmpwm4oav_x.rs:27:52\n   |\n27 |         let curr_speed_x: isize =\
    \ x * (x - last_x) / std::i32::MAX;\n   |                                    \
    \                ^ expected `i32`, found `isize`\n\nerror[E0271]: type mismatch\
    \ resolving `<i32 as Div>::Output == isize`\n  --> /tmp/tmpwm4oav_x.rs:29:74\n\
    \   |\n29 |         let curr_speed_x_square: isize = x * (x - last_x) * (x - last_x)\
    \ / std::i32::MAX;\n   |                                                     \
    \                     ^ expected `i32`, found `isize`\n\nerror[E0271]: type mismatch\
    \ resolving `<i32 as Div>::Output == isize`\n  --> /tmp/tmpwm4oav_x.rs:28:52\n\
    \   |\n28 |         let curr_speed_y: isize = y * (y - last_y) / std::i32::MAX;\n\
    \   |                                                    ^ expected `i32`, found\
    \ `isize`\n\nerror[E0271]: type mismatch resolving `<i32 as Div>::Output == isize`\n\
    \  --> /tmp/tmpwm4oav_x.rs:30:74\n   |\n30 |         let curr_speed_y_square:\
    \ isize = y * (y - last_y) * (y - last_y) / std::i32::MAX;\n   |             \
    \                                                             ^ expected `i32`,\
    \ found `isize`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0271, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count: isize = 0;\n    let start_x\
    \ = ((n - 1) / 2) * (CAR_WIDTH + CAR_OFFSET) + CAR_OFFSET;\n    let start_y =\
    \ n * CAR_HEIGHT + CAR_OFFSET;\n    let end_x = ((n - 1) / 2) * CAR_WIDTH + CAR_OFFSET;\n\
    \    let end_y = n * CAR_HEIGHT + CAR_OFFSET;\n\n    for x in start_x..end_x {\n\
    \        for y in start_y..end_y {\n            if abs(x - start_x) > abs(y -\
    \ start_y) {\n                collision_count += 1;\n            }\n        }\n\
    \    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `CAR_WIDTH` in this scope\n  --> /tmp/tmp05kgq3nz.rs:11:36\n\
    \   |\n11 |     let start_x = ((n - 1) / 2) * (CAR_WIDTH + CAR_OFFSET) + CAR_OFFSET;\n\
    \   |                                    ^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `CAR_OFFSET` in this scope\n  --> /tmp/tmp05kgq3nz.rs:11:48\n\
    \   |\n11 |     let start_x = ((n - 1) / 2) * (CAR_WIDTH + CAR_OFFSET) + CAR_OFFSET;\n\
    \   |                                                ^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `CAR_OFFSET` in this scope\n  --> /tmp/tmp05kgq3nz.rs:11:62\n\
    \   |\n11 |     let start_x = ((n - 1) / 2) * (CAR_WIDTH + CAR_OFFSET) + CAR_OFFSET;\n\
    \   |                                                              ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `CAR_HEIGHT` in this\
    \ scope\n  --> /tmp/tmp05kgq3nz.rs:12:23\n   |\n12 |     let start_y = n * CAR_HEIGHT\
    \ + CAR_OFFSET;\n   |                       ^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `CAR_OFFSET` in this scope\n  --> /tmp/tmp05kgq3nz.rs:12:36\n\
    \   |\n12 |     let start_y = n * CAR_HEIGHT + CAR_OFFSET;\n   |             \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAR_WIDTH` in this scope\n  --> /tmp/tmp05kgq3nz.rs:13:33\n   |\n\
    13 |     let end_x = ((n - 1) / 2) * CAR_WIDTH + CAR_OFFSET;\n   |           \
    \                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAR_OFFSET` in this scope\n  --> /tmp/tmp05kgq3nz.rs:13:45\n   |\n\
    13 |     let end_x = ((n - 1) / 2) * CAR_WIDTH + CAR_OFFSET;\n   |           \
    \                                  ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAR_HEIGHT` in this scope\n  --> /tmp/tmp05kgq3nz.rs:14:21\n\
    \   |\n14 |     let end_y = n * CAR_HEIGHT + CAR_OFFSET;\n   |               \
    \      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `CAR_OFFSET`\
    \ in this scope\n  --> /tmp/tmp05kgq3nz.rs:14:34\n   |\n14 |     let end_y = n\
    \ * CAR_HEIGHT + CAR_OFFSET;\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut c1 = -1;\n\
    \    let mut c2 = -1;\n    let mut car = -1;\n\n    for _ in 0..n {\n        let\
    \ mut car_x = -1;\n        let mut car_y = -1;\n\n        if (c1 < 0) {\n    \
    \        car = 1;\n            car_x = 1;\n            car_y = 1;\n          \
    \  c1 = 1;\n            c2 = 1;\n        } else {\n            car = 2;\n    \
    \        car_x = 2;\n            car_y = 1;\n        }\n\n        if (c2 < 0)\
    \ || (c2 >= 2) {\n            let c1 = (c1 - 1) % 3;\n            let c2 = (c2\
    \ - 1) % 3;\n\n            if c1 == c2 {\n                collisions += 1;\n \
    \           }\n        } else {\n            let c1 = (c1 - 2) % 3;\n        \
    \    let c2 = (c2 - 2) % 3;\n\n            if c1 == c2 {\n                collisions\
    \ += 1;\n            }\n        }\n\n        if car_x < 0 {\n            let car\
    \ = (car + 1) % 3;\n\n            if car == c1 {\n                collisions +=\
    \ 1;\n            }\n        } else {\n            let car = (car + 2) % 3;\n\n\
    \            if car == c1 {\n                collisions += 1;\n            }\n\
    \        }\n\n        if car_y < 0 {\n            let car = (car + 1) % 3;\n\n\
    \            if car == c2 {\n                collisions += 1;\n            }\n\
    \        } else {\n            let car = (car + 2) % 3;\n\n            if car\
    \ == c2 {\n                collisions += 1;\n            }\n        }\n    }\n\
    \n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `9`', /tmp/tmpf8bli5vg.rs:82:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0\n    }\n\n    // The cars\
    \ that cannot collide with each other are those that are moving\n    // left to\
    \ right AND right to left.\n    let cant_collide = vec![true, true];\n    // The\
    \ cars that can collide with each other are those that are moving left to\n  \
    \  // right OR right to left.\n    let can_collide = vec![false, false];\n\n \
    \   for car in 0..n {\n        if can_collide[car] {\n            can_collide[car]\
    \ = !can_collide[car]\n        } else {\n            cant_collide[car] = !cant_collide[car]\n\
    \        }\n    }\n    if cant_collide[0] && cant_collide[1] {\n        return\
    \ 2\n    }\n    if cant_collide[0] && cant_collide[1] {\n        return 2\n  \
    \  }\n    if cant_collide[0] && cant_collide[1] {\n        return 2\n    }\n\n\
    \    let mut count = 0;\n    for car in 0..n {\n        count += can_collide[car];\n\
    \    }\n    return count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmp6tmuyvdx.rs:22:12\n\
    \   |\n22 |         if can_collide[car] {\n   |            ^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp6tmuyvdx.rs:23:13\n   |\n23 |  \
    \           can_collide[car] = !can_collide[car]\n   |             ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmp6tmuyvdx.rs:23:33\n\
    \   |\n23 |             can_collide[car] = !can_collide[car]\n   |           \
    \                      ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp6tmuyvdx.rs:25:13\n   |\n25 |             cant_collide[car] = !cant_collide[car]\n\
    \   |             ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp6tmuyvdx.rs:25:34\n   |\n25 |             cant_colli"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n\n    // First, count the number\
    \ of collisions that are possible with n cars.\n    for i in 0..n {\n        for\
    \ j in (i + 1)..n {\n            if i != j {\n                let race_conditions\
    \ = car_race_condition(i, j);\n                if race_conditions == 0 {\n   \
    \                 collisions += 1;\n                }\n            }\n       \
    \ }\n    }\n\n    // Next, count the number of collisions that are possible with\
    \ n cars.\n    for j in 0..n {\n        for i in 0..n {\n            if i != j\
    \ {\n                let race_conditions = car_race_condition(i, j);\n       \
    \         if race_conditions == 0 {\n                    collisions += 1;\n  \
    \              }\n            }\n        }\n    }\n\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_condition` in this scope\n\
    \  --> /tmp/tmpg6xl0v8s.rs:16:39\n   |\n16 |                 let race_conditions\
    \ = car_race_condition(i, j);\n   |                                       ^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_race_condition`\
    \ in this scope\n  --> /tmp/tmpg6xl0v8s.rs:28:39\n   |\n28 |                 let\
    \ race_conditions = car_race_condition(i, j);\n   |                          \
    \             ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // A car starts out colliding with itself.\n    for i\
    \ in 0..n {\n        if i%2 == 0 {\n            return i;\n        }\n    }\n\
    \    // A car starts out colliding with every other car.\n    for i in 0..n {\n\
    \        if i%2 != 0 {\n            return i;\n        }\n    }\n    // All cars\
    \ collide with each other.\n    return n;\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpmv11y13k.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0\n\n    // Each car has a set of adjacent\
    \ cars, each one which it can collide with\n    let adjacent_cars: Vec<_> = (0..n)\n\
    \        .map(|_| Vec::new())\n        .collect();\n\n    // Each car has a set\
    \ of colliding cars, each one which it can collide with\n    let colliding_cars:\
    \ Vec<_> = (0..n)\n        .map(|_| Vec::new())\n        .collect();\n\n    //\
    \ Each car has a set of all cars it's already collided with\n    let colliding_cars_before:\
    \ Vec<_> = (0..n)\n        .map(|_| Vec::new())\n        .collect();\n\n    //\
    \ To save time, we skip cars whose colliding cars are already in the set\n   \
    \ let mut skip_car = 0;\n\n    let mut collision_level = 1;\n    let mut collision_level_increment\
    \ = 1;\n\n    for _ in 0..n {\n        loop {\n            let collision_level_next\
    \ = collision_level + collision_level_increment;\n            if collision_level_next\
    \ > n {\n                break collision_level_next;\n            }\n\n      \
    \      count += 1;\n            skip_car = 0;\n\n            for car_i in (0..n).rev()\
    \ {\n                // See if we've already collided with this car\n        \
    \        if !colliding_cars_before[car_i].contains(&car_i) {\n               \
    \     // See if the other car has already collided with us\n                 \
    \   if !adjacent_cars[car_i].contains(&car_i) {\n                        // See\
    \ if the car we haven't collided with is ahead of us\n                       \
    \ if car_i < car_i {\n                            // We've collided with it\n\
    \                            collision_level_increment += 1;\n               \
    \             continue;\n                        }\n\n                       \
    \ // We haven't collided with it; we need to collide with it\n               \
    \         let adjacent_cars_next = adjacent_cars[car_i]\n                    \
    \        .iter()\n                            .cloned()\n                    \
    \        .map(|i| i + 1)\n                            .collect();\n\n        \
    \                colliding_cars_before.push(&adjacent_cars_next);\n          \
    \              colliding_cars.push(car_i);\n                    }\n          \
    \      }\n\n                // We haven't collided with it; we need to collide\
    \ with it\n                skip_car += 1;\n            }\n\n            // If\
    \ we haven't collided with all the cars yet, skip a bit\n            if skip_car\
    \ < n {\n                // We're going to collide with cars until we get to the\
    \ one we're skipping\n                collision_level += 1;\n                skip_car\
    \ = 0;\n            }\n        }\n    }\n\n    count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5tk1vf8k.rs:10:22\n\
    \   |\n10 |     let mut count = 0\n   |                      ^ help: add `;` here\n\
    ...\n13 |     let adjacent_cars: Vec<_> = (0..n)\n   |     --- unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5tk1vf8k.rs:37:23\n   |\n37 |\
    \                 break collision_level_next;\n   |                       ^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found `isize`\n\nerror[E0277]: the type `[Vec<_>]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5tk1vf8k.rs:45:21\n   |\n45 |            \
    \     if !colliding_cars_before[car_i].contains(&car_i) {\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp5tk1vf8k.rs:47:25\n   |\n47 |                     if\
    \ !adjacent_cars[car_i].contains(&car_i) {\n   |                         ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmp5tk1vf8k.rs:56:50\n\
    \   |\n56 |                         let adjacent_cars_next = adjacent_cars[car_i]\n\
    \   |                                                  ^^^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0308]:\
    \ mismatched types\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count_collisions: isize = 0;\n\n    // Loop through\
    \ each possible starting position.\n    for start in 0..2 * n {\n        // For\
    \ each possible initial velocity...\n        for velocity in 1..2 * n {\n    \
    \        // For each possible initial direction...\n            for direction\
    \ in 1..2 * n {\n                let mut collision = false;\n\n              \
    \  // Keep track of how many cars hit the current car while moving.\n        \
    \        let mut hits = 0;\n\n                // Keep track of the cars that would\
    \ hit the current car at the starting position.\n                let mut current_hits\
    \ = vec![vec![0usize; n]; 2];\n\n                // Keep track of the cars that\
    \ would hit the current car at the current velocity.\n                let mut\
    \ current_hits = vec![vec![0usize; n]; 2];\n\n                // For each possible\
    \ velocity change...\n                for direction_change in 1..2 * n {\n   \
    \                 // For each possible starting direction...\n               \
    \     for start_direction in 1..2 * n {\n                        // For each possible\
    \ velocity-direction combination...\n                        for velocity in 1..2\
    \ * n {\n                            // Keep track of the cars that would collide\
    \ while moving.\n                            let mut collision = false;\n\n  \
    \                          // Keep track of the cars that would collide while\
    \ moving at the current velocity.\n                            let mut current_collisions\
    \ = vec![vec![0usize; n]; 2];\n\n                            // Keep track of\
    \ the cars that would collide while moving at the current velocity.\n        \
    \                    let mut current_collisions = vec![vec![0usize; n]; 2];\n\n\
    \                            // Keep track of the cars that would collide while\
    \ moving at the starting direction.\n                            let mut current_collisions\
    \ = vec![vec![0usize; n]; 2];\n\n                            // For each possible\
    \ starting position...\n                            for start in 0..2 * n {\n\
    \                                // For each possible direction-direction combination...\n\
    \                                for direction in 1..2 * n {\n               \
    \                     // Keep track of the cars that would collide while moving\
    \ at the current position.\n                                    let mut current_collisions\
    \ = vec![vec![0usize; n]; 2];\n\n                                    // Keep track\
    \ of the cars that would collide while moving at the current velocity.\n     \
    \                               let mut current_collisions = vec![vec![0usize;\
    \ n]; 2];\n\n                                    // Keep track of the cars that\
    \ would collide while moving at the current position.\n                      \
    \              let mut current_collisions = vec![vec![0usize; n]; 2];\n\n    \
    \                                // Keep track of the cars that would collide\
    \ while moving at the current velocity.\n                                    let\
    \ mut current_collisions = \n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2c23lplw.rs:71:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n13 |     for start in 0..2\
    \ * n {\n   |                           - unclosed delimiter\n14 |         //\
    \ For each possible initial velocity...\n15 |         for velocity in 1..2 * n\
    \ {\n   |                                  - unclosed delimiter\n16 |        \
    \     // For each possible initial direction...\n17 |             for direction\
    \ in 1..2 * n {\n   |                                       - unclosed delimiter\n\
    ...\n30 |                 for direction_change in 1..2 * n {\n   |           \
    \                                       - unclosed delimiter\n31 |           \
    \          // For each possible starting direction...\n32 |                  \
    \   for start_direction in 1..2 * n {\n   |                                  \
    \                   - unclosed delimiter\n33 |                         // For\
    \ each possible velocity-direction combination...\n34 |                      \
    \   for velocity in 1..2 * n {\n   |                                         \
    \         - unclosed delimiter\n...\n48 |                             for start\
    \ in 0..2 * n {\n   |                                                   - unclosed\
    \ delimiter\n49 |                                 // For each possible direction-direction\
    \ combination...\n50 |                                 for direction in 1..2 *\
    \ n {\n   |                                                           - this delimiter\
    \ might not be properly closed...\n...\n62 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n71 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmp2c23lplw.rs:62:1\n   |\n62 | }\n   | ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2c23lplw.rs:24:58\n   |\n24 |\
    \                 let mut current_hits = vec![vec![0usize; n]; 2];\n   |     \
    \                                                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        // no need to do anything special\n\
    \        return 0;\n    }\n\n    let mut collision_count = 0;\n    let mut race_direction\
    \ = Vec::new();\n\n    for i in 0..n {\n        race_direction.push((i & 0b1111)\
    \ == 0);\n    }\n\n    let mut leftmost_car_pos = Vec::new();\n    let mut rightmost_car_pos\
    \ = Vec::new();\n    let mut car_speed = Vec::new();\n\n    for i in 0..n {\n\
    \        if race_direction[i] {\n            leftmost_car_pos.push(i);\n     \
    \   } else {\n            rightmost_car_pos.push(i);\n        }\n    }\n\n   \
    \ let mut leftmost_car_time = std::cmp::max::<isize>(0.0, rightmost_car_pos[0]);\n\
    \    let mut rightmost_car_time = std::cmp::min::<isize>(0.0, leftmost_car_pos.last().unwrap());\n\
    \n    while leftmost_car_time < rightmost_car_time {\n        let mut collision_time\
    \ = leftmost_car_time;\n        let mut collision_pos = leftmost_car_pos;\n\n\
    \        // find the collision time & position\n        for j in 0..n {\n    \
    \        let j_idx = j as u8;\n            if !race_direction[j_idx] {\n     \
    \           collision_time = std::cmp::min::<isize>(collision_time, leftmost_car_time[j]);\n\
    \                collision_pos.push(j);\n            }\n        }\n\n        //\
    \ find the collision velocity & acceleration\n        let mut collision_velocity\
    \ = Vec::new();\n        let mut collision_acceleration = Vec::new();\n\n    \
    \    for j in 0..n {\n            let j_idx = j as u8;\n            if j_idx <\
    \ collision_pos.len() {\n                let j_idx_pos = j as u8;\n          \
    \      let j_idx_velocity = j_idx as isize;\n                let j_idx_acceleration\
    \ = j_idx as isize;\n\n                let d_j_idx_velocity = collision_pos[j_idx_pos]\
    \ - j_idx_velocity;\n                let d_j_idx_acceleration = d_j_idx_velocity\
    \ * d_j_idx_velocity;\n\n                let d_j_idx_acceleration = collision_acceleration[j_idx_pos]\n\
    \                    + d_j_idx_acceleration\n                    * collision_acceleration[j_idx_pos];\n\
    \                collision_acceleration[j_idx_pos] = d_j_idx_acceleration;\n \
    \               collision_velocity.push(d_j_idx_velocity);\n            }\n  \
    \      }\n\n        let mut collision_acceleration = collision_acceleration.clone();\n\
    \        let mut collision_velocity = collision_velocity.clone();\n\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnuvjl1zt.rs:84:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n37 |     while leftmost_car_time\
    \ < rightmost_car_time {\n   |                                               \
    \   - this delimiter might not be properly closed...\n...\n75 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n84 | }\n   |   ^\n\n\
    error[E0277]: the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpnuvjl1zt.rs:27:12\n\
    \   |\n27 |         if race_direction[i] {\n   |            ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnuvjl1zt.rs:34:56\n   |\n34 |     let mut leftmost_car_time\
    \ = std::cmp::max::<isize>(0.0, rightmost_car_pos[0]);\n   |                 \
    \                                       ^^^ expected `isize`, found floating-point\
    \ number\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnuvjl1zt.rs:35:57\n\
    \   |\n35 |     let mut rightmost_car_time = std::cmp::min::<isize>(0.0, leftmost_car_pos.last().unwrap());\n\
    \   |                                                         ^^^ expected `isize`,\
    \ found floating-point number\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnuvjl1zt.rs:35:62\n\
    \   |\n35 |     let mut rightmost_car_time = std::cmp::min::<isize>(0.0, leftmost_car_pos.last().unwrap());\n\
    \   |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n35 |     let mut rightmost_car_time = std::cmp::min::<isize>(0.0, *leftmost_car_pos.last().unwrap());\n\
    \   |                                                              +\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `u8`\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for car in (0..n)\n\
    \        .filter(|c| {\n            c % 2 != 0 && !(car % 2 == 0)\n        })\n\
    \        .filter(|c| {\n            c % 2 == 0 && !(car % 2 != 0)\n        })\
    \ {\n        let mut j = car / 2;\n        let mut k = car / 2;\n        while\
    \ j < n {\n            let mut left = j % 2 == 0;\n            let mut right =\
    \ !left;\n            while !left && k < n {\n                let mut left = j\
    \ % 2 == 0;\n                let mut right = !left;\n                while !left\
    \ && k < n {\n                    left ^= !left;\n                    right ^=\
    \ !right;\n                    k += 1;\n                }\n                k +=\
    \ 1;\n            }\n            collisions += 1;\n            j += 1;\n     \
    \   }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `car` in this scope\n  --> /tmp/tmp9cf0o1fl.rs:13:29\n\
    \   |\n13 |             c % 2 != 0 && !(car % 2 == 0)\n   |                  \
    \           ^^^ not found in this scope\n\nerror[E0425]: cannot find value `car`\
    \ in this scope\n  --> /tmp/tmp9cf0o1fl.rs:16:29\n   |\n16 |             c % 2\
    \ == 0 && !(car % 2 != 0)\n   |                             ^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The only difference between this function and `car_race_collision_imp`\
    \ is\n    // that this function uses `car_race_collision_imp` instead.\n    let\
    \ mut counter = 0;\n    let mut min_dist = isize::MAX;\n    for car1 in (0..n\
    \ - 1).flat_map(|i| {\n        let mut car2 = i + 1;\n        loop {\n       \
    \     let dist = car_race_collision_imp(car1, &mut car2);\n            if dist\
    \ < min_dist {\n                min_dist = dist;\n                counter = car1\
    \ + car2;\n            }\n            car2 += 1;\n            if car2 >= n {\n\
    \                break;\n            }\n        }\n    }).rev() {\n        //\
    \ The minus 1 is to account for the fact that `car1` is 0 based and\n        //\
    \ `car2` is 1 based.  Thus, a car that has 0 collisions with itself will\n   \
    \     // have -1 collisions.\n        let collisions = counter - 1;\n        println!(\"\
    There are {} collisions between cars {} and {}\", collisions, car1, car2);\n \
    \   }\n    counter\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_imp` in this scope\n\
    \  --> /tmp/tmpa00r38mq.rs:17:24\n   |\n17 |             let dist = car_race_collision_imp(car1,\
    \ &mut car2);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `car1` in this scope\n  --> /tmp/tmpa00r38mq.rs:17:47\n\
    \   |\n17 |             let dist = car_race_collision_imp(car1, &mut car2);\n\
    \   |                                               ^^^^ help: a local variable\
    \ with a similar name exists: `car2`\n\nerror[E0425]: cannot find value `car1`\
    \ in this scope\n  --> /tmp/tmpa00r38mq.rs:20:27\n   |\n20 |                 counter\
    \ = car1 + car2;\n   |                           ^^^^ help: a local variable with\
    \ a similar name exists: `car2`\n\nerror[E0425]: cannot find value `car2` in this\
    \ scope\n  --> /tmp/tmpa00r38mq.rs:32:86\n   |\n32 |         println!(\"There\
    \ are {} collisions between cars {} and {}\", collisions, car1, car2);\n   | \
    \                                                                            \
    \         ^^^^ help: a local variable with a similar name exists: `car1`\n\nerror[E0277]:\
    \ `()` is not an iterator\n    --> /tmp/tmpa00r38mq.rs:14:37\n     |\n14   | \
    \      for car1 in (0..n - 1).flat_map(|i| {\n     |  ____________________________--------_^\n\
    \     | |                            |\n     | |                            required\
    \ by a bound introduced by this call\n15   | |         let mut car2 = i + 1;\n\
    16   | |         loop {\n17   | |             let dist = car_race_collision_imp(car1,\
    \ &mut car2);\n...    |\n26   | |         }\n27   | |     }).rev() {\n     | |_____^\
    \ `()` is not an iterator\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `()`\n     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `()`\nnote: required by a bound in `flat_map`\n\nerror[E0599]: the method\
    \ `rev` exists for struct `FlatMap<std::ops::Range<isize>, (), [closure@/tmp/tmpa00r38mq.rs:14:37:\
    \ 27:6]>`, but its trait bounds were not satisfied\n  --> /tmp/tmpa00r38mq.rs:27:8\n\
    \   |\n27 |       }).rev() "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut total = 0;\n    let mut c = 0;\n    while c <\
    \ n {\n        let a = car::generate();\n        let b = car::generate();\n  \
    \      total += ((&a - &b).len() - 1).min(b.len());\n        c += 1;\n    }\n\
    \    total\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `car`\n\
    \  --> /tmp/tmpztnqiyyz.rs:13:17\n   |\n13 |         let a = car::generate();\n\
    \   |                 ^^^ use of undeclared crate or module `car`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `car`\n  --> /tmp/tmpztnqiyyz.rs:14:17\n\
    \   |\n14 |         let b = car::generate();\n   |                 ^^^ use of\
    \ undeclared crate or module `car`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut seen: HashSet<usize> = (1..n)\n        .iter()\n\
    \        .map(|i| i)\n        .collect();\n    let mut cars: Vec<_> = (1..n)\n\
    \        .map(|i| i)\n        .map(|i| i as usize)\n        .collect();\n    cars.sort();\n\
    \    let mut collisions = 0;\n    while cars.len() > 1 {\n        let left = cars.remove(0);\n\
    \        let right = cars.remove(0);\n        if left < right {\n            if\
    \ seen.contains(left) {\n                collisions += 1;\n            }\n   \
    \         seen.insert(right);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8tnztvja.rs:10:19\n\
    \   |\n10 |     let mut seen: HashSet<usize> = (1..n)\n   |                  \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]: no method named\
    \ `iter` found for struct `std::ops::Range` in the current scope\n  --> /tmp/tmp8tnztvja.rs:11:10\n\
    \   |\n11 |         .iter()\n   |          ^^^^ method not found in `std::ops::Range<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut\
    \ i = 10;\n    let mut c = 0;\n    while i > 1 {\n        i *= 3;\n        c++;\n\
    \    }\n\n    i *= n;\n    c\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpcw695rle.rs:18:10\n\
    \   |\n18 |         c++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n18 |         { let tmp = c; c += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n18 -         c++;\n18 +         c +=\
    \ 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut car_positions\
    \ = Vec::new();\n\n    for i in 1..n {\n        let j = n - i;\n        let mut\
    \ car1 = i;\n        let mut car2 = j;\n\n        while car1 != car2 {\n     \
    \       car1 += 1;\n            car2 -= 1;\n        }\n\n        if car1 == car2\
    \ {\n            collisions += 1;\n        }\n\n        car_positions.push((car1,\
    \ car2));\n    }\n\n    for (c1, c2) in car_positions.iter() {\n        let (car1,\
    \ car2) = c1.clone();\n        let (car3, car4) = c2.clone();\n\n        let mut\
    \ car_speed = usize::MAX;\n        let mut car_speed2 = usize::MAX;\n\n      \
    \  while car1 != car3 {\n            car_speed += 1;\n            car1 -= 1;\n\
    \        }\n\n        while car2 != car4 {\n            car_speed2 += 1;\n   \
    \         car2 -= 1;\n        }\n\n        car_speed = min(car_speed, car_speed2);\n\
    \n        if car_speed != car_speed2 {\n            collisions += 1;\n       \
    \ }\n\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpobr0dp5e.rs:47:21\n\
    \   |\n47 |         car_speed = min(car_speed, car_speed2);\n   |            \
    \         ^^^\n...\n58 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    47 |         car_speed = main(car_speed, car_speed2);\n   |                  \
    \   ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpobr0dp5e.rs:31:13\n   |\n\
    31 |         let (car1, car2) = c1.clone();\n   |             ^^^^^^^^^^^^   ----------\
    \ this expression has type `isize`\n   |             |\n   |             expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpobr0dp5e.rs:32:13\n\
    \   |\n32 |         let (car3, car4) = c2.clone();\n   |             ^^^^^^^^^^^^\
    \   ---------- this expression has type `isize`\n   |             |\n   |    \
    \         expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n\
    \             found tuple `(_, _)`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collided = false;\n    // Simulate two cars colliding.\n\
    \    while !collided {\n        let car_1 = 2 * n - 1;\n        let car_2 = 2\
    \ * n - 2;\n        if car_1 == 0 || car_2 == n {\n            collided = true;\n\
    \        } else {\n            if car_1 < car_2 {\n                let car_1_2\
    \ = car_1 - car_2;\n                if car_1_2 > 1 {\n                    let\
    \ car_3 = car_1 + car_2;\n                    if car_3 < n {\n               \
    \         let car_3_2 = car_3 - car_2;\n                        if car_3_2 > 1\
    \ {\n                            let car_4 = car_1 + car_3;\n                \
    \            if car_4 < n {\n                                let car_4_2 = car_4\
    \ - car_3;\n                                if car_4_2 > 1 {\n               \
    \                     let car_5 = car_1 + car_4;\n                           \
    \         if car_5 < n {\n                                        let car_5_2\
    \ = car_5 - car_4;\n                                        if car_5_2 > 1 {\n\
    \                                            if car_1_2 < car_3_2 && car_3_2 <\
    \ car_5_2 {\n                                                if car_1_2 < car_4_2\
    \ && car_4_2 < car_5_2 {\n                                                   \
    \ if car_1_2 < car_5_2 && car_5_2 < car_2_2 {\n                              \
    \                          if car_3_2 < car_4_2 && car_4_2 < car_5_2 {\n     \
    \                                                       if car_3_2 < car_5_2 &&\
    \ car_5_2 < car_2_2 {\n                                                      \
    \          if car_4_2 < car_5_2 {\n                                          \
    \                          if car_4_2 < car_5_2 {\n                          \
    \                                              if car_1_2 < car_5_2 {\n      \
    \                                                                      if car_1_2\
    \ < car_2_2 {\n                                                              \
    \                  if car_2_2 < car_3_2 {\n                                  \
    \                  if car_2_2 < car_3_2 {\n                                  \
    \                      if car_2_2 < car_4_2 {\n                              \
    \                              if car_2_2 < car_5_2 {\n                      \
    \                                          if car_1_2 < car_5_2 {\n          \
    \                                                          if car_1_2 < car_3_2\
    \ {\n                                                                        collided\
    \ = true;\n                                                                  \
    \  }\n                                                                }\n    \
    \                                                        }\n                 \
    \                                       }\n                                  \
    \                  }\n                                                       \
    \         }\n                                                            \n  \
    \                                                              if car_3_2 < car_4_2\
    \ {\n                                                                    if car_4_2\
    \ < car_5_2 {\n                                                              \
    \                          if car_4_2 < car_2_2 {\n                          \
    \                                                                  if car_2_2\
    \ < car_4_2 {\n                                                              \
    \                  collided = true;\n                                        \
    \                                    }\n                                     \
    \                                   }\n                                      \
    \                              }\n                                           \
    \                     }\n                                                    \
    \        \n                                                            }\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuv3bcv5k.rs:76:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n12 |     while !collided\
    \ {\n   |                     - unclosed delimiter\n...\n17 |         } else {\n\
    \   |                - unclosed delimiter\n18 |             if car_1 < car_2 {\n\
    \   |                              - unclosed delimiter\n19 |                \
    \ let car_1_2 = car_1 - car_2;\n20 |                 if car_1_2 > 1 {\n   |  \
    \                              - unclosed delimiter\n21 |                    \
    \ let car_3 = car_1 + car_2;\n22 |                     if car_3 < n {\n   |  \
    \                                - unclosed delimiter\n23 |                  \
    \       let car_3_2 = car_3 - car_2;\n24 |                         if car_3_2\
    \ > 1 {\n   |                                        - unclosed delimiter\n25\
    \ |                             let car_4 = car_1 + car_3;\n26 |             \
    \                if car_4 < n {\n   |                                        \
    \  - unclosed delimiter\n27 |                                 let car_4_2 = car_4\
    \ - car_3;\n28 |                                 if car_4_2 > 1 {\n   |      \
    \                                          - unclosed delimiter\n29 |        \
    \                             let car_5 = car_1 + car_4;\n30 |               \
    \                      if car_5 < n {\n   |                                  \
    \                - unclosed delimiter\n31 |                                  \
    \       let car_5_2 = car_5 - car_4;\n32 |                                   \
    \      if car_5_2 > 1 {\n   |                                                \
    \        - unclosed delimiter\n33 |                                          \
    \   if car_1_2 < car_3_2 && car_3_2 < car_5_2 {\n   |                        \
    \                                                               - unclosed delimiter\n\
    34 |                                                 if car_1_2 < car_4_2 && car_4_2\
    \ < car_5_2 {\n   |                                                           "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n\n    for _ in 0..n {\n\
    \        let mut collision = true;\n\n        // The cars start at the bottom\
    \ of the road.\n        for _ in 0..n {\n            if !collision { break; }\n\
    \n            // Move the cars right by one.\n            collision = !car_collides();\n\
    \        }\n\n        // When all the cars move right, there will be a collision.\n\
    \        collision_count = collision_count + 1;\n    }\n\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collides` in this scope\n  -->\
    \ /tmp/tmpakldmctp.rs:20:26\n   |\n20 |             collision = !car_collides();\n\
    \   |                          ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut x1: f64 = -3.0;\n    let mut y1: f64 = 1.0;\n\
    \    let mut x2: f64 = -3.0;\n    let mut y2: f64 = -1.0;\n    let mut c1 = 0.0;\n\
    \    let mut c2 = 0.0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut count\
    \ = 0;\n    loop {\n        i += 1;\n        j += 1;\n        if i >= n {\n  \
    \          x1 += 1.0;\n            i += 1;\n        }\n        if j >= n {\n \
    \           y1 += 1.0;\n            j += 1;\n        }\n        if i >= n {\n\
    \            x2 += 1.0;\n            i += 1;\n        }\n        if j >= n {\n\
    \            y2 += 1.0;\n            j += 1;\n        }\n\n        if x1 > x2\
    \ {\n            c1 = x1;\n            x1 = x2;\n            x2 = c2;\n      \
    \      c2 = c1;\n        }\n\n        if y1 > y2 {\n            c1 = y1;\n   \
    \         y1 = y2;\n            y2 = c2;\n            c2 = c1;\n        }\n  \
    \      if x1 != x2 || y1 != y2 {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // the number of collisions.\n\
    \    let mut a = ((n - 1) as f64 / 4).sqrt(); // the length of a segment of the\
    \ same angle as a.\n    let mut b = (n * (n - 1) * (n - 2) / 8).sqrt();  // the\
    \ length of a segment of the same angle as b.\n\n    // The length of the segment\
    \ of the same angle as a.\n    while a + a < b {\n        a += a;\n    }\n\n \
    \   // The length of the segment of the same angle as b.\n    while b + b < a\
    \ {\n        b += b;\n    }\n\n    // If the segments collide.\n    if a + b <\
    \ n {\n        collisions += 1;\n    }\n\n    // If the segments collide after\
    \ one iteration, then there are n collisions.\n    if collisions == n {\n    \
    \    0\n    } else {\n        collisions\n    }\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n  --> /tmp/tmp93agxc7w.rs:11:33\n\
    \   |\n11 |     let mut a = ((n - 1) as f64 / 4).sqrt(); // the length of a segment\
    \ of the same angle as a.\n   |                                 ^ no implementation\
    \ for `f64 / {integer}`\n   |\n   = help: the trait `Div<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n11 |     let mut a = ((n - 1) as f64 / 4.0).sqrt(); // the length\
    \ of a segment of the same angle as a.\n   |                                 \
    \   ++\n\nerror[E0599]: no method named `sqrt` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp93agxc7w.rs:12:45\n   |\n12 |     let mut b = (n * (n -\
    \ 1) * (n - 2) / 8).sqrt();  // the length of a segment of the same angle as b.\n\
    \   |                                             ^^^^ method not found in `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0;\n    while n > 0 {\n        n -= 1;\n\
    \        if n % 2 == 0 {\n            c += 1;\n        }\n    }\n    c\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpyolwl6uo.rs:12:9\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut n`\n...\n12 |      \
    \   n -= 1;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut collision_distance\
    \ = 0.0;\n    let mut collision_time = 0.0;\n    let mut collision_x = 0.0;\n\
    \    let mut collision_y = 0.0;\n    // let mut collision_dx = 0.0;\n    // let\
    \ mut collision_dy = 0.0;\n\n    for _ in 0..n {\n        // let mut collision_dx\
    \ = 0.0;\n        // let mut collision_dy = 0.0;\n\n        // This car moves\
    \ left to right\n        if collision_time == 0.0 {\n            collision_x =\
    \ 10.0;\n            collision_y = 10.0;\n            // collision_dx = 10.0;\n\
    \            // collision_dy = 10.0;\n        } else {\n            collision_x\
    \ += collision_dx;\n            collision_y += collision_dy;\n        }\n\n  \
    \      // The other car is moving to left and hitting this car\n        // let\
    \ mut collision_dx = 10.0;\n        // let mut collision_dy = 10.0;\n\n      \
    \  // This car moves right to left\n        // if collision_time == 0.0 {\n  \
    \      //     collision_x = 10.0;\n        //     collision_y = 10.0;\n      \
    \  //     // collision_dx = 10.0;\n        //     // collision_dy = 10.0;\n  \
    \      // } else {\n        //     collision_x -= collision_dx;\n        //  \
    \   collision_y -= collision_dy;\n        // }\n\n        // We use the distance\
    \ formula to calculate a distance between them\n        let distance = sqrt(((collision_x\
    \ - collision_x) as f32)\n                             * ((collision_x - collision_x)\
    \ as f32)\n                             + // x^2\n                           \
    \  ((collision_y - collision_y) as f32)\n                             * ((collision_y\
    \ - collision_y) as f32));\n        // TODO: Maybe this should include a square\
    \ root?  It may help us determine\n        // when two cars are colliding.\n \
    \       // TODO: This distance formula may need to be a little more complex...\
    \ if we get\n        // collisions with the same distance (ie: two cars traveling\
    \ at the same distance)\n        // we can ignore the collision time and just\
    \ assume they're colliding.\n\n        // This car has moved past the line for\
    \ too long\n        if collision_time > 10.0 {\n            collisions += 1;\n\
    \        }\n        // This car has moved past the line for too short\n      \
    \  if collision_time < -10.0 {\n            collisions += 1;\n        }\n    \
    \    // This car has moved past the line for too slow\n        if collision_time\
    \ > 10.0 || collision_time < -10.0 {\n            collisions += 1;\n        }\n\
    \n        // If this car has \n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxu6usg9e.rs:83:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n18 |     for _ in 0..n {\n\
    \   |                   - this delimiter might not be properly closed...\n...\n\
    74 | }\n   | - ...as it matches this but it has different indentation\n...\n83\
    \ | }\n   |   ^\n\nerror[E0425]: cannot find value `collision_dx` in this scope\n\
    \  --> /tmp/tmpxu6usg9e.rs:29:28\n   |\n29 |             collision_x += collision_dx;\n\
    \   |                            ^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `collision_x`\n\nerror[E0425]: cannot find value `collision_dy`\
    \ in this scope\n  --> /tmp/tmpxu6usg9e.rs:30:28\n   |\n30 |             collision_y\
    \ += collision_dy;\n   |                            ^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `collision_y`\n\nerror[E0425]: cannot find\
    \ function `sqrt` in this scope\n  --> /tmp/tmpxu6usg9e.rs:49:24\n   |\n49 | \
    \        let distance = sqrt(((collision_x - collision_x) as f32)\n   |      \
    \                  ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpxu6usg9e.rs:9:36\n  |\n9 | fn car_race_collision(n: isize) -> isize\
    \ {\n  |    ------------------              ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Initialize an array of boolean values.\n    // The\
    \ i-th element will be True if the i-th car is on the left and False\n    // otherwise.\n\
    \    let mut collides = vec![n].iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut n = n as isize;\n    // Iterate n times. At each iteration, if the i-th\
    \ car on the left and the\n    // i-th car on the right collide at the same time,\
    \ then the i-th car will\n    // not collide.\n    while n > 0 {\n        if collides[n\
    \ - 1] && collides[n - 2] {\n            return n - 1;\n        }\n        --n;\n\
    \    }\n    return 0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3m2039tn.rs:19:12\n\
    \   |\n19 |         if collides[n - 1] && collides[n - 2] {\n   |            ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3m2039tn.rs:19:31\n\
    \   |\n19 |         if collides[n - 1] && collides[n - 2] {\n   |            \
    \                   ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0;\n    for _ in 0..n {\n        for _ in\
    \ 0..n {\n            c += 1;\n        }\n    }\n    c\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // number of collisions\n   \
    \ let mut total_moves = 0; // number of moves cars have made (including collisions)\n\
    \    let mut first_move = vec![n];\n    first_move[0] = 1;\n    for &i in 1..n\
    \ {\n        let mut moves = first_move[i - 1];\n        while moves > 0 {\n \
    \           collisions += 1;\n            moves -= 1;\n        }\n        total_moves\
    \ += first_move[i - 1];\n        first_move[i - 1] -= 1;\n    }\n    total_moves\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuv4i8z9t.rs:14:9\n   |\n\
    14 |     for &i in 1..n {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (2..n).filter(|i| {\n        i % 2 == 0\n    }).count(|i|\
    \ {\n        i % 2 == 1\n    })\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpnujeoeu_.rs:12:8\n    |\n12  |       }).count(|i| {\n    |  ________^^^^^_-\n\
    \    | |        |\n    | |        expected 0 arguments\n13  | |         i % 2\
    \ == 1\n14  | |     })\n    | |_____- supplied 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnujeoeu_.rs:10:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n10 | /\
    \     (2..n).filter(|i| {\n11 | |         i % 2 == 0\n12 | |     }).count(|i|\
    \ {\n13 | |         i % 2 == 1\n14 | |     })\n   | |______^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     }).try_into().unwrap()\n\
    \   |       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The set of waypoints is the set of n points where\
    \ each point has two\n    // coordinates.\n    // For example, given three points\
    \ {(0,0), (10,0), (5,5)}, the set would be\n    // {(0,0), (0,10), (0,5), (5,0),\
    \ (5,5), (10,5), (10,0), (10,10)}\n    let waypoints = [(0., 0.) for _ in 0..=n].iter().cloned().collect::<Vec<_>>();\n\
    \n    // The set of cars are the n sets of waypoints, where a car has one waypoint\n\
    \    // and a set of waypoints is a unique (non-overlapping) set of waypoints.\n\
    \    // For example, given three cars {(0,0), (0,10), (0,5)}, the set would be\n\
    \    // {(0,0), (0,10), (0,5), (5,0), (5,5), (10,5), (10,0), (10,10)}\n    let\
    \ cars = (0..=n).map(|_| waypoints.clone()).collect::<Vec<_>>();\n\n    // The\
    \ function below finds if two cars collide (going left and right to\n    // the\
    \ same point).  If the cars overlap, then they will continue their\n    // trajectories\
    \ until they no longer overlap.\n    //\n    // As a result, if two cars collide,\
    \ then the distance between their waypoints\n    // is positive.  If the cars\
    \ aren't colliding, then the distance between\n    // their waypoints is zero.\
    \  So the function below returns true or false to\n    // determine if the two\
    \ cars collide.\n    let collides = (0..=n).map(|i| {\n        let c1 = cars[i];\n\
    \        let c2 = cars[(i+1) % n];\n\n        // Find the smallest waypoint between\
    \ c1 and c2 that they could collide.\n        let mut i1 = 0..=waypoints.len();\n\
    \        let mut i2 = 0..=waypoints.len();\n        while i1.len() < 2 {\n   \
    \         i1.push(0);\n            i2.push(0);\n        }\n\n        // Get the\
    \ indices of waypoints that will be affected by the collision.\n        let mut\
    \ collided1 = i1.iter().cloned().collect::<Vec<_>>();\n        let mut collided2\
    \ = i2.iter().cloned().collect::<Vec<_>>();\n\n        // If they collide, then\
    \ their waypoints must overlap.  We know if they\n        // collide if they hit\
    \ the same set of waypoints multiple times.\n        for _ in 0..=n {\n      \
    \      collided1.push(0);\n            collided2.push(0);\n        }\n\n     \
    \   // If the two cars overlap, then there will be a pair of waypoints that they\n\
    \        // will \n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp29ik8xpt.rs:64:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n30 |     let collides = (0..=n).map(|i|\
    \ {\n   |                               - unclosed delimiter\n...\n64 | }\n  \
    \ |   ^\n\nerror: expected one of `,`, `.`, `;`, `?`, `]`, or an operator, found\
    \ keyword `for`\n  --> /tmp/tmp29ik8xpt.rs:14:31\n   |\n14 |     let waypoints\
    \ = [(0., 0.) for _ in 0..=n].iter().cloned().collect::<Vec<_>>();\n   |     \
    \                          ^^^ expected one of `,`, `.`, `;`, `?`, `]`, or an\
    \ operator\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The race condition occurs when n and n_right are both\
    \ odd.  The\n    // race condition is the same as the race condition when n is\
    \ even,\n    // except that the collision is when the left and right cars collide\n\
    \    // in an odd position\n    // e.g. if the first n cars are moving right,\
    \ the second n cars are moving left\n    // then there is a collision if n_left\
    \ is odd.\n    let mut collisions = 0;\n    for i in 0..n {\n        for j in\
    \ 0..n {\n            if i % 2 == 0 && j % 2 == 0 {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpzcred26g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut collisions\
    \ = 0;\n    for (i, left) in (0..n)\n        .filter(|&i| i > 0)\n        .map(|&i|\
    \ {\n            (i, left - i);\n        })\n    {\n        for (j, right) in\
    \ (0..n)\n            .filter(|&j| j > 0)\n            .map(|&j| {\n         \
    \       (j, right - j);\n            })\n        {\n            collisions +=\
    \ if i == j && left == right {\n                1\n            } else {\n    \
    \            if i < j {\n                    -car_race_collision(i - 1)\n    \
    \            } else if j < i {\n                    -car_race_collision(j - 1)\n\
    \                } else {\n                    0\n                }\n        \
    \    };\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpk1l6ghdm.rs:17:17\n\
    \   |\n17 |             (i, left - i);\n   |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpk1l6ghdm.rs:23:21\n\
    \   |\n23 |                 (j, right - j);\n   |                     ^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk1l6ghdm.rs:16:15\n\
    \   |\n16 |         .map(|&i| {\n   |               ^--\n   |               ||\n\
    \   |               |expected due to this\n   |               expected `isize`,\
    \ found reference\n   |               help: did you mean `i`: `&isize`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk1l6ghdm.rs:14:9\n   |\n14 |       for (i, left)\
    \ in (0..n)\n   |  _________^^^^^^^^^____-\n   | |         |\n   | |         expected\
    \ `()`, found tuple\n15 | |         .filter(|&i| i > 0)\n16 | |         .map(|&i|\
    \ {\n17 | |             (i, left - i);\n18 | |         })\n   | |__________- this\
    \ expression has type `Option<()>`\n   |\n   = note: expected unit type `()`\n\
    \                  found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk1l6ghdm.rs:22:19\n   |\n22 |             .map(|&j| {\n   |        \
    \           ^--\n   |                   ||\n   |                   |expected due\
    \ to this\n   |                   expected `isize`, found reference\n   |    \
    \               help: did you mean `j`: `&isize`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk1l6ghdm.rs:20:13\n   |\n20 |           for (j, right) in (0..n)\n\
    \   |  _____________^^^^^^^^^^____-\n   | |             |\n   | |            \
    \ expected `()`, found tuple\n21 | |             .filter(|&j| j > 0)\n22 | | \
    \            .map(|&j| {\n23 | |                 (j, right - j);\n24 | |     \
    \        })\n   | |______________- this expression has type `Option<()>`\n   |\n\
    \   = note: expected unit type `()`\n                  found tuple `(_, _)`\n\n\
    error: aborting due to 6 previo"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut i = 1; // number of collision pairs\n    let\
    \ mut j = 1; // number of collision pairs\n    let mut collisions = 0;\n    while\
    \ i != n && j != n {\n        i -= j;\n        i += j;\n        j -= i;\n    \
    \    j += i;\n        if i == n {\n            i--;\n        }\n        if j ==\
    \ n {\n            j--;\n        }\n        collisions++;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp27hdi3he.rs:19:16\n\
    \   |\n19 |             i--;\n   |                ^ expected expression\n\nerror:\
    \ expected expression, found `;`\n  --> /tmp/tmp27hdi3he.rs:22:16\n   |\n22 |\
    \             j--;\n   |                ^ expected expression\n\nerror: Rust has\
    \ no postfix increment operator\n  --> /tmp/tmp27hdi3he.rs:24:19\n   |\n24 | \
    \        collisions++;\n   |                   ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n24 |         { let tmp = collisions; collisions\
    \ += 1; tmp };\n   |         +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    24 -         collisions++;\n24 +         collisions += 1;\n   | \n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: usize = 0;\n    for _ in 0..n {\n\
    \        let mut speed = rand::random::<f64>();\n        let mut collision_point\
    \ = 0;\n        while speed > CAR_SPEED + CAR_SPEED*CAR_RADIUS {\n           \
    \ collision_point += 1;\n            speed -= CAR_SPEED;\n        }\n        while\
    \ speed < CAR_SPEED - CAR_SPEED*CAR_RADIUS {\n            collision_point += 1;\n\
    \            speed += CAR_SPEED;\n        }\n        for _ in 0..collision_point\
    \ {\n            speed += CAR_SPEED * 0.5;\n        }\n        collisions += 1;\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpao1qgr7q.rs:12:25\n   |\n12 |         let mut speed = rand::random::<f64>();\n\
    \   |                         ^^^^ use of undeclared crate or module `rand`\n\n\
    error[E0425]: cannot find value `CAR_SPEED` in this scope\n  --> /tmp/tmpao1qgr7q.rs:14:23\n\
    \   |\n14 |         while speed > CAR_SPEED + CAR_SPEED*CAR_RADIUS {\n   |   \
    \                    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAR_SPEED` in this scope\n  --> /tmp/tmpao1qgr7q.rs:14:35\n   |\n\
    14 |         while speed > CAR_SPEED + CAR_SPEED*CAR_RADIUS {\n   |          \
    \                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAR_RADIUS` in this scope\n  --> /tmp/tmpao1qgr7q.rs:14:45\n   |\n\
    14 |         while speed > CAR_SPEED + CAR_SPEED*CAR_RADIUS {\n   |          \
    \                                   ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAR_SPEED` in this scope\n  --> /tmp/tmpao1qgr7q.rs:16:22\n\
    \   |\n16 |             speed -= CAR_SPEED;\n   |                      ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `CAR_SPEED` in this\
    \ scope\n  --> /tmp/tmpao1qgr7q.rs:18:23\n   |\n18 |         while speed < CAR_SPEED\
    \ - CAR_SPEED*CAR_RADIUS {\n   |                       ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `CAR_SPEED` in this scope\n  -->\
    \ /tmp/tmpao1qgr7q.rs:18:35\n   |\n18 |         while speed < CAR_SPEED - CAR_SPEED*CAR_RADIUS\
    \ {\n   |                                   ^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `CAR_RADIUS` in this scope\n  --> /tmp/tmpao1qgr7q.rs:18:45\n\
    \   |\n18 |         while speed < CAR_SPEED - CAR_SPEED*CAR_RADIUS {\n   |   \
    \                                          ^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `CAR_SPEED` in this scope\n  --> /tmp/tmpao1qgr7q.rs:20:22\n\
    \   |\n20 |             speed += CAR_SPEED;\n   |                      ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `CAR_"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut max_x = 0;\n   \
    \ let mut max_y = 0;\n    let mut max_x = 0;\n    let mut max_y = 0;\n    for\
    \ i in 0..n {\n        let mut x = 2 * i + 1;\n        let mut y = 2 * i + 1;\n\
    \        let mut dx = 0;\n        let mut dy = 0;\n        while x < n {\n   \
    \         if x + 1 < n {\n                if dx > dy {\n                    max_x\
    \ = x;\n                    dy = dy;\n                }\n                x +=\
    \ 1;\n            } else {\n                x += 1;\n            }\n        }\n\
    \        while y < n {\n            if y + 1 < n {\n                if dy > dx\
    \ {\n                    max_y = y;\n                    dx = dx;\n          \
    \      }\n                y += 1;\n            } else {\n                y +=\
    \ 1;\n            }\n        }\n        if dx != dy {\n            collisions\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpsh3ndl8s.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    for i in 1..n {\n       \
    \ for j in (i + 1)..n {\n            if i != j {\n                if car_collision(i,\
    \ j) || car_collision(j, i) {\n                    collisions += 1;\n        \
    \        }\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpw4v67kq5.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     for i in 1..n {\n   |     --- unexpected token\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmpw4v67kq5.rs:14:20\n\
    \   |\n14 |                 if car_collision(i, j) || car_collision(j, i) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmpw4v67kq5.rs:14:43\n\
    \   |\n14 |                 if car_collision(i, j) || car_collision(j, i) {\n\
    \   |                                           ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    for _ in 0..n {\n      \
    \  let mut collision = 0;\n        for j in 0..n {\n            if j == i {\n\
    \                continue;\n            }\n            if j <= i {\n         \
    \       continue;\n            }\n            if car_race_collision(j) & car_race_collision(i)\
    \ == 0 {\n                collision += 1;\n            }\n        }\n        if\
    \ collision == 0 {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpz29mola9.rs:14:21\n\
    \   |\n14 |             if j == i {\n   |                     ^ help: a local\
    \ variable with a similar name exists: `j`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpz29mola9.rs:17:21\n   |\n17 |             if\
    \ j <= i {\n   |                     ^ help: a local variable with a similar name\
    \ exists: `j`\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpz29mola9.rs:20:59\n\
    \   |\n20 |             if car_race_collision(j) & car_race_collision(i) == 0\
    \ {\n   |                                                           ^ help: a\
    \ local variable with a similar name exists: `j`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut previous_collision_distance\
    \ = -1;\n    let mut current_collision_distance = -1;\n    let mut prev_x_value\
    \ = -1;\n    let mut current_x_value = -1;\n    for _ in 0..n {\n        // move\
    \ a car\n        let car_pos = car_pos(i);\n        prev_x_value = car_pos.x;\n\
    \        current_x_value = car_pos.x;\n        current_collision_distance = (car_pos.x\
    \ - car_pos.x) / 2;\n        if current_collision_distance > previous_collision_distance\
    \ {\n            collision_count += 1;\n        }\n        previous_collision_distance\
    \ = current_collision_distance;\n    }\n    collision_count\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_pos` in this scope\n  --> /tmp/tmpxdz0r1mm.rs:17:23\n\
    \   |\n17 |         let car_pos = car_pos(i);\n   |                       ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n\
    \  --> /tmp/tmpxdz0r1mm.rs:17:31\n   |\n17 |         let car_pos = car_pos(i);\n\
    \   |                               ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for i in 1..n {\n\
    \        let speed = i as isize;\n        let mut colliding = 0;\n        let\
    \ mut current = i;\n        while current >= 1 {\n            if current % 2 ==\
    \ 0 {\n                colliding += speed;\n            }\n            current\
    \ /= 2;\n        }\n        if colliding > speed {\n            collisions +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpqkj89as6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n\n    for _ in 0..n {\n\
    \        let mut collision = false;\n        for _ in 0..n {\n            if car_collision(&mut\
    \ collision, false, false) != false {\n                collision = true;\n   \
    \         }\n        }\n\n        if collision == false {\n            collisions\
    \ += 1;\n        }\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmp5r_cqf4i.rs:15:16\n   |\n15 |             if car_collision(&mut collision,\
    \ false, false) != false {\n   |                ^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `collision`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collided = 0;\n\n    // We will track what car\
    \ is moving left and right as we iterate over each car.\n    let mut left_car\
    \ = false;\n    let mut right_car = false;\n\n    for i in 1..n {\n        let\
    \ left_car = !left_car;\n        let right_car = !right_car;\n\n        // The\
    \ collision test requires that both cars are at the same speed.\n        if left_car\
    \ && right_car {\n            // Keep track of how many collisions we saw before\
    \ we see this one.\n            if collided == 0 {\n                collided++;\n\
    \            }\n        } else {\n            // If we're moving one car and not\
    \ the other, we've seen a collision.\n            if collided != 0 {\n       \
    \         return collided;\n            }\n        }\n    }\n\n    return collided;\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpww6tyq_0.rs:24:25\n\
    \   |\n24 |                 collided++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |         \
    \        { let tmp = collided; collided += 1; tmp };\n   |                 +++++++++++\
    \         ~~~~~~~~~~~~~~~~~~~~~~\n24 -                 collided++;\n24 +     \
    \            collided += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n % 2 == 0 {\n        return 0;\n    }\n    let mut\
    \ collisions = 1;\n    for x in (n - 1) / 2..n {\n        for y in x..x {\n  \
    \          if !((y - x) % 2) {\n                if car_collision(x, y) == -1 {\n\
    \                    collisions += 1;\n                }\n                if car_collision(y,\
    \ x) == -1 {\n                    collisions += 1;\n                }\n      \
    \      }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmplmks2ffv.rs:17:20\n   |\n17 |                 if car_collision(x, y)\
    \ == -1 {\n   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmplmks2ffv.rs:20:20\n\
    \   |\n20 |                 if car_collision(y, x) == -1 {\n   |             \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplmks2ffv.rs:16:16\n   |\n16 |             if !((y - x) % 2) {\n\
    \   |                ^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    while n > 0 {\n    \
    \    if n % 2 == 0 {\n            // The cars are moving left to right.\n    \
    \        let left_lane = n - 1;\n            let right_lane = n;\n           \
    \ let left_road = left_lane * 2;\n            let right_road = right_lane * 2;\n\
    \n            let left_lane_car_x = left_road + 1;\n            let right_lane_car_x\
    \ = right_road + 1;\n\n            let left_lane_car_y = left_lane + 1;\n    \
    \        let right_lane_car_y = right_lane + 1;\n\n            let left_car_radius\
    \ = 10;\n            let right_car_radius = 10;\n            let left_car_x =\
    \ left_lane_car_x - left_car_radius;\n            let right_car_x = right_lane_car_x\
    \ + right_car_radius;\n            let left_car_y = left_lane_car_y - left_car_radius;\n\
    \            let right_car_y = right_lane_car_y + right_car_radius;\n\n      \
    \      if left_car_x >= left_lane_car_x &&\n                right_car_x <= right_lane_car_x\
    \ &&\n                left_car_y <= left_lane_car_y &&\n                right_car_y\
    \ >= right_lane_car_y {\n                println!(\"Collision at left lane {}\
    \ & right lane {}\",\n                         left_lane, right_lane);\n     \
    \           println!(\"Car {} is {} cm away\",\n                         left_car_x,\
    \ left_car_y);\n                println!(\"Car {} is {} cm away\",\n         \
    \                right_car_x, right_car_y);\n                num_collisions +=\
    \ 1;\n            }\n\n            if left_lane <= n / 2 && right_lane >= n /\
    \ 2 {\n                // The cars are moving right to left.\n               \
    \ let left_lane_car_x = left_road + 1;\n                let right_lane_car_x =\
    \ right_road + 1;\n\n                let left_lane_car_y = left_lane + 1;\n  \
    \              let right_lane_car_y = right_lane + 1;\n\n                let left_car_radius\
    \ = 10;\n                let right_car_radius = 10;\n                let left_car_x\
    \ = left_lane_car_x + left_car_radius;\n                let right_car_x = right_lane_car_x\
    \ - right_car_radius;\n                let left_car_y = left_lane_car_y + left_car_radius;\n\
    \                let right_car_y = right_lane_car_y - right_car_radius;\n\n  \
    \              if left_car_x >= left_lane_car_x &&\n                    right_car_x\
    \ <= right_lane_car_x &&\n                    left_car_y <= left_lane_car_\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjqi38hhj.rs:72:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n10 |     let mut num_collisions\
    \ = 0;\n11 |     while n > 0 {\n   |                 - unclosed delimiter\n12\
    \ |         if n % 2 == 0 {\n   |                       - unclosed delimiter\n\
    ...\n35 |                 right_car_y >= right_lane_car_y {\n   |            \
    \                                     - this delimiter might not be properly closed...\n\
    ...\n43 |             }\n   |             - ...as it matches this but it has different\
    \ indentation\n...\n72 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  -->\
    \ /tmp/tmpjqi38hhj.rs:63:1\n   |\n60 |                 if left_car_x >= left_lane_car_x\
    \ &&\n   |                 -- this `if` expression has a condition, but no block\n\
    ...\n63 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjqi38hhj.rs:11:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n10 |  \
    \     let mut num_collisions = 0;\n11 | /     while n > 0 {\n12 | |         if\
    \ n % 2 == 0 {\n13 | |             // The cars are moving left to right.\n14 |\
    \ |             let left_lane = n - 1;\n...  |\n71 | |     assert_eq!(candidate(10),\
    \ 100);\n72 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..(n + 1)).filter(|x| x > n - 1).filter(|x| x > 0).count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8lj2e4l1.rs:10:33\n   |\n\
    10 |     (0..(n + 1)).filter(|x| x > n - 1).filter(|x| x > 0).count\n   |    \
    \                             ^^^^^\n   |                                 |\n\
    \   |                                 expected `&isize`, found `isize`\n   | \
    \                                help: consider borrowing here: `&(n - 1)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8lj2e4l1.rs:10:55\n   |\n10 |  \
    \   (0..(n + 1)).filter(|x| x > n - 1).filter(|x| x > 0).count\n   |         \
    \                                              ^\n   |                       \
    \                                |\n   |                                     \
    \                  expected `&isize`, found integer\n   |                    \
    \                                   help: consider borrowing here: `&0`\n\nerror[E0615]:\
    \ attempted to take value of method `count` on type `Filter<Filter<std::ops::Range<isize>,\
    \ [closure@/tmp/tmp8lj2e4l1.rs:10:25: 10:38]>, [closure@/tmp/tmp8lj2e4l1.rs:10:47:\
    \ 10:56]>`\n  --> /tmp/tmp8lj2e4l1.rs:10:58\n   |\n10 |     (0..(n + 1)).filter(|x|\
    \ x > n - 1).filter(|x| x > 0).count\n   |                                   \
    \                       ^^^^^ method, not a field\n   |\nhelp: use parentheses\
    \ to call the method\n   |\n10 |     (0..(n + 1)).filter(|x| x > n - 1).filter(|x|\
    \ x > 0).count()\n   |                                                       \
    \        ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0615.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut collisions:\
    \ isize = 0;\n    for &mut i in 0..n + 1 {\n        for &mut j in (i + 1)..n {\n\
    \            if car_collision(i, j) {\n                collisions += 1;\n    \
    \        }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmppznq90ap.rs:16:16\n   |\n16 |             if car_collision(i, j) {\n\
    \   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppznq90ap.rs:14:9\n   |\n14 |     for &mut i in 0..n + 1\
    \ {\n   |         ^^^^^^    -------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found `&mut _`\n   |         help:\
    \ you can probably remove the explicit borrow: `i`\n   |\n   = note:         \
    \  expected type `isize`\n           found mutable reference `&mut _`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppznq90ap.rs:15:13\n   |\n15 |         for &mut\
    \ j in (i + 1)..n {\n   |             ^^^^^^    ---------- this expression has\
    \ type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found `&mut _`\n   |             help: you can probably remove the explicit\
    \ borrow: `j`\n   |\n   = note:           expected type `isize`\n           found\
    \ mutable reference `&mut _`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut max_x = n - 1;\n\
    \    let mut min_x = 1;\n    while min_x < max_x {\n        let mut current_x\
    \ = min_x;\n        let mut current_y = n - 1;\n        let mut current_speed\
    \ = 0;\n        while current_y < current_x {\n            let mut jump_x = current_x;\n\
    \            let mut jump_y = current_y;\n            let mut jump_speed = 0;\n\
    \            while jump_x < jump_y {\n                let mut prev_x = jump_x;\n\
    \                let mut prev_y = jump_y;\n                let mut prev_speed\
    \ = jump_speed;\n                while prev_y < prev_x {\n                   \
    \ let next_speed = prev_speed + jump_speed + 1;\n                    if next_speed\
    \ < car_max_speed {\n                        jump_x += 1;\n                  \
    \      jump_speed += 1;\n                    } else {\n                      \
    \  jump_x = prev_x;\n                        jump_y = prev_y;\n              \
    \          jump_speed = prev_speed;\n                        break;\n        \
    \            }\n                }\n                prev_x = jump_x;\n        \
    \        prev_y = jump_y;\n                prev_speed = jump_speed;\n        \
    \    }\n            current_x += 1;\n            current_y += 1;\n           \
    \ current_speed += 1;\n        }\n        max_x = current_x;\n        min_x =\
    \ current_x;\n        let mut temp_x = max_x;\n        let mut temp_y = min_x;\n\
    \        let mut temp_speed = current_speed;\n        while temp_y < temp_x {\n\
    \            let mut jump_x = temp_x;\n            let mut jump_y = temp_y;\n\
    \            let mut jump_speed = temp_speed;\n            while jump_x < jump_y\
    \ {\n                let mut prev_x = jump_x;\n                let mut prev_y\
    \ = jump_y;\n                let mut prev_speed = jump_speed;\n              \
    \  while prev_y < prev_x {\n                    let next_speed = prev_speed +\
    \ jump_speed + 1;\n                    if next_speed < car_max_speed {\n     \
    \                   jump_x += 1;\n                        jump_speed += 1;\n \
    \                   } else {\n                        jump_x = prev_x;\n     \
    \                   jump_y = prev_y;\n                        jump_speed = prev_speed;\n\
    \                        break;\n                    }\n                }\n  \
    \              prev_x = jump_x;\n                prev_y = jump_y;\n          \
    \      prev_speed = jump_speed;\n            }\n            temp_x += 1;\n   \
    \         temp_y += 1;\n            temp_speed += 1;\n        }\n        if temp_speed\
    \ < car_max_speed {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `car_max_speed` in this scope\n  --> /tmp/tmp2p0cmppd.rs:27:37\n\
    \   |\n27 |                     if next_speed < car_max_speed {\n   |        \
    \                             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `car_max_speed` in this scope\n  --> /tmp/tmp2p0cmppd.rs:60:37\n\
    \   |\n60 |                     if next_speed < car_max_speed {\n   |        \
    \                             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `car_max_speed` in this scope\n  --> /tmp/tmp2p0cmppd.rs:78:25\n\
    \   |\n78 |         if temp_speed < car_max_speed {\n   |                    \
    \     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut speed = CAR_SPEED;\n\
    \    while n >= 2 {\n        collisions += count_collisions(&mut speed, n);\n\
    \        speed = -speed;\n        n -= 2;\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `CAR_SPEED` in this scope\n  --> /tmp/tmpoam_s7_u.rs:11:21\n\
    \   |\n11 |     let mut speed = CAR_SPEED;\n   |                     ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `count_collisions`\
    \ in this scope\n  --> /tmp/tmpoam_s7_u.rs:13:23\n   |\n13 |         collisions\
    \ += count_collisions(&mut speed, n);\n   |                       ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for _ in 0..n {\n \
    \       let mut left_road_end = 0;\n        let mut right_road_start = 0;\n  \
    \      for _ in 0..n {\n            let left_end_point = left_road_end;\n    \
    \        let right_start_point = right_road_start;\n            let left_speed\
    \ = left_end_point - left_road_end;\n            let right_speed = right_start_point\
    \ - right_road_start;\n            if left_speed > right_speed {\n           \
    \     left_road_end += 1;\n            } else {\n                right_road_start\
    \ += 1;\n            }\n            if left_road_end == n {\n                left_road_end\
    \ = 0;\n            }\n            if right_road_start == n {\n              \
    \  right_road_start = 0;\n            }\n            if left_end_point == right_start_point\
    \ {\n                collision_count += 1;\n            }\n        }\n    }\n\
    \    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpe20w3cic.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collide: isize = 0;\n    for _ in 0..n {\n  \
    \      let mut speed = 50;\n        let mut next_x = speed * 2 - 1;\n        for\
    \ _ in 0..n {\n            let mut collide = speed;\n            let mut collide\
    \ = collide;\n            let mut collide = collide;\n            let collide\
    \ = collide;\n            next_x += collide;\n        }\n    }\n    collide\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpf_z8w46k.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    fn in_triangle(a: &[i32], b: &[i32], c: &[i32]) -> bool\
    \ {\n        let mut l = a[0].powi(2);\n        let mut r = b[0].powi(2);\n  \
    \      let mut t = c[0].powi(2);\n        l += r; r += t; t += l;\n        l -=\
    \ r; r -= t; t -= l;\n        l += r; r += t; t += l;\n        l -= r; r -= t;\
    \ t -= l;\n        l += r; r += t; t += l;\n        l -= r; r -= t; t -= l;\n\
    \        l += r; r += t; t += l;\n        l -= r; r -= t; t -= l;\n        l +=\
    \ r; r += t; t += l;\n        l -= r; r -= t; t -= l;\n        l += r; r += t;\
    \ t += l;\n        l -= r; r -= t; t -= l;\n        l += r; r += t; t += l;\n\
    \        l -= r; r -= t; t -= l;\n        l += r; r += t; t += l;\n        l -=\
    \ r; r -= t; t -= l;\n        l += r; r += t; t += l;\n        l -= r; r -= t;\
    \ t -= l;\n        l += r; r += t; t += l;\n        l -= r; r -= t; t -= l;\n\
    \        l += r; r += t; t += l;\n        l -= r; r -= t; t -= l;\n        l +=\
    \ r; r += t; t += l;\n        l -= r; r -= t; t -= l;\n        l += r; r += t;\
    \ t += l;\n        l -= r; r -= t; t -= l;\n        l += r; r += t; t += l;\n\
    \        l -= r; r -= t; t -= l;\n        l += r; r += t; t += l;\n        l -=\
    \ r; r -= t; t -= l;\n        l += r; r += t; t += l;\n        l -= r; r -= t;\
    \ t -= l;\n        l += r; r += t; t += l;\n        l -= r; r -= t; t -= l;\n\
    \        l += r; r += t; t += l;\n        \n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpec8si8_v.rs:59:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n10 |     fn in_triangle(a: &[i32],\
    \ b: &[i32], c: &[i32]) -> bool {\n   |                                      \
    \                       - this delimiter might not be properly closed...\n...\n\
    50 | }\n   | - ...as it matches this but it has different indentation\n...\n59\
    \ | }\n   |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpec8si8_v.rs:9:36\n\
    \  |\n9 | fn car_race_collision(n: isize) -> isize {\n  |    ------------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror[E0599]:\
    \ no method named `powi` found for type `i32` in the current scope\n  --> /tmp/tmpec8si8_v.rs:11:26\n\
    \   |\n11 |         let mut l = a[0].powi(2);\n   |                          ^^^^\
    \ help: there is an associated function with a similar name: `pow`\n\nerror[E0599]:\
    \ no method named `powi` found for type `i32` in the current scope\n  --> /tmp/tmpec8si8_v.rs:12:26\n\
    \   |\n12 |         let mut r = b[0].powi(2);\n   |                          ^^^^\
    \ help: there is an associated function with a similar name: `pow`\n\nerror[E0599]:\
    \ no method named `powi` found for type `i32` in the current scope\n  --> /tmp/tmpec8si8_v.rs:13:26\n\
    \   |\n13 |         let mut t = c[0].powi(2);\n   |                          ^^^^\
    \ help: there is an associated function with a similar name: `pow`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpec8si8_v.rs:10:56\n   |\n10 |     fn in_triangle(a:\
    \ &[i32], b: &[i32], c: &[i32]) -> bool {\n   |        -----------           \
    \                          ^^^^ expected `bool`, found `()`\n   |        |\n \
    \  |        implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).filter(|&i| i % 2 == 1).count()\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgl3oglc.rs:10:5\n   |\n\
    9  | fn car_race_collision(n: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n10 |     (1..n).filter(|&i|\
    \ i % 2 == 1).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     (1..n).filter(|&i|\
    \ i % 2 == 1).count().try_into().unwrap()\n   |                              \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n\n    // Calculate the\
    \ initial speeds of each car.  Each car has a speed of its own.\n    let initial_speeds:\
    \ Vec<f32> = (0..n).collect();\n\n    // Calculate the initial position of each\
    \ car.\n    let mut initial_positions: Vec<Vec<f32>> = (0..n).map(|i| vec![i as\
    \ f32]).collect();\n\n    // Calculate the initial speeds of each car.  Each car\
    \ has a speed of its own.\n    let mut current_speeds: Vec<f32> = (0..n).map(|i|\
    \ i).collect();\n\n    // Calculate the initial position of each car.\n    let\
    \ mut current_positions: Vec<Vec<f32>> = (0..n).map(|i| vec![i as f32]).collect();\n\
    \n    // Compute the initial collision positions of each car.\n    let initial_collision_positions:\
    \ Vec<Vec<f32>> = (0..n).map(|i| vec![i as f32]).collect();\n\n    // Initialize\
    \ a counter for cars colliding with themselves.  This will be used\n    // to\
    \ tell how many collisions were detected before any collisions were detected.\n\
    \    let mut colliding_with_self = false;\n\n    // Start racing by moving the\
    \ initial set of cars a bit.\n    for _ in 0..6 {\n        // Iterate through\
    \ the sets of cars.\n        for _ in 0..n {\n            // Iterate through the\
    \ cars in the set.\n            for car_i in 0..n {\n                let car_speed\
    \ = initial_speeds[car_i];\n                let car_position = current_positions[car_i];\n\
    \n                // Move the car.\n                current_positions[car_i] =\
    \ car_position + car_speed * 0.1;\n                current_speeds[car_i] = car_speed\
    \ + 0.1;\n            }\n\n            // Compute the collision position of each\
    \ car.\n            let collision_positions: Vec<Vec<f32>> = (0..n).map(|i| vec![i\
    \ as f32]).collect();\n\n            // Check for collisions.\n            for\
    \ (collision_i, collision_position) in collision_positions.iter().enumerate()\
    \ {\n                let car_speed = initial_speeds[collision_i];\n          \
    \      let car_position = current_positions[collision_i];\n\n                //\
    \ Compute the car's speed vector and distance.\n                let collision_speed\
    \ = initial_speeds[collision_i];\n                let collision_position = current_positions[collision_i];\n\
    \                let distance = ((collision_position - car_position).magnitude()\
    \ - (car_speed * 0.5)).abs();\n\n                // If it is within our specified\
    \ distance of collision\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8xdk9t_r.rs:68:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n32 |     for _ in 0..6 {\n\
    \   |                   - unclosed delimiter\n33 |         // Iterate through\
    \ the sets of cars.\n34 |         for _ in 0..n {\n   |                      \
    \ - unclosed delimiter\n...\n49 |             for (collision_i, collision_position)\
    \ in collision_positions.iter().enumerate() {\n   |                          \
    \                                                                   - this delimiter\
    \ might not be properly closed...\n...\n59 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n68 | }\n   |   ^\n\nerror[E0277]: a value\
    \ of type `Vec<f32>` cannot be built from an iterator over elements of type `isize`\n\
    \    --> /tmp/tmp8xdk9t_r.rs:13:43\n     |\n13   |     let initial_speeds: Vec<f32>\
    \ = (0..n).collect();\n     |                                           ^^^^^^^\
    \ value of type `Vec<f32>` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \     |\n     = help: the trait `FromIterator<isize>` is not implemented for `Vec<f32>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: a value of type `Vec<f32>` cannot be\
    \ built from an iterator over elements of type `isize`\n    --> /tmp/tmp8xdk9t_r.rs:19:58\n\
    \     |\n19   |     let mut current_speeds: Vec<f32> = (0..n).map(|i| i).collect();\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<f32>` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \     |\n     = help: the trait `FromIterator<isize>` is not implemented for `Vec<f32>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the type `[f32]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp8xdk9t_r.rs:37:33\n   |\n37 |                 let\
    \ car_speed = initial_speeds[car_i];\n   |                                 ^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let mut\
    \ right = 0;\n    for _ in 0..n {\n        let left1 = left + 1;\n        let\
    \ right1 = right + 1;\n        if left1 <= n && right1 <= n && std::cmp::min(left,\
    \ right) == 0 {\n            let mut left2 = left;\n            let mut right2\
    \ = right;\n            while left2 <= n && right2 <= n && std::cmp::min(left2,\
    \ right2) == 0 {\n                count += std::cmp::max(left - right2, right2\
    \ - left2);\n                left2 += 1;\n                right2 += 1;\n     \
    \       }\n        }\n        left += 1;\n        right += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpkdsp2cwq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Assume n is even.\n    let mut num_collisions = 1;\n\
    \    for _ in 0..n {\n        let mut car_1 = rand::random::<isize>();\n     \
    \   let mut car_2 = rand::random::<isize>();\n        // Skip if either car has\
    \ already hit another car.\n        if car_1 > car_2 {\n            car_2 += n\
    \ - 1;\n        }\n        // Move the car toward the other car.\n        car_1\
    \ += car_2;\n        car_2 += car_1;\n        // If both cars collide.\n     \
    \   if car_1 > car_2 {\n            num_collisions += 1;\n        }\n    }\n \
    \   num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmptffy58ry.rs:13:25\n   |\n13 |         let mut car_1 = rand::random::<isize>();\n\
    \   |                         ^^^^ use of undeclared crate or module `rand`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n  -->\
    \ /tmp/tmptffy58ry.rs:14:25\n   |\n14 |         let mut car_2 = rand::random::<isize>();\n\
    \   |                         ^^^^ use of undeclared crate or module `rand`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
