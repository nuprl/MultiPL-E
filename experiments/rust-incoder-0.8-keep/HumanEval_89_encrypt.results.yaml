name: HumanEval_89_encrypt
language: rust
results:
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted: Vec<char> = s.chars().map(|c| {\n        if c >= 'a' && c <= 'z'\
    \ {\n            c = (c - 'a' + 2) % 26 + 'a';\n        } else if c >= 'A' &&\
    \ c <= 'Z' {\n            c = (c - 'A' + 2) % 26 + 'A';\n        } else {\n  \
    \          c = c;\n        }\n\n        c\n    }).collect();\n    encrypted.push(encrypted.chars().last().unwrap());\n\
    \n    for c in encrypted[..] {\n        if c >= 'a' && c <= 'z' {\n          \
    \  c = (c - 'a' + 2) % 26 + 'a';\n        } else if c >= 'A' && c <= 'Z' {\n \
    \           c = (c - 'A' + 2) % 26 + 'A';\n        }\n    }\n    String::from_utf8(encrypted).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpu_6c7yq4.rs:13:20\n\
    \   |\n13 |             c = (c - 'a' + 2) % 26 + 'a';\n   |                  -\
    \ ^ --- char\n   |                  |\n   |                  char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpu_6c7yq4.rs:15:20\n   |\n\
    15 |             c = (c - 'A' + 2) % 26 + 'A';\n   |                  - ^ ---\
    \ char\n   |                  |\n   |                  char\n\nerror[E0599]: no\
    \ method named `chars` found for struct `Vec<char>` in the current scope\n  -->\
    \ /tmp/tmpu_6c7yq4.rs:22:30\n   |\n22 |     encrypted.push(encrypted.chars().last().unwrap());\n\
    \   |                              ^^^^^ method not found in `Vec<char>`\n\nerror[E0277]:\
    \ the size for values of type `[char]` cannot be known at compilation time\n \
    \ --> /tmp/tmpu_6c7yq4.rs:24:14\n   |\n24 |     for c in encrypted[..] {\n   |\
    \              ^^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[char]: IntoIterator` is not satisfied\n  \
    \ = note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[char]`\nhelp: consider borrowing here\n   |\n24 |     for c in &encrypted[..]\
    \ {\n   |              +\n24 |     for c in &mut encrypted[..] {\n   |       \
    \       ++++\n\nerror[E0277]: `[char]` is not an iterator\n  --> /tmp/tmpu_6c7yq4.rs:24:14\n\
    \   |\n24 |     for c in encrypted[..] {\n   |              ^^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[char]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[char]`\nhelp: consider borrowing here\n\
    \   |\n24 |     for c in &encrypted[..] {\n   |              +\n24 |     for c\
    \ in &mut encrypted[..] {\n   |              ++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu_6c7yq4.rs:31:23\n   |\n31 |     String::from_utf8(encrypted).unwrap()\n\
    \   |                       ^^^^^^^^^ expected `u8`, found `char`\n   |\n   =\
    \ note: expected struct `Vec<u8>`\n              found struct `Vec<char>`\n\n\
    error: aborting due to 6 "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ l = s.chars().collect::<Vec<_>>();\n    for &c in l {\n        c.rotate_left(2);\n\
    \    }\n    l\n        .iter()\n        .map(|c| c.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpopdwmh11.rs:12:9\n   |\n\
    12 |     for &c in l {\n   |         ^^    - this expression has type `Option<char>`\n\
    \   |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet : Vec<char> = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut new_alphabet: Vec<char> = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\
    \ 'X', 'Y', 'Z'];\n    let mut shift: Vec<char> = vec!['A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z'];\n\
    \n    alphabet.iter().for_each(|c| *new_alphabet.push(c));\n    shift.iter().for_each(|c|\
    \ *new_alphabet.push(c));\n\n    new_alphabet.iter().for_each(|c| *shift.push(c));\n\
    \    new_alphabet.iter().for_each(|c| *alphabet.push(c));\n\n    let mut temp_alphabet:\
    \ Vec<char> = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut temp_shift: Vec<char> = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\
    \ 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\
    \ 'Y', 'Z'];\n    let mut temp_new_alphabet: Vec<char> = vec!['A', 'B', 'C', 'D',\
    \ 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    s.chars().for_each(|c| *temp_alphabet.push(c));\n\
    \    temp_alphabet.iter().for_each(|c| *temp_shift.push(c));\n    temp_alphabet.iter().for_each(|c|\
    \ *temp_new_alphabet.push(c));\n\n    temp_shift.iter().for_each(|c| *temp_alphabet.push(c));\n\
    \    temp_alphabet.iter().for_each(|c| *\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpu5gyru2i.rs:30:34\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n30 |     temp_alphabet.iter().for_each(|c|\
    \ *\n   |                                  ^ unclosed delimiter\n31 | }\n   |\
    \ ^ mismatched closing delimiter\n\nerror: expected expression, found `)`\n  -->\
    \ /tmp/tmpu5gyru2i.rs:31:1\n   |\n31 | }\n   | ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu5gyru2i.rs:15:53\n   |\n15 |     alphabet.iter().for_each(|c|\
    \ *new_alphabet.push(c));\n   |                                              \
    \       ^ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n15 |     alphabet.iter().for_each(|c| *new_alphabet.push(*c));\n\
    \   |                                                     +\n\nerror[E0614]: type\
    \ `()` cannot be dereferenced\n  --> /tmp/tmpu5gyru2i.rs:15:34\n   |\n15 |   \
    \  alphabet.iter().for_each(|c| *new_alphabet.push(c));\n   |                \
    \                  ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpu5gyru2i.rs:16:50\n   |\n16 |     shift.iter().for_each(|c| *new_alphabet.push(c));\n\
    \   |                                                  ^ expected `char`, found\
    \ `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |     shift.iter().for_each(|c|\
    \ *new_alphabet.push(*c));\n   |                                             \
    \     +\n\nerror[E0614]: type `()` cannot be dereferenced\n  --> /tmp/tmpu5gyru2i.rs:16:31\n\
    \   |\n16 |     shift.iter().for_each(|c| *new_alphabet.push(c));\n   |      \
    \                         ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu5gyru2i.rs:18:50\n   |\n18 |     new_alphabet.iter().for_each(|c|\
    \ *shift.push(c));\n   |                                                  ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     new_alphabet.iter().for_each(|c| *shift.push(*c));\n   |            \
    \                                      +\n\nerror[E0614]: type `()` ca"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    s.rotate_right(2);\n    s.rotate_right(2);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_right` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp7nnd1q7k.rs:12:7\n   |\n12 |     s.rotate_right(2);\n\
    \   |       ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trim_right`\n\nerror[E0599]: no method named `rotate_right` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp7nnd1q7k.rs:13:7\n   |\n\
    13 |     s.rotate_right(2);\n   |       ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `trim_right`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet : Vec<char> = vec!['a'..'z'; 'A'..'Z'];\n    let mut i = 0;\n    for\
    \ c in s.chars() {\n        alphabet[i] = alphabet[c];\n        alphabet[c] =\
    \ alphabet[c + 1];\n        alphabet[c + 1] = alphabet[i];\n        i += 1;\n\
    \    }\n    alphabet\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpws4csj_i.rs:11:41\n   |\n\
    11 |     let mut alphabet : Vec<char> = vec!['a'..'z'; 'A'..'Z'];\n   |      \
    \                                   ^^^^^^^^ expected `char`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected type `char`\n            found struct `std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpws4csj_i.rs:11:51\n   |\n11 |\
    \     let mut alphabet : Vec<char> = vec!['a'..'z'; 'A'..'Z'];\n   |         \
    \                                          ^^^^^^^^ expected `usize`, found struct\
    \ `std::ops::Range`\n   |\n   = note: expected type `usize`\n            found\
    \ struct `std::ops::Range<char>`\n\nerror[E0277]: the type `[char]` cannot be\
    \ indexed by `char`\n  --> /tmp/tmpws4csj_i.rs:14:23\n   |\n14 |         alphabet[i]\
    \ = alphabet[c];\n   |                       ^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<char>`\n\nerror[E0277]: the type `[char]`\
    \ cannot be indexed by `char`\n  --> /tmp/tmpws4csj_i.rs:15:9\n   |\n15 |    \
    \     alphabet[c] = alphabet[c + 1];\n   |         ^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<char>`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmpws4csj_i.rs:15:34\n   |\n15 |         alphabet[c] =\
    \ alphabet[c + 1];\n   |                                - ^ - {integer}\n   |\
    \                                |\n   |                                char\n\
    \nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpws4csj_i.rs:16:20\n\
    \   |\n16 |         alphabet[c + 1] = alphabet[i];\n   |                  - ^\
    \ - {integer}\n   |                  |\n   |                  char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpws4csj_i.rs:19:5\n   |\n10 | fn encrypt(s: String)\
    \ -> String {\n   |         "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ rotate(c, 2)).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpd5as7she.rs:11:23\n\
    \   |\n11 |     s.chars().map(|c| rotate(c, 2)).collect()\n   |              \
    \         ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet: Vec<u32> = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut rotated = s.chars().cloned().collect::<String>();\n    for (index,\
    \ c) in rotated.iter().enumerate() {\n        rotated[index] = alphabet[(alphabet.len()\
    \ - 1 - alphabet.iter().position(|&x| x == c).unwrap())];\n    }\n    return rotated;\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpna070caj.rs:11:39\n   |\n\
    11 |     let mut alphabet: Vec<u32> = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',...\n   |  \
    \                                     ^^^ expected `u32`, found `char`\n   |\n\
    help: you can cast a `char` to a `u32`, since a `char` always occupies 4 bytes\n\
    \   |\n11 |     let mut alphabet: Vec<u32> = vec!['a' as u32, 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n   |                                           ++++++\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpna070caj.rs:12:33\n     |\n12   |     let mut rotated = s.chars().cloned().collect::<String>();\n\
    \     |                                 ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpna070caj.rs:12:42\n   |\n12 |       let mut rotated = s.chars().cloned().collect::<String>();\n\
    \   |                                            ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars()\n\
    \        .map(|c| {\n            let x = c - 'a';\n            let y = x - 2;\n\
    \            x * 26 + y\n        })\n        .collect()\n        .fold(String::new(),\
    \ |mut acc, &c| {\n            acc.push_str(&c + &c.to_ascii_lowercase());\n \
    \           acc.push_str(&c + &c.to_ascii_uppercase());\n            acc\n   \
    \     })\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpa8tzzcb7.rs:13:23\n\
    \   |\n13 |             let x = c - 'a';\n   |                     - ^ --- char\n\
    \   |                     |\n   |                     char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().filter_map(|c|\
    \ match c {\n        'h' => {\n            'l' => {\n                'm' => {\n\
    \                    'g'\n                }\n            }\n        }\n      \
    \  'i' => {\n            'x' => {\n                'j'\n            }\n      \
    \  }\n        'g' => {\n            'k' => {\n                'f'\n          \
    \  }\n        }\n        'e' => {\n            'w' => {\n                'h' =>\
    \ {\n                    'j'\n                }\n            }\n        }\n  \
    \      't' => {\n            'i' => {\n                'x'\n            }\n  \
    \      }\n        _ => c,\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpceke62ui.rs:13:17\n   |\n13 |             'l' => {\n   |      \
    \           ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected\
    \ one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> /tmp/tmpceke62ui.rs:20:17\n\
    \   |\n20 |             'x' => {\n   |                 ^^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`,\
    \ or an operator, found `=>`\n  --> /tmp/tmpceke62ui.rs:25:17\n   |\n25 |    \
    \         'k' => {\n   |                 ^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpceke62ui.rs:30:17\n   |\n30 |             'w' => {\n\
    \   |                 ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> /tmp/tmpceke62ui.rs:37:17\n\
    \   |\n37 |             'i' => {\n   |                 ^^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: aborting due to 5 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().fold(String::new(),\
    \ |a, c| {\n        let x = c.to_ascii_uppercase().wrapping_mul(2);\n        let\
    \ y = a.as_str().to_ascii_uppercase().wrapping_mul(2);\n        String::from_utf8(x\
    \ + y).unwrap()\n    })\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_mul` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpq3pnsahm.rs:12:40\n   |\n12 |         let x = c.to_ascii_uppercase().wrapping_mul(2);\n\
    \   |                                        ^^^^^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `wrapping_mul` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpq3pnsahm.rs:13:49\n   |\n13 |         let\
    \ y = a.as_str().to_ascii_uppercase().wrapping_mul(2);\n   |                 \
    \                                ^^^^^^^^^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for i in s.chars() {\n        let letter = i.to_ascii_lowercase();\n\
    \        let offset = letter + 'a' - 'a'.to_ascii_lowercase();\n        let offset\
    \ = if offset > 26 { offset - 26 }\n        else { 0 };\n        let letter =\
    \ i.rotate_right(offset).to_ascii_lowercase();\n        result.push_str(&letter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpf4lkw3ph.rs:14:29\n\
    \   |\n14 |         let offset = letter + 'a' - 'a'.to_ascii_lowercase();\n  \
    \ |                      ------ ^ --- char\n   |                      |\n   |\
    \                      char\n\nerror[E0599]: no method named `rotate_right` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpf4lkw3ph.rs:17:24\n   |\n\
    17 |         let letter = i.rotate_right(offset).to_ascii_lowercase();\n   | \
    \                       ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt(&s,\
    \ &Alphabet::ROTATE_LEFT)\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpt54ere58.rs:11:18\n   |\n11 |     encrypt(&s, &Alphabet::ROTATE_LEFT)\n\
    \   |                  ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpt54ere58.rs:11:5\n\
    \   |\n11 |     encrypt(&s, &Alphabet::ROTATE_LEFT)\n   |     ^^^^^^^ --  ----------------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpt54ere58.rs:10:4\n   |\n10 | fn encrypt(s:\
    \ String) -> String {\n   |    ^^^^^^^ ---------\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet: Vec<String> = vec![\"\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for i in\
    \ 0..alphabet.len() {\n        alphabet[i] = alphabet.clone().rotate(2).collect();\n\
    \    }\n\n    let mut result = \"\";\n    let mut index = 0;\n\n    for char in\
    \ s.chars() {\n        index = alphabet.iter().position(|&x| x == char).unwrap_or(0);\n\
    \        result.append(alphabet[index].clone());\n    }\n\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmeeswb0z.rs:11:42\n   |\n\
    11 |     let mut alphabet: Vec<String> = vec![\"\", \"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s...\n   |                                          ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                        |\n   |                                          expected\
    \ struct `String`, found `&str`\n\nerror[E0599]: no method named `rotate` found\
    \ for struct `Vec<String>` in the current scope\n  --> /tmp/tmpmeeswb0z.rs:13:40\n\
    \   |\n13 |         alphabet[i] = alphabet.clone().rotate(2).collect();\n   |\
    \                                        ^^^^^^ help: there is an associated function\
    \ with a similar name: `rotate_left`\n\nerror[E0277]: can't compare `String` with\
    \ `char`\n  --> /tmp/tmpmeeswb0z.rs:20:49\n   |\n20 |         index = alphabet.iter().position(|&x|\
    \ x == char).unwrap_or(0);\n   |                                             \
    \    ^^ no implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0599]: no method named `append` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpmeeswb0z.rs:21:16\n   |\n21 |   \
    \      result.append(alphabet[index].clone());\n   |                ^^^^^^ method\
    \ not found in `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmeeswb0z.rs:24:5\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          ------\
    \ expected `String` because of return type\n...\n24 |     result\n   |     ^^^^^^-\
    \ help: try using a conversion method: `.to_st"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    for &c in s.chars() {\n        rotate_alphabet(c);\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpzck6vn1t.rs:13:9\n   |\n13 |         rotate_alphabet(c);\n   |     \
    \    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzck6vn1t.rs:12:9\n   |\n12 |     for &c in s.chars() {\n   |  \
    \       ^^    --------- this expression has type `Option<char>`\n   |        \
    \ |\n   |         expected `char`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    if s.len()\
    \ == 0 {\n        \"\"\n    } else {\n        let mut ciphertext = String::new();\n\
    \        let mut i = 0;\n        let mut alphabet = [\"a\".to_string(), \"b\"\
    .to_string(), \"c\".to_string(), \"d\".to_string(), \"e\".to_string(), \"f\".to_string(),\
    \ \"g\".to_string(), \"h\".to_string()];\n        for c in s.chars() {\n     \
    \       ciphertext += alphabet[i % alphabet.len()];\n            i += 2;\n   \
    \     }\n        ciphertext\n    }\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzbsoijd9.rs:12:9\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n11 |     if s.len() == 0 {\n12 |         \"\
    \"\n   |         ^^- help: try using a conversion method: `.to_string()`\n   |\
    \         |\n   |         expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzbsoijd9.rs:18:27\n   |\n18 |             ciphertext\
    \ += alphabet[i % alphabet.len()];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                           |\n   |                           expected `&str`,\
    \ found struct `String`\n   |                           help: consider borrowing\
    \ here: `&alphabet[i % alphabet.len()]`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\trotate_str(&s.chars().map(|c|\
    \ *c + 1).collect::<Vec<_>>(), 2)\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_str` in this scope\n  --> /tmp/tmp95a9vtr1.rs:11:2\n\
    \   |\n11 |     rotate_str(&s.chars().map(|c| *c + 1).collect::<Vec<_>>(), 2)\n\
    \   |     ^^^^^^^^^^ not found in this scope\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp95a9vtr1.rs:11:32\n   |\n11 |     rotate_str(&s.chars().map(|c|\
    \ *c + 1).collect::<Vec<_>>(), 2)\n   |                                   ^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0614.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet: Vec<&'static str> = vec!['e', 'o', 'f', 'h', 'i', 'l', 'm', 'p', 'q',\
    \ 'a', 'u', 'y', 'o', 'n', 'c', 'k', 'j', 'o', 'h', 'g', 'n', 't', 'b', 's'];\n\
    \n    let mut rotate_alphabet: Vec<&'static str> = vec!['h', 'i', 'm', 'l', 'o',\
    \ 'g', 'b', 'm', 'n', 'a', 'l', 'j', 'p', 'q', 's', 'e', 't', 'i', 'x', 'u', 'y'];\n\
    \n    for i in s.chars() {\n        let shift = (rotate_alphabet.len() - alphabet.len())\
    \ / 2;\n        alphabet = rotate_alphabet[..shift].iter().cloned()\n        \
    \    .chain(alphabet.iter().cloned()[shift..])\n            .collect();\n\n  \
    \      rotate_alphabet = rotate_alphabet[shift..rotate_alphabet.len()].iter().cloned().collect();\n\
    \    }\n\n    let mut new_s = String::new();\n    for i in s.chars() {\n     \
    \   let index = alphabet.iter().position(|&x| x == &*i);\n        new_s.push_str(&alphabet[index\
    \ as usize]);\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz4j62qnu.rs:11:48\n   |\n\
    11 |     let mut alphabet: Vec<&'static str> = vec!['e', 'o', 'f', 'h', 'i', 'l',\
    \ 'm', 'p', 'q', 'a', 'u', 'y', 'o', 'n', 'c', 'k', 'j', 'o', ...\n   |      \
    \                                          ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    11 |     let mut alphabet: Vec<&'static str> = vec![\"e\", 'o', 'f', 'h', 'i',\
    \ 'l', 'm', 'p', 'q', 'a', 'u', 'y', 'o', 'n', 'c', 'k', 'j', 'o', 'h', 'g', 'n',\
    \ 't', 'b', 's'];\n   |                                                ~~~\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpz4j62qnu.rs:13:55\n   |\n13 |  \
    \   let mut rotate_alphabet: Vec<&'static str> = vec!['h', 'i', 'm', 'l', 'o',\
    \ 'g', 'b', 'm', 'n', 'a', 'l', 'j', 'p', 'q', 's', 'e', 't'...\n   |        \
    \                                               ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    13 |     let mut rotate_alphabet: Vec<&'static str> = vec![\"h\", 'i', 'm', 'l',\
    \ 'o', 'g', 'b', 'm', 'n', 'a', 'l', 'j', 'p', 'q', 's', 'e', 't', 'i', 'x', 'u',\
    \ 'y'];\n   |                                                       ~~~\n\nerror[E0608]:\
    \ cannot index into a value of type `Cloned<std::slice::Iter<'_, &str>>`\n  -->\
    \ /tmp/tmpz4j62qnu.rs:18:20\n   |\n18 |             .chain(alphabet.iter().cloned()[shift..])\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpz4j62qnu.rs:26:57\n   |\n26 | \
    \        let index = alphabet.iter().position(|&x| x == &*i);\n   |          \
    \                                               ^^\n\nerror[E0605]: non-primitive\
    \ cast: `Option<usize>` as `usize`\n  --> /tmp/tmpz4j62qnu.rs:27:34\n   |\n27\
    \ |         new_s.push_str(&alphabet[index as usize]);\n   |                 \
    \                 ^^^^^^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have d"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    let mut output = \"\".to_string();\n    for\
    \ c in s.chars() {\n        output += alphabet[alphabet.find(c.to_string()) +\
    \ 2];\n    }\n    output\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp9drzq8xb.rs:12:14\n   |\n12 |     alphabet.rotate_left(1);\n\
    \   |              ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `rotate_left` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp9drzq8xb.rs:13:14\n   |\n13 |     alphabet.rotate_left(1);\n  \
    \ |              ^^^^^^^^^^^ method not found in `String`\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmp9drzq8xb.rs:16:42\n\
    \     |\n16   |         output += alphabet[alphabet.find(c.to_string()) + 2];\n\
    \     |                                     ---- ^^^^^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                                     |\n     |\
    \                                     required by a bound introduced by this call\n\
    \     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n16   |         output += alphabet[alphabet.find(&c.to_string())\
    \ + 2];\n     |                                          +\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmp9drzq8xb.rs:16:57\n   |\n\
    16 |         output += alphabet[alphabet.find(c.to_string()) + 2];\n   |     \
    \                       ---------------------------- ^ - {integer}\n   |     \
    \                       |\n   |                            Option<usize>\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet: [i32; 26] = Default::default();\n    for ch in s.chars() {\n     \
    \   alphabet[ch as usize] = alphabet[ch as usize] + 2;\n    }\n    alphabet\n\
    \        .iter()\n        .fold(\"\".to_string(), |mut acc, i| acc + i.to_string());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwk2jvhxa.rs:17:50\n   |\n\
    17 |         .fold(\"\".to_string(), |mut acc, i| acc + i.to_string());\n   |\
    \                                                  ^^^^^^^^^^^^^\n   |       \
    \                                           |\n   |                          \
    \                        expected `&str`, found struct `String`\n   |        \
    \                                          help: consider borrowing here: `&i.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwk2jvhxa.rs:10:26\n   |\n10 |\
    \ fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n...\n17 |         .fold(\"\".to_string(),\
    \ |mut acc, i| acc + i.to_string());\n   |                                   \
    \                             - help: remove this semicolon\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_letter(s,\
    \ 2, 1)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_letter` in this scope\n  -->\
    \ /tmp/tmpj8azuc0t.rs:11:5\n   |\n11 |     rotate_letter(s, 2, 1)\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = alphabet_string();\n    alphabet.rotate_right(2);\n    let mut c\
    \ = s.chars().map(|c| alphabet.index(c)).collect();\n    alphabet.rotate_left(2);\n\
    \    c.extend(s.chars().map(|c| alphabet.index(c)).collect());\n    c.chars().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `alphabet_string` in this scope\n  -->\
    \ /tmp/tmpkjucpk3o.rs:11:24\n   |\n11 |     let mut alphabet = alphabet_string();\n\
    \   |                        ^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    en(s.to_ascii_lowercase()).to_owned()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `en` in this scope\n  --> /tmp/tmpt6rp1rnp.rs:11:5\n\
    \   |\n11 |     en(s.to_ascii_lowercase()).to_owned()\n   |     ^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = String::new();\n    let mut n = s.len();\n    let mut count = 1;\n\
    \    while n > 0 {\n        alphabet.push(s.chars().nth(n % alphabet.length).unwrap().to_ascii_uppercase());\n\
    \        n /= alphabet.length;\n        count *= alphabet.length;\n    }\n   \
    \ alphabet.repeat(count).join(\"\")\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmp8tku4acd.rs:15:50\n\
    \   |\n15 |         alphabet.push(s.chars().nth(n % alphabet.length).unwrap().to_ascii_uppercase());\n\
    \   |                                                  ^^^^^^ unknown field\n\n\
    error[E0609]: no field `length` on type `String`\n  --> /tmp/tmp8tku4acd.rs:16:23\n\
    \   |\n16 |         n /= alphabet.length;\n   |                       ^^^^^^ unknown\
    \ field\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp8tku4acd.rs:17:27\n\
    \   |\n17 |         count *= alphabet.length;\n   |                          \
    \ ^^^^^^ unknown field\n\nerror[E0599]: no method named `join` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp8tku4acd.rs:19:28\n   |\n19 | \
    \    alphabet.repeat(count).join(\"\")\n   |                            ^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut result:\
    \ String = String::new();\n\tfor c in s.chars() {\n\t\tlet mut tmp = c;\n\t\t\
    tmp += (c << 2);\n\t\ttmp += (c << 1);\n\t\ttmp += (c << 0);\n\t\tresult += Char::from_code_point(tmp);\n\
    \t}\n\tresult\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmpauk3yj6_.rs:17:13\n\
    \   |\n17 |         result += Char::from_code_point(tmp);\n   |              \
    \     ^^^^ use of undeclared type `Char`\n\nwarning: unnecessary parentheses around\
    \ assigned value\n  --> /tmp/tmpauk3yj6_.rs:14:10\n   |\n14 |         tmp += (c\
    \ << 2);\n   |                ^      ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n14 -         tmp += (c\
    \ << 2);\n14 +         tmp += c << 2;\n   | \n\nwarning: unnecessary parentheses\
    \ around assigned value\n  --> /tmp/tmpauk3yj6_.rs:15:10\n   |\n15 |         tmp\
    \ += (c << 1);\n   |                ^      ^\n   |\nhelp: remove these parentheses\n\
    \   |\n15 -         tmp += (c << 1);\n15 +         tmp += c << 1;\n   | \n\nwarning:\
    \ unnecessary parentheses around assigned value\n  --> /tmp/tmpauk3yj6_.rs:16:10\n\
    \   |\n16 |         tmp += (c << 0);\n   |                ^      ^\n   |\nhelp:\
    \ remove these parentheses\n   |\n16 -         tmp += (c << 0);\n16 +        \
    \ tmp += c << 0;\n   | \n\nerror[E0369]: no implementation for `char << {integer}`\n\
    \  --> /tmp/tmpauk3yj6_.rs:14:13\n   |\n14 |         tmp += (c << 2);\n   |  \
    \               - ^^ - {integer}\n   |                 |\n   |               \
    \  char\n\nerror[E0369]: no implementation for `char << {integer}`\n  --> /tmp/tmpauk3yj6_.rs:15:13\n\
    \   |\n15 |         tmp += (c << 1);\n   |                 - ^^ - {integer}\n\
    \   |                 |\n   |                 char\n\nerror[E0369]: no implementation\
    \ for `char << {integer}`\n  --> /tmp/tmpauk3yj6_.rs:16:13\n   |\n16 |       \
    \  tmp += (c << 0);\n   |                 - ^^ - {integer}\n   |             \
    \    |\n   |                 char\n\nerror: aborting due to 4 previous errors;\
    \ 3 warnings emitted\n\nSome errors have detailed explanations: E0369, E0433.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    enc(s.chars(),\
    \ &ALPHABET[ROTATE_MAPPING.len()])\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `enc` in this scope\n  --> /tmp/tmp5lun27vj.rs:11:5\n\
    \   |\n11 |     enc(s.chars(), &ALPHABET[ROTATE_MAPPING.len()])\n   |     ^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `ALPHABET` in this\
    \ scope\n  --> /tmp/tmp5lun27vj.rs:11:21\n   |\n11 |     enc(s.chars(), &ALPHABET[ROTATE_MAPPING.len()])\n\
    \   |                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROTATE_MAPPING` in this scope\n  --> /tmp/tmp5lun27vj.rs:11:30\n\
    \   |\n11 |     enc(s.chars(), &ALPHABET[ROTATE_MAPPING.len()])\n   |        \
    \                      ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ c: Char = s[0];\n    let mut i = 0;\n    while i < s.size() {\n        c = rotate_left(c,\
    \ 2);\n        i += 1;\n    }\n    c\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmptkn4qt7v.rs:11:16\n\
    \   |\n11 |     let mut c: Char = s[0];\n   |                ^^^^ help: a builtin\
    \ type with a similar name exists (notice the capitalization): `char`\n\nerror[E0425]:\
    \ cannot find function `rotate_left` in this scope\n  --> /tmp/tmptkn4qt7v.rs:14:13\n\
    \   |\n14 |         c = rotate_left(c, 2);\n   |             ^^^^^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::intrinsics::rotate_left;\n   |\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmptkn4qt7v.rs:11:23\n   |\n11 |     let\
    \ mut c: Char = s[0];\n   |                       ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `size` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmptkn4qt7v.rs:13:17\n   |\n13 |     while\
    \ i < s.size() {\n   |                 ^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412, E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet: Vec<char> = s.chars().collect();\n    alphabet.swap(0, alphabet.len());\n\
    \    rotate(alphabet, 1);\n    encrypt(alphabet)\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpfkmfkukw.rs:13:5\n\
    \   |\n13 |     rotate(alphabet, 1);\n   |     ^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfkmfkukw.rs:14:13\n   |\n14 |\
    \     encrypt(alphabet)\n   |             ^^^^^^^^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `String`\n              found\
    \ struct `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alpha = [('A'..'Z').chars().next().unwrap()];\n    alpha.push('z');\n    alpha.push('a');\n\
    \    let mut alpha_rotate = [('A'..'Z').chars().next().unwrap()];\n    alpha_rotate.push('z');\n\
    \    alpha_rotate.push('a');\n    let mut i = 0;\n    for c in s.chars() {\n \
    \       let mut rotated_letter = [c];\n        for r in 0..2 {\n            if\
    \ i % 2 == 0 {\n                rotated_letter.push(alpha_rotate[alpha.len() -\
    \ alpha.len() - rotated_letter.len() - 2 - r]);\n            } else {\n      \
    \          rotated_letter.push(alpha[alpha.len() - alpha.len() - rotated_letter.len()\
    \ - 2 - r]);\n            }\n            i += 1;\n        }\n        alpha.push(rotated_letter[rotated_letter.len()\
    \ - alpha.len()]);\n    }\n    alpha.push('z');\n    alpha.push('a');\n    String::from_utf8(alpha.iter().map(|&x|\
    \ x as u8).collect()).unwrap()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmp1oh4e9ba.rs:11:33\n   |\n11 |     let mut\
    \ alpha = [('A'..'Z').chars().next().unwrap()];\n   |                        \
    \         ^^^^^ method not found in `std::ops::Range<char>`\n\nerror[E0599]: no\
    \ method named `chars` found for struct `std::ops::Range` in the current scope\n\
    \  --> /tmp/tmp1oh4e9ba.rs:14:40\n   |\n14 |     let mut alpha_rotate = [('A'..'Z').chars().next().unwrap()];\n\
    \   |                                        ^^^^^ method not found in `std::ops::Range<char>`\n\
    \nerror[E0599]: no method named `push` found for array `[char; 1]` in the current\
    \ scope\n  --> /tmp/tmp1oh4e9ba.rs:22:32\n   |\n22 |                 rotated_letter.push(alpha_rotate[alpha.len()\
    \ - alpha.len() - rotated_letter.len() - 2 - r]);\n   |                      \
    \          ^^^^ method not found in `[char; 1]`\n\nerror[E0599]: no method named\
    \ `push` found for array `[char; 1]` in the current scope\n  --> /tmp/tmp1oh4e9ba.rs:24:32\n\
    \   |\n24 |                 rotated_letter.push(alpha[alpha.len() - alpha.len()\
    \ - rotated_letter.len() - 2 - r]);\n   |                                ^^^^\
    \ method not found in `[char; 1]`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    if s.len()\
    \ < 2 {\n        return s;\n    }\n    let mut result = String::new();\n    let\
    \ mut shift = 1;\n    for i in s.chars() {\n        result.append(encrypt_char(i,\
    \ &mut shift));\n        shift += 2;\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encrypt_char` in this scope\n  -->\
    \ /tmp/tmpfppv7hae.rs:17:23\n   |\n17 |         result.append(encrypt_char(i,\
    \ &mut shift));\n   |                       ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfppv7hae.rs:17:16\n   |\n17 |         result.append(encrypt_char(i,\
    \ &mut shift));\n   |                ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ letters = s.chars();\n    let mut new_letters = vec![letters.next()];\n    let\
    \ mut num_letters = 0;\n    loop {\n        if num_letters == 2 {\n          \
    \  new_letters.push(letters.next());\n            num_letters = 0;\n        }\
    \ else {\n            num_letters += 1;\n        }\n        if new_letters.len()\
    \ >= 26 {\n            break;\n        }\n    }\n    new_letters.reverse();\n\
    \    new_letters.into_iter().map(|&c| ascii_codes[c]).collect::<Vec<_>>()\n  \
    \      .join::<String>(\"\").to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ascii_codes` in this scope\n  --> /tmp/tmpbqkfe2oy.rs:26:38\n\
    \   |\n26 |     new_letters.into_iter().map(|&c| ascii_codes[c]).collect::<Vec<_>>()\n\
    \   |                                      ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbqkfe2oy.rs:26:34\n   |\n26 |\
    \     new_letters.into_iter().map(|&c| ascii_codes[c]).collect::<Vec<_>>()\n \
    \  |                                  ^--\n   |                              \
    \    ||\n   |                                  |expected due to this\n   |   \
    \                               expected enum `Option`, found reference\n   |\
    \                                  help: did you mean `c`: `&Option<char>`\n \
    \  |\n   = note:   expected enum `Option<char>`\n           found reference `&_`\n\
    \nerror[E0277]: the trait bound `[_]: Join<String>` is not satisfied\n  --> /tmp/tmpbqkfe2oy.rs:27:10\n\
    \   |\n27 |         .join::<String>(\"\").to_string()\n   |          ^^^^ the\
    \ trait `Join<String>` is not implemented for `[_]`\n   |\n   = help: the following\
    \ other types implement trait `Join<Separator>`:\n             <[S] as Join<&str>>\n\
    \             <[V] as Join<&T>>\n             <[V] as Join<&[T]>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbqkfe2oy.rs:27:25\n   |\n27 |         .join::<String>(\"\
    \").to_string()\n   |                         ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                         |\n   |               \
    \          expected struct `String`, found `&str`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = s.chars().chain(|c| c.to_ascii_lowercase()).collect::<Vec<Char>>();\n    let\
    \ mut rotated_alphabet = alphabet.clone();\n    for &i in 0..alphabet.len() {\n\
    \        rotated_alphabet[i] = rotated_alphabet[(i + 2) % alphabet.len()];\n \
    \   }\n    rotated_alphabet.iter().map(|c| c.to_string()).collect::<Vec<String>>()\n\
    \        .iter().map(|s| s.as_str()).collect::<Vec<String>>()\n        .join('')\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmprdm230z6.rs:18:16\n   |\n\
    18 |         .join('')\n   |                ^ empty character literal\n\nerror[E0412]:\
    \ cannot find type `Char` in this scope\n  --> /tmp/tmprdm230z6.rs:11:78\n   |\n\
    11 |     let alphabet = s.chars().chain(|c| c.to_ascii_lowercase()).collect::<Vec<Char>>();\n\
    \   |                                                                        \
    \      ^^^^\n   |\nhelp: a builtin type with a similar name exists\n   |\n11 |\
    \     let alphabet = s.chars().chain(|c| c.to_ascii_lowercase()).collect::<Vec<char>>();\n\
    \   |                                                                        \
    \      ~~~~\nhelp: you might be missing a type parameter\n   |\n10 | fn encrypt<Char>(s:\
    \ String) -> String {\n   |           ++++++\n\nerror[E0282]: type annotations\
    \ needed\n  --> /tmp/tmprdm230z6.rs:11:37\n   |\n11 |     let alphabet = s.chars().chain(|c|\
    \ c.to_ascii_lowercase()).collect::<Vec<Char>>();\n   |                      \
    \               ^ consider giving this closure parameter a type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprdm230z6.rs:13:9\n\
    \   |\n13 |     for &i in 0..alphabet.len() {\n   |         ^^    -----------------\
    \ this expression has type `Option<{integer}>`\n   |         |\n   |         expected\
    \ integer, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:   expected type `{integer}`\n           found\
    \ reference `&_`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0282, E0308, E0412.\nFor more information about an error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    &s[..s.len()\
    \ - 2] + &s[s.len() - 2..] + &s[..s.len() - 2]\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpf4vq6lk3.rs:11:23\n\
    \   |\n11 |     &s[..s.len() - 2] + &s[s.len() - 2..] + &s[..s.len() - 2]\n  \
    \ |     ----------------- ^ ----------------- &str\n   |     |               \
    \  |\n   |     |                 `+` cannot be used to concatenate two `&str`\
    \ strings\n   |     &str\n   |\n   = note: string concatenation requires an owned\
    \ `String` on the left\nhelp: remove the borrow to obtain an owned `String`\n\
    \   |\n11 -     &s[..s.len() - 2] + &s[s.len() - 2..] + &s[..s.len() - 2]\n11\
    \ +     s[..s.len() - 2] + &s[s.len() - 2..] + &s[..s.len() - 2]\n   | \n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate(s,\
    \ ROTATE_ROT)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpvcm3ji8f.rs:11:5\n\
    \   |\n11 |     rotate(s, ROTATE_ROT)\n   |     ^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `ROTATE_ROT` in this scope\n  --> /tmp/tmpvcm3ji8f.rs:11:15\n\
    \   |\n11 |     rotate(s, ROTATE_ROT)\n   |               ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().zip(s.chars().cloned()).map(|(a,\
    \ b)| (a.to_ascii_lowercase(), b.to_ascii_lowercase())).map(|(a, b)| b + a[b.len()-1]).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpjgvy415y.rs:11:29\n     |\n11   |     s.chars().zip(s.chars().cloned()).map(|(a,\
    \ b)| (a.to_ascii_lowercase(), b.to_ascii_lowercase())).map(|(a, b)| b + a[b.len()-1]).colle...\n\
    \     |                             ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpjgvy415y.rs:11:19\n\
    \   |\n11 |     s.chars().zip(s.chars().cloned()).map(|(a, b)| (a.to_ascii_lowercase(),\
    \ b.to_ascii_lowercase())).map(|(a, b)| b + a[b.len()-1]).colle...\n   |     \
    \          --- ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |     \
    \          |\n   |               required by a bound introduced by this call\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0599]: the method `map` exists for struct\
    \ `Zip<Chars<'_>, Cloned<Chars<'_>>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpjgvy415y.rs:11:39\n   |\n11 |    ...chars().cloned()).map(|(a,\
    \ b)| (a.to_ascii_lowercase(), b.to_ascii_lowercase())).map(|(a, b)| b + a[b.len()-1]).collect()\n\
    \   |                         ^^^ method cannot be called on `Zip<Chars<'_>, Cloned<Chars<'_>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Cloned<Chars<'_>>: Iterator`\n           which\
    \ is required by `Zip<Chars<'_>, Cloned<Chars<'_>>>: Iterator`\n           `Zip<Chars<'_>,\
    \ Cloned<Chars<'_>>>: Iterator`\n           which is required by `&mut Zip<Chars<'_>,\
    \ Cloned<Chars<'_>>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0271, E0599.\nFor more information about\
    \ an error, try `rustc --exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    let mut alphabet = [\n        'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l',\n        'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y',\n        'z',\n    ];\n    alphabet.rotate_left(2);\n  \
    \  alphabet.rotate_left(5);\n    alphabet.rotate_left(3);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(3);\n    alphabet.rotate_left(3);\n\
    \    alphabet.rotate_left(5);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(5);\n\
    \    alphabet.rotate_left(3);\n    alphabet.rotate_left(3);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(5);\n    alphabet.rotate_left(3);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(5);\n\
    \    alphabet.rotate_left(3);\n    alphabet.rotate_left(5);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(3);\n    alphabet.rotate_left(5);\n    alphabet.rotate_left(3);\n\
    \    alphabet.rotate_left(3);\n    alphabet.rotate_left(3);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(3);\n\
    \    alphabet.rotate_left(5);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(5);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(3);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(3);\n\
    \    alphabet.rotate_left(5);\n    alphabet.rotate_left(5);\n    alphabet.rotate_left(3);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(5);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(5);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(5);\n    alphabet.rotate_left(3);\n    alphabet.rotate_left(5);\n\
    \    alphabet.rotate_left(5);\n    alphabet.rotate_left(3);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(5);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphab\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmpax6u2khf.rs:82:5\n\
    \   |\n82 |     alphab\n   |     ^^^^^^ help: a local variable with a similar\
    \ name exists: `alphabet`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    let mut new_alphabet = alphabet.clone();\n\
    \    new_alphabet.remove(Alphabet::Z);\n    new_alphabet = alphabet.rotate(Alphabet::Z).unwrap();\n\
    \    new_alphabet.remove('A');\n    new_alphabet = alphabet.rotate(Alphabet::Z).unwrap();\n\
    \n    let mut output: Vec<char> = Vec::new();\n    s.chars().for_each(|c| {\n\
    \        if alphabet.contains(c) {\n            output.push(c); // push in the\
    \ letter itself\n        }\n        \n        if !new_alphabet.contains(c) {\n\
    \            output.push('A');\n        }\n    });\n\n    String::from_utf8_lossy(&output).to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpvw3swoin.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpvw3swoin.rs:13:25\n\
    \   |\n13 |     new_alphabet.remove(Alphabet::Z);\n   |                      \
    \   ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Alphabet`\n  --> /tmp/tmpvw3swoin.rs:14:36\n   |\n14\
    \ |     new_alphabet = alphabet.rotate(Alphabet::Z).unwrap();\n   |          \
    \                          ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpvw3swoin.rs:16:36\n\
    \   |\n16 |     new_alphabet = alphabet.rotate(Alphabet::Z).unwrap();\n   |  \
    \                                  ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvw3swoin.rs:29:29\n   |\n29 |\
    \     String::from_utf8_lossy(&output).to_string()\n   |                     \
    \        ^^^^^^^ expected slice `[u8]`, found struct `Vec`\n   |\n   = note: expected\
    \ reference `&[u8]`\n              found reference `&Vec<char>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet: Vec<Char> = vec!['A'..'Z'];\n    alphabet.rotate(2);\n    alphabet.extend_from_slice(alphabet.clone());\n\
    \    alphabet.extend_from_slice(alphabet.clone());\n    alphabet.extend_from_slice(alphabet.clone());\n\
    \    alphabet.extend_from_slice(alphabet.clone());\n    alphabet.extend_from_slice(alphabet.clone());\n\
    \    let mut encrypted: String = s.to_owned();\n    for char in s.chars() {\n\
    \        encrypted = encrypted.chars().filter(|c|\n            !alphabet.contains(c)\n\
    \        ).map(|c|\n            alphabet[alphabet.iter().position(|c| *c == c).unwrap().unwrap()\
    \ + 2] \n        ).join(\"\") + encrypted;\n    }\n    encrypted\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpy8gxgfdw.rs:11:27\n\
    \   |\n11 |     let mut alphabet: Vec<Char> = vec!['A'..'Z'];\n   |          \
    \                 ^^^^\n   |\nhelp: a builtin type with a similar name exists\n\
    \   |\n11 |     let mut alphabet: Vec<char> = vec!['A'..'Z'];\n   |          \
    \                 ~~~~\nhelp: you might be missing a type parameter\n   |\n10\
    \ | fn encrypt<Char>(s: String) -> String {\n   |           ++++++\n\nerror[E0599]:\
    \ no method named `join` found for struct `Map` in the current scope\n  --> /tmp/tmpy8gxgfdw.rs:24:11\n\
    \   |\n24 |         ).join(\"\") + encrypted;\n   |           ^^^^ method not\
    \ found in `Map<Filter<Chars<'_>, [closure@/tmp/tmpy8gxgfdw.rs:20:46: 21:34]>,\
    \ _>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ chars = s.chars();\n    chars.next().unwrap();\n    let mut rot_chars = chars.rotate_left(2);\n\
    \    rot_chars.next().unwrap();\n    rot_chars.next().unwrap();\n    rot_chars.next().unwrap();\n\
    \    rot_chars.next().unwrap();\n    let mut chars = rot_chars.collect::<String>();\n\
    \    chars.next();\n    chars\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_left` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpjc2m6woq.rs:13:31\n   |\n13 |     let mut rot_chars\
    \ = chars.rotate_left(2);\n   |                               ^^^^^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_alphabet(s.chars().cloned().collect(),\
    \ 2);\n    s.to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpzr6u15by.rs:11:5\n   |\n11 |     rotate_alphabet(s.chars().cloned().collect(),\
    \ 2);\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0271]: type\
    \ mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpzr6u15by.rs:11:31\n\
    \     |\n11   |     rotate_alphabet(s.chars().cloned().collect(), 2);\n     |\
    \                               ^^^^^^ expected reference, found `char`\n    \
    \ |\n     = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpzr6u15by.rs:11:40\n   |\n11 |       rotate_alphabet(s.chars().cloned().collect(),\
    \ 2);\n   |                                          ^^^^^^^ method cannot be\
    \ called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alpha: Vec<&'static str> = ALPHA.chars().collect();\n    let mut i: usize =\
    \ 0;\n    let mut j: usize = 0;\n    let mut k: usize = 0;\n    let mut t: String\
    \ = \"\";\n    \n    // find out how many times we want to rotate alpha \n   \
    \ for _ in s.chars() {\n        alpha = alpha.iter_mut();\n        alpha[k] =\
    \ alpha[k + 1];\n        k = 0;\n        \n        i = alpha.len();\n        j\
    \ = alpha.len() - 2;\n        \n        while i > j {\n            alpha[j+1]\
    \ = alpha[j];\n            j--;\n        }\n        \n        k++;\n    }\n  \
    \  \n    // now we can perform the encryption \n    for c in s.chars() {\n   \
    \     t = t + alpha.iter().filter_map(|c| c.to_string()).collect();\n    }\n \
    \   \n    t\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp7gjhdjhf.rs:28:16\n\
    \   |\n28 |             j--;\n   |                ^ expected expression\n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmp7gjhdjhf.rs:31:10\n  \
    \ |\n31 |         k++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n31 |         { let tmp = k; k += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n31 -         k++;\n31 +         k +=\
    \ 1;\n   | \n\nerror[E0425]: cannot find value `ALPHA` in this scope\n  --> /tmp/tmp7gjhdjhf.rs:11:40\n\
    \   |\n11 |     let mut alpha: Vec<&'static str> = ALPHA.chars().collect();\n\
    \   |                                        ^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7gjhdjhf.rs:15:25\n   |\n15 |  \
    \   let mut t: String = \"\";\n   |                ------   ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                |        |\n   |  \
    \              |        expected struct `String`, found `&str`\n   |         \
    \       expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7gjhdjhf.rs:19:17\n\
    \   |\n11 |     let mut alpha: Vec<&'static str> = ALPHA.chars().collect();\n\
    \   |                    ----------------- expected due to this type\n...\n19\
    \ |         alpha = alpha.iter_mut();\n   |                 ^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `std::slice::IterMut`\n   |\n   = note: expected\
    \ struct `Vec<&'static str>`\n              found struct `std::slice::IterMut<'_,\
    \ &'static str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7gjhdjhf.rs:36:45\n\
    \   |\n36 |         t = t + alpha.iter().filter_map(|c| c.to_string()).collect();\n\
    \   |                                             ^^^^^^^^^^^^^ expected enum\
    \ `Option`, found struct `String`\n   |\n   = note: expected enum `Option<_>`\n\
    \            found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n36 |         t = t + alpha.iter().filter_map(|c| Some(c.to_string())).collect();\n\
    \   |                                             +++++             +\n\nerror[E0277]:\
    \ a value of type `&str` cann"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().filter_map(|c|\
    \ match c {\n        'a' .. 'z' => c - 'a' + 1,\n        _ => c\n    }).collect::<String>().rotate_left(2).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpcv4xl7w5.rs:12:9\n\
    \   |\n12 |         'a' .. 'z' => c - 'a' + 1,\n   |         ^^^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0369]: cannot subtract `char` from `char`\n \
    \ --> /tmp/tmpcv4xl7w5.rs:12:25\n   |\n12 |         'a' .. 'z' => c - 'a' + 1,\n\
    \   |                       - ^ --- char\n   |                       |\n   | \
    \                      char\n\nerror[E0599]: no method named `rotate_left` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpcv4xl7w5.rs:14:28\n\
    \   |\n14 |     }).collect::<String>().rotate_left(2).collect::<String>()\n  \
    \ |                            ^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599, E0658.\nFor more information about an error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut encrypted = String::new();\n\
    \    encrypted.clear();\n    for c in s.chars() {\n        let n = alphabet.chars().position(|c|\
    \ c == c);\n        encrypted.push((alphabet.chars().nth(n).unwrap().to_string())\
    \ * 2);\n        encrypted.push(alphabet.chars().nth((n + 1) % alphabet.chars().len()).unwrap().to_string());\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvwgvudr7.rs:16:46\n   |\n\
    16 |         encrypted.push((alphabet.chars().nth(n).unwrap().to_string()) * 2);\n\
    \   |                                              ^ expected `usize`, found enum\
    \ `Option`\n   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0369]: cannot multiply `String` by `{integer}`\n  --> /tmp/tmpvwgvudr7.rs:16:71\n\
    \   |\n16 |         encrypted.push((alphabet.chars().nth(n).unwrap().to_string())\
    \ * 2);\n   |                        ----------------------------------------------\
    \ ^ - {integer}\n   |                        |\n   |                        String\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpvwgvudr7.rs:17:48\n\
    \   |\n17 |         encrypted.push(alphabet.chars().nth((n + 1) % alphabet.chars().len()).unwrap().to_string());\n\
    \   |                                              - ^ - {integer}\n   |     \
    \                                         |\n   |                            \
    \                  Option<usize>\n\nerror[E0599]: no method named `len` found\
    \ for struct `Chars` in the current scope\n  --> /tmp/tmpvwgvudr7.rs:17:72\n \
    \  |\n17 |         encrypted.push(alphabet.chars().nth((n + 1) % alphabet.chars().len()).unwrap().to_string());\n\
    \   |                                                                        ^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvwgvudr7.rs:17:24\n\
    \   |\n17 |         encrypted.push(alphabet.chars().nth((n + 1) % alphabet.chars().len()).unwrap().to_string());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ x = String::new();\n    for i in s.chars() {\n        x.push((i.to_ascii_lowercase()\
    \ + i.to_ascii_uppercase()).chars().nth(2).unwrap());\n    }\n    x\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpo74_qm4d.rs:13:40\n\
    \   |\n13 |         x.push((i.to_ascii_lowercase() + i.to_ascii_uppercase()).chars().nth(2).unwrap());\n\
    \   |                 ---------------------- ^ ---------------------- char\n \
    \  |                 |\n   |                 char\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ c ^ 0x39).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ {integer}`\n  --> /tmp/tmppzck_2j8.rs:11:25\n\
    \   |\n11 |     s.chars().map(|c| c ^ 0x39).collect()\n   |                  \
    \     - ^ ---- {integer}\n   |                       |\n   |                 \
    \      char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut result\
    \ = String::new();\n\tlet mut rotate = 0;\n\tlet mut j = 0;\n\tfor i in s.chars().filter_map(|c|\
    \ {\n\t\tif rotate == 0 {\n\t\t\tresult = format!(\"{}{}\", c.to_ascii_lowercase(),\
    \ result);\n\t\t\trotate = 1;\n\t\t\tj = 0;\n\t\t} else if rotate == 1 {\n\t\t\
    \tresult = format!(\"{}{}\", result, c.to_ascii_lowercase());\n\t\t\trotate =\
    \ 2;\n\t\t\tj = 0;\n\t\t} else if rotate == 2 {\n\t\t\tresult = format!(\"{}{}\"\
    , result, c.to_ascii_lowercase());\n\t\t\trotate = 0;\n\t\t\tj = 0;\n\t\t}\n\t\
    \tj += 1;\n\t\tif j > 2 {\n\t\t\trotate = 0;\n\t\t\tj = 0;\n\t\t}\n\t\tSome(c).unwrap()\n\
    \t}) {\n\t\tresult = format!(\"{}\", result);\n\t}\n\treturn result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7wg5h1yw.rs:33:3\n   |\n\
    33 |         Some(c).unwrap()\n   |         ^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n33 |       \
    \  Some(Some(c).unwrap())\n   |         +++++                +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt_rotation(s.chars().collect(),\
    \ Alphabet::ROTATE_RIGHT)\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpav5z9ca0.rs:11:43\n   |\n11 |     encrypt_rotation(s.chars().collect(),\
    \ Alphabet::ROTATE_RIGHT)\n   |                                           ^^^^^^^^\
    \ use of undeclared type `Alphabet`\n\nerror[E0425]: cannot find function `encrypt_rotation`\
    \ in this scope\n  --> /tmp/tmpav5z9ca0.rs:11:5\n   |\n11 |     encrypt_rotation(s.chars().collect(),\
    \ Alphabet::ROTATE_RIGHT)\n   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ res = String::new();\n    s.chars().for_each(|c|{\n        if c >= 'a' && c\
    \ <= 'z'{\n            res.push_str(&(c + &'z' + 2));\n        } else if c >=\
    \ 'A' && c <= 'Z'{\n            res.push_str(&(c + &'Z' + 2));\n        } else\
    \ {\n            res.push_str(&c + 2);\n        }\n    });\n    res\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&char` to `char`\n  --> /tmp/tmpbp7pvm22.rs:14:30\n\
    \   |\n14 |             res.push_str(&(c + &'z' + 2));\n   |                 \
    \           - ^ ---- &char\n   |                            |\n   |          \
    \                  char\n\nerror[E0369]: cannot add `&char` to `char`\n  --> /tmp/tmpbp7pvm22.rs:16:30\n\
    \   |\n16 |             res.push_str(&(c + &'Z' + 2));\n   |                 \
    \           - ^ ---- &char\n   |                            |\n   |          \
    \                  char\n\nerror[E0369]: cannot add `{integer}` to `&char`\n \
    \ --> /tmp/tmpbp7pvm22.rs:18:29\n   |\n18 |             res.push_str(&c + 2);\n\
    \   |                          -- ^ - {integer}\n   |                        \
    \  |\n   |                          &char\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    if s.len()\
    \ == 0 {\n        return String::new();\n    }\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut result = String::new();\n    for &c in s.chars() {\n   \
    \     result += ((i - 1) % 26) + j % 26;\n        i += 1;\n        j += 1;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp55a11mr5.rs:17:9\n   |\n\
    17 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp55a11mr5.rs:18:19\n   |\n18 |         result\
    \ += ((i - 1) % 26) + j % 26;\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found integer\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = s.chars().map(|c| c - 'a').collect::<Vec<u8>>();\n    let alphabet = alphabet.to_owned();\n\
    \    let mut new_alphabet = [0; alphabet.len()];\n    let mut i = 0;\n    let\
    \ mut j = alphabet.len();\n    for c in alphabet {\n        let mut rotate = match\
    \ rotate_right((i + j) % alphabet.len(), &mut new_alphabet) {\n            Ok(a)\
    \ => a,\n            Err(_) => return s.to_owned(),\n        };\n        if c\
    \ == 0 {\n            rotate = match rotate_left(rotate, &mut new_alphabet) {\n\
    \                Ok(a) => a,\n                Err(_) => return s.to_owned(),\n\
    \            };\n        }\n        *a = c;\n        i = rotate;\n    }\n    String::from_utf8(new_alphabet).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp9gucmuf1.rs:13:32\n   |\n11 |     let alphabet = s.chars().map(|c| c\
    \ - 'a').collect::<Vec<u8>>();\n   |     ------------ help: consider using `const`\
    \ instead of `let`: `const alphabet`\n12 |     let alphabet = alphabet.to_owned();\n\
    13 |     let mut new_alphabet = [0; alphabet.len()];\n   |                   \
    \             ^^^^^^^^ non-constant value\n\nerror[E0425]: cannot find function\
    \ `rotate_right` in this scope\n  --> /tmp/tmp9gucmuf1.rs:17:32\n   |\n17 |  \
    \       let mut rotate = match rotate_right((i + j) % alphabet.len(), &mut new_alphabet)\
    \ {\n   |                                ^^^^^^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this function\n   |\n1  | use std::intrinsics::rotate_right;\n\
    \   |\n\nerror[E0425]: cannot find function `rotate_left` in this scope\n  -->\
    \ /tmp/tmp9gucmuf1.rs:22:28\n   |\n22 |             rotate = match rotate_left(rotate,\
    \ &mut new_alphabet) {\n   |                            ^^^^^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::intrinsics::rotate_left;\n   |\n\nerror[E0425]: cannot find value `a` in\
    \ this scope\n  --> /tmp/tmp9gucmuf1.rs:27:10\n   |\n27 |         *a = c;\n  \
    \ |          ^ help: a local variable with a similar name exists: `c`\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmp9gucmuf1.rs:11:40\n   |\n\
    11 |     let alphabet = s.chars().map(|c| c - 'a').collect::<Vec<u8>>();\n   |\
    \                                      - ^ --- char\n   |                    \
    \                  |\n   |                                      char\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0425, E0435.\nFor more information about an error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    let mut cipher = s.to_owned();\n\
    \    for (i, ch) in alphabet.chars().enumerate() {\n        let (shift, ch) =\
    \ alphabet.split_at(i);\n        cipher.push(ch);\n        cipher.push(shift);\n\
    \    }\n    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp872s12j4.rs:15:21\n   |\n\
    15 |         cipher.push(ch);\n   |                     ^^ expected `char`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp872s12j4.rs:16:21\n\
    \   |\n16 |         cipher.push(shift);\n   |                     ^^^^^ expected\
    \ `char`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|x|\
    \ alphabet[x]).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpz8agmeqb.rs:11:23\n\
    \   |\n11 |     s.chars().map(|x| alphabet[x]).collect()\n   |               \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ 'a'.cmp(bcd_table[c])).fold((0,0), |(t,c), (l,r)|\n    {\n        (t*2 + l,\
    \ r + 2*c + 1)\n    }).unwrap()\n        .fold((0,0), (m, c) -> (t, r) -> (m +\
    \ (bcd_table[c] - 'a').wrapping_mul(t),\n            r + (2*c + 1).wrapping_mul(t)))\n\
    \        .unwrap()\n        .1.0\n        .wrapping_mul(ALPHABET_ROTATION_TABLE)\n\
    \        .unwrap()\n        + s.chars().map(|c| ALPHABET_ROTATION_TABLE.entry(c).or_insert(c)).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `->`\n\
    \  --> /tmp/tmphx6vzdlo.rs:15:29\n   |\n15 |         .fold((0,0), (m, c) -> (t,\
    \ r) -> (m + (bcd_table[c] - 'a').wrapping_mul(t),\n   |                     \
    \        ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars()\n\
    \        .map(|&c| {\n            rotate_alphabet_by(c, 2)\n        })\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet_by` in this scope\n\
    \  --> /tmp/tmp702eln17.rs:13:13\n   |\n13 |             rotate_alphabet_by(c,\
    \ 2)\n   |             ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp702eln17.rs:12:15\n   |\n12 |         .map(|&c|\
    \ {\n   |               ^--\n   |               ||\n   |               |expected\
    \ due to this\n   |               expected `char`, found reference\n   |     \
    \          help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars()\n\
    \        .filter_map(|c| alphabet.find(c).unwrap())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpu1hbnvji.rs:12:25\n\
    \   |\n12 |         .filter_map(|c| alphabet.find(c).unwrap())\n   |         \
    \                ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // Write\
    \ your code here\n    let mut cipher = 'A'; // start at A\n    let len = s.len();\n\
    \    let mut new_s = String::with_capacity(len + 1);\n    for i in 0..len {\n\
    \        let c = cipher;\n        cipher = s.chars().nth(i).unwrap();\n      \
    \  new_s.push(c);\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Ah\"`,\n right: `\"lm\"`', /tmp/tmp_xeyqahh.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = s.len() - 1;\n\
    \    let mut a = s.len() - 1;\n    loop {\n        if l < 0 {\n            k =\
    \ k + 2;\n            a--\n        }\n        if k < 0 {\n            l = l +\
    \ 2;\n            a--;\n        }\n        if i < l {\n            let c = s.chars().nth(i).unwrap();\n\
    \            let r = c.rotate_right();\n            let mut b = '';\n        \
    \    for c in r {\n                b += c;\n            }\n            a = a +\
    \ 1;\n            i += 1;\n            l = l - 1;\n            j = j - 1;\n  \
    \      }\n        if j < k {\n            let c = s.chars().nth(j).unwrap();\n\
    \            let r = c.rotate_right();\n            let mut b = '';\n        \
    \    for c in r {\n                b += c;\n            }\n            a = a +\
    \ 1;\n            j += 1;\n            l = l - 1;\n            k = k - 1;\n  \
    \      }\n        if k < l {\n            let c = s.chars().nth(k).unwrap();\n\
    \            let r = c.rotate_right();\n            let mut b = '';\n        \
    \    for c in r {\n                b += c;\n            }\n            a = a +\
    \ 1;\n            k = k - 1;\n            l = l - 1;\n        }\n        if k\
    \ == l {\n            let c = s.chars().nth(k).unwrap();\n            let r =\
    \ c.rotate_right();\n            let mut b = '';\n            for c in r {\n \
    \               b += c;\n            }\n            a = a + 1;\n            return\
    \ b;\n        }\n    }\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmps6gb004l.rs:28:26\n   |\n\
    28 |             let mut b = '';\n   |                          ^ empty character\
    \ literal\n\nerror: empty character literal\n  --> /tmp/tmps6gb004l.rs:40:26\n\
    \   |\n40 |             let mut b = '';\n   |                          ^ empty\
    \ character literal\n\nerror: empty character literal\n  --> /tmp/tmps6gb004l.rs:52:26\n\
    \   |\n52 |             let mut b = '';\n   |                          ^ empty\
    \ character literal\n\nerror: empty character literal\n  --> /tmp/tmps6gb004l.rs:63:26\n\
    \   |\n63 |             let mut b = '';\n   |                          ^ empty\
    \ character literal\n\nerror: expected expression, found `}`\n  --> /tmp/tmps6gb004l.rs:20:9\n\
    \   |\n20 |         }\n   |         ^ expected expression\n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmps6gb004l.rs:23:16\n   |\n23 |             a--;\n  \
    \ |                ^ expected expression\n\nerror[E0599]: no method named `rotate_right`\
    \ found for type `char` in the current scope\n  --> /tmp/tmps6gb004l.rs:27:23\n\
    \   |\n27 |             let r = c.rotate_right();\n   |                      \
    \ ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `rotate_right`\
    \ found for type `char` in the current scope\n  --> /tmp/tmps6gb004l.rs:39:23\n\
    \   |\n39 |             let r = c.rotate_right();\n   |                      \
    \ ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `rotate_right`\
    \ found for type `char` in the current scope\n  --> /tmp/tmps6gb004l.rs:51:23\n\
    \   |\n51 |             let r = c.rotate_right();\n   |                      \
    \ ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `rotate_right`\
    \ found for type `char` in the current scope\n  --> /tmp/tmps6gb004l.rs:62:23\n\
    \   |\n62 |             let r = c.rotate_right();\n   |                      \
    \ ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting due to 10 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'f', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\
    \    .iter()\n    .cloned()\n    .cycle()\n    .collect();\n    let mut encrypted:\
    \ Vec<String> = s.chars().map(|c| {\n        alphabet.pop();\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        alphabet.push(alphabet.pop());\n        alphabet.push(alphabet.pop());\n\
    \        \n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph5a3_yp2.rs:84:3\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n16 |     let mut encrypted: Vec<String> = s.chars().map(|c|\
    \ {\n   |                                                   - unclosed delimiter\n\
    ...\n84 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator,\
    \ found keyword `fn`\n  --> /tmp/tmph5a3_yp2.rs:74:1\n   |\n72 | }\n   |  - expected\
    \ one of `)`, `,`, `.`, `?`, or an operator\n73 | \n74 | fn main() {\n   | ^^\
    \ unexpected token\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ ciphertext = String::with_capacity(s.len());\n    let mut alphabet = Alphabet::rotate();\n\
    \    let mut i = 0;\n    match s.len() {\n        0 => ciphertext.push('\\0'),\n\
    \        _ => s.chars().for_each(|c| {\n            ciphertext.push((alphabet.get_character(c)\
    \ + alphabet.get_character(c)).to_string());\n        }),\n    }\n    ciphertext\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpzbkt3ygt.rs:12:24\n   |\n12 |     let mut alphabet = Alphabet::rotate();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet : Vec<char> = vec!['A'..'Z', 'a'..'z', ''..'0', ''..'9'];\n    alphabet.swap(0,\
    \ 1); // Alphabet rotated by 2 places. \n                         // Swap 0 with\
    \ 1\n    alphabet.swap(2, 3); // Alphabet rotated by 4 places. \n            \
    \             // Swap 2 with 3\n    alphabet.swap(5, 6); // Alphabet rotated by\
    \ 6 places. \n                         // Swap 5 with 6\n\n    let mut index :\
    \ usize = 0;\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            result.push(c);\n        }\n        else {\n\
    \            result.append(alphabet[index * 2]);\n            result.append(alphabet[index\
    \ * 2 + 1]);\n        }\n        index = (index + 1) % alphabet.len();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpunj2ucik.rs:11:62\n   |\n\
    11 |     let mut alphabet : Vec<char> = vec!['A'..'Z', 'a'..'z', ''..'0', ''..'9'];\n\
    \   |                                                              ^ empty character\
    \ literal\n\nerror: empty character literal\n  --> /tmp/tmpunj2ucik.rs:11:71\n\
    \   |\n11 |     let mut alphabet : Vec<char> = vec!['A'..'Z', 'a'..'z', ''..'0',\
    \ ''..'9'];\n   |                                                            \
    \           ^ empty character literal\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpunj2ucik.rs:11:41\n   |\n11 |     let mut alphabet : Vec<char> = vec!['A'..'Z',\
    \ 'a'..'z', ''..'0', ''..'9'];\n   |                                         ^^^^^^^^\
    \ expected `char`, found struct `std::ops::Range`\n   |\n   = note: expected type\
    \ `char`\n            found struct `std::ops::Range<char>`\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpunj2ucik.rs:26:20\n   |\n26 |             result.append(alphabet[index\
    \ * 2]);\n   |                    ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpunj2ucik.rs:27:20\n   |\n27 |             result.append(alphabet[index\
    \ * 2 + 1]);\n   |                    ^^^^^^ method not found in `String`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    let mut i = 0;\n    while i < s.len() {\n        let c = s[i];\n\
    \        s[i] = s[(c + 2) as usize];\n        s[(c + 2) as usize] = c;\n     \
    \   i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7s4nhb4p.rs:14:17\n\
    \   |\n14 |         let c = s[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7s4nhb4p.rs:15:9\n   |\n15 |         s[i] = s[(c + 2) as usize];\n\
    \   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7s4nhb4p.rs:15:16\n   |\n15 |         s[i] = s[(c + 2) as usize];\n\
    \   |                ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // Rotate\
    \ the alphabet by two letters at a time.\n    let mut s = &s[..];\n    for i in\
    \ 0..s.len() {\n        // Find a place for the rotated alphabet character\n \
    \       let mut rotated_letter = s.chars().nth(i).unwrap();\n        if rotated_letter\
    \ < 'a' {\n            rotated_letter += 'a' - 'a';\n        }\n        if rotated_letter\
    \ > 'z' {\n            rotated_letter += 'z' - 'a';\n        }\n        // Rotate\
    \ the letter\n        let rotated_letter = rotated_letter + 'a' - 'a';\n     \
    \   // Append the rotated letter\n        s += rotated_letter;\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp2450bery.rs:17:35\n\
    \   |\n17 |             rotated_letter += 'a' - 'a';\n   |                   \
    \            --- ^ --- char\n   |                               |\n   |      \
    \                         char\n\nerror[E0369]: cannot subtract `char` from `char`\n\
    \  --> /tmp/tmp2450bery.rs:20:35\n   |\n20 |             rotated_letter += 'z'\
    \ - 'a';\n   |                               --- ^ --- char\n   |            \
    \                   |\n   |                               char\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmp2450bery.rs:23:45\n   |\n23 |   \
    \      let rotated_letter = rotated_letter + 'a' - 'a';\n   |                \
    \              -------------- ^ --- char\n   |                              |\n\
    \   |                              char\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmp2450bery.rs:25:9\n   |\n\
    25 |         s += rotated_letter;\n   |         -^^^^^^^^^^^^^^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2450bery.rs:27:5\n   |\n10 | fn encrypt(s: String) -> String\
    \ {\n   |                          ------ expected `String` because of return\
    \ type\n...\n27 |     s\n   |     ^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    match s\
    \ {\n        \"\" | \"e\" | \"i\" => s,\n        \"a\" => rotate_cipher(\"a\"\
    , 1),\n        \"b\" => rotate_cipher(\"b\", 2),\n        \"c\" => rotate_cipher(\"\
    c\", 3),\n        \"d\" => rotate_cipher(\"d\", 4),\n        \"e\" => rotate_cipher(\"\
    e\", 5),\n        \"f\" => rotate_cipher(\"f\", 6),\n        \"g\" => rotate_cipher(\"\
    g\", 7),\n        \"h\" => rotate_cipher(\"h\", 8),\n        \"i\" => rotate_cipher(\"\
    i\", 9),\n        \"j\" => rotate_cipher(\"j\", 10),\n        \"k\" => rotate_cipher(\"\
    k\", 11),\n        \"l\" => rotate_cipher(\"l\", 12),\n        \"m\" => rotate_cipher(\"\
    m\", 13),\n        \"n\" => rotate_cipher(\"n\", 14),\n        \"o\" => rotate_cipher(\"\
    o\", 15),\n        \"p\" => rotate_cipher(\"p\", 16),\n        \"q\" => rotate_cipher(\"\
    q\", 17),\n        \"r\" => rotate_cipher(\"r\", 18),\n        \"s\" => rotate_cipher(\"\
    s\", 19),\n        \"t\" => rotate_cipher(\"t\", 20),\n        \"u\" => rotate_cipher(\"\
    u\", 21),\n        \"v\" => rotate_cipher(\"v\", 22),\n        \"w\" => rotate_cipher(\"\
    w\", 23),\n        \"x\" => rotate_cipher(\"x\", 24),\n        \"y\" => rotate_cipher(\"\
    y\", 25),\n        \"z\" => rotate_cipher(\"z\", 26),\n        _ => panic!(\"\
    Encrypt function does not work correctly.\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_cipher` in this scope\n  -->\
    \ /tmp/tmpir00q5d_.rs:13:16\n   |\n13 |         \"a\" => rotate_cipher(\"a\",\
    \ 1),\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `rotate_cipher` in this scope\n  --> /tmp/tmpir00q5d_.rs:14:16\n\
    \   |\n14 |         \"b\" => rotate_cipher(\"b\", 2),\n   |                ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `rotate_cipher`\
    \ in this scope\n  --> /tmp/tmpir00q5d_.rs:15:16\n   |\n15 |         \"c\" =>\
    \ rotate_cipher(\"c\", 3),\n   |                ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `rotate_cipher` in this scope\n\
    \  --> /tmp/tmpir00q5d_.rs:16:16\n   |\n16 |         \"d\" => rotate_cipher(\"\
    d\", 4),\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `rotate_cipher` in this scope\n  --> /tmp/tmpir00q5d_.rs:17:16\n\
    \   |\n17 |         \"e\" => rotate_cipher(\"e\", 5),\n   |                ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `rotate_cipher`\
    \ in this scope\n  --> /tmp/tmpir00q5d_.rs:18:16\n   |\n18 |         \"f\" =>\
    \ rotate_cipher(\"f\", 6),\n   |                ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `rotate_cipher` in this scope\n\
    \  --> /tmp/tmpir00q5d_.rs:19:16\n   |\n19 |         \"g\" => rotate_cipher(\"\
    g\", 7),\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `rotate_cipher` in this scope\n  --> /tmp/tmpir00q5d_.rs:20:16\n\
    \   |\n20 |         \"h\" => rotate_cipher(\"h\", 8),\n   |                ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `rotate_cipher`\
    \ in this scope\n  --> /tmp/tmpir00q5d_.rs:21:16\n   |\n21 |         \"i\" =>\
    \ rotate_cipher(\"i\", 9),\n   |                ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `rotate_cipher` in this scope\n\
    \  --> /tmp/tmpir00q5d_.rs:22:16\n   |\n22 |         \"j\" => rotate_cipher(\"\
    j\", 10),\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    \n    if\
    \ s.len() % 2 == 1 {\n        return \"invalid input\";\n    }\n    \n    let\
    \ mut counter = 0;\n    let mut result = 0;\n    for i in 0..s.len() {\n     \
    \   let letter = s.chars().nth(i).unwrap();\n        result += alphabet.lookup(letter).unwrap()\
    \ * counter;\n        counter += 1;\n    }\n    return result.to_string();\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp_og_c6m3.rs:20:19\n\
    \   |\n20 |         result += alphabet.lookup(letter).unwrap() * counter;\n  \
    \ |                   ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_og_c6m3.rs:13:16\n   |\n10 | fn encrypt(s: String) ->\
    \ String {\n   |                          ------ expected `String` because of\
    \ return type\n...\n13 |         return \"invalid input\";\n   |             \
    \   ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                |\n   |                expected struct `String`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().fold(\"\
    \".to_owned(), |mut c, c| {\n        *c += 1;\n        *c += 1;\n        String::from_utf8(&c.to_utf8()).unwrap()\n\
    \    })\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `c` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmpds1zbplb.rs:11:43\n   |\n11 |     s.chars().fold(\"\".to_owned(),\
    \ |mut c, c| {\n   |                                           ^ used as parameter\
    \ more than once\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpds1zbplb.rs:12:9\n\
    \   |\n12 |         *c += 1;\n   |         ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmpds1zbplb.rs:13:9\n   |\n13 |         *c += 1;\n\
    \   |         ^^\n\nerror[E0599]: no method named `to_utf8` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpds1zbplb.rs:14:30\n   |\n14 |         String::from_utf8(&c.to_utf8()).unwrap()\n\
    \   |                              ^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0415, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0415`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".to_string();\n  \
    \  let mut alphabet = alphabet.chars().collect::<Vec<&'static str>>();\n    for\
    \ i in 0..alphabet.len() {\n        alphabet[i] = alphabet[alphabet.len() - i\
    \ - 1] + alphabet[i] + alphabet[alphabet.len() - i];\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut alphabet = alphabet.to_string();\n    let mut\
    \ s = s.to_string();\n    for i in s.chars() {\n        j = alphabet.chars().position(|&x|\
    \ *x == i).unwrap();\n        alphabet[i] = alphabet[j];\n        alphabet[j]\
    \ = alphabet[i];\n    }\n    alphabet.join(\"\").to_string()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<&'static str>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmps602m0f2.rs:12:41\n\
    \     |\n12   |     let mut alphabet = alphabet.chars().collect::<Vec<&'static\
    \ str>>();\n     |                                         ^^^^^^^ value of type\
    \ `Vec<&'static str>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&'static\
    \ str>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0369]: cannot add `&str` to `&str`\n\
    \  --> /tmp/tmps602m0f2.rs:14:56\n   |\n14 |         alphabet[i] = alphabet[alphabet.len()\
    \ - i - 1] + alphabet[i] + alphabet[alphabet.len() - i];\n   |               \
    \        -------------------------------- ^ ----------- &str\n   |           \
    \            |                                |\n   |                       |\
    \                                `+` cannot be used to concatenate two `&str`\
    \ strings\n   |                       &str\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: create an owned `String` from\
    \ a string reference\n   |\n14 |         alphabet[i] = alphabet[alphabet.len()\
    \ - i - 1].to_owned() + alphabet[i] + alphabet[alphabet.len() - i];\n   |    \
    \                                                   +++++++++++\n\nerror[E0599]:\
    \ the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmps602m0f2.rs:18:33\n    |\n18  |       let mut\
    \ alphabet = alphabet.to_string();\n    |                                   ^^^^^^^^^\
    \ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds\n   \
    \ |\n    = note: the following trait bounds were not satisfied:\n            `Vec<&str>:\
    \ std::fmt::Display`\n            which is required by `Vec<&str>: ToString`\n\
    \            `[&str]: std::fmt::Display`\n            which is required by `[&str]:\
    \ ToString`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0369, E"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    if s.len()\
    \ < 2 {\n        return s\n    }\n    let mut s = \"\".to_string();\n    for i\
    \ in s.chars() {\n        if i.is_alpha() {\n            let c = alphabet.chars().nth((i.as_byte()\
    \ as usize) - 1).unwrap();\n            let a = (c + alphabet.chars().nth((i.as_byte()\
    \ as usize) + 1).unwrap()).to_string();\n            s += a;\n        } else {\n\
    \            s += i;\n        }\n    }\n    return s\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpmetyebyq.rs:17:21\n\
    \   |\n17 |             let c = alphabet.chars().nth((i.as_byte() as usize) -\
    \ 1).unwrap();\n   |                     ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpmetyebyq.rs:18:26\n\
    \   |\n18 |             let a = (c + alphabet.chars().nth((i.as_byte() as usize)\
    \ + 1).unwrap()).to_string();\n   |                          ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `is_alpha` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpmetyebyq.rs:16:14\n   |\n16 |         if\
    \ i.is_alpha() {\n   |              ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_alphabetic`\n\nerror[E0599]: no method named `as_byte`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpmetyebyq.rs:17:45\n\
    \   |\n17 |             let c = alphabet.chars().nth((i.as_byte() as usize) -\
    \ 1).unwrap();\n   |                                             ^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `as_byte` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpmetyebyq.rs:18:50\n   |\n18 |   \
    \          let a = (c + alphabet.chars().nth((i.as_byte() as usize) + 1).unwrap()).to_string();\n\
    \   |                                                  ^^^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmetyebyq.rs:21:18\n\
    \   |\n21 |             s += i;\n   |                  ^ expected `&str`, found\
    \ `char`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = String::from(*s);\n    rot(&mut s, ROTATE_LEFT);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rot` in this scope\n  --> /tmp/tmpnvzdfvg4.rs:12:5\n\
    \   |\n12 |     rot(&mut s, ROTATE_LEFT);\n   |     ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `ROTATE_LEFT` in this scope\n  --> /tmp/tmpnvzdfvg4.rs:12:17\n\
    \   |\n12 |     rot(&mut s, ROTATE_LEFT);\n   |                 ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmpnvzdfvg4.rs:11:30\n    |\n11  |\
    \     let mut s = String::from(*s);\n    |                 ------------ ^^ doesn't\
    \ have a size known at compile-time\n    |                 |\n    |          \
    \       required by a bound introduced by this call\n    |\n    = help: the trait\
    \ `Sized` is not implemented for `str`\nnote: required by a bound in `from`\n\n\
    error[E0277]: the trait bound `String: From<str>` is not satisfied\n  --> /tmp/tmpnvzdfvg4.rs:11:17\n\
    \   |\n11 |     let mut s = String::from(*s);\n   |                 ^^^^^^^^^^^^\
    \ the trait `From<str>` is not implemented for `String`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    // Iterate over each character in s\n    for c in s.chars() {\n\
    \        // Rotate c by two multiplied by two shifts down\n        c += (c * 2);\n\
    \        // Rotate c by two multiplied by two shifts up\n        c += (c * 2);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmphzyes1fg.rs:15:14\n\
    \   |\n15 |         c += (c * 2);\n   |              ^     ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    15 -         c += (c * 2);\n15 +         c += c * 2;\n   | \n\nwarning: unnecessary\
    \ parentheses around assigned value\n  --> /tmp/tmphzyes1fg.rs:17:14\n   |\n17\
    \ |         c += (c * 2);\n   |              ^     ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n17 -         c += (c * 2);\n17 +         c += c * 2;\n  \
    \ | \n\nerror[E0369]: cannot multiply `char` by `{integer}`\n  --> /tmp/tmphzyes1fg.rs:15:17\n\
    \   |\n15 |         c += (c * 2);\n   |               - ^ - {integer}\n   |  \
    \             |\n   |               char\n\nerror[E0369]: cannot multiply `char`\
    \ by `{integer}`\n  --> /tmp/tmphzyes1fg.rs:17:17\n   |\n17 |         c += (c\
    \ * 2);\n   |               - ^ - {integer}\n   |               |\n   |      \
    \         char\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = [\n        'z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p',\
    \ 'o', 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'];\n\
    \    alphabet.insert(0, alphabet.last());\n    let mut rotatedAlphabet = alphabet;\n\
    \    rotatedAlphabet.rotate();\n\n    let mut cipher = s;\n    let mut position\
    \ = 0;\n    while position < cipher.len() {\n        cipher = cipher.chars().fold(cipher.to_string(),\
    \ |acc, ch| {\n            if let Some(pos) = rotatedAlphabet.find(|c| c.unwrap()\
    \ == ch) {\n                acc.insert(pos as usize, ch)\n            } else {\n\
    \                acc.insert(ch.to_ascii_lowercase().len(), ch)\n            }\n\
    \        });\n        position += cipher.len() - 1;\n    }\n    cipher\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `insert` found for array `[char; 26]` in\
    \ the current scope\n  --> /tmp/tmpk7lz0tsw.rs:13:14\n   |\n13 |     alphabet.insert(0,\
    \ alphabet.last());\n   |              ^^^^^^ help: there is an associated function\
    \ with a similar name: `iter`\n\nerror[E0599]: no method named `rotate` found\
    \ for array `[char; 26]` in the current scope\n  --> /tmp/tmpk7lz0tsw.rs:15:21\n\
    \   |\n15 |     rotatedAlphabet.rotate();\n   |                     ^^^^^^ help:\
    \ there is an associated function with a similar name: `rotate_left`\n\nerror[E0599]:\
    \ no method named `find` found for array `[char; 26]` in the current scope\n \
    \ --> /tmp/tmpk7lz0tsw.rs:21:48\n   |\n21 |             if let Some(pos) = rotatedAlphabet.find(|c|\
    \ c.unwrap() == ch) {\n   |                                                ^^^^\
    \ method not found in `[char; 26]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk7lz0tsw.rs:22:17\n\
    \   |\n22 |                 acc.insert(pos as usize, ch)\n   |               \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n   |\nnote:\
    \ method `insert` modifies its receiver in-place\n  --> /tmp/tmpk7lz0tsw.rs:22:21\n\
    \   |\n22 |                 acc.insert(pos as usize, ch)\n   |               \
    \  --- ^^^^^^ this call modifies `acc` in-place\n   |                 |\n   |\
    \                 you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `insert`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmpk7lz0tsw.rs:24:52\n\
    \   |\n24 |                 acc.insert(ch.to_ascii_lowercase().len(), ch)\n  \
    \ |                                                    ^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk7lz0tsw.rs:24:17\n\
    \   |\n24 |                 acc.insert(ch.to_ascii_lowercase().len(), ch)\n  \
    \ |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `insert` modifies its receiver in-place\n\
    \  --> /tmp/tmpk7lz0tsw.rs:24:21\n   |\n24 |                 acc.insert"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt2(s,\
    \ ALPHABET)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encrypt2` in this scope\n  --> /tmp/tmppnmeef3s.rs:11:5\n\
    \   |\n11 |     encrypt2(s, ALPHABET)\n   |     ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmppnmeef3s.rs:11:17\n\
    \   |\n11 |     encrypt2(s, ALPHABET)\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    alphabet.shuffle();\n    let\
    \ mut alphabet2 = alphabet.clone();\n    alphabet2.rotate(2);\n    let mut result\
    \ = s.to_string();\n    for c in s.chars().cloned() {\n        alphabet2.next().unwrap();\n\
    \        result.insert(alphabet.index(c), c.to_char());\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `shuffle` found for struct `Vec<&str>` in\
    \ the current scope\n  --> /tmp/tmpwgu3srpw.rs:12:14\n   |\n12 |     alphabet.shuffle();\n\
    \   |              ^^^^^^^ method not found in `Vec<&str>`\n\nerror[E0599]: no\
    \ method named `rotate` found for struct `Vec<&str>` in the current scope\n  -->\
    \ /tmp/tmpwgu3srpw.rs:14:15\n   |\n14 |     alphabet2.rotate(2);\n   |       \
    \        ^^^^^^ help: there is an associated function with a similar name: `rotate_left`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpwgu3srpw.rs:16:24\n     |\n16   |     for c in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpwgu3srpw.rs:16:14\n\
    \   |\n16 |     for c in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpwgu3srpw.rs:16:14\n   |\n16 |     for c in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<&str>` in the current\
    \ scope\n  --> /tmp/tmpwgu3srpw.rs:17:19\n   |\n17 |         alphabet2.next().unwrap();\n\
    \   |                   ^^^^ method not found in `Vec<&str>`\n\nerror[E0599]:\
    \ no method named `index` found for struct `Vec<&str>` in the current scope\n\
    \  --> /tmp/tmpwgu3srpw.rs:18"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ alphabet.rotate(2);\n\n    let mut result = String::new();\n    let mut current\
    \ = s[0];\n\n    for ch in s.chars() {\n        let index = alphabet.binary_search_index(&*current);\n\
    \        match index {\n            None => result.push(*current),\n         \
    \   Some(index) => {\n                let shifted = alphabet.iter().nth(index).unwrap();\n\
    \                result.push(shifted);\n            }\n        };\n        current\
    \ = ch;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmpqjbyaa5p.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmpqjbyaa5p.rs:15:23\n   |\n15 |     let mut current\
    \ = s[0];\n   |                       ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `binary_search_index` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmpqjbyaa5p.rs:18:30\n   |\n18\
    \ |         let index = alphabet.binary_search_index(&*current);\n   |       \
    \                       ^^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `binary_search`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqjbyaa5p.rs:23:29\n   |\n23 |                 result.push(shifted);\n\
    \   |                             ^^^^^^^ expected `char`, found `&char`\n   |\n\
    help: consider dereferencing the borrow\n   |\n23 |                 result.push(*shifted);\n\
    \   |                             +\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n\
    \    let mut shift = alphabet.len();\n    let mut pos = alphabet.len();\n    for\
    \ ch in s.chars() {\n        let a = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let b = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let\
    \ c = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let d = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let e = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let\
    \ f = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let g = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let h = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let\
    \ i = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let j = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let k = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let\
    \ l = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let m = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let n = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let\
    \ o = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let p = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let q = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let\
    \ r = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let s = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let t = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let\
    \ u = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let v = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let w = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let\
    \ x = alphabet.chars().nth(pos).unwrap().to_digit(10);\n        let y = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\
    \        let z = alphabet.chars().nth(pos).unwrap().to_digit(10);\n\n        let\
    \ mut new_alphabet = alphabet;\n        new_alphabet.insert(pos + 1, alphabet[pos\
    \ + \n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqrmrrr7j.rs:57:3\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n15 |     for ch in s.chars() {\n   |      \
    \                   - this delimiter might not be properly closed...\n...\n45\
    \ | }\n   | - ...as it matches this but it has different indentation\n...\n57\
    \ | }\n   |   ^\n\nerror: expected expression, found `]`\n  --> /tmp/tmpqrmrrr7j.rs:45:1\n\
    \   |\n45 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpqrmrrr7j.rs:44:46\n   |\n10 | fn encrypt(s: String) -> String\
    \ {\n   |                                 - closing delimiter possibly meant for\
    \ this\n...\n44 |         new_alphabet.insert(pos + 1, alphabet[pos + \n   | \
    \                                             ^ unclosed delimiter\n45 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqrmrrr7j.rs:10:26\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = ROTATE_TABLE[ROTATE_TABLE.len()-1];\n    for (i, c) in s.chars().enumerate()\
    \ {\n        alphabet[i] = ROTATE_TABLE[alphabet.index_mut(c) - ROTATE_TABLE.len()-1];\n\
    \    }\n    alphabet.iter().map(|x| char::from(x)).collect()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROTATE_TABLE` in this scope\n  --> /tmp/tmp4d0f3lcd.rs:11:24\n\
    \   |\n11 |     let mut alphabet = ROTATE_TABLE[ROTATE_TABLE.len()-1];\n   | \
    \                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROTATE_TABLE` in this scope\n  --> /tmp/tmp4d0f3lcd.rs:11:37\n\
    \   |\n11 |     let mut alphabet = ROTATE_TABLE[ROTATE_TABLE.len()-1];\n   | \
    \                                    ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `ROTATE_TABLE` in this scope\n  --> /tmp/tmp4d0f3lcd.rs:13:23\n\
    \   |\n13 |         alphabet[i] = ROTATE_TABLE[alphabet.index_mut(c) - ROTATE_TABLE.len()-1];\n\
    \   |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROTATE_TABLE` in this scope\n  --> /tmp/tmp4d0f3lcd.rs:13:60\n\
    \   |\n13 |         alphabet[i] = ROTATE_TABLE[alphabet.index_mut(c) - ROTATE_TABLE.len()-1];\n\
    \   |                                                            ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    alphabet.rotate_left();\n\
    \    alphabet.rotate_left();\n    alphabet.rotate_left();\n    alphabet.rotate_left();\n\
    \    alphabet.rotate_left();\n    alphabet.rotate_left();\n\n    let mut s = s.to_string();\n\
    \    let mut result = '';\n\n    for c in s.chars() {\n        if alphabet.contains(c)\
    \ {\n            result += alphabet.find(c)+1;\n        } else {\n           \
    \ result += c;\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpbhm8mza7.rs:20:23\n   |\n\
    20 |     let mut result = '';\n   |                       ^ empty character literal\n\
    \nerror[E0599]: no method named `rotate_left` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbhm8mza7.rs:12:14\n   |\n12 |     alphabet.rotate_left();\n\
    \   |              ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `rotate_left` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpbhm8mza7.rs:13:14\n   |\n13 |     alphabet.rotate_left();\n   |\
    \              ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpbhm8mza7.rs:14:14\n\
    \   |\n14 |     alphabet.rotate_left();\n   |              ^^^^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `rotate_left` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpbhm8mza7.rs:15:14\n   |\n\
    15 |     alphabet.rotate_left();\n   |              ^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `rotate_left` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpbhm8mza7.rs:16:14\n   |\n16 | \
    \    alphabet.rotate_left();\n   |              ^^^^^^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `rotate_left` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpbhm8mza7.rs:17:14\n   |\n17 |     alphabet.rotate_left();\n\
    \   |              ^^^^^^^^^^^ method not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmpbhm8mza7.rs:24:39\n   |\n\
    24 |             result += alphabet.find(c)+1;\n   |                       ----------------^-\
    \ {integer}\n   |                       |\n   |                       Option<usize>\n\
    \nerror[E0277]: cannot add-assign `char` to `String`\n  --> /tmp/tmpbhm8mza7.rs:26:20\n\
    \   |\n26 |             result += c;\n   |                    ^^ no implementation\
    \ for `String += char`\n   |\n   = help: the trait `AddAssign<char>` is not implemented\
    \ for `String`\n   = help: the trait `AddAssign<&str>` is i"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ res = String::new();\n    let mut i = 0;\n\n    for c in s.chars() {\n     \
    \   if let c = 'z' {\n            res.push_char(c + 2);\n        } else {\n  \
    \          res.push_char(c);\n        }\n        res.push_char(c);\n    }\n\n\
    \    i = 0;\n\n    for _ in 0..s.len() {\n        if let c = res.chars().next()\
    \ {\n            if let c = 'z' {\n                i += 2;\n            } else\
    \ {\n                i += 1;\n            }\n            res.push_char(c);\n \
    \       }\n    }\n\n    res.to_string()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push_char` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpea4eno5y.rs:16:17\n   |\n16 |             res.push_char(c\
    \ + 2);\n   |                 ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push_str`\n\nerror[E0369]: cannot add `{integer}` to `char`\n\
    \  --> /tmp/tmpea4eno5y.rs:16:29\n   |\n16 |             res.push_char(c + 2);\n\
    \   |                           - ^ - {integer}\n   |                        \
    \   |\n   |                           char\n\nerror[E0599]: no method named `push_char`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpea4eno5y.rs:18:17\n\
    \   |\n18 |             res.push_char(c);\n   |                 ^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `push_str`\n\nerror[E0599]:\
    \ no method named `push_char` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpea4eno5y.rs:20:13\n   |\n20 |         res.push_char(c);\n   | \
    \            ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `push_str`\n\nerror[E0599]: no method named `push_char` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpea4eno5y.rs:32:17\n   |\n32 |          \
    \   res.push_char(c);\n   |                 ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `push_str`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = &['e', 'p', 'h', 'n', 'q', 'm', 'w', 'r', 'y', 'u', 't', 'b', 'f', 'x', 'j',\
    \ 'k', 'l', 'o', 's', 'd', 'f'];\n    let mut s = String::from(s);\n    \n   \
    \ for a in alphabet {\n        s.insert(s.len() - 2, a);\n    }\n    \n    let\
    \ mut i = 0;\n    while i < s.len() - 2 {\n        let mut t = s.chars().nth(i).unwrap();\n\
    \        t ^= t << 1;\n        t ^= t >> 1;\n        t ^= t << 1;\n        \n\
    \        let mut new_t = s.chars().nth(i + 1).unwrap();\n        new_t ^= new_t\
    \ >> 1;\n        new_t ^= new_t << 1;\n        new_t ^= new_t >> 1;\n        \n\
    \        s.swap(i + 1, i + 2);\n        s.swap(i, i + 1);\n        \n        i\
    \ += 2;\n        s.swap(i, i);\n    }\n    \n    s\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk81zbzw8.rs:15:31\n   |\n\
    15 |         s.insert(s.len() - 2, a);\n   |                               ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    15 |         s.insert(s.len() - 2, *a);\n   |                               +\n\
    \nerror[E0369]: no implementation for `char << {integer}`\n  --> /tmp/tmpk81zbzw8.rs:21:16\n\
    \   |\n21 |         t ^= t << 1;\n   |              - ^^ - {integer}\n   |   \
    \           |\n   |              char\n\nerror[E0369]: no implementation for `char\
    \ >> {integer}`\n  --> /tmp/tmpk81zbzw8.rs:22:16\n   |\n22 |         t ^= t >>\
    \ 1;\n   |              - ^^ - {integer}\n   |              |\n   |          \
    \    char\n\nerror[E0369]: no implementation for `char << {integer}`\n  --> /tmp/tmpk81zbzw8.rs:23:16\n\
    \   |\n23 |         t ^= t << 1;\n   |              - ^^ - {integer}\n   |   \
    \           |\n   |              char\n\nerror[E0369]: no implementation for `char\
    \ >> {integer}`\n  --> /tmp/tmpk81zbzw8.rs:26:24\n   |\n26 |         new_t ^=\
    \ new_t >> 1;\n   |                  ----- ^^ - {integer}\n   |              \
    \    |\n   |                  char\n\nerror[E0369]: no implementation for `char\
    \ << {integer}`\n  --> /tmp/tmpk81zbzw8.rs:27:24\n   |\n27 |         new_t ^=\
    \ new_t << 1;\n   |                  ----- ^^ - {integer}\n   |              \
    \    |\n   |                  char\n\nerror[E0369]: no implementation for `char\
    \ >> {integer}`\n  --> /tmp/tmpk81zbzw8.rs:28:24\n   |\n28 |         new_t ^=\
    \ new_t >> 1;\n   |                  ----- ^^ - {integer}\n   |              \
    \    |\n   |                  char\n\nerror[E0599]: no method named `swap` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpk81zbzw8.rs:30:11\n\
    \   |\n30 |         s.swap(i + 1, i + 2);\n   |           ^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpk81zbzw8.rs:31:11\n   |\n31 |         s.swap(i,\
    \ i + 1);\n   |           ^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `swap` found for struct `String` in the current"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_str = \"\";\n    for c in s.chars() {\n        let i = alphabet.index(c\
    \ + 2);\n        new_str += alphabet[(i as usize) - 1];\n    }\n    new_str\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp25by8j8s.rs:13:17\n\
    \   |\n13 |         let i = alphabet.index(c + 2);\n   |                 ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `alphabet` in this\
    \ scope\n  --> /tmp/tmp25by8j8s.rs:14:20\n   |\n14 |         new_str += alphabet[(i\
    \ as usize) - 1];\n   |                    ^^^^^^^^ not found in this scope\n\n\
    error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp25by8j8s.rs:13:34\n\
    \   |\n13 |         let i = alphabet.index(c + 2);\n   |                     \
    \           - ^ - {integer}\n   |                                |\n   |     \
    \                           char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25by8j8s.rs:16:5\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          ------\
    \ expected `String` because of return type\n...\n16 |     new_str\n   |     ^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    s.rotate_left(2);\n    s.rotate_left(2);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpcdwir055.rs:12:7\n   |\n12 |     s.rotate_left(2);\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpcdwir055.rs:13:7\n\
    \   |\n13 |     s.rotate_left(2);\n   |       ^^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z', 'a'..'z'];\n    let mut cipher = String::new();\n\
    \    for c in s.chars().cloned() {\n        cipher.push((alphabet.len() * 2 -\
    \ alphabet.iter().filter(|&a| a != c).count() as u32).to_string());\n        alphabet.push(c);\
    \ // swap two letters\n    }\n    cipher\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpo0_7usz5.rs:13:24\n     |\n13   |     for c in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpo0_7usz5.rs:13:14\n\
    \   |\n13 |     for c in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpo0_7usz5.rs:13:14\n   |\n13 |     for c in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo0_7usz5.rs:14:43\n   |\n14 |\
    \         cipher.push((alphabet.len() * 2 - alphabet.iter().filter(|&a| a != c).count()\
    \ as u32).to_string());\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n\
    \  --> /tmp/tmpo0_7usz5.rs:14:41\n   |\n14 |         cipher.push((alphabet.len()\
    \ * 2 - alphabet.iter().filter(|&a| a != c).count() as u32).to_string());\n  \
    \ |                                         ^ no implementation for `usize - u32`\n\
    \   |\n   = help: the trait `Sub<u32>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = s.to_string();\n    for i in 0..s.len() {\n        let mut j = i;\n\
    \        loop {\n            j = j / 2;\n            if j == 0 {\n           \
    \     break;\n            }\n            if result[j].is_empty() {\n         \
    \       result[j] = &s[(i + j) % s.len()];\n                break;\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp47ytxw5w.rs:19:16\n\
    \   |\n19 |             if result[j].is_empty() {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp47ytxw5w.rs:20:17\n   |\n20 |                 result[j] = &s[(i\
    \ + j) % s.len()];\n   |                 ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp47ytxw5w.rs:20:30\n   |\n20 |                 result[j] = &s[(i\
    \ + j) % s.len()];\n   |                              ^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<s"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.add(&'a');\n    alphabet.add(&'b');\n\
    \    alphabet.add(&'c');\n    alphabet.add(&'d');\n    alphabet.add(&'e');\n \
    \   alphabet.add(&'f');\n    alphabet.add(&'g');\n    alphabet.add(&'h');\n  \
    \  alphabet.add(&'i');\n    alphabet.add(&'j');\n    alphabet.add(&'k');\n   \
    \ alphabet.add(&'l');\n    alphabet.add(&'m');\n    alphabet.add(&'n');\n    alphabet.add(&'o');\n\
    \    alphabet.add(&'p');\n    alphabet.add(&'q');\n    alphabet.add(&'r');\n \
    \   alphabet.add(&'s');\n    alphabet.add(&'t');\n    alphabet.add(&'u');\n  \
    \  alphabet.add(&'v');\n    alphabet.add(&'w');\n    alphabet.add(&'x');\n   \
    \ alphabet.add(&'y');\n    alphabet.add(&'z');\n    alphabet.add(&'A');\n    alphabet.add(&'B');\n\
    \    alphabet.add(&'C');\n    alphabet.add(&'D');\n    alphabet.add(&'E');\n \
    \   alphabet.add(&'F');\n    alphabet.add(&'G');\n    alphabet.add(&'H');\n  \
    \  alphabet.add(&'I');\n    alphabet.add(&'J');\n    alphabet.add(&'K');\n   \
    \ alphabet.add(&'L');\n    alphabet.add(&'M');\n    alphabet.add(&'N');\n    alphabet.add(&'O');\n\
    \    alphabet.add(&'P');\n    alphabet.add(&'Q');\n    alphabet.add(&'R');\n \
    \   alphabet.add(&'S');\n    alphabet.add(&'T');\n    alphabet.add(&'U');\n  \
    \  alphabet.add(&'V');\n    alphabet.add(&'W');\n    alphabet.add(&'X');\n   \
    \ alphabet.add(&'Y');\n    alphabet.add(&'Z');\n    alphabet.add(&'a');\n    alphabet.add(&'b');\n\
    \    alphabet.add(&'c');\n    alphabet.add(&'d');\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpxlzykw5i.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxlzykw5i.rs:10:26\n   |\n10 | fn encrypt(s:\
    \ String) -> String {\n   |    -------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt_alphabet(&ALPHABET,\
    \ s)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encrypt_alphabet` in this scope\n \
    \ --> /tmp/tmplg561kz0.rs:11:5\n   |\n11 |     encrypt_alphabet(&ALPHABET, s)\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ALPHABET` in this scope\n  --> /tmp/tmplg561kz0.rs:11:23\n   |\n11 |\
    \     encrypt_alphabet(&ALPHABET, s)\n   |                       ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ implement me\n    \"\"\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaptcmrba.rs:12:5\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n11 |     // TODO: implement me\n12 |     \"\
    \"\n   |     ^^- help: try using a conversion method: `.to_string()`\n   |   \
    \  |\n   |     expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.rotate_right(3).rotate_left(2)\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_right` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp3rkiducw.rs:11:7\n   |\n11 |     s.rotate_right(3).rotate_left(2)\n\
    \   |       ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trim_right`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().filter_map(|c|\
    \ c.to_ascii_lowercase().chars().nth(s.len() - 1).unwrap())\n        .map(|c|\
    \ c.to_ascii_lowercase() + c.to_ascii_lowercase().chars().nth(2).unwrap())\n \
    \       .collect::<String>()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpjd55itmu.rs:11:53\n   |\n11 |     s.chars().filter_map(|c|\
    \ c.to_ascii_lowercase().chars().nth(s.len() - 1).unwrap())\n   |            \
    \                                         ^^^^^ method not found in `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars().collect::<Vec<_>>();\n   \
    \ alphabet.swap_remove(0);\n    alphabet.swap_remove(alphabet.len());\n    let\
    \ alphabet = alphabet.into_iter().cloned();\n\n    s[1..].chars().for_each(|c|\
    \ {\n        alphabet = alphabet.chain(\n            alphabet.map(|ch| {\n   \
    \             match ch {\n                    a if a == c => a - 2,\n        \
    \            b if b == c => b - 2,\n                    c if c == c => c - 2,\n\
    \                    d if d == c => d - 2,\n                    e if e == c =>\
    \ e - 2,\n                    f if f == c => f - 2,\n                    g if\
    \ g == c => g - 2,\n                    h if h == c => h - 2,\n              \
    \      i if i == c => i - 2,\n                    j if j == c => j - 2,\n    \
    \                k if k == c => k - 2,\n                    l if l == c => l -\
    \ 2,\n                    m if m == c => m - 2,\n                    n if n ==\
    \ c => n - 2,\n                    o if o == c => o - 2,\n                   \
    \ p if p == c => p - 2,\n                    q if q == c => q - 2,\n         \
    \           r if r == c => r - 2,\n                    s if s == c => s - 2,\n\
    \                    t if t == c => t - 2,\n                    u if u == c =>\
    \ u - 2,\n                    v if v == c => v - 2,\n                    w if\
    \ w == c => w - 2,\n                    x if x == c => x - 2,\n              \
    \      y if y == c => y - 2,\n                    z if z == c => z - 2,\n    \
    \                A if A == c => A - 2,\n                    B if B == c => B -\
    \ 2,\n                    C if C == c => C - 2,\n                    D if D ==\
    \ c => D - 2,\n                    E if E == c => E - 2,\n                   \
    \ F if F == c => F - 2,\n                    G if G == c => G - 2,\n         \
    \           H if H == c => H - 2,\n                    I if I == c => I - 2,\n\
    \                    J if J == c => J - 2,\n                    K if K == c =>\
    \ K - 2,\n                    L if L == c => L - 2,\n                    M if\
    \ M == c => M - 2,\n                    N if N == c => N - 2,\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkltc55jn.rs:72:3\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n16 |     s[1..].chars().for_each(|c| {\n  \
    \ |                            -    - unclosed delimiter\n   |               \
    \             |\n   |                            unclosed delimiter\n17 |    \
    \     alphabet = alphabet.chain(\n   |                                  - unclosed\
    \ delimiter\n18 |             alphabet.map(|ch| {\n   |                      \
    \   -     - unclosed delimiter\n   |                         |\n   |         \
    \                unclosed delimiter\n19 |                 match ch {\n   |   \
    \                       - this delimiter might not be properly closed...\n...\n\
    60 | }\n   | - ...as it matches this but it has different indentation\n...\n72\
    \ | }\n   |   ^\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<char>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpkltc55jn.rs:14:41\n     |\n14   |\
    \     let alphabet = alphabet.into_iter().cloned();\n     |                  \
    \                       ^^^^^^ expected reference, found `char`\n     |\n    \
    \ = note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `chain` exists for\
    \ struct `Cloned<std::vec::IntoIter<char>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpkltc55jn.rs:17:29\n   |\n17 |           alphabet = alphabet.chain(\n\
    \   |                               ^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<char>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<char> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<char>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<char>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<char>>: Iterator`\n\nerror[E0599]:\
    \ the method `map` exists for struct `Cloned<std::vec::IntoIter<char>>`, but its\
    \ trait bounds were not satisfied"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().fold(\"\
    \", |mut r, c| {\n        let l = if c != 'a' { c + 2 } else { c - 2 };\n    \
    \    r += ALPHABET[l];\n        r\n    })\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpjdvxm8go.rs:13:14\n\
    \   |\n13 |         r += ALPHABET[l];\n   |              ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjdvxm8go.rs:11:20\n\
    \   |\n11 |     s.chars().fold(\"\", |mut r, c| {\n   |                    ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found `&str`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `char`\n  --> /tmp/tmpjdvxm8go.rs:12:33\n   |\n12\
    \ |         let l = if c != 'a' { c + 2 } else { c - 2 };\n   |              \
    \                 - ^ - {integer}\n   |                               |\n   |\
    \                               char\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `char`\n  --> /tmp/tmpjdvxm8go.rs:12:48\n   |\n12 |         let l = if\
    \ c != 'a' { c + 2 } else { c - 2 };\n   |                                   \
    \           - ^ - {integer}\n   |                                            \
    \  |\n   |                                              char\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut alphabet\
    \ = s.chars().collect::<Vec<_>>();\n\talphabet.sort_by(|a,b| a.cmp(b));\n\talphabet.rotate_left(2);\n\
    \talphabet.to_owned().into_iter().map(|x| x + 'a').collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmp53mv26t8.rs:14:44\n\
    \   |\n14 |     alphabet.to_owned().into_iter().map(|x| x + 'a').collect::<String>()\n\
    \   |                                             - ^ --- char\n   |         \
    \                                    |\n   |                                 \
    \            char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s[0] +\
    \ s[1] + s[2] + s[3] + s[4] + s[5] + s[6] + s[7] + s[8] + s[9]\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpjsyoozh4.rs:11:5\n   |\n11 |     s[0] + s[1] + s[2] + s[3] + s[4] +\
    \ s[5] + s[6] + s[7] + s[8] + s[9]\n   |     ^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpjsyoozh4.rs:11:12\n   |\n11 |     s[0] + s[1] + s[2] + s[3] + s[4]\
    \ + s[5] + s[6] + s[7] + s[8] + s[9]\n   |            ^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpjsyoozh4.rs:11:19\n   |\n11 |     s[0] + s[1] + s[2] + s[3] + s[4]\
    \ + s[5] + s[6] + s[7] + s[8] + s[9]\n   |                   ^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ r : usize = 0;\n    let mut c : usize = 0;\n    let mut alphabet : Vec<usize>\
    \ = vec![0xE0, 0x50, 0x80, 0x90, 0xD0, 0xF0, 0xC0];\n    let mut alphabet_count\
    \ : usize = 0;\n    let mut rlen : usize = 0;\n    for letter in s.chars() {\n\
    \        c += 2;\n        alphabet_count += 1;\n        let a = alphabet.len()\
    \ as usize - alphabet_count;\n        rlen += 1;\n        if rlen > alphabet.len()\
    \ {\n            rlen = 0;\n            r += 1;\n        }\n        if c > alphabet.len()\
    \ {\n            c = 1;\n        }\n        alphabet[alphabet.get_index(a)] =\
    \ letter;\n    }\n    let mut encrypted_string : String = String::new();\n   \
    \ for letter in alphabet {\n        encrypted_string.push_str(&letter);\n    }\n\
    \    return encrypted_string;\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `get_index` found for struct `Vec<usize>`\
    \ in the current scope\n  --> /tmp/tmpbrucb6ts.rs:28:27\n   |\n28 |         alphabet[alphabet.get_index(a)]\
    \ = letter;\n   |                           ^^^^^^^^^ method not found in `Vec<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbrucb6ts.rs:32:35\n   |\n32 |\
    \         encrypted_string.push_str(&letter);\n   |                          \
    \         ^^^^^^^ expected `str`, found `usize`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&usize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet: Vec<&str> = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    alphabet.extend(s.chars().cloned());\n\
    \    alphabet.sort();\n    let mut result: Vec<&str> = Vec::with_capacity(s.len());\n\
    \    let mut i = 0;\n    for &s in &alphabet {\n        result.append(&s[i % s.len()]);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpfsqr1o56.rs:12:31\n     |\n12   |     alphabet.extend(s.chars().cloned());\n\
    \     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n   --> /tmp/tmpfsqr1o56.rs:12:21\n\
    \    |\n12  |     alphabet.extend(s.chars().cloned());\n    |              ------\
    \ ^^^^^^^^^^^^^^^^^^ expected reference, found `char`\n    |              |\n\
    \    |              required by a bound introduced by this call\n    |\n    =\
    \ note: expected reference `&_`\n                    found type `char`\n    =\
    \ note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    note: required by a bound in `extend`\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n   --> /tmp/tmpfsqr1o56.rs:12:21\n  \
    \  |\n12  |     alphabet.extend(s.chars().cloned());\n    |              ------\
    \ ^^^^^^^^^^^^^^^^^^ expected reference, found `char`\n    |              |\n\
    \    |              required by a bound introduced by this call\n    |\n    =\
    \ note: expected reference `&_`\n                    found type `char`\n    =\
    \ note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\nnote: required by a bound in `extend`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpfsqr1o56.rs:17:24\n\
    \   |\n17 |         result.append(&s[i % s.len()]);\n   |                    \
    \    ^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfs"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = \"\";\n    for (i, ch) in s.chars().enumerate() {\n        let ch =\
    \ ch + 2;\n        result = result.chars().nth(i).unwrap().to_string().push_str(&ch.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpc0pqi25c.rs:13:21\n\
    \   |\n13 |         let ch = ch + 2;\n   |                  -- ^ - {integer}\n\
    \   |                  |\n   |                  char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc0pqi25c.rs:14:18\n   |\n11 |     let mut result = \"\"\
    ;\n   |                      -- expected due to this value\n...\n14 |        \
    \ result = result.chars().nth(i).unwrap().to_string().push_str(&ch.to_string());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc0pqi25c.rs:16:5\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          ------\
    \ expected `String` because of return type\n...\n16 |     result\n   |     ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    alphabet.sort_unstable();\n\
    \n    let mut alphabet = alphabet.clone();\n    alphabet.insert(0, alphabet[alphabet.len()-1]);\n\
    \    let mut shift = alphabet[0];\n\n    for c in s.chars() {\n        if let\
    \ Some(x) = alphabet[shift.index(c) + 1] {\n            shift += x;\n        }\
    \ else {\n            shift += c.to_digit(2).unwrap();\n        }\n    }\n   \
    \ \n    return &shift;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpniiugetj.rs:19:41\n   |\n19 |         if let Some(x) =\
    \ alphabet[shift.index(c) + 1] {\n   |                                       \
    \  ^^^^^ method not found in `char`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `char`\n  --> /tmp/tmpniiugetj.rs:20:13\n   |\n\
    20 |             shift += x;\n   |             -----^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpniiugetj.rs:22:13\n\
    \   |\n22 |             shift += c.to_digit(2).unwrap();\n   |             -----^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpniiugetj.rs:26:12\n   |\n10 | fn encrypt(s:\
    \ String) -> String {\n   |                          ------ expected `String`\
    \ because of return type\n...\n26 |     return &shift;\n   |            ^^^^^^\
    \ expected struct `String`, found `&char`\n   |\nhelp: try using a conversion\
    \ method\n   |\n26 |     return (&shift).to_string();\n   |            +     \
    \ +++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s; // Make a copy so we don't modify s\n    for (i, c) in s.chars().enumerate()\
    \ {\n        s.push((c + ((i + 2) % 26)).to_string());\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `usize` to `char`\n  --> /tmp/tmpz4_j_gp0.rs:13:19\n\
    \   |\n13 |         s.push((c + ((i + 2) % 26)).to_string());\n   |          \
    \       - ^ -------------- usize\n   |                 |\n   |               \
    \  char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = String::with_capacity(s.len());\n    for c in s.chars() {\n        s.append(char::encrypt((c\
    \ as char).to_digit(), 2)); \n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpc3tjr26h.rs:13:11\n   |\n13 |         s.append(char::encrypt((c\
    \ as char).to_digit(), 2)); \n   |           ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no function or associated item named `encrypt` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpc3tjr26h.rs:13:24\n   |\n13 |   \
    \      s.append(char::encrypt((c as char).to_digit(), 2)); \n   |            \
    \            ^^^^^^^ function or associated item not found in `char`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpc3tjr26h.rs:13:44\n\
    \    |\n13  |         s.append(char::encrypt((c as char).to_digit(), 2)); \n \
    \   |                                            ^^^^^^^^- supplied 0 arguments\n\
    \    |                                            |\n    |                   \
    \                         expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    fn rotate_left(x:\
    \ u32, n: u32) -> u32 {\n        n * 32 + x\n    }\n    \n    fn rotate_right(x:\
    \ u32, n: u32) -> u32 {\n        n - x\n    }\n    \n    let mut s = String::from(\"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\");\n    for c\
    \ in s.chars() {\n        s.swap(0, rotate_left(c.to_digit(10), 1));\n       \
    \ s.swap(1, rotate_right(c.to_digit(10), 1));\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp9mmskzvl.rs:21:11\n   |\n21 |         s.swap(0, rotate_left(c.to_digit(10),\
    \ 1));\n   |           ^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9mmskzvl.rs:21:31\n   |\n21 |         s.swap(0, rotate_left(c.to_digit(10),\
    \ 1));\n   |                               ^^^^^^^^^^^^^^ expected `u32`, found\
    \ enum `Option`\n   |\n   = note: expected type `u32`\n              found enum\
    \ `Option<u32>`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp9mmskzvl.rs:22:11\n   |\n22 |         s.swap(1,\
    \ rotate_right(c.to_digit(10), 1));\n   |           ^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9mmskzvl.rs:22:32\n   |\n22 |\
    \         s.swap(1, rotate_right(c.to_digit(10), 1));\n   |                  \
    \              ^^^^^^^^^^^^^^ expected `u32`, found enum `Option`\n   |\n   =\
    \ note: expected type `u32`\n              found enum `Option<u32>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet:\
    \ Vec<&str> = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"\
    i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut result = String::with_capacity(s.len()\
    \ * 2);\n    for letter in s.chars().filter(|c| !alphabet.contains(&c.to_string()))\
    \ {\n        result += letter;\n    }\n    for letter in alphabet.iter().rev()\
    \ {\n        result += alphabet.len() - letter - 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ldynbmf.rs:13:59\n   |\n\
    13 |     for letter in s.chars().filter(|c| !alphabet.contains(&c.to_string()))\
    \ {\n   |                                                           ^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ldynbmf.rs:14:19\n   |\n14 |         result += letter;\n\
    \   |                   ^^^^^^ expected `&str`, found `char`\n\nerror[E0277]:\
    \ cannot subtract `&&str` from `usize`\n  --> /tmp/tmp_ldynbmf.rs:17:34\n   |\n\
    17 |         result += alphabet.len() - letter - 1;\n   |                    \
    \              ^ no implementation for `usize - &&str`\n   |\n   = help: the trait\
    \ `Sub<&&str>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n    \
    \         <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n      \
    \       <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n          \
    \   <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a\
    \ isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().enumerate().map(|(a,b)|\
    \ (b + 2) * a.to_owned()).collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp_3pdma9c.rs:11:42\n\
    \   |\n11 |     s.chars().enumerate().map(|(a,b)| (b + 2) * a.to_owned()).collect::<String>()\n\
    \   |                                        - ^ - {integer}\n   |           \
    \                             |\n   |                                        char\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet : Vec<char> = vec!['z'; 26];\n    for c in s.chars() {\n        alphabet[alphabet.iter().position(|x|\
    \ x == c).unwrap() + 2] =\n            alphabet[alphabet.iter().position(|x| x\
    \ == c).unwrap() - 2];\n    }\n    let mut rotated_alphabet = alphabet.clone();\n\
    \    for (index, &c) in alphabet.iter().enumerate() {\n        rotated_alphabet[index]\
    \ = c;\n    }\n    let mut new_alphabet = alphabet.clone();\n    for (index, &c)\
    \ in alphabet.iter().enumerate() {\n        new_alphabet[index] = rotated_alphabet[index];\n\
    \    }\n    let mut result = vec!['z'; 26];\n    for (index, &c) in result.iter().enumerate()\
    \ {\n        result[index] = new_alphabet[index];\n    }\n    \n    let mut index\
    \ = 0;\n    for c in s.chars() {\n        result[index] = c;\n        index +=1;\n\
    \    }\n    \n    result.iter().cloned().collect::<Vec<_>>()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6z1l76sm.rs:13:49\n\
    \   |\n13 |         alphabet[alphabet.iter().position(|x| x == c).unwrap() + 2]\
    \ =\n   |                                                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6z1l76sm.rs:14:53\n\
    \   |\n14 |             alphabet[alphabet.iter().position(|x| x == c).unwrap()\
    \ - 2];\n   |                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6z1l76sm.rs:35:5\n   |\n10 | fn\
    \ encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n35 |     result.iter().cloned().collect::<Vec<_>>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_s = String::new();\n\n    for c in s.chars().cloned() {\n        new_s.push_char(rotate_letter(c.clone(),\
    \ 2));\n    }\n\n    new_s\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_letter` in this scope\n  -->\
    \ /tmp/tmpuouu76cl.rs:14:25\n   |\n14 |         new_s.push_char(rotate_letter(c.clone(),\
    \ 2));\n   |                         ^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpuouu76cl.rs:13:24\n     |\n13   |     for c in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpuouu76cl.rs:13:14\n\
    \   |\n13 |     for c in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpuouu76cl.rs:13:14\n   |\n13 |     for c in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `push_char` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpuouu76cl.rs:14:15\n   |\n14 |         new_s.push_char(rotate_letter(c.clone(),\
    \ 2));\n   |               ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `push_str`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0271, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_alphabet(s,\
    \ 2)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmp40_y9orf.rs:11:5\n   |\n11 |     rotate_alphabet(s, 2)\n   |     ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // Write\
    \ code here\n    let alphabet = vec!['e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut new_s\
    \ = \"\";\n    for ch in s.chars() {\n        let c = ch as char;\n        if\
    \ c < 'a' || c > 'z' {\n            println!(\"invalid char\");\n        }\n \
    \       let index = c - 'a' as usize;\n        if index > 26 {\n            println!(\"\
    invalid char\");\n        }\n        new_s += alphabet[(index / 2)];\n       \
    \ new_s += alphabet[(index % 2)];\n    }\n    return new_s;\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmpm9g0n2yg.rs:19:23\n\
    \   |\n19 |         let index = c - 'a' as usize;\n   |                     -\
    \ ^ ------------ usize\n   |                     |\n   |                     char\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmpm9g0n2yg.rs:23:9\n   |\n23 |         new_s += alphabet[(index /\
    \ 2)];\n   |         -----^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n   |    \
    \     cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmpm9g0n2yg.rs:24:9\n   |\n\
    24 |         new_s += alphabet[(index % 2)];\n   |         -----^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm9g0n2yg.rs:26:12\n   |\n10 | fn encrypt(s:\
    \ String) -> String {\n   |                          ------ expected `String`\
    \ because of return type\n...\n26 |     return new_s;\n   |            ^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |            |\n   |\
    \            expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_left(s.chars().collect::<Vec<_>>(),\
    \ 2)\n        .chain(s.chars().skip(2).collect::<Vec<_>>())\n        .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_left` in this scope\n  --> /tmp/tmprqqhcduy.rs:11:5\n\
    \   |\n11 |     rotate_left(s.chars().collect::<Vec<_>>(), 2)\n   |     ^^^^^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::intrinsics::rotate_left;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n\talphabet[alphabet.len() - 2..alphabet.len()\
    \ - 1] = \"zyxwvutsrqponmlkjihgfedcba\".to_string();\n\talphabet[alphabet.len()\
    \ - 3..alphabet.len() - 1] = \"nopqehglkjiycbnsdvwxyza\".to_string();\n\talphabet[alphabet.len()\
    \ - 4..alphabet.len() - 1] = \"hxjknqrstuvwxyabmnwyx\".to_string();\n\talphabet[alphabet.len()\
    \ - 5..alphabet.len() - 1] = \"vwzysrqponmlkjihgfedcbam\".to_string();\n\talphabet[alphabet.len()\
    \ - 6..alphabet.len() - 1] = \"xwvutsrqponmlkjiyhgiyxedcba\".to_string();\n\t\
    alphabet[alphabet.len() - 7..alphabet.len() - 1] = \"rwzysqpomnwjhihgfedcbae\"\
    .to_string();\n\talphabet[alphabet.len() - 8..alphabet.len() - 1] = \"pqysqpnwjhiyhgfedcbaeil\"\
    .to_string();\n\talphabet[alphabet.len() - 9..alphabet.len() - 1] = \"pqysqpomnwjhihgfedcbaeilr\"\
    .to_string();\n\talphabet[alphabet.len() - 10..alphabet.len() - 1] = \"pqysqpomnwjhihgfedcbaeilrty\"\
    .to_string();\n\talphabet[alphabet.len() - 11..alphabet.len() - 1] = \"pqysqpomnwjhihgfedcbaeilrtyu\"\
    .to_string();\n\talphabet[alphabet.len() - 12..alphabet.len() - 1] = \"pqysqpomnwjhihgfedcbaeilrtyuv\"\
    .to_string();\n\talphabet[alphabet.len() - 13..alphabet.len() - 1] = \"pqysqpomnwjhihgfedcbaeilrtyuvw\"\
    .to_string();\n\talphabet[alphabet.len() - 14..alphabet.len() - 1] = \"pqysqpomnwjhihgfedcbaeilrtyuvwx\"\
    .to_string();\n\talphabet[alphabet.len() - 15..alphabet.len() - 1] = \"pqysqpomnwjhihgfedcbaeilrtyuvwxy\"\
    .to_string();\n\talphabet[alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `]`\n  --> /tmp/tmpdx9njz6e.rs:27:1\n   |\n27\
    \ | }\n   | ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpdx9njz6e.rs:26:10\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n26 |     alphabet[alphabet.\n\
    \   |             ^ unclosed delimiter\n27 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdx9njz6e.rs:12:53\n   |\n12 |\
    \     alphabet[alphabet.len() - 2..alphabet.len() - 1] = \"zyxwvutsrqponmlkjihgfedcba\"\
    .to_string();\n   |     ------------------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `String`\n   |     |\n   |     expected due to\
    \ the type of this binding\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpdx9njz6e.rs:12:2\n   |\n\
    12 |     alphabet[alphabet.len() - 2..alphabet.len() - 1] = \"zyxwvutsrqponmlkjihgfedcba\"\
    .to_string();\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: the left-hand-side of an assignment must have\
    \ a statically known size\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdx9njz6e.rs:13:53\n\
    \   |\n13 |     alphabet[alphabet.len() - 3..alphabet.len() - 1] = \"nopqehglkjiycbnsdvwxyza\"\
    .to_string();\n   |     ------------------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `String`\n   |     |\n   |     expected due to\
    \ the type of this binding\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpdx9njz6e.rs:13:2\n   |\n\
    13 |     alphabet[alphabet.len() - 3..alphabet.len() - 1] = \"nopqehglkjiycbnsdvwxyza\"\
    .to_string();\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: the left-hand-side of an assignment must have\
    \ a statically k"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new = [0; s.len() * 2];\n    for &c in s.chars() {\n        new.get_mut(c.to_digit(s.len())).unwrap()\
    \ = c.to_digit(s.len() / 2).unwrap();\n    }\n    new.iter().map(|&b| if b ==\
    \ 0 { b'z'} else { b'a' }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpbzljndcx.rs:11:23\n   |\n10 | fn encrypt(s: String) -> String {\n  \
    \ |            - this would need to be a `const`\n11 |     let mut new = [0; s.len()\
    \ * 2];\n   |                       ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbzljndcx.rs:12:9\n   |\n12 |     for &c in s.chars() {\n   |       \
    \  ^^    --------- this expression has type `Option<char>`\n   |         |\n \
    \  |         expected `char`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpbzljndcx.rs:13:51\n   |\n13 |         new.get_mut(c.to_digit(s.len())).unwrap()\
    \ = c.to_digit(s.len() / 2).unwrap();\n   |         -----------------------------------------\
    \ ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0277]:\
    \ a value of type `String` cannot be built from an iterator over elements of type\
    \ `u8`\n    --> /tmp/tmpbzljndcx.rs:15:58\n     |\n15   |     new.iter().map(|&b|\
    \ if b == 0 { b'z'} else { b'a' }).collect()\n     |                         \
    \                                 ^^^^^^^ value of type `String` cannot be built\
    \ from `std::iter::Iterator<Item=u8>`\n     |\n     = help: the trait `FromIterator<u8>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0070, E0277, E0308, E0435.\nFor more\
    \ information about an error, try `rustc --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encryptedString = \"\";\n    for i in s.chars() {\n        if i % 2 == 0 {\n\
    \            encryptedString += i.rotate_left(2);\n        } else {\n        \
    \    encryptedString += i.rotate_left(1);\n        }\n    }\n    return encryptedString;\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmpby6paski.rs:13:14\n\
    \   |\n13 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            char\n\nerror[E0599]: no method named `rotate_left`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpby6paski.rs:14:34\n\
    \   |\n14 |             encryptedString += i.rotate_left(2);\n   |           \
    \                       ^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `rotate_left` found for type `char` in the current scope\n \
    \ --> /tmp/tmpby6paski.rs:16:34\n   |\n16 |             encryptedString += i.rotate_left(1);\n\
    \   |                                  ^^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpby6paski.rs:19:12\n   |\n10 |\
    \ fn encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n19 |     return encryptedString;\n   |\
    \            ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |            |\n   |            expected struct `String`, found `&str`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = \"\";\n    for (i, ch) in s.chars().enumerate() {\n        let mut\
    \ rotated = ch - 'a' + 2; // shift down by 2\n        let rotated %= 2 + 'a'.len();\
    \ // wrap around alphabet if it goes past 'z'\n        result += &mut rotated;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: can't reassign to an uninitialized variable\n  --> /tmp/tmpyzscel41.rs:14:21\n\
    \   |\n14 |         let rotated %= 2 + 'a'.len(); // wrap around alphabet if it\
    \ goes past 'z'\n   |                     ^^ help: initialize the variable\n \
    \  |\n   = help: if you meant to overwrite, remove the `let` binding\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpyzscel41.rs:13:30\n   |\n\
    13 |         let mut rotated = ch - 'a' + 2; // shift down by 2\n   |        \
    \                   -- ^ --- char\n   |                           |\n   |    \
    \                       char\n\nerror[E0599]: no method named `len` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpyzscel41.rs:14:32\n   |\n14\
    \ |         let rotated %= 2 + 'a'.len(); // wrap around alphabet if it goes past\
    \ 'z'\n   |                                ^^^ method not found in `char`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmpyzscel41.rs:15:9\n   |\n15 |         result += &mut rotated;\n\
    \   |         ------^^^^^^^^^^^^^^^^\n   |         |\n   |         cannot use\
    \ `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyzscel41.rs:17:5\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          ------\
    \ expected `String` because of return type\n...\n17 |     result\n   |     ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0369, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ cipher = \"\";\n    s.chars().enumerate().for_each(|(i, c)| {\n        if c\
    \ > 'z' {\n            cipher += c + 1;\n        } else {\n            cipher\
    \ += c + 2;\n        }\n    });\n    cipher\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp2l0f8il8.rs:14:25\n\
    \   |\n14 |             cipher += c + 1;\n   |                       - ^ - {integer}\n\
    \   |                       |\n   |                       char\n\nerror[E0369]:\
    \ cannot add `{integer}` to `char`\n  --> /tmp/tmp2l0f8il8.rs:16:25\n   |\n16\
    \ |             cipher += c + 2;\n   |                       - ^ - {integer}\n\
    \   |                       |\n   |                       char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2l0f8il8.rs:19:5\n   |\n10 | fn encrypt(s: String)\
    \ -> String {\n   |                          ------ expected `String` because\
    \ of return type\n...\n19 |     cipher\n   |     ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ rotate = s.chars().map(|c| c as u32 + 2).collect::<Vec<u32>>();\n    rotate.sort_unstable();\n\
    \    rotate(0).map(|c| c as char).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `Vec<u32>`\n  --> /tmp/tmp3r3vke7s.rs:13:5\n\
    \   |\n11 |     let mut rotate = s.chars().map(|c| c as u32 + 2).collect::<Vec<u32>>();\n\
    \   |         ---------- `rotate` has type `Vec<u32>`\n12 |     rotate.sort_unstable();\n\
    13 |     rotate(0).map(|c| c as char).collect()\n   |     ^^^^^^---\n   |    \
    \ |\n   |     call expression requires function\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result: String = \"\".to_string();\n    let mut current: char = \"a\".to_string();\n\
    \    for i in s.chars() {\n        result += current + current.chars().skip_while(|&c|\
    \ c != 'z').collect::<String>();\n        current += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0dcv8ssj.rs:12:29\n   |\n\
    12 |     let mut current: char = \"a\".to_string();\n   |                    \
    \  ----   ^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |       \
    \               |\n   |                      expected due to this\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmp0dcv8ssj.rs:14:37\n\
    \   |\n14 |         result += current + current.chars().skip_while(|&c| c != 'z').collect::<String>();\n\
    \   |                                     ^^^^^ method not found in `char`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `char`\n\
    \  --> /tmp/tmp0dcv8ssj.rs:15:9\n   |\n15 |         current += 1;\n   |      \
    \   -------^^^^^\n   |         |\n   |         cannot use `+=` on type `char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet: Vec<&str> = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut rotated_alphabet\
    \ = alphabet.clone();\n    let mut i = 0;\n    rotated_alphabet[0] = alphabet[i];\n\
    \    rotated_alphabet[1] = alphabet[(i + 1) % alphabet.len()];\n    for letter\
    \ in alphabet {\n        i += 2;\n        rotated_alphabet[letter] = alphabet[(i\
    \ + alphabet.len()) % alphabet.len()];\n        rotated_alphabet[letter + 1] =\
    \ alphabet[(i + 2 * alphabet.len()) % alphabet.len()];\n    }\n    rotated_alphabet.push(\"\
    z\");\n    rotated_alphabet.pop();\n    \n    let mut result: String = s.to_string();\n\
    \    let mut i = 0;\n    for letter in s.chars() {\n        result += rotated_alphabet[alphabet.index(&letter)];\n\
    \        i += 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[&str]` cannot be indexed by `&str`\n  --> /tmp/tmps6souel8.rs:18:9\n\
    \   |\n18 |         rotated_alphabet[letter] = alphabet[(i + alphabet.len()) %\
    \ alphabet.len()];\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `Index<&str>` for `Vec<&str>`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `&str`\n  --> /tmp/tmps6souel8.rs:19:33\n   |\n19 |         rotated_alphabet[letter\
    \ + 1] = alphabet[(i + 2 * alphabet.len()) % alphabet.len()];\n   |          \
    \                ------ ^ - {integer}\n   |                          |\n   | \
    \                         &str\n\nerror[E0599]: no method named `index` found\
    \ for struct `Vec<&str>` in the current scope\n  --> /tmp/tmps6souel8.rs:27:45\n\
    \   |\n27 |         result += rotated_alphabet[alphabet.index(&letter)];\n   |\
    \                                             ^^^^^ method not found in `Vec<&str>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_s = String::new();\n    let mut num_letters = s.size();\n    let mut letters\
    \ = String::new();\n    letters.push('h');\n    letters.push('t');\n    letters.push('i');\n\
    \    letters.push('j');\n    letters.push('k');\n    letters.push('l');\n    letters.push('m');\n\
    \    letters.push('n');\n    letters.push('o');\n    letters.push('p');\n    letters.push('q');\n\
    \    letters.push('r');\n    letters.push('s');\n    letters.push('t');\n    letters.push('u');\n\
    \    letters.push('v');\n    letters.push('w');\n    letters.push('x');\n    letters.push('y');\n\
    \    letters.push('z');\n    letters.push('a');\n    letters.push('b');\n    letters.push('c');\n\
    \    letters.push('d');\n    letters.push('e');\n    letters.push('f');\n    letters.push('g');\n\
    \    letters.push('h');\n    letters.push('i');\n    letters.push('j');\n    letters.push('k');\n\
    \    letters.push('l');\n    letters.push('m');\n    letters.push('n');\n    letters.push('o');\n\
    \    letters.push('p');\n    letters.push('q');\n    letters.push('r');\n    letters.push('s');\n\
    \    letters.push('t');\n    letters.push('u');\n    letters.push('v');\n    letters.push('w');\n\
    \    letters.push('x');\n    letters.push('y');\n    letters.push('z');\n    letters.push('a');\n\
    \    letters.push('b');\n    letters.push('c');\n    letters.push('d');\n    letters.push('e');\n\
    \    letters.push('f');\n    letters.push('g');\n    letters.push('h');\n    letters.push('i');\n\
    \    letters.push('j');\n    letters.push('k');\n    letters.push('l');\n    letters.push('m');\n\
    \    letters.push('n');\n    letters.push('o');\n    letters.push('p');\n    letters.push('q');\n\
    \    letters.push('r');\n    letters.push('s');\n    letters.push('t');\n    letters.push('u');\n\
    \    letters.push('v');\n    letters.push('w');\n    letters.push('x');\n    letters.push('\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpm82mx5l8.rs:84:18\n\
    \   |\n84 |     letters.push('\n   |                  ^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_s = String::new();\n    for c in s.chars() {\n        let mut new_c = c.to_ascii_uppercase();\n\
    \        let mut idx = new_c.len() - 1;\n        let mut mult = 0;\n        let\
    \ mut shift = 0;\n        while idx >= 0 {\n            let c = new_c[idx];\n\
    \            let c_lower = c.to_ascii_lowercase();\n            let mut new_idx\
    \ = new_c.len() - 1;\n            while new_idx >= 0 && c_lower == new_c[new_idx]\
    \ {\n                new_idx -= 1;\n            }\n            let mut c_shift\
    \ = c_lower - c;\n            if c_shift > 0 {\n                shift += 2;\n\
    \            }\n            mult += 1;\n            new_idx += 1;\n          \
    \  new_c[new_idx] = c.to_ascii_lowercase();\n            new_idx -= 1;\n     \
    \       if c_shift < 0 {\n                shift -= 2;\n            }\n       \
    \     idx -= 1;\n        }\n        new_s += char::from_u32(mult << 24 + shift\
    \ + 64) as char;\n    }\n    return new_s\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpmysuq3u7.rs:14:29\n   |\n14 |         let mut idx = new_c.len()\
    \ - 1;\n   |                             ^^^ method not found in `char`\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpmysuq3u7.rs:18:21\n\
    \   |\n18 |             let c = new_c[idx];\n   |                     ^^^^^^^^^^\n\
    \nerror[E0599]: no method named `len` found for type `char` in the current scope\n\
    \  --> /tmp/tmpmysuq3u7.rs:20:37\n   |\n20 |             let mut new_idx = new_c.len()\
    \ - 1;\n   |                                     ^^^ method not found in `char`\n\
    \nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpmysuq3u7.rs:21:46\n\
    \   |\n21 |             while new_idx >= 0 && c_lower == new_c[new_idx] {\n  \
    \ |                                              ^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpmysuq3u7.rs:30:13\n\
    \   |\n30 |             new_c[new_idx] = c.to_ascii_lowercase();\n   |       \
    \      ^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmysuq3u7.rs:37:18\n\
    \   |\n37 |         new_s += char::from_u32(mult << 24 + shift + 64) as char;\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0605]: non-primitive cast: `Option<char>` as\
    \ `char`\n  --> /tmp/tmpmysuq3u7.rs:37:18\n   |\n37 |         new_s += char::from_u32(mult\
    \ << 24 + shift + 64) as char;\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599, E0605, E0608.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    fn rotate_letter_left(letter:\
    \ char) -> char {\n        letter.chars().next().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap()\n\
    \    }\n\n    fn rotate_letter_right(letter: char) -> char {\n        letter.chars().next().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap()\n\
    \    }\n\n    let mut result = String::new();\n    for c in s.chars() {\n    \
    \    let mut letter = c.to_ascii_lowercase().unwrap();\n        letter = rotate_letter_left(letter);\n\
    \        result.push(letter);\n        letter = rotate_letter_right(letter);\n\
    \        result.push(letter);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmptd267qyd.rs:21:49\n   |\n21 |         let mut letter =\
    \ c.to_ascii_lowercase().unwrap();\n   |                                     \
    \            ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmptd267qyd.rs:12:16\n\
    \   |\n12 | ...   letter.chars().next().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_u...\n\
    \   |              ^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmptd267qyd.rs:16:16\n\
    \   |\n16 | ...   letter.chars().next().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_u...\n\
    \   |              ^^^^^ method not found in `char`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().enumerate().map(|(i,\
    \ c)| {\n        (c * 2).max(1) as char\n    }).collect::<Vec<_>>().join(\"\"\
    )\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot multiply `char` by `{integer}`\n  --> /tmp/tmpsm1v63sj.rs:12:12\n\
    \   |\n12 |         (c * 2).max(1) as char\n   |          - ^ - {integer}\n  \
    \ |          |\n   |          char\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    for &c in s.chars() {\n        s.rotate_left(2);\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp81a11gvc.rs:12:9\n   |\n\
    12 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `rotate_left` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp81a11gvc.rs:13:11\n   |\n13 |         s.rotate_left(2);\n   | \
    \          ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = ROTATE;\n    for c in s.chars() {\n        alphabet = alphabet.rotate_left(2);\n\
    \        alphabet.push(c);\n    }\n    alphabet\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROTATE` in this scope\n  --> /tmp/tmp78lfr5o6.rs:11:24\n\
    \   |\n11 |     let mut alphabet = ROTATE;\n   |                        ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    for c in s.chars() {\n        alphabet.push(c);\n\
    \    }\n    alphabet.rotate_left(2);\n    let mut shift = Alphabet::new();\n \
    \   for c in alphabet.chars() {\n        shift.push(c);\n    }\n    shift.rotate_left(2);\n\
    \    shift.rotate_right(2);\n    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        result.push(c);\n        result.push(shift.pop());\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmptuht4td3.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmptuht4td3.rs:16:21\n\
    \   |\n16 |     let mut shift = Alphabet::new();\n   |                     ^^^^^^^^\
    \ use of undeclared type `Alphabet`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ rotated_letter_alphabet(c)).collect()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotated_letter_alphabet` in this scope\n\
    \  --> /tmp/tmp26m27uax.rs:11:23\n   |\n11 |     s.chars().map(|c| rotated_letter_alphabet(c)).collect()\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = 'a' .. 'z';\n\n    for char in s.chars().cloned() {\n        let\
    \ shift_amount = (alphabet.len() - alphabet.chars().last().unwrap().unwrap() -\
    \ char.unwrap()) % alphabet.len();\n        alphabet = alphabet.chars().filter(|c|\
    \ *c != char).map(|c| *c+shift_amount).collect();\n    }\n\n    alphabet.chars().map(|c|\
    \ char::from_digits(*c, 10)).collect()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp6evfzxs9.rs:13:27\n     |\n13   |     for char in s.chars().cloned()\
    \ {\n     |                           ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmp6evfzxs9.rs:13:17\n\
    \   |\n13 |     for char in s.chars().cloned() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp6evfzxs9.rs:13:17\n   |\n13 |     for char in s.chars().cloned()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `len` found for struct `std::ops::Range` in the\
    \ current scope\n  --> /tmp/tmp6evfzxs9.rs:14:38\n   |\n14 |         let shift_amount\
    \ = (alphabet.len() - alphabet.chars().last().unwrap().unwrap() - char.unwrap())\
    \ % alphabet.len();\n   |                                      ^^^ method not\
    \ found in `std::ops::Range<char>`\n\nerror[E0599]: no method named `chars` found\
    \ for struct `std::ops::Range` in the current scope\n  --> /tmp/tmp6evfzxs9.rs:14:55\n\
    \   |\n14 |         let shift_amount = (alphabet.len() - alphabet.chars().last().unwrap().unwrap()\
    \ - char.unwrap()) % alphabet.len();\n   |                                   \
    \                    ^^^^^ method not found in `std::ops::Range<char>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `std::ops::Range` in the c"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\".chars().collect::<String>().to_vec();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut result = \"\";\n \
    \   for (i, ch) in s.chars().enumerate() {\n        result += rotate_character(ch,\
    \ &alphabet[(alphabet.len() - 1) - alphabet.iter().rposition(|c| c == ch)].unwrap(),\
    \ i);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_character` in this scope\n \
    \ --> /tmp/tmpukp_3eyw.rs:15:19\n   |\n15 |         result += rotate_character(ch,\
    \ &alphabet[(alphabet.len() - 1) - alphabet.iter().rposition(|c| c == ch)].unwrap(),\
    \ i);\n   |                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `to_vec` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpukp_3eyw.rs:11:81\n   |\n11 |     let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect::<String>().to_vec();\n   |                                 \
    \                                                ^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpukp_3eyw.rs:17:5\n   |\n10 | fn\
    \ encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n17 |     result\n   |     ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ r = String::new();\n    for c in s.chars() {\n        let mut new_c = c;\n \
    \       let mut shifted_c = c.rotate_left(2);\n        new_c.push(shifted_c);\n\
    \        r.push_str(new_c);\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_left` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpislotfku.rs:14:31\n   |\n14 |         let mut shifted_c\
    \ = c.rotate_left(2);\n   |                               ^^^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `push` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpislotfku.rs:15:15\n   |\n15 |         new_c.push(shifted_c);\n\
    \   |               ^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpislotfku.rs:16:20\n   |\n16 |         r.push_str(new_c);\n\
    \   |                    ^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_alphabet(ROTATE_ALPHABET);\n\
    \    encrypt_string::<ROTATE_ALPHABET>(s)\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmph6az0umv.rs:11:5\n   |\n11 |     rotate_alphabet(ROTATE_ALPHABET);\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ROTATE_ALPHABET` in this scope\n  --> /tmp/tmph6az0umv.rs:11:21\n   |\n\
    11 |     rotate_alphabet(ROTATE_ALPHABET);\n   |                     ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `encrypt_string`\
    \ in this scope\n  --> /tmp/tmph6az0umv.rs:12:5\n   |\n12 |     encrypt_string::<ROTATE_ALPHABET>(s)\n\
    \   |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find\
    \ type `ROTATE_ALPHABET` in this scope\n  --> /tmp/tmph6az0umv.rs:12:22\n   |\n\
    10 | fn encrypt(s: String) -> String {\n   |           - help: you might be missing\
    \ a type parameter: `<ROTATE_ALPHABET>`\n11 |     rotate_alphabet(ROTATE_ALPHABET);\n\
    12 |     encrypt_string::<ROTATE_ALPHABET>(s)\n   |                      ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0412, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet:\
    \ Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n    let mut ciphertext\
    \ = s.chars().map(|c| alphabet.iter().find(|&a| c == a).unwrap().unwrap());\n\
    \    ciphertext.iter_mut().for_each(|c| {\n        let x = ciphertext.last().unwrap()\
    \ + 2;\n        c.rotate_left(x);\n    });\n    ciphertext.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8wm4qpoa.rs:12:75\n   |\n\
    12 |     let mut ciphertext = s.chars().map(|c| alphabet.iter().find(|&a| c ==\
    \ a).unwrap().unwrap());\n   |                                               \
    \                            ^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n12 |     let mut ciphertext = s.chars().map(|c|\
    \ alphabet.iter().find(|&a| c == *a).unwrap().unwrap());\n   |               \
    \                                                            +\n\nerror[E0599]:\
    \ no method named `unwrap` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmp8wm4qpoa.rs:12:87\n   |\n12 |     let mut ciphertext = s.chars().map(|c|\
    \ alphabet.iter().find(|&a| c == a).unwrap().unwrap());\n   |                \
    \                                                                       ^^^^^^\
    \ method not found in `&char`\n\nerror[E0599]: no method named `iter_mut` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmp8wm4qpoa.rs:13:16\n   |\n\
    13 |     ciphertext.iter_mut().for_each(|c| {\n   |                ^^^^^^^^ method\
    \ not found in `Map<Chars<'_>, _>`\n\nerror[E0599]: no method named `iter` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmp8wm4qpoa.rs:17:16\n   |\n\
    17 |     ciphertext.iter().collect()\n   |                ^^^^ private field,\
    \ not a method\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // Use\
    \ this string as the base to rotate the alphabet by\n    let mut alphabet = s;\n\
    \    let mut char_count = alphabet.len();\n    while char_count > 0 {\n      \
    \  // Rotate the alphabet by 2\n        alphabet += alphabet[char_count - 1];\n\
    \        alphabet += alphabet[char_count - 1];\n        // Move the index down\
    \ by two\n        char_count -= 2;\n    }\n    alphabet\n}\n\nfn main() {\n  \
    \  let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcwbcmq59.rs:16:21\n\
    \   |\n16 |         alphabet += alphabet[char_count - 1];\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcwbcmq59.rs:17:21\n\
    \   |\n17 |         alphabet += alphabet[char_count - 1];\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ c = s.to_string();\n    let mut i = 0;\n    \n    while i < c.len() {\n    \
    \    c[i] = c[i + 1; 2..c.len()];\n        i = i + 1;\n    }\n\n    c.to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `?`, `]`, or an operator, found `;`\n  -->\
    \ /tmp/tmp4pgx2z5q.rs:15:23\n   |\n15 |         c[i] = c[i + 1; 2..c.len()];\n\
    \   |                       ^ expected one of `.`, `?`, `]`, or an operator\n\n\
    error: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    \n    let\
    \ mut ciphertext = \"\";\n    \n    for (index, letter) in enumerate(s) {\n  \
    \      \n        if letter == 'a' {\n            ciphertext += &'z' \n       \
    \ } else {\n            ciphertext += &'a'\n        }\n    }\n    \n    ciphertext\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `enumerate` in this scope\n  --> /tmp/tmpl_dakofv.rs:14:28\n\
    \   |\n14 |     for (index, letter) in enumerate(s) {\n   |                  \
    \          ^^^^^^^^^ not found in this scope\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpl_dakofv.rs:17:13\n\
    \   |\n17 |             ciphertext += &'z' \n   |             ----------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpl_dakofv.rs:19:13\n\
    \   |\n19 |             ciphertext += &'a'\n   |             ----------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl_dakofv.rs:23:5\n   |\n10 | fn encrypt(s: String)\
    \ -> String {\n   |                          ------ expected `String` because\
    \ of return type\n...\n23 |     ciphertext\n   |     ^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = String::with_capacity(s.len());\n    for i in 0..s.len() {\n        if s.len()\
    \ > 0 {\n            let mut cur = i as u32 + 2;\n            \n            while\
    \ cur > s.len() {\n                cur -= s.len();\n            }\n          \
    \  \n            s.push( s[cur - 2] + s[cur - 1] );\n        }\n        \n   \
    \     s.push( s[i]);\n    }\n    \n    s\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppacnx7zy.rs:16:25\n   |\n\
    16 |             while cur > s.len() {\n   |                         ^^^^^^^ expected\
    \ `u32`, found `usize`\n   |\nhelp: you can convert a `usize` to a `u32` and panic\
    \ if the converted value doesn't fit\n   |\n16 |             while cur > s.len().try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppacnx7zy.rs:17:24\n   |\n17 |              \
    \   cur -= s.len();\n   |                        ^^^^^^^ expected `u32`, found\
    \ `usize`\n\nerror[E0277]: cannot subtract-assign `usize` from `u32`\n  --> /tmp/tmppacnx7zy.rs:17:21\n\
    \   |\n17 |                 cur -= s.len();\n   |                     ^^ no implementation\
    \ for `u32 -= usize`\n   |\n   = help: the trait `SubAssign<usize>` is not implemented\
    \ for `u32`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror[E0277]: the type `String` cannot be indexed by `u32`\n  -->\
    \ /tmp/tmppacnx7zy.rs:20:21\n   |\n20 |             s.push( s[cur - 2] + s[cur\
    \ - 1] );\n   |                     ^^^^^^^^^^ `String` cannot be indexed by `u32`\n\
    \   |\n   = help: the trait `Index<u32>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `u32`\n  -->\
    \ /tmp/tmppacnx7zy.rs:20:34\n   |\n20 |             s.push( s[cur - 2] + s[cur\
    \ - 1] "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    fn rotate_letter(l:\
    \ char, rotate_amount: u8, alphabet: &str) -> u8 {\n        let rot_val = alphabet.chars().nth(rotate_amount).unwrap();\n\
    \        let mut char_val = l.to_digit(10);\n        char_val = char_val + rot_val\
    \ - 'a' as u8;\n        char_val as u8\n    }\n\n    let mut cipher = s.to_string();\n\
    \    cipher.chars().for_each(|c| {\n        let rotate_val = rotate_letter(c.to_string(),\
    \ 2, &\"abcdefghijklmnopqrstuvwxyz\".to_string());\n        cipher = format!(\"\
    {}{}\", c, rotate_val);\n    });\n    cipher\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnvqbkws9.rs:20:40\n   |\n\
    20 |         let rotate_val = rotate_letter(c.to_string(), 2, &\"abcdefghijklmnopqrstuvwxyz\"\
    .to_string());\n   |                                        ^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnvqbkws9.rs:12:44\n\
    \   |\n12 |         let rot_val = alphabet.chars().nth(rotate_amount).unwrap();\n\
    \   |                                            ^^^^^^^^^^^^^ expected `usize`,\
    \ found `u8`\n   |\nhelp: you can convert a `u8` to a `usize`\n   |\n12 |    \
    \     let rot_val = alphabet.chars().nth(rotate_amount.into()).unwrap();\n   |\
    \                                                         +++++++\n\nerror[E0369]:\
    \ cannot add `char` to `Option<u32>`\n  --> /tmp/tmpnvqbkws9.rs:14:29\n   |\n\
    14 |         char_val = char_val + rot_val - 'a' as u8;\n   |                \
    \    -------- ^ ------- char\n   |                    |\n   |                \
    \    Option<u32>\n\nerror[E0605]: non-primitive cast: `Option<u32>` as `u8`\n\
    \  --> /tmp/tmpnvqbkws9.rs:15:9\n   |\n15 |         char_val as u8\n   |     \
    \    ^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive\
    \ types or to coerce to a specific trait object\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0605.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ rotate(c, 2)).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpx8mtw5yg.rs:11:23\n\
    \   |\n11 |     s.chars().map(|c| rotate(c, 2)).collect()\n   |              \
    \         ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ rotated = s.to_string();\n    for ch in &rotated {\n        let index = alphabet.chars().position(|x|\
    \ *x == ch).unwrap();\n        *index = index + 2;\n    }\n    rotated\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpqhacwxcp.rs:13:21\n\
    \   |\n13 |         let index = alphabet.chars().position(|x| *x == ch).unwrap();\n\
    \   |                     ^^^^^^^^ not found in this scope\n\nerror[E0277]: `&String`\
    \ is not an iterator\n  --> /tmp/tmpqhacwxcp.rs:12:15\n   |\n12 |     for ch in\
    \ &rotated {\n   |               ^^^^^^^^ `&String` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_alphabet(ROTATE_ALPHABET(),\
    \ s)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpi2a_gxrm.rs:11:5\n   |\n11 |     rotate_alphabet(ROTATE_ALPHABET(),\
    \ s)\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function, tuple struct or tuple variant `ROTATE_ALPHABET` in this scope\n\
    \  --> /tmp/tmpi2a_gxrm.rs:11:21\n   |\n11 |     rotate_alphabet(ROTATE_ALPHABET(),\
    \ s)\n   |                     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().enumerate().filter(|&(i,\
    \ c)| c > 'a' && c < 'z').map(|(i, c)| (c+'a'+2)*(i*2))\n        .map(|c| c +\
    \ 'z' - 'a' + 2)\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpruwl6924.rs:11:79\n\
    \   |\n11 |     s.chars().enumerate().filter(|&(i, c)| c > 'a' && c < 'z').map(|(i,\
    \ c)| (c+'a'+2)*(i*2))\n   |                                                 \
    \                             -^--- char\n   |                               \
    \                                               |\n   |                      \
    \                                                        char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = [0, 1, 2, 3, 4, 5, 6, 7];\n    for char in s.chars().cloned() {\n\
    \        alphabet[alphabet[alphabet.index(char) + 2] as usize - 2] = alphabet[alphabet.index(char)\
    \ - 2] as usize;\n    }\n    alphabet.iter().cloned().map(|c| c as usize + 2).collect::<Vec<_>>().join(\"\
    \").to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmptnpnfxb4.rs:12:27\n     |\n12   |     for char in s.chars().cloned()\
    \ {\n     |                           ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmptnpnfxb4.rs:12:17\n\
    \   |\n12 |     for char in s.chars().cloned() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmptnpnfxb4.rs:12:17\n   |\n12 |     for char in s.chars().cloned()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `index` found for array `[{integer}; 8]` in the\
    \ current scope\n  --> /tmp/tmptnpnfxb4.rs:13:36\n   |\n13 |         alphabet[alphabet[alphabet.index(char)\
    \ + 2] as usize - 2] = alphabet[alphabet.index(char) - 2] as usize;\n   |    \
    \                                ^^^^^ method not found in `[{integer}; 8]`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named\
    \ `index` found for array `[{integer}; 8]` in the current scope\n  --> /tmp/tmptnpnfxb4.rs:13:87\n\
    \   |\n13 |         alphabet[alphabet[alphabet.index(char) + 2] as usize - 2]\
    \ = alphabet[alphabet.index(char) - 2] as usize;\n   |             "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    if s.len()\
    \ == 0 {\n        return s\n    }\n    if s.len() > 26 {\n        let mut a =\
    \ s.chars().enumerate();\n        let b = a.next();\n        while b.is_some()\
    \ {\n            let (index, value) = b.unwrap();\n            let mut c = value.to_ascii_lowercase();\n\
    \            c = c.chars().enumerate();\n            let d = c.next();\n     \
    \       while d.is_some() {\n                let (index2, value2) = d.unwrap();\n\
    \                let c = value2.to_ascii_lowercase();\n                c = c.chars().enumerate();\n\
    \                let e = c.next();\n                while e.is_some() {\n    \
    \                let (index3, value3) = e.unwrap();\n                    let d\
    \ = value3.to_ascii_lowercase();\n                    d = d.chars().enumerate();\n\
    \                    let f = d.next();\n                    while f.is_some()\
    \ {\n                        let (index4, value4) = f.unwrap();\n            \
    \            let c = value4.to_ascii_lowercase();\n                        c =\
    \ c.chars().enumerate();\n                        let g = c.next();\n        \
    \                while g.is_some() {\n                            let (index5,\
    \ value5) = g.unwrap();\n                            let d = value5.to_ascii_lowercase();\n\
    \                            d = d.chars().enumerate();\n                    \
    \        let h = d.next();\n                            while h.is_some() {\n\
    \                                let (index6, value6) = h.unwrap();\n        \
    \                        let c = value6.to_ascii_lowercase();\n              \
    \                  c = c.chars().enumerate();\n                              \
    \  let i = c.next();\n                                while i.is_some() {\n  \
    \                                  let (index7, value7) = i.unwrap();\n      \
    \                              let d = value7.to_ascii_lowercase();\n        \
    \                            d = d.chars().enumerate();\n                    \
    \                let j = d.next();\n                                    while\
    \ j.is_some() {\n                                        let (index8, value8)\
    \ = j.unwrap();\n                                        let c = value8.to_ascii_lowercase();\n\
    \                                        c = c.chars().enumerate();\n        \
    \                                let k = c.next();\n                         \
    \               while k.is_some() {\n                                        \
    \    let (index9, value9) = k.unwrap();\n                                    \
    \        return string::from_utf8(rotate_alphabet(rotate_alphabet(rotate_alphabet(rotate_alphabet(s,\
    \ index), index2), index3), index4).to_utf8()) + string::from_utf8(rotate_alphabet(rotate_alphabet(rotate_alphabet(rotate_alphabet(s,\
    \ index2), index3), index5), index6).to_utf8()) + string::from_utf8(rotate_alphabet(rotate_alphabet(rotate_alphabet(rotate_alphabet(s,\
    \ index3), index5), index7), index8).to_utf8()) + string::from_utf8(rotate_alphabet(rotate_alphabet(rotate_alphabet(rotate_alphabet(s,\
    \ index4), index5), index6), index7).to_utf8()) + string::from_\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpijpqscmp.rs:72:3\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n14 |     if s.len() > 26 {\n   |          \
    \           - unclosed delimiter\n...\n17 |         while b.is_some() {\n   |\
    \                           - unclosed delimiter\n...\n22 |             while\
    \ d.is_some() {\n   |                               - unclosed delimiter\n...\n\
    27 |                 while e.is_some() {\n   |                               \
    \    - unclosed delimiter\n...\n32 |                     while f.is_some() {\n\
    \   |                                       - unclosed delimiter\n...\n37 |  \
    \                       while g.is_some() {\n   |                            \
    \               - unclosed delimiter\n...\n42 |                             while\
    \ h.is_some() {\n   |                                               - unclosed\
    \ delimiter\n...\n47 |                                 while i.is_some() {\n \
    \  |                                                   - unclosed delimiter\n\
    ...\n52 |                                     while j.is_some() {\n   |      \
    \                                                 - unclosed delimiter\n...\n\
    57 |                                         while k.is_some() {\n   |       \
    \                                                    - this delimiter might not\
    \ be properly closed...\n...\n60 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n72 | }\n   |   ^\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `string`\n  --> /tmp/tmpijpqscmp.rs:59:52\n\
    \   |\n59 | ...   return string::from_utf8(rotate_alphabet(rotate_alphabet(rotate_alphabet(rotate_alphabet(s,\
    \ index), index2), index3), index4).to_ut...\n   |              ^^^^^^ use of\
    \ undeclared crate or module `string`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `string`\n  --> /tmp/tmpijpqscmp.rs:59:184\n \
    \  |\n59 | ...), index2), index3), index4).to_utf8()) + string::from_utf8(rotate_alphabet(rotate_alphabet(rotate_alphabet(rotate_alphabet(s,\
    \ in"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for (i, ch) in s.chars().enumerate() {\n      \
    \  result.append(ch.rotate_left(2));\n        result.append(ch.rotate_left(3));\n\
    \        if i + 1 < s.len() {\n            result.append(ch.rotate_left(1));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpa8fwj7eg.rs:13:16\n   |\n13 |         result.append(ch.rotate_left(2));\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for type `char` in the current scope\n  --> /tmp/tmpa8fwj7eg.rs:13:26\n\
    \   |\n13 |         result.append(ch.rotate_left(2));\n   |                  \
    \        ^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmpa8fwj7eg.rs:14:16\n\
    \   |\n14 |         result.append(ch.rotate_left(3));\n   |                ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `rotate_left`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpa8fwj7eg.rs:14:26\n\
    \   |\n14 |         result.append(ch.rotate_left(3));\n   |                  \
    \        ^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmpa8fwj7eg.rs:16:20\n\
    \   |\n16 |             result.append(ch.rotate_left(1));\n   |              \
    \      ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `rotate_left`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpa8fwj7eg.rs:16:30\n\
    \   |\n16 |             result.append(ch.rotate_left(1));\n   |              \
    \                ^^^^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to 6 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    \n    let\
    \ mut alphabet = ROTATE_TABLE.clone();\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(3);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n    alphabet.rotate_left(1);\n\
    \    alphab\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROTATE_TABLE` in this scope\n  --> /tmp/tmp_o7a2168.rs:12:24\n\
    \   |\n12 |     let mut alphabet = ROTATE_TABLE.clone();\n   |               \
    \         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `alphab` in this scope\n  --> /tmp/tmp_o7a2168.rs:84:5\n   |\n84 |     alphab\n\
    \   |     ^^^^^^ help: a local variable with a similar name exists: `alphabet`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for i in s.chars() {\n        encrypted.push_str(i.to_string().rotate_right(2).to_string());\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_right` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp68a8fb0t.rs:13:42\n   |\n13 |         encrypted.push_str(i.to_string().rotate_right(2).to_string());\n\
    \   |                                          ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `trim_right`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for i in s.chars().rev() {\n        let mut shift\
    \ = (s.len() - i) * 2;\n        shift %= s.size();\n        result.push((s.chars().nth(shift).unwrap()\
    \ + s.chars().nth(shift + 1).unwrap()) % 26);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `char` from `usize`\n  --> /tmp/tmpeqs6581d.rs:13:34\n\
    \   |\n13 |         let mut shift = (s.len() - i) * 2;\n   |                 \
    \                 ^ no implementation for `usize - char`\n   |\n   = help: the\
    \ trait `Sub<char>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n    \
    \         <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n      \
    \       <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n          \
    \   <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a\
    \ isize as Sub<isize>>\n           and 48 others\n\nerror[E0599]: no method named\
    \ `size` found for struct `String` in the current scope\n  --> /tmp/tmpeqs6581d.rs:14:20\n\
    \   |\n14 |         shift %= s.size();\n   |                    ^^^^ method not\
    \ found in `String`\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpeqs6581d.rs:15:52\n\
    \   |\n15 |         result.push((s.chars().nth(shift).unwrap() + s.chars().nth(shift\
    \ + 1).unwrap()) % 26);\n   |                      -----------------------------\
    \ ^ --------------------------------- char\n   |                      |\n   |\
    \                      char\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_alphabet(s.chars().map(|c|\
    \ c).collect(), 2);\n    \"\".to_owned() + s\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmprlog080q.rs:11:5\n   |\n11 |     rotate_alphabet(s.chars().map(|c| c).collect(),\
    \ 2);\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprlog080q.rs:12:21\n   |\n12 |     \"\".to_owned() + s\n\
    \   |                     ^\n   |                     |\n   |                \
    \     expected `&str`, found struct `String`\n   |                     help: consider\
    \ borrowing here: `&s`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = [\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    ];\n  \
    \  \n    // The key needs to be doubled so that it ends up\n    // rotated correctly\
    \ and when it is combined with\n    // each character in the alphabet it shifts\
    \ down by two\n    // so that it can shift down two places for each letter\n \
    \   let key = alphabet.iter().cloned().cloned().collect::<Vec<String>>().push(\"\
    z\").collect();\n    let mut key_index = 0;\n    let mut shift = 1;\n    for c\
    \ in s.chars() {\n        if key_index >= key.len() {\n            key_index =\
    \ 0;\n        }\n        key_index = key_index + 1;\n        let a = alphabet[key_index];\n\
    \        let b = key[key_index];\n        let c = c + shift * b;\n        shift\
    \ = shift * 2;\n        alphabet[key_index] = c;\n    }\n    alphabet.iter().cloned().collect::<Vec<String>>().join()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, char> as Iterator>::Item\
    \ == &&_`\n    --> /tmp/tmppe48ma4o.rs:19:40\n     |\n19   |     let key = alphabet.iter().cloned().cloned().collect::<Vec<String>>().push(\"\
    z\").collect();\n     |                                        ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&&_`\n   \
    \             found reference `&char`\n     = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, char>>`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Cloned<std::slice::Iter<'_, char>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmppe48ma4o.rs:19:49\n   |\n19 |       let key = alphabet.iter().cloned().cloned().collect::<Vec<String>>().push(\"\
    z\").collect();\n   |                                                   ^^^^^^^\
    \ method cannot be called on `Cloned<Cloned<std::slice::Iter<'_, char>>>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `<Cloned<std::slice::Iter<'_, char>> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Cloned<std::slice::Iter<'_, char>>>:\
    \ Iterator`\n           `Cloned<Cloned<std::slice::Iter<'_, char>>>: Iterator`\n\
    \           which is required by `&mut Cloned<Cloned<std::slice::Iter<'_, char>>>:\
    \ Iterator`\n\nerror[E0369]: cannot add `_` to `char`\n  --> /tmp/tmppe48ma4o.rs:29:19\n\
    \   |\n29 |         let c = c + shift * b;\n   |                 - ^ ---------\
    \ _\n   |                 |\n   |                 char\n\nerror[E0277]: a value\
    \ of type `Vec<String>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmppe48ma4o.rs:33:30\n     |\n33   |     alphabet.iter().cloned().collect::<Vec<String>>().join()\n\
    \     |                              ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIte"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new(&'a to 'z as &'a + 'a);\n\n    // The 'n' key can be\
    \ replaced by a different alphabet if desired.\n    let mut key = Alphabet::new(&'a\
    \ to 'z as &'a + 'n);\n\n    // Initialize alphabet with rotated characters.\n\
    \    alphabet = alphabet.rotate_right();\n\n    // The 'm' key can be replaced\
    \ by a different alphabet if desired.\n    key = key.rotate_right();\n\n    let\
    \ mut result = String::from(\"a\");\n\n    let mut shift = alphabet.len();\n\n\
    \    loop {\n        if shift == 0 {\n            result += s.chars().next().unwrap();\n\
    \            break;\n        }\n\n        let mut index = 0;\n        let mut\
    \ value = alphabet.at(index);\n\n        // Get the next character.\n        let\
    \ char = s.chars().next().unwrap();\n        \n        // Replace the character\
    \ at index with its encrypted value.\n        value = value.rotate_right();\n\n\
    \        // Update the alphabet with the new character.\n        alphabet = alphabet.rotate_right();\n\
    \n        // Add the character to the result string.\n        result += char;\n\
    \n        // Shift the alphabet.\n        shift -= 1;\n\n        // Update the\
    \ key.\n        key = key.rotate_right();\n    }\n\n    // Return the result.\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: borrow expressions cannot be annotated with lifetimes\n  --> /tmp/tmp32o1clym.rs:11:38\n\
    \   |\n11 |     let mut alphabet = Alphabet::new(&'a to 'z as &'a + 'a);\n   |\
    \                                      ^--^^^\n   |                          \
    \             |\n   |                                       annotated with lifetime\
    \ here\n   |                                       help: remove the lifetime annotation\n\
    \nerror: expected `while`, `for`, `loop` or `{` after a label\n  --> /tmp/tmp32o1clym.rs:11:48\n\
    \   |\n11 |     let mut alphabet = Alphabet::new(&'a to 'z as &'a + 'a);\n   |\
    \                                                ^^ expected `while`, `for`, `loop`\
    \ or `{` after a label\n\nerror: expected one of `!`, `)`, `,`, `.`, `::`, `?`,\
    \ `{`, or an operator, found `'z`\n  --> /tmp/tmp32o1clym.rs:11:45\n   |\n11 |\
    \     let mut alphabet = Alphabet::new(&'a to 'z as &'a + 'a);\n   |         \
    \                                    ^^ expected one of 8 possible tokens\n\n\
    error: expected type, found `+`\n  --> /tmp/tmp32o1clym.rs:11:55\n   |\n11 | \
    \    let mut alphabet = Alphabet::new(&'a to 'z as &'a + 'a);\n   |          \
    \                                             ^ expected type\n\nerror: aborting\
    \ due to 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    rotate_alphabet(s);\n    s\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmp67i2fn8h.rs:12:5\n   |\n12 |     rotate_alphabet(s);\n   |     ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate([*s;\
    \ ..s.len()].iter().cloned().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpmwtr_603.rs:11:19\n   |\n10 | fn encrypt(s: String) -> String {\n  \
    \ |            - this would need to be a `const`\n11 |     rotate([*s; ..s.len()].iter().cloned().collect::<String>())\n\
    \   |                   ^\n\nerror[E0425]: cannot find function `rotate` in this\
    \ scope\n  --> /tmp/tmpmwtr_603.rs:11:5\n   |\n11 |     rotate([*s; ..s.len()].iter().cloned().collect::<String>())\n\
    \   |     ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpmwtr_603.rs:11:17\n   |\n11 |     rotate([*s; ..s.len()].iter().cloned().collect::<String>())\n\
    \   |                 ^^^^^^^^^ expected `usize`, found struct `RangeTo`\n   |\n\
    \   = note: expected type `usize`\n            found struct `RangeTo<_>`\n\nerror[E0599]:\
    \ the method `iter` exists for array `[str; _]`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpmwtr_603.rs:11:28\n   |\n11 |     rotate([*s; ..s.len()].iter().cloned().collect::<String>())\n\
    \   |                            ^^^^ method cannot be called on `[str; _]` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `str: Sized`\n\nerror[E0277]: the trait bound `str:\
    \ Copy` is not satisfied\n  --> /tmp/tmpmwtr_603.rs:11:13\n   |\n11 |     rotate([*s;\
    \ ..s.len()].iter().cloned().collect::<String>())\n   |             ^^ the trait\
    \ `Copy` is not implemented for `str`\n   |\n   = note: the `Copy` trait is required\
    \ because this value will be copied for each element of the array\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425, E0435, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut alpha:\
    \ Vec<u32> = s.chars().map(|c| c.to_u32()).collect();\n\talpha[alpha.len() - 2..alpha.len()\
    \ - 1]\n\t\t.iter_mut().for_each(|&c| c += 2);\n\talpha.sort();\n\tlet mut cipher:\
    \ Vec<u32> = alpha.iter().cloned().collect();\n\tlet mut cipher_map: HashMap<u32,\
    \ u32> = HashMap::new();\n\tfor &c in &cipher {\n\t\tcipher_map.insert(c, *c);\n\
    \t}\n\t\n\tlet mut cipher = cipher.clone();\n\tlet mut c = s.chars().map(|c| c.to_u32()).collect();\n\
    \tlet mut last = 0;\n\tlet mut i = 0;\n\tlet mut cipher_len = 0;\n\tlet mut cipher_len2\
    \ = cipher_len + 1;\n\twhile i < c.len() {\n\t\tlet mut j = 0;\n\t\twhile j <\
    \ cipher_len {\n\t\t\tlet key = cipher_map[*c].unwrap();\n\t\t\tc[i] = cipher_map[*c].unwrap();\n\
    \t\t\tcipher_map[key] = cipher_map[cipher_map[*c].unwrap()].unwrap();\n\t\t\t\n\
    \t\t\tc[i] += key;\n\t\t\tc[last] = cipher_map[*c].unwrap();\n\t\t\t\n\t\t\tcipher_len2\
    \ += 1;\n\t\t\t\n\t\t\tj = cipher_len2;\n\t\t}\n\t\tcipher_len = cipher_len2;\n\
    \t\tlast = i;\n\t\ti += 1;\n\t}\n\tlet mut result = c.iter().cloned().collect();\n\
    \tresult.sort();\n\t\n\tfor &c in &result {\n\t\tprintln!(\"{:?}\", c);\n\t}\n\
    \t\n\tresult.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpvw8hoq0e.rs:16:22\n\
    \   |\n16 |     let mut cipher_map: HashMap<u32, u32> = HashMap::new();\n   |\
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpvw8hoq0e.rs:16:42\n\
    \   |\n16 |     let mut cipher_map: HashMap<u32, u32> = HashMap::new();\n   |\
    \                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no method named `to_u32` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvw8hoq0e.rs:11:48\n   |\n11 |     let mut alpha: Vec<u32>\
    \ = s.chars().map(|c| c.to_u32()).collect();\n   |                           \
    \                        ^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvw8hoq0e.rs:13:25\n   |\n13 |         .iter_mut().for_each(|&c|\
    \ c += 2);\n   |                               ^--\n   |                     \
    \          ||\n   |                               |expected due to this\n   |\
    \                               types differ in mutability\n   |             \
    \                  help: did you mean `c`: `&&mut u32`\n   |\n   = note: expected\
    \ mutable reference `&mut u32`\n                      found reference `&_`\n\n\
    error[E0614]: type `u32` cannot be dereferenced\n  --> /tmp/tmpvw8hoq0e.rs:18:24\n\
    \   |\n18 |         cipher_map.insert(c, *c);\n   |                          \
    \    ^^\n\nerror[E0599]: no method named `to_u32` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpvw8hoq0e.rs:22:34\n   |\n22 |     let mut c = s.chars().map(|c|\
    \ c.to_u32()).collect();\n   |                                     ^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0412, E0433, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt_alphabet_helper(s.chars().map(|c|\
    \ c.to_ascii_uppercase()).collect(), &ROTATE_ALPHABET)\n}\n\nfn main() {\n   \
    \ let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encrypt_alphabet_helper` in this scope\n\
    \  --> /tmp/tmpuyf4n6cc.rs:11:5\n   |\n11 |     encrypt_alphabet_helper(s.chars().map(|c|\
    \ c.to_ascii_uppercase()).collect(), &ROTATE_ALPHABET)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `ROTATE_ALPHABET`\
    \ in this scope\n  --> /tmp/tmpuyf4n6cc.rs:11:83\n   |\n11 |     encrypt_alphabet_helper(s.chars().map(|c|\
    \ c.to_ascii_uppercase()).collect(), &ROTATE_ALPHABET)\n   |                 \
    \                                                                  ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut new_s\
    \ = String::new();\n\n\tfor i in s.chars() {\n\t\tnew_s.push_str(&rotate_c(&i.to_string()));\n\
    \t}\n\n\treturn new_s;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_c` in this scope\n  --> /tmp/tmp_ozc3wor.rs:14:19\n\
    \   |\n14 |         new_s.push_str(&rotate_c(&i.to_string()));\n   |         \
    \                ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ rotated_alphabet.index_of(c)).fold(\"\".to_string(), |acc, c|\n        acc.chars().fold(acc.to_string().chars().map(|&x|\
    \ *x+2).collect(), |acc, c|\n            acc.append(c)))\n}\n\nfn main() {\n \
    \   let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `rotated_alphabet` in this scope\n  -->\
    \ /tmp/tmpyls4f9q5.rs:11:23\n   |\n11 |     s.chars().map(|c| rotated_alphabet.index_of(c)).fold(\"\
    \".to_string(), |acc, c|\n   |                       ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyls4f9q5.rs:12:55\n\
    \   |\n12 |         acc.chars().fold(acc.to_string().chars().map(|&x| *x+2).collect(),\
    \ |acc, c|\n   |                                                       ^--\n \
    \  |                                                       ||\n   |          \
    \                                             |expected due to this\n   |    \
    \                                                   expected `char`, found reference\n\
    \   |                                                       help: did you mean\
    \ `x`: `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0599]: no method named `append` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpyls4f9q5.rs:13:17\n   |\n13 |             acc.append(c)))\n\
    \   |                 ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ c: Vec<char> = s.chars().collect();\n    c.rotate_left(2);\n    c.iter_mut().for_each(|&c|\
    \ c.rotate_right());\n    let mut r: Vec<char> = c.collect();\n    r.resize(s.size());\n\
    \    r.reverse();\n    r.iter_mut().for_each(|&r| r.append(c));\n    let mut s\
    \ = String::new();\n    for i in r.iter() {\n        s.append(i);\n    }\n   \
    \ s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2dt1p0oi.rs:13:28\n   |\n\
    13 |     c.iter_mut().for_each(|&c| c.rotate_right());\n   |                 \
    \           ^--\n   |                            ||\n   |                    \
    \        |expected due to this\n   |                            types differ in\
    \ mutability\n   |                            help: did you mean `c`: `&&mut char`\n\
    \   |\n   = note: expected mutable reference `&mut char`\n                   \
    \   found reference `&_`\n\nerror[E0599]: `Vec<char>` is not an iterator\n   -->\
    \ /tmp/tmp2dt1p0oi.rs:14:30\n    |\n14  |       let mut r: Vec<char> = c.collect();\n\
    \    |                                ^^^^^^^ `Vec<char>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>: Iterator`\n\
    \            `[char]: Iterator`\n            which is required by `&mut [char]:\
    \ Iterator`\n\nerror[E0599]: no method named `size` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp2dt1p0oi.rs:15:16\n   |\n15 |     r.resize(s.size());\n\
    \   |                ^^^^ method not found in `String`\n\nerror[E0061]: this function\
    \ takes 2 arguments but 1 argument was supplied\n    --> /tmp/tmp2dt1p0oi.rs:15:7\n\
    \     |\n15   |     r.resize(s.size());\n     |       ^^^^^^ -------- supplied\
    \ 1 argument\n     |       |\n     |       expected 2 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2dt1p0oi.rs:17:28\n\
    \   |\n17 |     r.iter_mut().for_each(|&r| r.append(c));\n   |               \
    \             ^--\n   |                            ||\n   |                  \
    \          |expected due to this\n   |                            types differ\
    \ in mutability\n   |                            help: did you mean `r`: `&&mut\
    \ char`\n   |\n   = note: expected mutable reference `&mut char`\n           \
    \           found reference `&_`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp2dt1p0oi.rs:20:11\n\
    \   |\n20 |         s.append(i);\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    \n    //\
    \ Get length of string\n    let len = s.len();\n    \n    // Initialize result\
    \ string with all letters up\n    let mut result = String::new(len.to_string());\n\
    \    for i in 0..len {\n        result.push(s[i]);\n    }\n    \n    // Initialize\
    \ shift by 2\n    let mut shift = 2;\n    \n    // Continue until there are no\
    \ more characters in string\n    while len > 0 {\n        \n        // Get letter\
    \ and character at current position\n        let letter = result[len-1];\n   \
    \     let char = s[len-1];\n        \n        // Get rotated letter\n        let\
    \ rotated_char = alphabet[alphabet[char].shift() - shift].to_string();\n     \
    \   \n        // Append rotated letter to result string\n        result[len-1]\
    \ = rotated_char;\n        \n        // Add shift amount to shift\n        shift\
    \ += 2;\n        \n        // Decrement len\n        len -= 1;\n    }\n    \n\
    \    // Return result string\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpbe7q597n.rs:32:28\n\
    \   |\n32 |         let rotated_char = alphabet[alphabet[char].shift() - shift].to_string();\n\
    \   |                            ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmpbe7q597n.rs:32:37\n\
    \   |\n32 |         let rotated_char = alphabet[alphabet[char].shift() - shift].to_string();\n\
    \   |                                     ^^^^^^^^ not found in this scope\n\n\
    error[E0061]: this function takes 0 arguments but 1 argument was supplied\n  \
    \ --> /tmp/tmpbe7q597n.rs:16:22\n    |\n16  |     let mut result = String::new(len.to_string());\n\
    \    |                      ^^^^^^^^^^^ --------------- supplied 1 argument\n\
    \    |                      |\n    |                      expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpbe7q597n.rs:18:21\n   |\n18 |  \
    \       result.push(s[i]);\n   |                     ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbe7q597n.rs:28:22\n   |\n28 |         let letter = result[len-1];\n\
    \   |                      ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n    "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().enumerate().map(|(i,\
    \ c)| {\n        if i >= s.len() / 2 {\n            c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + \n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8jot3a8j.rs:26:3\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n11 |     s.chars().enumerate().map(|(i, c)| {\n\
    \   |                              -         - unclosed delimiter\n   |      \
    \                        |\n   |                              unclosed delimiter\n\
    12 |         if i >= s.len() / 2 {\n   |                             - this delimiter\
    \ might not be properly closed...\n13 |             c + c + c + c + c + c + c...\n\
    14 | }\n   | - ...as it matches this but it has different indentation\n...\n26\
    \ | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmp8jot3a8j.rs:14:1\n\
    \   |\n14 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8jot3a8j.rs:11:5\n   |\n10 |   fn encrypt(s: String) -> String\
    \ {\n   |                            ------ expected `String` because of return\
    \ type\n11 | /     s.chars().enumerate().map(|(i, c)| {\n12 | |         if i >=\
    \ s.len() / 2 {\n13 | |             c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c\
    \ + c + c...\n14 | | }\n...  |\n25 | |     assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n26 | | }\n   | |__^ expected struct `String`, found\
    \ struct `Map`\n   |\n   = note: expected struct `String`\n              found\
    \ struct `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmp8jot3a8j.rs:11:31: 26:3]>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // Your\
    \ code goes here\n    let mut ret = \"\".to_string();\n    for i in s.chars()\
    \ {\n        ret += i.to_string() + i.to_string() + i.to_string() + i.to_string();\n\
    \    }\n    return ret;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphhanz86r.rs:14:32\n   |\n\
    14 |         ret += i.to_string() + i.to_string() + i.to_string() + i.to_string();\n\
    \   |                                ^^^^^^^^^^^^^\n   |                     \
    \           |\n   |                                expected `&str`, found struct\
    \ `String`\n   |                                help: consider borrowing here:\
    \ `&i.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphhanz86r.rs:14:48\n\
    \   |\n14 |         ret += i.to_string() + i.to_string() + i.to_string() + i.to_string();\n\
    \   |                                                ^^^^^^^^^^^^^\n   |     \
    \                                           |\n   |                          \
    \                      expected `&str`, found struct `String`\n   |          \
    \                                      help: consider borrowing here: `&i.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphhanz86r.rs:14:64\n   |\n14 |\
    \         ret += i.to_string() + i.to_string() + i.to_string() + i.to_string();\n\
    \   |                                                                ^^^^^^^^^^^^^\n\
    \   |                                                                |\n   | \
    \                                                               expected `&str`,\
    \ found struct `String`\n   |                                                \
    \                help: consider borrowing here: `&i.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphhanz86r.rs:14:16\n   |\n14 |         ret +=\
    \ i.to_string() + i.to_string() + i.to_string() + i.to_string();\n   |       \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \                |\n   |                expected `&str`, found struct `String`\n\
    \   |                help: consider borrowing here: `&(i.to_string() + i.to_string()\
    \ + i.to_string() + i.to_string())`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = ALPHABET.clone();\n    alphabet.rotate_left(2);\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let mut d = alphabet.find(c)?;\n\
    \        // Rotate c twice to the left\n        d = alphabet.rotate_left(2);\n\
    \        result = result.push_str(&alphabet[d..].to_lowercase());\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmp_dxf6jvn.rs:11:24\n\
    \   |\n11 |     let mut alphabet = ALPHABET.clone();\n   |                   \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0277]: the `?` operator can only\
    \ be used in a function that returns `Result` or `Option` (or another type that\
    \ implements `FromResidual`)\n  --> /tmp/tmp_dxf6jvn.rs:15:37\n   |\n10 | / fn\
    \ encrypt(s: String) -> String {\n11 | |     let mut alphabet = ALPHABET.clone();\n\
    12 | |     alphabet.rotate_left(2);\n13 | |     let mut result = String::new();\n\
    14 | |     for c in s.chars() {\n15 | |         let mut d = alphabet.find(c)?;\n\
    \   | |                                     ^ cannot use the `?` operator in a\
    \ function that returns `String`\n...  |\n20 | |     result\n21 | | }\n   | |_-\
    \ this function should return `Result` or `Option` to accept `?`\n   |\n   = help:\
    \ the trait `FromResidual<_>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_dxf6jvn.rs:18:18\n   |\n13 |     let mut result\
    \ = String::new();\n   |                      ------------- expected due to this\
    \ value\n...\n18 |         result = result.push_str(&alphabet[d..].to_lowercase());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver\
    \ in-place\n  --> /tmp/tmp_dxf6jvn.rs:18:25\n   |\n18 |         result = result.push_str(&alphabet[d..].to_lowercase());\n\
    \   |                  ------ ^^^^^^^^ this call modifies `result` in-place\n\
    \   |                  |\n   |                  you probably want to use this\
    \ value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `push_str`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ if c >= 'a' && c <= 'z' then c + 2 else *c + 1).collect()\n        .to_string()\
    \ + s.chars().map(|c| if c >= 'a' && c <= 'z' then c - 2 else *c - 1).collect()\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmp80o2rw9w.rs:11:47\n  \
    \ |\n11 |     s.chars().map(|c| if c >= 'a' && c <= 'z' then c + 2 else *c + 1).collect()\n\
    \   |                       --                      ^^^^ expected `{`\n   |  \
    \                     |\n   |                       this `if` expression has a\
    \ condition, but no block\n   |\nhelp: try placing this code inside a block\n\
    \   |\n11 |     s.chars().map(|c| if c >= 'a' && c <= 'z' { then } c + 2 else\
    \ *c + 1).collect()\n   |                                               +    \
    \  +\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().fold(\"\
    \", |mut c, char| {\n        c + (if char == char::FromValue('a') then char::FromValue('z')\
    \ else char::FromValue('a')).to_string();\n    })\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmpbxi79u7z.rs:12:46\n  \
    \ |\n12 |         c + (if char == char::FromValue('a') then char::FromValue('z')\
    \ else char::FromValue('a')).to_string();\n   |              --              \
    \                ^^^^ expected `{`\n   |              |\n   |              this\
    \ `if` expression has a condition, but no block\n   |\nhelp: try placing this\
    \ code inside a block\n   |\n12 |         c + (if char == char::FromValue('a')\
    \ { then } char::FromValue('z') else char::FromValue('a')).to_string();\n   |\
    \                                              +      +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbxi79u7z.rs:11:20\n   |\n11 |     s.chars().fold(\"\",\
    \ |mut c, char| {\n   |                    ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxi79u7z.rs:11:38\n\
    \   |\n11 |       s.chars().fold(\"\", |mut c, char| {\n   |  ______________________________________^\n\
    12 | |         c + (if char == char::FromValue('a') then char::FromValue('z')\
    \ else char::FromValue('a')).to_string();\n   | |                            \
    \                                                                            \
    \      - help: remove this semicolon\n13 | |     })\n   | |_____^ expected struct\
    \ `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = [0; 26];\n    for &c in s.chars() {\n        alphabet[c - 97 as usize]\
    \ += 1;\n    }\n    let mut result = [0; 26];\n    for i in 0..26 {\n        result[alphabet[i]]\
    \ += 1;\n    }\n    to_string(&result)\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpqxxfb0ii.rs:19:5\n\
    \   |\n19 |     to_string(&result)\n   |     ^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqxxfb0ii.rs:12:9\n   |\n12 | \
    \    for &c in s.chars() {\n   |         ^^    --------- this expression has type\
    \ `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let len\
    \ = s.len();\n    let mut res = String::new();\n    let mut shift: i32 = 0;\n\
    \    for i in 0..len {\n        res.push_char(alphabet[(alphabet.len() - shift)\
    \ as usize] as char);\n        shift += 2;\n    }\n    res += s;\n    res\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp_0ftvr22.rs:15:23\n\
    \   |\n15 |         res.push_char(alphabet[(alphabet.len() - shift) as usize]\
    \ as char);\n   |                       ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmp_0ftvr22.rs:15:33\n\
    \   |\n15 |         res.push_char(alphabet[(alphabet.len() - shift) as usize]\
    \ as char);\n   |                                 ^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `push_char` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp_0ftvr22.rs:15:13\n   |\n15 |         res.push_char(alphabet[(alphabet.len()\
    \ - shift) as usize] as char);\n   |             ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `push_str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_0ftvr22.rs:18:12\n   |\n18 |     res += s;\n   |            ^\n\
    \   |            |\n   |            expected `&str`, found struct `String`\n \
    \  |            help: consider borrowing here: `&s`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ rotated_alphabet = [0; 26];\n\n    let mut result = String::new();\n\n    for\
    \ c in s.chars() {\n        let mut index = alphabet_index(&c);\n        let rotated_index\
    \ = index + 2;\n        rotated_alphabet[rotated_index] = rotated_alphabet[index];\n\
    \        rotated_alphabet[rotated_index + 1] = rotated_alphabet[index + 1];\n\
    \        rotated_index = rotated_index + 2;\n        result.append(&rotated_alphabet[rotated_index]);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `alphabet_index` in this scope\n  -->\
    \ /tmp/tmp6jlpthxl.rs:16:25\n   |\n16 |         let mut index = alphabet_index(&c);\n\
    \   |                         ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp6jlpthxl.rs:21:16\n   |\n21 |         result.append(&rotated_alphabet[rotated_index]);\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ newS = \"\";\n    let alphabet = s.chars().map(|c| c.to_string());\n    alphabet.rev().for_each(|&c|\
    \ {\n        let idx = alphabet.iter().find(|&x| x.cmp(&c) == Some(Ordering::Equal)).unwrap();\n\
    \        newS.push((idx % alphabet.len()).to_string());\n    });\n    newS\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpbt_b__oo.rs:14:63\n   |\n14 |         let idx = alphabet.iter().find(|&x|\
    \ x.cmp(&c) == Some(Ordering::Equal)).unwrap();\n   |                        \
    \                                       ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt_b__oo.rs:13:30\n   |\n13 |\
    \     alphabet.rev().for_each(|&c| {\n   |                              ^--\n\
    \   |                              ||\n   |                              |expected\
    \ due to this\n   |                              expected struct `String`, found\
    \ reference\n   |                              help: did you mean `c`: `&String`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0599]: no method named `iter` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmpbt_b__oo.rs:14:28\n   |\n14 |         let idx = alphabet.iter().find(|&x|\
    \ x.cmp(&c) == Some(Ordering::Equal)).unwrap();\n   |                        \
    \    ^^^^ private field, not a method\n\nerror[E0599]: no method named `push`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpbt_b__oo.rs:15:14\n\
    \   |\n15 |         newS.push((idx % alphabet.len()).to_string());\n   |     \
    \         ^^^^ method not found in `&str`\n\nerror[E0599]: the method `len` exists\
    \ for struct `Map<Chars<'_>, [closure@/tmp/tmpbt_b__oo.rs:12:34: 12:51]>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpbt_b__oo.rs:15:35\n   |\n\
    15 |           newS.push((idx % alphabet.len()).to_string());\n   |          \
    \                           ^^^ method cannot be called on `Map<Chars<'_>, [closure@/tmp/tmpbt_b__oo.rs:12:34:\
    \ 12:51]>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `Chars<'_>: ExactSizeIterator`\n    \
    \       which is required by `Map<Chars<'_>, [closure@/tmp/tmpbt_b__oo.rs:12:34:\
    \ 12:51]>: ExactSizeIterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbt_b__oo.rs:17:5\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ cipherText = String::new();\n    let mut i = 0;\n    loop {\n        cipherText.push((s[i]\
    \ + s[(i+1)%s.length()]));\n        i += 2;\n        i %= s.length;\n    }\n \
    \   cipherText\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpe2v428y_.rs:14:25\n\
    \   |\n14 |         cipherText.push((s[i] + s[(i+1)%s.length()]));\n   |     \
    \                    ^                          ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n14 -         cipherText.push((s[i]\
    \ + s[(i+1)%s.length()]));\n14 +         cipherText.push(s[i] + s[(i+1)%s.length()]);\n\
    \   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n \
    \ --> /tmp/tmpe2v428y_.rs:14:26\n   |\n14 |         cipherText.push((s[i] + s[(i+1)%s.length()]));\n\
    \   |                          ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpe2v428y_.rs:14:43\n   |\n14 |         cipherText.push((s[i]\
    \ + s[(i+1)%s.length()]));\n   |                                           ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpe2v428y_.rs:14:33\n\
    \   |\n14 |         cipherText.push((s[i] + s[(i+1)%s.length()]));\n   |     \
    \                            ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_alphabet(s.to_ascii_uppercase().to_owned(),\
    \ 2)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpf7_tdxun.rs:11:5\n   |\n11 |     rotate_alphabet(s.to_ascii_uppercase().to_owned(),\
    \ 2)\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    for c in &s {\n        if c >= 'a' && c <= 'z' {\n            c\
    \ += 2;\n        }\n        if c >= 'A' && c <= 'Z' {\n            c -= 2;\n \
    \       }\n    }\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpm22erbhx.rs:12:14\n\
    \   |\n12 |     for c in &s {\n   |              ^^ `&String` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&String`\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `&String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    if s.len()\
    \ <= 1 {\n        return s;\n    }\n    let mut s = s;\n    for c in s.chars()\
    \ {\n        *c = rotate_alphabet(*c);\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmp9or0_s8s.rs:16:14\n   |\n16 |         *c = rotate_alphabet(*c);\n  \
    \ |              ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmp9or0_s8s.rs:16:9\n   |\n16 |  \
    \       *c = rotate_alphabet(*c);\n   |         ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp9or0_s8s.rs:16:30\n   |\n16 |        \
    \ *c = rotate_alphabet(*c);\n   |                              ^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0614.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate(s.chars().collect(),\
    \ |char| char + 2);\n    s.chars().collect::<String>().collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpkmo2a_y7.rs:11:5\n\
    \   |\n11 |     rotate(s.chars().collect(), |char| char + 2);\n   |     ^^^^^^\
    \ not found in this scope\n\nerror[E0599]: `String` is not an iterator\n   -->\
    \ /tmp/tmpkmo2a_y7.rs:12:35\n    |\n12  |       s.chars().collect::<String>().collect()\n\
    \    |                                     ^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ Rewrite this function so that it works in the general case\n    // The key will\
    \ need to be rotated in the opposite manner as \n    // the encryption alphabet\
    \ is rotated \n    let mut key = [0; 26];\n    let mut alphabet : [char; 26] =\
    \ [0; 26];\n    for i in 0..key.len() {\n        key[i] = i;\n    }\n    let mut\
    \ shift = 2;\n    let mut encrypted_string = \"\".to_string();\n    for (i, c)\
    \ in s.chars().enumerate() {\n        alphabet[i] = c;\n        key[i] += shift;\n\
    \        if key[i] > 26 {\n            key[i] -= 26;\n            shift += 2;\n\
    \        }\n    }\n    for i in 0..alphabet.len() {\n        encrypted_string.push((alphabet[alphabet.len()-i-1]).to_string());\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwtn86oij.rs:15:38\n   |\n\
    15 |     let mut alphabet : [char; 26] = [0; 26];\n   |                      \
    \                ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwtn86oij.rs:30:31\n   |\n30 |         encrypted_string.push((alphabet[alphabet.len()-i-1]).to_string());\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt1(s,\
    \ ROTATE_LEFT)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encrypt1` in this scope\n  --> /tmp/tmpgxexhias.rs:11:5\n\
    \   |\n11 |     encrypt1(s, ROTATE_LEFT)\n   |     ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `ROTATE_LEFT` in this scope\n  -->\
    \ /tmp/tmpgxexhias.rs:11:17\n   |\n11 |     encrypt1(s, ROTATE_LEFT)\n   |   \
    \              ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n\n    for c in s.chars() {\n        let index = c.index\
    \ % ALPHABET_SIZE;\n        result.append(ALPHABET[index]);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ALPHABET_SIZE` in this scope\n  --> /tmp/tmp05_bp2vg.rs:14:31\n\
    \   |\n14 |         let index = c.index % ALPHABET_SIZE;\n   |               \
    \                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ALPHABET` in this scope\n  --> /tmp/tmp05_bp2vg.rs:15:23\n   |\n\
    15 |         result.append(ALPHABET[index]);\n   |                       ^^^^^^^^\
    \ not found in this scope\n\nerror[E0610]: `char` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp05_bp2vg.rs:14:23\n   |\n14 |         let\
    \ index = c.index % ALPHABET_SIZE;\n   |                       ^^^^^\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp05_bp2vg.rs:15:16\n   |\n15 |         result.append(ALPHABET[index]);\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599,\
    \ E0610.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = [\n        2, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 8, 9, 10, 10, 10,\
    \ \n        11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, \n\
    \        15, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, \n\
    \        19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22,\
    \ \n        22, 23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26,\
    \ 26, \n        27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30,\
    \ 30, 31, \n        31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 34, 34,\
    \ 34, 34, 34, 34, \n        35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37,\
    \ 37, 37, 38, 38, 38, 38, \n        38, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40,\
    \ 41, 41, 41, 41, 41, 42, 42, 42, \n        42, 42, 42, 43, 43, 43, 43, 43, 44,\
    \ 44, 44, 44, 44, 45, 45, 45, 45, \n        45, 46, 46, 46, 46, 46, 47, 47, 47,\
    \ 47, 47, 48, 48, 48, 48, 48, 48, 49, \n        49, 49, 49, 49, 50, 50, 50, 50,\
    \ 50, 50, 51, 51, 51, 51, 51, 51, 52, 52, 52, \n        52, 52, 53, 53, 53, 53,\
    \ 53, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, \n        55, 56, 56, 56, 56,\
    \ 56, 56, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, \n        59, 59, 59, 59,\
    \ 59, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, \n        62, 62,\
    \ 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 66, \n        66,\
    \ 66, 66, 66, 67, 67, 67, 67, 67, 67, 68, 68, 68, 68, 68, 68, 69, 69, 69, 69,\
    \ \n        69, 69, 69, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 72, 72, 72,\
    \ 72, \n        72, 73, 73, 73, 73, 73, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75,\
    \ 75, 75, \n        76, 76, 76, 76, 76, 76, 77, 77, 77, 77, 77, 77, 78, 78, 78,\
    \ 78, 78, 78, \n        79, 79, 79, 79, 79, 79, 80, 80, 80, 80, 80, 80, \n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpejvc024n.rs:33:1\n   |\n33 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpejvc024n.rs:11:24\n   |\n10 | fn encrypt(s: String) -> String {\n  \
    \ |                                 - closing delimiter possibly meant for this\n\
    11 |     let mut alphabet = [\n   |                        ^ unclosed delimiter\n\
    ...\n33 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_alphabet = vec!['h', 'e', 'l', 'm', 'n', 'p', 'q', 'r', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    new_alphabet.extend(vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z']);\n    new_alphabet = std::mem::replace(new_alphabet, vec![]);\n\
    \n    let mut rotated_alphabet = new_alphabet.clone();\n    rotated_alphabet.pop();\n\
    \    rotated_alphabet.pop();\n    rotated_alphabet.extend(vec!['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z']);\n    rotated_alphabet = std::mem::replace(rotated_alphabet,\
    \ vec![]);\n\n    let mut new_s = s.clone();\n    new_s.rotate_left(2);\n\n  \
    \  let mut result: String = String::new();\n    let mut char_iter: chars = new_s.chars();\n\
    \    while let Some(ch) = char_iter.next() {\n        let rotated_ch = rotated_alphabet[ch];\n\
    \        result.append(rotated_ch);\n    }\n\n    result\n}\n\nfn main() {\n \
    \   let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `chars` in this scope\n  --> /tmp/tmp27tvv_2a.rs:25:24\n\
    \   |\n25 |     let mut char_iter: chars = new_s.chars();\n   |              \
    \          ^^^^^ help: a builtin type with a similar name exists: `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp27tvv_2a.rs:13:38\n   |\n13 |     new_alphabet\
    \ = std::mem::replace(new_alphabet, vec![]);\n   |                           \
    \           ^^^^^^^^^^^^\n   |                                      |\n   |  \
    \                                    expected `&mut Vec<char>`, found struct `Vec`\n\
    \   |                                      help: consider mutably borrowing here:\
    \ `&mut new_alphabet`\n   |\n   = note: expected mutable reference `&mut Vec<char>`\n\
    \                         found struct `Vec<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp27tvv_2a.rs:19:42\n   |\n19 |     rotated_alphabet = std::mem::replace(rotated_alphabet,\
    \ vec![]);\n   |                                          ^^^^^^^^^^^^^^^^\n \
    \  |                                          |\n   |                        \
    \                  expected `&mut Vec<char>`, found struct `Vec`\n   |       \
    \                                   help: consider mutably borrowing here: `&mut\
    \ rotated_alphabet`\n   |\n   = note: expected mutable reference `&mut Vec<char>`\n\
    \                         found struct `Vec<char>`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmp27tvv_2a.rs:22:11\n\
    \   |\n22 |     new_s.rotate_left(2);\n   |           ^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp27tvv_2a.rs:28:16\n   |\n28 |         result.append(rotated_ch);\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0412,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ rotations = vec![false; 26];\n    for (i, c) in s.chars().enumerate() {\n  \
    \      rotations[i] = ((c + i) % 2) == 0;\n    }\n    let mut enc = String::new();\n\
    \    for (i, c) in s.chars().enumerate() {\n        if rotations[i] {\n      \
    \      enc.push(c - 26);\n        } else {\n            enc.push(c);\n       \
    \ }\n    }\n    enc\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `usize` to `char`\n  --> /tmp/tmphg688wue.rs:13:28\n\
    \   |\n13 |         rotations[i] = ((c + i) % 2) == 0;\n   |                 \
    \         - ^ - usize\n   |                          |\n   |                 \
    \         char\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  -->\
    \ /tmp/tmphg688wue.rs:18:24\n   |\n18 |             enc.push(c - 26);\n   |  \
    \                    - ^ -- {integer}\n   |                      |\n   |     \
    \                 char\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = s.chars().map(|c| c + 2);\n    alphabet = alphabet.collect();\n \
    \   alphabet.insert(0,'\\0');\n    alphabet.insert(alphabet.len(),'\\0');\n  \
    \  alphabet.push('\\0');\n    let mut x = alphabet.len();\n    let mut y = alphabet.len();\n\
    \    let mut c = alphabet.len();\n    let mut rs = String::new();\n    while x\
    \ < alphabet.len() {\n        y = alphabet.len() - x;\n        c = x;\n      \
    \  while c < alphabet.len() {\n            let mut c = alphabet.len() - y;\n \
    \           if c >= alphabet.len() {\n                c -= alphabet.len();\n \
    \           }\n            let mut z = c;\n            while z >= alphabet.len()\
    \ {\n                z -= alphabet.len();\n            }\n            if alphabet.len()\
    \ == 1 || z == c {\n                alphabet[c] = alphabet[z];\n            }\
    \ else {\n                alphabet[c] = alphabet[z] + alphabet[y];\n         \
    \   }\n            alphabet = alphabet.clone();\n            c += 1;\n       \
    \     x += 1;\n        }\n        x = alphabet.len();\n        rs.push(*alphabet);\n\
    \    }\n    rs\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp44e542qa.rs:11:44\n\
    \   |\n11 |     let mut alphabet = s.chars().map(|c| c + 2);\n   |           \
    \                               - ^ - {integer}\n   |                        \
    \                  |\n   |                                          char\n\nerror[E0277]:\
    \ a value of type `Map<Chars<'_>, _>` cannot be built from an iterator over elements\
    \ of type `_`\n    --> /tmp/tmp44e542qa.rs:12:25\n     |\n12   |     alphabet\
    \ = alphabet.collect();\n     |                         ^^^^^^^ value of type\
    \ `Map<Chars<'_>, _>` cannot be built from `std::iter::Iterator<Item=_>`\n   \
    \  |\n     = help: the trait `FromIterator<_>` is not implemented for `Map<Chars<'_>,\
    \ _>`\nnote: required by a bound in `collect`\n\nerror[E0599]: no method named\
    \ `insert` found for struct `Map` in the current scope\n  --> /tmp/tmp44e542qa.rs:13:14\n\
    \   |\n13 |     alphabet.insert(0,'\\0');\n   |              ^^^^^^ method not\
    \ found in `Map<Chars<'_>, _>`\n\nerror[E0599]: no method named `insert` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmp44e542qa.rs:14:14\n   |\n\
    14 |     alphabet.insert(alphabet.len(),'\\0');\n   |              ^^^^^^ method\
    \ not found in `Map<Chars<'_>, _>`\n\nerror[E0599]: the method `len` exists for\
    \ struct `Map<Chars<'_>, _>`, but its trait bounds were not satisfied\n  --> /tmp/tmp44e542qa.rs:14:30\n\
    \   |\n14 |       alphabet.insert(alphabet.len(),'\\0');\n   |               \
    \                 ^^^ method cannot be called on `Map<Chars<'_>, _>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Chars<'_>: ExactSizeIterator`\n           which is required by `Map<Chars<'_>,\
    \ _>: ExactSizeIterator`\n\nerror[E0599]: no method named `push` found for struct\
    \ `Map` in the current scope\n  --> /tmp/tmp44e542qa.rs:15:14\n   |\n15 |    \
    \ alphabet.push('\\0');\n   |              ^^^^ method not found in `Map<Chars<'_>,\
    \ _>`\n\nerror[E0599]: the method `len` exists for struct `Map<Chars<'_>, _>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp44e542qa.rs:16:26\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s: String = s;\n    let mut new: String = \"\";\n    let mut current_position\
    \ = 0;\n\n    while s != \"\" {\n        let mut current_char = s[current_position];\n\
    \        let mut next_char = s[current_position + 1];\n\n        if current_char\
    \ == 'a' || current_char == 'e' || current_char == 'i' || current_char == 'o'\
    \ || current_char == 'u' {\n            next_char = s[current_position - 2];\n\
    \        }\n\n        let mut new_char = current_char + next_char;\n        \n\
    \        if new_char >= 'A' && new_char <= 'Z' {\n            new_char -= ('A'\
    \ as u32);\n        }\n\n        if new_char >= 'a' && new_char <= 'z' {\n   \
    \         new_char -= ('a' as u32);\n        }\n\n        new += new_char;\n \
    \       current_position += 2;\n    }\n\n    new\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpxro1kboa.rs:26:25\n\
    \   |\n26 |             new_char -= ('A' as u32);\n   |                      \
    \   ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n26 -             new_char -= ('A' as u32);\n\
    26 +             new_char -= 'A' as u32;\n   | \n\nwarning: unnecessary parentheses\
    \ around assigned value\n  --> /tmp/tmpxro1kboa.rs:30:25\n   |\n30 |         \
    \    new_char -= ('a' as u32);\n   |                         ^          ^\n  \
    \ |\nhelp: remove these parentheses\n   |\n30 -             new_char -= ('a' as\
    \ u32);\n30 +             new_char -= 'a' as u32;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxro1kboa.rs:12:27\n   |\n12 |     let mut new: String =\
    \ \"\";\n   |                  ------   ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                  |        |\n   |                  |  \
    \      expected struct `String`, found `&str`\n   |                  expected\
    \ due to this\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpxro1kboa.rs:16:32\n   |\n16 |         let mut current_char = s[current_position];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpxro1kboa.rs:17:29\n   |\n17 |         let mut next_char = s[current_position\
    \ + 1];\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for i in s.chars().cloned() {\n        let n =\
    \ i;\n        n ^= n >> 4;\n        n ^= n >> 2;\n        n ^= n >> 1;\n     \
    \   n ^= n >> 3;\n        n ^= n >> 5;\n        result .= String::from_char(n);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `=`\n  --> /tmp/tmp9cynbzp4.rs:19:17\n   |\n19\
    \ |         result .= String::from_char(n);\n   |                 ^\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp9cynbzp4.rs:12:24\n\
    \     |\n12   |     for i in s.chars().cloned() {\n     |                    \
    \    ^^^^^^ expected reference, found `char`\n     |\n     = note: expected reference\
    \ `&_`\n                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp9cynbzp4.rs:12:14\n   |\n12 |     for i in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp9cynbzp4.rs:12:14\n   |\n12 |     for\
    \ i in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0599]: no function or associated item named\
    \ `from_char` found for struct `String` in the current scope\n  --> /tmp/tmp9cynbzp4.rs:19:27\n\
    \   |\n19 |         result .= String::from_char(n);\n   |                    \
    \       ^^^^^^^^^ function or associated item not found in `String`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.rotate_right(2).chars().map(|c|\
    \ c+1).collect::<String>()\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_right` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmplq6v4h95.rs:11:7\n   |\n11 |     s.rotate_right(2).chars().map(|c|\
    \ c+1).collect::<String>()\n   |       ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `trim_right`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ counter = 1;\n    let mut alphabet_size = s.len() + 1;\n    let alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\";\n    \n    let mut char_array: Vec<String> = s.chars().collect();\n\
    \    \n    let mut cipher: String = String::new();\n    \n    for i in char_array.iter()\
    \ {\n        cipher[counter] = alphabet[alphabet.index(i.to_string()) + counter\
    \ * 2];\n        counter = counter + 2;\n    }\n    \n    cipher\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmphb4gdyrw.rs:15:49\n     |\n15\
    \   |     let mut char_array: Vec<String> = s.chars().collect();\n     |     \
    \                                            ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `index` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmphb4gdyrw.rs:20:45\n   |\n20 |   \
    \      cipher[counter] = alphabet[alphabet.index(i.to_string()) + counter * 2];\n\
    \   |                                             ^^^^^ method not found in `&str`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmphb4gdyrw.rs:20:9\n   |\n20 |\
    \         cipher[counter] = alphabet[alphabet.index(i.to_string()) + counter *\
    \ 2];\n   |         ^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ cipherText = \"\";\n    for c in s.chars() {\n        let letter = c * 2;\n\
    \        let offset = letter - letter + 6;\n        cipherText += alphabet[offset];\n\
    \    }\n    return cipherText;\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpxl1m5vc1.rs:15:23\n\
    \   |\n15 |         cipherText += alphabet[offset];\n   |                    \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot multiply `char` by\
    \ `{integer}`\n  --> /tmp/tmpxl1m5vc1.rs:13:24\n   |\n13 |         let letter\
    \ = c * 2;\n   |                      - ^ - {integer}\n   |                  \
    \    |\n   |                      char\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxl1m5vc1.rs:17:12\n   |\n10 | fn encrypt(s: String) -> String {\n  \
    \ |                          ------ expected `String` because of return type\n\
    ...\n17 |     return cipherText;\n   |            ^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |            |\n   |            expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_letters(&s,\
    \ 1);\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_letters` in this scope\n  -->\
    \ /tmp/tmpoo_nv5qj.rs:11:5\n   |\n11 |     rotate_letters(&s, 1);\n   |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt(s.chars().collect::<Vec<_>>(),\
    \ s)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp08xfwhq7.rs:11:5\n   |\n11 |     encrypt(s.chars().collect::<Vec<_>>(),\
    \ s)\n   |     ^^^^^^^ -----------------------------  - supplied 2 arguments\n\
    \   |     |\n   |     expected 1 argument\n   |\nnote: function defined here\n\
    \  --> /tmp/tmp08xfwhq7.rs:10:4\n   |\n10 | fn encrypt(s: String) -> String {\n\
    \   |    ^^^^^^^ ---------\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ rotated_alphabet = Alphabet::new();\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if c.is_lowercase() {\n            rotated_alphabet.add_lowercase(c);\n\
    \        } else {\n            rotated_alphabet.add_uppercase(c);\n        }\n\
    \        if i % 2 == 0 {\n            rotated_alphabet.add_lowercase(Alphabet::ROTATE_ONE);\n\
    \        } else {\n            rotated_alphabet.add_uppercase(Alphabet::ROTATE_ONE);\n\
    \        }\n    }\n\n    let mut encrypted_alphabet_len = Alphabet::ROTATE_ONE.len;\n\
    \    let mut encrypted_alphabet = String::new();\n    for (i, c) in rotated_alphabet.chars().enumerate()\
    \ {\n        encrypted_alphabet.append(c.to_string());\n        if i % 2 == 0\
    \ {\n            encrypted_alphabet_len += Alphabet::ROTATE_ONE.len;\n       \
    \ } else {\n            encrypted_alphabet_len += Alphabet::ROTATE_TWO.len;\n\
    \        }\n    }\n    encrypted_alphabet += encrypted_alphabet_len.to_string();\n\
    \    encrypted_alphabet += \"0\"; // append a 0 to the end of the string\n   \
    \ encrypted_alphabet\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp8rhl8roc.rs:11:32\n   |\n11 |     let mut rotated_alphabet = Alphabet::new();\n\
    \   |                                ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmp8rhl8roc.rs:19:44\n\
    \   |\n19 |             rotated_alphabet.add_lowercase(Alphabet::ROTATE_ONE);\n\
    \   |                                            ^^^^^^^^ use of undeclared type\
    \ `Alphabet`\n\nerror[E0433]: failed to resolve: use of undeclared type `Alphabet`\n\
    \  --> /tmp/tmp8rhl8roc.rs:21:44\n   |\n21 |             rotated_alphabet.add_uppercase(Alphabet::ROTATE_ONE);\n\
    \   |                                            ^^^^^^^^ use of undeclared type\
    \ `Alphabet`\n\nerror[E0433]: failed to resolve: use of undeclared type `Alphabet`\n\
    \  --> /tmp/tmp8rhl8roc.rs:25:38\n   |\n25 |     let mut encrypted_alphabet_len\
    \ = Alphabet::ROTATE_ONE.len;\n   |                                      ^^^^^^^^\
    \ use of undeclared type `Alphabet`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Alphabet`\n  --> /tmp/tmp8rhl8roc.rs:30:39\n   |\n30 |    \
    \         encrypted_alphabet_len += Alphabet::ROTATE_ONE.len;\n   |          \
    \                             ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmp8rhl8roc.rs:32:39\n\
    \   |\n32 |             encrypted_alphabet_len += Alphabet::ROTATE_TWO.len;\n\
    \   |                                       ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp8rhl8roc.rs:28:28\n   |\n28 |         encrypted_alphabet.append(c.to_string());\n\
    \   |                            ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = vec!['A'..'Z'];\n    alphabet.rotate(2);\n    alphabet.swap_remove(0);\n\
    \n    let mut ciphertext = String::new();\n    ciphertext.resize(s.len());\n\n\
    \    for c in s.chars() {\n        let pos = alphabet.index(c).unwrap();\n   \
    \     ciphertext.insert(pos, c);\n    }\n\n    ciphertext\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<std::ops::Range<char>>`\
    \ in the current scope\n  --> /tmp/tmp7ho015hl.rs:12:14\n   |\n12 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `resize` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp7ho015hl.rs:16:16\n   |\n16 | \
    \    ciphertext.resize(s.len());\n   |                ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `index` found for struct `Vec<std::ops::Range<char>>`\
    \ in the current scope\n  --> /tmp/tmp7ho015hl.rs:19:28\n   |\n19 |         let\
    \ pos = alphabet.index(c).unwrap();\n   |                            ^^^^^ method\
    \ not found in `Vec<std::ops::Range<char>>`\n   |\n   = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = vec![2,1,5,3,6,4,7,8,9,10,11,12,13,14];\n    let mut encrypted_s = String::new();\n\
    \    for ch in s.chars() {\n        let mut encrypted_ch = ch;\n        for a\
    \ in alphabet {\n            encrypted_ch = encrypted_ch.rotate_left(a);\n   \
    \     }\n        encrypted_s.push_str(&encrypted_ch);\n    }\n    encrypted_s\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_left` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpbu3ykuvh.rs:16:41\n   |\n16 |             encrypted_ch\
    \ = encrypted_ch.rotate_left(a);\n   |                                       \
    \  ^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbu3ykuvh.rs:18:30\n   |\n18 |         encrypted_s.push_str(&encrypted_ch);\n\
    \   |                              ^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt(s.chars().collect::<String>(),\
    \ alphabet.size() - 2)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp8rmnzuse.rs:11:44\n\
    \   |\n11 |     encrypt(s.chars().collect::<String>(), alphabet.size() - 2)\n\
    \   |                                            ^^^^^^^^ not found in this scope\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp8rmnzuse.rs:11:5\n   |\n11 |     encrypt(s.chars().collect::<String>(),\
    \ alphabet.size() - 2)\n   |     ^^^^^^^ -----------------------------  -------------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmp8rmnzuse.rs:10:4\n   |\n10 | fn encrypt(s:\
    \ String) -> String {\n   |    ^^^^^^^ ---------\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotate_string(s)\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_string` in this scope\n  -->\
    \ /tmp/tmp3gcei2bl.rs:11:5\n   |\n11 |     rotate_string(s)\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().for_each(|c|\
    \ {\n        let d = c - 'a';\n        d += 2;\n        if d >= 26 {\n       \
    \     d = d - 26;\n        }\n        c += 'a' + d.to_ascii_lowercase()\n    })\n\
    \    .collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpigdci9io.rs:12:19\n\
    \   |\n12 |         let d = c - 'a';\n   |                 - ^ --- char\n   |\
    \                 |\n   |                 char\n\nerror[E0599]: `()` is not an\
    \ iterator\n  --> /tmp/tmpigdci9io.rs:19:6\n   |\n19 |     .collect()\n   |  \
    \    ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|x|\
    \ match x {\n        'a' => 1,\n        'b' => 2,\n        'c' => 3,\n       \
    \ 'd' => 4,\n        'e' => 5,\n        'f' => 6,\n        'g' => 7,\n       \
    \ 'h' => 8,\n        'i' => 9,\n        'j' => 10,\n        'k' => 11,\n     \
    \   'l' => 12,\n        'm' => 13,\n        'n' => 14,\n        'o' => 15,\n \
    \       'p' => 16,\n        'q' => 17,\n        'r' => 18,\n        's' => 19,\n\
    \        't' => 20,\n        'u' => 21,\n        'v' => 22,\n        'w' => 23,\n\
    \        'x' => 24,\n        'y' => 25,\n        'z' => 26,\n        _ => unreachable!(),\n\
    \    }).collect::<Vec<_>>().iter().map(|x| x + 2i32 + 2).collect::<Vec<_>>().map(|x|\
    \ x + 32).collect::<Vec<_>>().join(\"@\")\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<i32>` is not an iterator\n   --> /tmp/tmpaitk24cf.rs:39:77\n\
    \    |\n39  |       }).collect::<Vec<_>>().iter().map(|x| x + 2i32 + 2).collect::<Vec<_>>().map(|x|\
    \ x + 32).collect::<Vec<_>>().join(\"@\")\n    |                             \
    \                                                  ^^^ `Vec<i32>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<i32>: Iterator`\n            which is required by `&mut Vec<i32>: Iterator`\n\
    \            `[i32]: Iterator`\n            which is required by `&mut [i32]:\
    \ Iterator`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s.to_lowercase();\n    s.rotate_left(2)\n        .iter()\n        .fold(s.to_string(),\
    \ |s| s.to_string() + s.to_string() + s.to_string());\n    s\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp5la30fo5.rs:12:7\n   |\n12 |     s.rotate_left(2)\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|&c|\
    \ c).fold(\"\".to_string(), |out, c| {\n        out += &c.rotate_left(2).to_string();\n\
    \        out[out.len() - 2..].rotate_left(1).to_string();\n        out\n    })\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6mceacz_.rs:11:20\n   |\n\
    11 |     s.chars().map(|&c| c).fold(\"\".to_string(), |out, c| {\n   |       \
    \             ^--\n   |                    ||\n   |                    |expected\
    \ due to this\n   |                    expected `char`, found reference\n   |\
    \                    help: did you mean `c`: `&char`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `rotate_left` found for type `str` in the current scope\n  --> /tmp/tmp6mceacz_.rs:13:30\n\
    \   |\n13 |         out[out.len() - 2..].rotate_left(1).to_string();\n   |   \
    \                           ^^^^^^^^^^^ method not found in `str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s.replace(s.chars().collect::<Vec<&str>>(), \"\");\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n    s = s.rotate_left(2).collect();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpwot2m352.rs:11:37\n     |\n11\
    \   |     let mut s = s.replace(s.chars().collect::<Vec<&str>>(), \"\");\n   \
    \  |                                     ^^^^^^^ value of type `Vec<&str>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `Vec<&str>`\n\
    \   --> /tmp/tmpwot2m352.rs:11:27\n    |\n11  |     let mut s = s.replace(s.chars().collect::<Vec<&str>>(),\
    \ \"\");\n    |                   ------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ an `FnMut<(char,)>` closure, found `Vec<&str>`\n    |                   |\n\
    \    |                   required by a bound introduced by this call\n    |\n\
    \    = help: the trait `FnMut<(char,)>` is not implemented for `Vec<&str>`\n \
    \   = help: the following other types implement trait `Pattern<'a>`:\n       \
    \       &'b String\n              &'b [char; N]\n              &'b [char]\n  \
    \            &'b str\n              &'c &'b str\n              [char; N]\n   \
    \           char\n              pattern::MultiCharEqPattern<C>\n    = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `Vec<&str>`\nnote:\
    \ required by a bound in `str::<impl str>::replace`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpwot2m352.rs:12:11\n\
    \   |\n12 |     s = s.rotate_left(2).collect();\n   |           ^^^^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `concat` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpwot2m352.rs:13:11\n   |\n13 | \
    \    s = s.concat(&[s.chars().collect::<Vec<&str>>()]);\n   |           ^^^^^^\
    \ method not found in `String`\n\nerror[E0277]: a value of type `Vec<&str>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpwot2m352.rs:13:3"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s.to_string();\n    for i in s.chars().cloned().rev() {\n        let mut\
    \ t = i;\n        let mut c = i;\n        let mut d = i;\n        while c != 'a'\
    \ && c != 'b'\n            && c != 'c' && c != 'd'\n            && c != 'e' &&\
    \ c != 'f'\n            && c != 'g' && c != 'h'\n            && c != 'j' && c\
    \ != 'k'\n            && c != 'l' && c != 'n'\n            && c != 'p' && c !=\
    \ 'q'\n            && c != 'r' && c != 's'\n            && c != 't' && c != 'v'\n\
    \            && c != 'w' && c != 'x'\n            && c != 'y' && c != 'z'\n  \
    \      {\n            c = c + 1;\n            d = d + 2;\n        }\n        t\
    \ = t - 1;\n        if t < 0 {\n            t = 0;\n        }\n        s = String::from_utf8(c.to_bytes(1,\
    \ 'big')) + s.to_string() + String::from_utf8(d.to_bytes(1, 'big'));\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmps6_3bpz0.rs:35:45\n\
    \   |\n35 |         s = String::from_utf8(c.to_bytes(1, 'big')) + s.to_string()\
    \ + String::from_utf8(d.to_bytes(1, 'big'));\n   |                           \
    \                  ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n35 |         s = String::from_utf8(c.to_bytes(1, \"big\"\
    )) + s.to_string() + String::from_utf8(d.to_bytes(1, 'big'));\n   |          \
    \                                   ~~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmps6_3bpz0.rs:35:103\n   |\n35 |        \
    \ s = String::from_utf8(c.to_bytes(1, 'big')) + s.to_string() + String::from_utf8(d.to_bytes(1,\
    \ 'big'));\n   |                                                             \
    \                                          ^^^^^\n   |\nhelp: if you meant to\
    \ write a `str` literal, use double quotes\n   |\n35 |         s = String::from_utf8(c.to_bytes(1,\
    \ 'big')) + s.to_string() + String::from_utf8(d.to_bytes(1, \"big\"));\n   | \
    \                                                                            \
    \                          ~~~~~\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmps6_3bpz0.rs:12:24\n     |\n12   |\
    \     for i in s.chars().cloned().rev() {\n     |                        ^^^^^^\
    \ expected reference, found `char`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `rev` exists for struct `Cloned<Chars<'_>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmps6_3bpz0.rs:12:33\n   |\n12 |\
    \       for i in s.chars().cloned().rev() {\n   |                            \
    \       ^^^ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Chars<'_> as Iterator>::Item = &_`\n           which is required\
    \ by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n\
    \           which is require"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = String::from(\"abcdefghijklmnopqrstuvwxyz\".to_string());\n    for i in\
    \ s.chars().enumerate().skip(2) {\n        let (first, second) = i.1;\n      \
    \  s.insert(second, first);\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5b35lp8i.rs:13:13\n   |\n\
    13 |         let (first, second) = i.1;\n   |             ^^^^^^^^^^^^^^^   ---\
    \ this expression has type `char`\n   |             |\n   |             expected\
    \ `char`, found tuple\n   |\n   = note: expected type `char`\n             found\
    \ tuple `(_, _)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ x = s.chars().cloned().enumerate();\n    x.sort_by_key(|&(a, b)| (*a as usize)\
    \ < (*b as usize));\n    let mut a = x.next();\n    let mut b = x.next();\n  \
    \  let mut c = x.next();\n    let mut d = x.next();\n    let mut e = x.next();\n\
    \    loop {\n        if a != c.1 {\n            x.next();\n            e = x.next();\n\
    \        }\n        if b != d.1 {\n            x.next();\n            d = x.next();\n\
    \        }\n        if a != b.1 {\n            x.next();\n            c = x.next();\n\
    \        }\n        if b != e.1 {\n            x.next();\n            e = x.next();\n\
    \        }\n        if c != d.1 {\n            x.next();\n            d = x.next();\n\
    \        }\n        if d != e.1 {\n            x.next();\n            e = x.next();\n\
    \        }\n        if a == c.1 {\n            let mut t = a.1;\n            a\
    \ = b.1;\n            b = t;\n        }\n        if b == d.1 {\n            let\
    \ mut t = b.1;\n            b = c.1;\n            c = t;\n        }\n        if\
    \ a == b.1 {\n            let mut t = a.1;\n            a = c.1;\n           \
    \ c = t;\n        }\n        if b == e.1 {\n            let mut t = b.1;\n   \
    \         b = d.1;\n            d = t;\n        }\n        if c == d.1 {\n   \
    \         let mut t = c.1;\n            c = e.1;\n            e = t;\n       \
    \ }\n        if d == e.1 {\n            let mut t = d.1;\n            d = e.1;\n\
    \            e = t;\n        }\n    }\n    let mut x = s.chars().cloned().enumerate();\n\
    \    x.sort_by_key(|&(a, b)| (*a as usize) < (*b as usize));\n    let mut a =\
    \ x.next();\n    let mut b = x.next();\n    let mut c = x.next();\n    let mut\
    \ d = x.next();\n    let mut e = x.next();\n    loop {\n        if a != c.1 {\n\
    \            x.next();\n            e = x.next();\n        }\n        if b !=\
    \ d.1 {\n            x.next();\n            d = x.next();\n        }\n       \
    \ if a != b.1 {\n            x.next();\n            c = x.next();\n        }\n\
    \        if b != e.1 {\n            x.next();\n            e = x.next();\n   \
    \     }\n        if c != d.1 {\n            x.next();\n            d = x.next();\n\
    \        }\n        if d != e.1 {\n            x.next();\n            e = x.next();\n\
    \        }\n        if a == c.1 {\n            let mut t = a.1;\n            a\
    \ = b.1;\n            b = t;\n        }\n        if b == d.1 {\n            let\
    \ mut t = b.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_5o6zpqv.rs:125:3\n\
    \    |\n10  | fn encrypt(s: String) -> String {\n    |                       \
    \          - unclosed delimiter\n...\n81  |     loop {\n    |          - unclosed\
    \ delimiter\n...\n111 |         if b == d.1 {\n    |                     - this\
    \ delimiter might not be properly closed...\n112 |             let mut t = b.\n\
    113 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    125 | }\n    |   ^\n\nerror: unexpected token: `}`\n   --> /tmp/tmp_5o6zpqv.rs:113:1\n\
    \    |\n113 | }\n    | ^\n\nerror: expected `;`, found `}`\n   --> /tmp/tmp_5o6zpqv.rs:112:27\n\
    \    |\n112 |             let mut t = b.\n    |                           ^ help:\
    \ add `;` here\n113 | }\n    | - unexpected token\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp_5o6zpqv.rs:11:27\n\
    \     |\n11   |     let mut x = s.chars().cloned().enumerate();\n     |      \
    \                     ^^^^^^ expected reference, found `char`\n     |\n     =\
    \ note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `enumerate` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmp_5o6zpqv.rs:11:36\n   |\n11 |       let mut x = s.chars().cloned().enumerate();\n\
    \   |                                      ^^^^^^^^^ method cannot be called on\
    \ `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nwarning: unreachable statement\n  --> /tmp/tmp_5o6zpqv.rs:74:5\n\
    \   |\n18 | /     loop {\n19 | |         if a != c.1 {\n20 | |             x.next();\n\
    21 | |             e = x.next();\n...  |\n72 | |         }\n73 | |     }\n   |\
    \ |_____- any code following this expression is unreachable\n74 |       let mut\
    \ x = s.chars("
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ c.to_digit(2).to_string()).collect::<Vec<_>>().iter().\n            zip(s.chars().map(|c|\
    \ c.to_digit(10).to_string()).collect::<Vec<_>>()).\n            filter(|(a, b)|\
    \ !a.is_empty() && !b.is_empty()).\n            map(|(a, b)| a.to_string().to_digit(2).to_string().to_string()\
    \ +\n                      b.to_string().to_digit(2).to_string().to_string()).\n\
    \            collect::<Vec<_>>().iter().\n            zip((0..s.len() - 1).map(|i|\
    \ (s.len() + 1).to_string()).collect::<Vec<_>>()).\n            map(|(a, b)| a.to_string().to_digit(10).to_string()\
    \ + b.to_string()).\n            collect::<Vec<_>>().iter().\n            map(|(a,\
    \ b)| a.to_string().to_digit(2).to_string() + b.to_string()).\n            collect::<Vec<_>>().iter().\n\
    \            map(|(a, b)| (*a + b).to_string()).\n            collect::<Vec<_>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<u32>` doesn't implement `std::fmt::Display`\n   -->\
    \ /tmp/tmpw3sr47wo.rs:11:37\n    |\n11  |       s.chars().map(|c| c.to_digit(2).to_string()).collect::<Vec<_>>().iter().\n\
    \    |                                       ^^^^^^^^^ `Option<u32>` cannot be\
    \ formatted with the default formatter\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Option<u32>: std::fmt::Display`\n \
    \           which is required by `Option<u32>: ToString`\n\nerror[E0599]: `Option<u32>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpw3sr47wo.rs:12:50\n  \
    \  |\n12  |               zip(s.chars().map(|c| c.to_digit(10).to_string()).collect::<Vec<_>>()).\n\
    \    |                                                    ^^^^^^^^^ `Option<u32>`\
    \ cannot be formatted with the default formatter\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<u32>: std::fmt::Display`\n\
    \            which is required by `Option<u32>: ToString`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    rotated_alphabet(s).to_owned()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotated_alphabet` in this scope\n \
    \ --> /tmp/tmpn5_ohr6a.rs:11:5\n   |\n11 |     rotated_alphabet(s).to_owned()\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().fold(\"\
    \", |acc: String, c| {\n        let num = *c.to_ascii_lowercase().unwrap() - *acc.to_ascii_lowercase().unwrap()\n\
    \        num % 26 + 65 + 2\n    })\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `num`\n  --> /tmp/tmpm2izm6am.rs:12:88\n   |\n\
    12 |         let num = *c.to_ascii_lowercase().unwrap() - *acc.to_ascii_lowercase().unwrap()\n\
    \   |                                                                        \
    \                ^ help: add `;` here\n13 |         num % 26 + 65 + 2\n   |  \
    \       --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm2izm6am.rs:11:20\n\
    \   |\n11 |     s.chars().fold(\"\", |acc: String, c| {\n   |                \
    \    ^^- help: try using a conversion method: `.to_string()`\n   |           \
    \         |\n   |                    expected struct `String`, found `&str`\n\n\
    error[E0599]: no method named `unwrap` found for type `char` in the current scope\n\
    \  --> /tmp/tmpm2izm6am.rs:12:43\n   |\n12 |         let num = *c.to_ascii_lowercase().unwrap()\
    \ - *acc.to_ascii_lowercase().unwrap()\n   |                                 \
    \          ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpm2izm6am.rs:12:80\n\
    \   |\n12 |         let num = *c.to_ascii_lowercase().unwrap() - *acc.to_ascii_lowercase().unwrap()\n\
    \   |                                                                        \
    \        ^^^^^^ method not found in `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(s.chars().map(|c|\
    \ rotate_alphabet_left(c)).collect())\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_alphabet_left` in this scope\n\
    \  --> /tmp/tmp71tjxin9.rs:11:36\n   |\n11 |     String::from(s.chars().map(|c|\
    \ rotate_alphabet_left(c)).collect())\n   |                                  \
    \  ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    s.rotate_right(2);\n    s\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_right` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp4h2ghlfs.rs:12:7\n   |\n12 |     s.rotate_right(2);\n\
    \   |       ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trim_right`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s;\n    s.rotate_left(2);\n    s.rotate_left(2);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpa8n6tcrz.rs:12:7\n   |\n12 |     s.rotate_left(2);\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpa8n6tcrz.rs:13:7\n\
    \   |\n13 |     s.rotate_left(2);\n   |       ^^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ a = alphabet.clone();\n    a.rotate_by(1);\n    a.rotate_left(1);\n    let mut\
    \ result = s.clone();\n    result.rotate_left((a.len()+1).log2());\n    a.rotate_left(1);\n\
    \    a.rotate_left(1);\n    let mut i = 1;\n    loop {\n        if i > s.len()\
    \ {\n            return result;\n        }\n        if s[i] == a[0] {\n      \
    \      result[i] = a[1];\n        } else {\n            result[i] = a[0];\n  \
    \      }\n        i += 1;\n    }\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpuhdtwbxi.rs:11:17\n\
    \   |\n11 |     let mut a = alphabet.clone();\n   |                 ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `rotate_left` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpuhdtwbxi.rs:15:12\n   |\n\
    15 |     result.rotate_left((a.len()+1).log2());\n   |            ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpuhdtwbxi.rs:23:12\n   |\n23 |         if s[i] == a[0]\
    \ {\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuhdtwbxi.rs:24:13\n   |\n24 |             result[i] = a[1];\n \
    \  |             ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuhdtwbxi.rs:26:13\n   |\n26 |             result[i] = a[0];\n \
    \  |             ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the fol"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.add_letter('t');\n    alphabet.add_letter('w');\n\
    \    alphabet.add_letter('e');\n    alphabet.add_letter('r');\n    alphabet.add_letter('s');\n\
    \    alphabet.add_letter('q');\n    alphabet.add_letter('u');\n    alphabet.add_letter('p');\n\
    \    alphabet.add_letter('a');\n    alphabet.add_letter('f');\n    alphabet.add_letter('d');\n\
    \    alphabet.add_letter('g');\n    alphabet.add_letter('h');\n    alphabet.add_letter('k');\n\
    \    alphabet.add_letter('j');\n    alphabet.add_letter('l');\n    alphabet.add_letter('n');\n\
    \    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n    alphabet.add_letter('q');\n\
    \    alphabet.add_letter('v');\n    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n\
    \    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n\
    \    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n\
    \    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n\
    \    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n\
    \    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n\
    \    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n\
    \    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n\
    \    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n\
    \    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n\
    \    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n\
    \    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n\
    \    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n\
    \    alphabet.add_letter('z');\n    alphabet.add_letter('x');\n    alphabet.add_letter('z');\n\
    \    alphabet.add_letter('x');\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp8u7a0jxv.rs:11:24\n   |\n11 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8u7a0jxv.rs:10:26\n   |\n10 | fn encrypt(s:\
    \ String) -> String {\n   |    -------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
