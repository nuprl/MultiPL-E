name: HumanEval_145_order_by_points
language: rust
results:
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .filter_map(|(i, num)| {\n            // Find two items with same sum\n\
    \            fn find_pair_sum(pair: (isize, isize), sum: isize) -> Option<(isize,\
    \ isize)> {\n                if pair.0 == i || pair.0 == sum {\n             \
    \       return None;\n                }\n\n                let mut s = pair.0\
    \ + pair.1; // Sum two items\n                if s == i || s == sum {\n      \
    \              return Some(pair);\n                }\n\n                let mut\
    \ t = s - sum; // Difference two items\n                if t == i || t == sum\
    \ {\n                    return Some(pair);\n                }\n\n           \
    \     let mut u = t - sum; // Same as above\n                if u == i || u ==\
    \ sum {\n                    return Some(pair);\n                }\n         \
    \       return None;\n            }\n\n            // Remove duplicate pair\n\
    \            |&(i, &num)| find_pair_sum(i, num).map(|pair| (i, num))\n       \
    \ })\n        .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpequw49gn.rs:15:30\n\
    \   |\n15 |                 if pair.0 == i || pair.0 == sum {\n   |          \
    \                    ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\
    \nerror[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpequw49gn.rs:20:25\n\
    \   |\n20 |                 if s == i || s == sum {\n   |                    \
    \     ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]:\
    \ can't capture dynamic environment in a fn item\n  --> /tmp/tmpequw49gn.rs:25:25\n\
    \   |\n25 |                 if t == i || t == sum {\n   |                    \
    \     ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]:\
    \ can't capture dynamic environment in a fn item\n  --> /tmp/tmpequw49gn.rs:30:25\n\
    \   |\n30 |                 if u == i || u == sum {\n   |                    \
    \     ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpequw49gn.rs:37:13\n   |\n37 |             |&(i,\
    \ &num)| find_pair_sum(i, num).map(|pair| (i, num))\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found closure\n   |\n   = note: expected enum `Option<_>`\n\
    \           found closure `[closure@/tmp/tmpequw49gn.rs:37:13: 37:68]`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n37 |             Some(|&(i, &num)|\
    \ find_pair_sum(i, num).map(|pair| (i, num)))\n   |             +++++        \
    \                                               +\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0434.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .sort_by_key(|&n| n.leading_digits())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmplqjm3vhv.rs:12:10\n   |\n12 |         .sort_by_key(|&n|\
    \ n.leading_digits())\n   |          ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut s = nums.iter().map(|&x| x.to_digits()).sum::<isize>();\n\
    \    s.sort_unstable_by_key(|&a| a.to_digits());\n    s.collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n --> /tmp/tmpjvlxyjg7.rs:9:40\n  |\n9 |     let mut s = nums.iter().map(|&x|\
    \ x.to_digits()).sum::<isize>();\n  |                                        ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `sort_unstable_by_key`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpjvlxyjg7.rs:10:7\n\
    \   |\n10 |     s.sort_unstable_by_key(|&a| a.to_digits());\n   |       ^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: `isize` is not an iterator\n  -->\
    \ /tmp/tmpjvlxyjg7.rs:11:7\n   |\n11 |     s.collect::<Vec<isize>>()\n   |   \
    \    ^^^^^^^ `isize` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `isize: Iterator`\n           which is\
    \ required by `&mut isize: Iterator`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sums: Vec<isize> = nums.iter().cloned().map(|i|\
    \ i as isize).collect();\n    sums.sort_unstable_by(|x, y| x + y);\n    sums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpse2rpug_.rs:10:34\n   |\n\
    10 |     sums.sort_unstable_by(|x, y| x + y);\n   |                          \
    \        ^^^^^ expected enum `std::cmp::Ordering`, found `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(nums.is_sorted());\n\n    let\
    \ mut points = [0; 10];\n    let mut index = 0;\n\n    for num in nums {\n   \
    \     points[num % 10] += 1;\n        index += 1;\n    }\n\n    let mut res =\
    \ vec![nums[0]; 10];\n    let mut offset = 0;\n    let mut sum = 0;\n\n    for\
    \ point in &points {\n        sum += point as isize;\n        while index > 0\
    \ && sum > 0 {\n            let mut current_sum = sum;\n            let mut min_idx\
    \ = index;\n\n            for i in 0..index {\n                let mut d = current_sum\
    \ % 10 - nums[i as usize - 1] % 10;\n                if d == 0 {\n           \
    \         break;\n                }\n                current_sum -= d;\n     \
    \           min_idx += 1;\n            }\n\n            sum += nums[min_idx as\
    \ usize - 1] % 10 - current_sum % 10;\n            res[offset] += 1;\n       \
    \     index -= 1;\n            offset += 1;\n        }\n    }\n\n    res\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n -->\
    \ /tmp/tmpa_q6cpsb.rs:9:24\n  |\n9 |     debug_assert!(nums.is_sorted());\n  |\
    \                        ^^^^^^^^^\n  |\n  = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpa_q6cpsb.rs:15:9\n   |\n15 |         points[num %\
    \ 10] += 1;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[{integer}]`\n\nerror[E0606]: casting `&{integer}` as `isize`\
    \ is invalid\n  --> /tmp/tmpa_q6cpsb.rs:24:16\n   |\n24 |         sum += point\
    \ as isize;\n   |                -----^^^^^^^^^\n   |                |\n   | \
    \               cannot cast `&{integer}` as `isize`\n   |                help:\
    \ dereference the expression: `*point`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0606, E0658.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    for num in nums\
    \ {\n        let mut cur = num;\n        let mut total = 0;\n        while cur\
    \ > 0 {\n            total += cur % 10;\n            cur /= 10;\n        }\n \
    \       if total >= 0 {\n            res.push(total);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 0, 0, 0]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpttlwesgj.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums\n        .iter()\n    \
    \    .map(|x| x.to_digit())\n        .collect::<Vec<_>>();\n\n    let mut sum_of_digits\
    \ = nums.iter().sum::<isize>();\n\n    let mut nums_sorted = vec![];\n    let\
    \ mut i = 0;\n\n    // Sorting while summing the digits\n    while i < nums.len()\
    \ {\n        // Summing while sorting by digit\n        let mut sum = 0;\n   \
    \     for j in i .. nums.len() {\n            sum += nums[j].to_digit();\n   \
    \     }\n        if sum < sum_of_digits {\n            let temp = nums[i];\n \
    \           nums[i] = nums[sum_of_digits];\n            nums[sum_of_digits] =\
    \ temp;\n        }\n        i += 1;\n        sum_of_digits -= nums[i].to_digit();\n\
    \    }\n\n    nums_sorted.extend(nums.iter().cloned());\n\n    nums_sorted.sort_unstable_by_key(|x|\
    \ x.to_digit());\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digit` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp04cowkea.rs:11:20\n   |\n11 |         .map(|x|\
    \ x.to_digit())\n   |                    ^^^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `to_digit` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp04cowkea.rs:24:28\n   |\n24 |             sum += nums[j].to_digit();\n\
    \   |                            ^^^^^^^^ method not found in `isize`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp04cowkea.rs:28:23\n\
    \   |\n28 |             nums[i] = nums[sum_of_digits];\n   |                 \
    \      ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp04cowkea.rs:29:13\n\
    \   |\n29 |             nums[sum_of_digits] = temp;\n   |             ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `to_digit` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp04cowkea.rs:32:34\n   |\n32 |         sum_of_digits -= nums[i].to_digit();\n\
    \   |                                  ^^^^^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `to_digit` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmp04cowkea.rs:37:44\n   |\n37 |     nums_sorted.sort_unstable_by_key(|x|\
    \ x.to_digit());\n   |                                            ^^^^^^^^ method\
    \ not found in `&isize`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.to_vec();\n    nums_copy.sort_by_key(|x|\
    \ {\n        let mut ans = x;\n        ans = ans.checked_mul(10).ok_or(\"Input\
    \ numbers should be non-negative\")?;\n        ans.checked_add(10).ok_or(\"Input\
    \ numbers should be non-negative\")?;\n        ans\n    });\n    nums_copy\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: `?` operator has incompatible types\n  --> /tmp/tmpk9dtmsj4.rs:12:15\n\
    \   |\n12 |         ans = ans.checked_mul(10).ok_or(\"Input numbers should be\
    \ non-negative\")?;\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |               |\n   |               expected `&isize`, found `isize`\n \
    \  |               help: consider borrowing here: `&ans.checked_mul(10).ok_or(\"\
    Input numbers should be non-negative\")?`\n   |\n   = note: `?` operator cannot\
    \ convert from `isize` to `&isize`\nnote: return type inferred to be `&isize`\
    \ here\n  --> /tmp/tmpk9dtmsj4.rs:12:15\n   |\n12 |         ans = ans.checked_mul(10).ok_or(\"\
    Input numbers should be non-negative\")?;\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: the `?` operator can only be used in a closure that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmpk9dtmsj4.rs:12:80\n\
    \   |\n10 |       nums_copy.sort_by_key(|x| {\n   |  ___________________________-\n\
    11 | |         let mut ans = x;\n12 | |         ans = ans.checked_mul(10).ok_or(\"\
    Input numbers should be non-negative\")?;\n   | |                            \
    \                                                    ^ cannot use the `?` operator\
    \ in a closure that returns `&isize`\n13 | |         ans.checked_add(10).ok_or(\"\
    Input numbers should be non-negative\")?;\n14 | |         ans\n15 | |     });\n\
    \   | |_____- this function should return `Result` or `Option` to accept `?`\n\
    \   |\n   = help: the trait `FromResidual<Result<Infallible, &str>>` is not implemented\
    \ for `&isize`\n\nerror[E0277]: the `?` operator can only be used in a closure\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpk9dtmsj4.rs:13:74\n   |\n10 |       nums_copy.sort_by_key(|x| {\n\
    \   |  ___________________________-\n11 | |         let mut ans = x;\n12 | | \
    \        ans = ans.checked_mul(10).ok_or(\"Input numbers should be non-negative\"\
    )?;\n13 | |         ans.checked_add(10).ok_or(\"Input numbers should be non-ne"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n\
    \    let mut digits = Vec::new();\n    for n in nums {\n        digits.push(n.to_string().chars().filter(|c|\
    \ c >= '0' && c <= '9').count());\n    }\n    for (i, n) in digits.iter().enumerate()\
    \ {\n        result.push(n - digits[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1b8xm6d_.rs:12:59\n   |\n\
    12 |         digits.push(n.to_string().chars().filter(|c| c >= '0' && c <= '9').count());\n\
    \   |                                                           ^^^\n   |    \
    \                                                       |\n   |              \
    \                                             expected `&char`, found `char`\n\
    \   |                                                           help: consider\
    \ borrowing here: `&'0'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1b8xm6d_.rs:12:71\n\
    \   |\n12 |         digits.push(n.to_string().chars().filter(|c| c >= '0' && c\
    \ <= '9').count());\n   |                                                    \
    \                   ^^^\n   |                                                \
    \                       |\n   |                                              \
    \                         expected `&char`, found `char`\n   |               \
    \                                                        help: consider borrowing\
    \ here: `&'9'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1b8xm6d_.rs:15:21\n\
    \   |\n15 |         result.push(n - digits[i]);\n   |                     ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |         result.push((n\
    \ - digits[i]).try_into().unwrap());\n   |                     +             +++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sums = vec![0; nums.len()];\n    for\
    \ i in 0..nums.len() {\n        sums[i] = nums[i] * 10 + nums[i];\n    }\n   \
    \ sums.iter().map(|n| n.clone()).for_each(|n| {\n        let mut i = nums.iter().cloned().skip(1);\n\
    \        while *i < n {\n            *i = *i + 1;\n            i += 1;\n     \
    \   }\n    });\n    nums.iter().cloned().for_each(|n| {\n        let mut i = sums.iter().cloned().skip(1);\n\
    \        while *i < n {\n            *i = *i + 1;\n            i += 1;\n     \
    \   }\n    });\n    nums.iter().cloned().collect()\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Skip<Cloned<std::slice::Iter<'_, isize>>>` cannot be\
    \ dereferenced\n  --> /tmp/tmptja8cev8.rs:15:15\n   |\n15 |         while *i <\
    \ n {\n   |               ^^\n\nerror[E0614]: type `Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>` cannot be dereferenced\n  --> /tmp/tmptja8cev8.rs:16:13\n   |\n16\
    \ |             *i = *i + 1;\n   |             ^^\n\nerror[E0614]: type `Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>` cannot be dereferenced\n  --> /tmp/tmptja8cev8.rs:16:18\n   |\n16\
    \ |             *i = *i + 1;\n   |                  ^^\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n  --> /tmp/tmptja8cev8.rs:17:13\n   |\n17 |             i += 1;\n\
    \   |             -^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `Skip<Cloned<std::slice::Iter<'_, isize>>>`\n\nerror[E0614]: type `Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>` cannot be dereferenced\n  --> /tmp/tmptja8cev8.rs:22:15\n   |\n22\
    \ |         while *i < n {\n   |               ^^\n\nerror[E0614]: type `Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>` cannot be dereferenced\n  --> /tmp/tmptja8cev8.rs:23:13\n   |\n23\
    \ |             *i = *i + 1;\n   |             ^^\n\nerror[E0614]: type `Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>` cannot be dereferenced\n  --> /tmp/tmptja8cev8.rs:23:18\n   |\n23\
    \ |             *i = *i + 1;\n   |                  ^^\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n  --> /tmp/tmptja8cev8.rs:24:13\n   |\n24 |             i += 1;\n\
    \   |             -^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `Skip<Cloned<std::slice::Iter<'_, isize>>>`\n\nerror: aborting due to\
    \ 8 previous errors\n\nSome errors have detailed explanations: E0368, E0614.\n\
    For more information about an error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sums = vec![];\n    for i in nums {\n\
    \        sums.push(i::isize);\n    }\n    sums.sort_by_key(|x| x.checked_add());\n\
    \    sums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `i`\n\
    \  --> /tmp/tmp8sqv1ssn.rs:11:19\n   |\n11 |         sums.push(i::isize);\n  \
    \ |                   ^ use of undeclared crate or module `i`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    order_by_digits(&mut\
    \ nums_sorted);\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `order_by_digits` in this scope\n  -->\
    \ /tmp/tmpgwrrzknt.rs:10:5\n   |\n10 |     order_by_digits(&mut nums_sorted);\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    //\
    \ Sort the list in reverse order according to the sum of their digits\n    sorted_nums.sort_by_key(|x|\
    \ x.checked_div10().unwrap_or(0));\n    sorted_nums\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_div10` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpdjg4huld.rs:11:35\n   |\n11 |     sorted_nums.sort_by_key(|x|\
    \ x.checked_div10().unwrap_or(0));\n   |                                   ^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `checked_div`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, item)| {\n            let mut sum = 0;\n            let mut\
    \ num = item;\n            while num != 0 {\n                sum += num % 10;\n\
    \                num /= 10;\n            }\n            sum\n        })\n    \
    \    .sort_unstable()\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpp2z5r411.rs:15:23\n\
    \   |\n15 |             while num != 0 {\n   |                       ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&isize`\n  --> /tmp/tmpp2z5r411.rs:17:17\n \
    \  |\n17 |                 num /= 10;\n   |                 ---^^^^^^\n   |  \
    \               |\n   |                 cannot use `/=` on type `&isize`\n   |\n\
    help: `/=` can be used on `isize`, you can dereference `num`\n   |\n17 |     \
    \            *num /= 10;\n   |                 +\n\nerror[E0599]: no method named\
    \ `sort_unstable` found for struct `Map` in the current scope\n  --> /tmp/tmpp2z5r411.rs:21:10\n\
    \   |\n21 |         .sort_unstable()\n   |          ^^^^^^^^^^^^^ method not found\
    \ in `Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpp2z5r411.rs:12:14:\
    \ 20:10]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0368, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sums = Vec::new();\n    nums_copy.sort_unstable();\n    for num in nums_copy\
    \ {\n        sums.push(num);\n    }\n    let mut min_sum = isize::MAX;\n    let\
    \ mut min_pos = Vec::new();\n    for i in 0..sums.len() {\n        let mut current_sum\
    \ = sums[i];\n        let mut pos = i;\n        for (j, &v) in sums.iter().enumerate()\
    \ {\n            if j == i {\n                continue;\n            }\n     \
    \       if v < current_sum {\n                current_sum = v;\n             \
    \   pos = j;\n            }\n        }\n        min_sum = min_sum.min(current_sum);\n\
    \        min_pos.push(pos);\n    }\n    let mut res = vec![];\n    for i in min_pos.iter().rev()\
    \ {\n        res.push(nums[*i]);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp71rushle.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_len = nums.len();\n    let mut\
    \ num_sum = 0;\n    for &num in nums {\n        num_sum += num;\n    }\n    let\
    \ mut nums_buffer = Vec::new();\n    let mut index_of_num_sum = 0;\n    for &num\
    \ in nums {\n        if num_sum == num {\n            nums_buffer.push(num);\n\
    \            index_of_num_sum += num;\n        } else {\n            index_of_num_sum\
    \ += num;\n            if index_of_num_sum < num_sum {\n                nums_buffer.push(num);\n\
    \                index_of_num_sum += num;\n            }\n        }\n    }\n \
    \   nums_buffer\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphpzm77oh.rs:11:9\n   |\n\
    11 |     for &num in nums {\n   |         ^^^^    ---- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphpzm77oh.rs:16:9\n   |\n16 |     for &num in\
    \ nums {\n   |         ^^^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `num`\n   |\n   = note: \
    \  expected type `isize`\n           found reference `&_`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    let mut min_sum: isize = 0;\n    let mut num_sorted: Vec<isize>\
    \ = nums.clone();\n\n    for &i in &mut num_sorted {\n        if min_sum < i {\n\
    \            min_sum = i;\n        }\n    }\n\n    for &i in &mut num_sorted {\n\
    \        if min_sum == i {\n            if nums.iter().position(|&j| i == *j).is_some()\
    \ {\n                let index = nums.iter().position(|&j| i == *j).unwrap();\n\
    \                nums.swap(index, nums.iter().position(|&j| i == *j).unwrap());\n\
    \            }\n        }\n    }\n    return num_sorted;\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpec1gs5q2.rs:16:9\n   |\n\
    16 |     for &i in &mut num_sorted {\n   |         ^^    --------------- this\
    \ expression has type `Option<&mut isize>`\n   |         |\n   |         types\
    \ differ in mutability\n   |         help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note: expected mutable reference `&mut isize`\n    \
    \                  found reference `&_`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpec1gs5q2.rs:22:9\n   |\n22 |     for &i in &mut num_sorted {\n   | \
    \        ^^    --------------- this expression has type `Option<&mut isize>`\n\
    \   |         |\n   |         types differ in mutability\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note: expected mutable\
    \ reference `&mut isize`\n                      found reference `&_`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpec1gs5q2.rs:24:47\n   |\n\
    24 |             if nums.iter().position(|&j| i == *j).is_some() {\n   |     \
    \                                          ^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmpec1gs5q2.rs:25:60\n   |\n25 |               \
    \  let index = nums.iter().position(|&j| i == *j).unwrap();\n   |            \
    \                                                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpec1gs5q2.rs:26:65\n   |\n26 |        \
    \         nums.swap(index, nums.iter().position(|&j| i == *j).unwrap());\n   |\
    \                                                                 ^^\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|&num| {\n        if num <\
    \ 0 {\n            std::cmp::Ordering::Less => num as isize,\n            std::cmp::Ordering::Greater\
    \ => num as isize * -1\n        } else {\n            std::cmp::Ordering::Greater\
    \ => num as isize,\n            std::cmp::Ordering::Less => num as isize * -1\n\
    \        }\n    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmp967s6bx1.rs:11:38\n   |\n11 |             std::cmp::Ordering::Less\
    \ => num as isize,\n   |                                      ^^ expected one\
    \ of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`,\
    \ `}`, or an operator, found `=>`\n  --> /tmp/tmp967s6bx1.rs:14:41\n   |\n14 |\
    \             std::cmp::Ordering::Greater => num as isize,\n   |             \
    \                            ^^ expected one of 8 possible tokens\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort();\n    if nums.is_empty() {\n  \
    \      nums\n    } else {\n        let mut tmp = nums[0];\n        let mut digits\
    \ = String::new();\n        let mut i = 0; // index in nums\n        while i <\
    \ nums.len() {\n            let mut dig = String::new();\n            while i\
    \ < nums.len() && nums[i] > 0 {\n                dig += &nums[i].to_string();\n\
    \                i += 1;\n            }\n            if dig == &tmp {\n      \
    \          tmp.swap(nums[i]);\n            } else {\n                tmp = nums[i];\n\
    \                digits = dig;\n            }\n        }\n        nums = digits.into_owned().split_whitespace().collect::<Vec<_>>();\n\
    \        nums.sort_unstable_by_key(|&x| x.to_i());\n        nums\n    }\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5fpt1s6p.rs:23:21\n   |\n23 |                 tmp.swap(nums[i]);\n\
    \   |                     ^^^^ method not found in `isize`\n\nerror[E0277]: can't\
    \ compare `String` with `&isize`\n  --> /tmp/tmp5fpt1s6p.rs:22:20\n   |\n22 |\
    \             if dig == &tmp {\n   |                    ^^ no implementation for\
    \ `String == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0599]: no method\
    \ named `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmp5fpt1s6p.rs:29:23\n\
    \   |\n29 |         nums = digits.into_owned().split_whitespace().collect::<Vec<_>>();\n\
    \   |                       ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmp5fpt1s6p.rs:30:42\n\
    \   |\n30 |         nums.sort_unstable_by_key(|&x| x.to_i());\n   |          \
    \                                ^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut total_digits = nums.iter().map(|x| x.to_string().chars().count()).sum();\n\
    \    sorted_list.extend(nums.iter().enumerate().filter_map(|(idx, x)| {\n    \
    \    let sum = x.to_string().chars().count();\n        if total_digits == sum\
    \ {\n            Some((idx, x))\n        } else {\n            None\n        }\n\
    \    }).collect());\n    sorted_list.sort();\n    sorted_list.into_iter().map(|x|\
    \ x.1).collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpc9xzfbxz.rs:20:34\n\
    \   |\n20 |     sorted_list.into_iter().map(|x| x.1).collect()\n   |         \
    \                         ^ consider giving this closure parameter a type\n  \
    \ |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Sort the list in descending order according\
    \ to their sum\n    // of their digits.\n    let mut sum_map = nums.iter().map(|x|\
    \ x + x).collect::<Vec<_>>();\n    sum_map.sort();\n\n    // If there are more\
    \ than one item with the same sum,\n    // sort them according to their index\
    \ in\n    // original list.\n    let mut num_map: HashMap<isize, Vec<isize>> =\
    \ nums.iter().enumerate().cloned().collect();\n    if num_map.len() > 1 {\n  \
    \      let mut nums_copy = nums.clone();\n        for (i, x) in num_map {\n  \
    \          for (j, y) in num_map.iter().rev() {\n                if x == y {\n\
    \                    nums_copy[i] = nums_copy[j];\n                    num_map.remove(&j);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n\n    num_map.iter().map(|(i, nums)| nums).collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpiqcx5s58.rs:17:22\n\
    \   |\n17 |     let mut num_map: HashMap<isize, Vec<isize>> = nums.iter().enumerate().cloned().collect();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0271]:\
    \ type mismatch resolving `<Enumerate<std::slice::Iter<'_, isize>> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpiqcx5s58.rs:17:75\n     |\n17   |     let mut num_map:\
    \ HashMap<isize, Vec<isize>> = nums.iter().enumerate().cloned().collect();\n \
    \    |                                                                       \
    \    ^^^^^^ expected reference, found tuple\n     |\n     = note: expected reference\
    \ `&_`\n                    found tuple `(usize, &isize)`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpiqcx5s58.rs:17:84\n\
    \   |\n17 |        let mut num_map: HashMap<isize, Vec<isize>> = nums.iter().enumerate().cloned().collect();\n\
    \   |                                                                        \
    \               ^^^^^^^ method cannot be called on `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Enumerate<std::slice::Iter<'_, isize>>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n           `Cloned<Enumerate<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0412, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    // Get the sums of each digits in the given numbers\n    let mut\
    \ sums = vec![0, *nums.iter().cloned().fold(0, |sum, i| sum + i)];\n    // Find\
    \ first two numbers\n    let first = nums.iter().enumerate().filter(|(_, v)| v\
    \ > 0).next();\n    let second = nums.iter().enumerate().filter(|(_, v)| v ==\
    \ 0).next();\n    // If the sum of their digits is equal to zero, order them based\
    \ on their index\n    if sums[0] == 0 {\n        let mut it = nums.iter().enumerate();\n\
    \        it.sort_by_key(|(i, _)| i.1);\n        return it.collect();\n    }\n\
    \    // If the sum of their digits is not equal to zero, order them by their sum\n\
    \    if sums[1] == 0 {\n        let mut it = nums.iter().enumerate();\n      \
    \  it.sort_by_key(|(i, _)| -i.1);\n        return it.collect();\n    }\n    //\
    \ If the sum of their digits are equal and both numbers have same first index,\
    \ order them based on their sum\n    if first.0 == second.0 {\n        let mut\
    \ it = nums.iter().enumerate();\n        it.sort_by_key(|(i, _)| sums[i] - sums[first.0]);\n\
    \        return it.collect();\n    }\n    // If the sum of their digits are equal\
    \ and both numbers have same second index, order them based on their sum\n   \
    \ if first.0 == second.0 {\n        let mut it = nums.iter().enumerate();\n  \
    \      it.sort_by_key(|(i, _)| sums[first.0] - sums[i.1]);\n        return it.collect();\n\
    \    }\n    // If the sum of their digits are equal and both numbers have different\
    \ first index, order them based on their sum\n    if first.0 == second.0 {\n \
    \       let mut it = nums.iter().enumerate();\n        it.sort_by_key(|(i, _)|\
    \ sums[i.1] - sums[first.0]);\n        return it.collect();\n    }\n    // If\
    \ the sum of their digits are equal and both numbers have different second index,\
    \ order them based on their sum\n    if first.0 == second.0 {\n        let mut\
    \ it = nums.iter().enumerate();\n        it.sort_by_key(|(i, _)| sums[first.0]\
    \ - sums[i.1]);\n        return it.collect();\n    }\n    // If the sum of their\
    \ digits are equal and one of them have different index, order them based on their\
    \ sum\n    if first.0 == second.0 {\n        let mut it = nums.iter().enumerate();\n\
    \        it.sort_by_key(|(i, _)| sums[i.1]\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpun9qj7tp.rs:68:3\n\
    \   |\n8  | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n55 |\
    \     if first.0 == second.0 {\n   |                            - this delimiter\
    \ might not be properly closed...\n...\n58 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n68 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpun9qj7tp.rs:57:23\n   |\n8  | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          \
    \          - closing delimiter possibly meant for this\n...\n57 |         it.sort_by_key(|(i,\
    \ _)| sums[i.1]\n   |                       ^ unclosed delimiter\n58 | }\n   |\
    \ ^ mismatched closing delimiter\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpun9qj7tp.rs:14:28\n   |\n14 |     let mut sums = vec![0, *nums.iter().cloned().fold(0,\
    \ |sum, i| sum + i)];\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpun9qj7tp.rs:16:61\n   |\n16 |\
    \     let first = nums.iter().enumerate().filter(|(_, v)| v > 0).next();\n   |\
    \                                                             ^ expected `&&isize`,\
    \ found integer\n\nerror[E0277]: can't compare `&&isize` with `{integer}`\n  -->\
    \ /tmp/tmpun9qj7tp.rs:17:60\n   |\n17 |     let second = nums.iter().enumerate().filter(|(_,\
    \ v)| v == 0).next();\n   |                                                  \
    \          ^^ no implementation for `&&isize == {integer}`\n   |\n   = help: the\
    \ trait `PartialEq<{integer}>` is not implemented for `&&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpun9qj7tp.rs:21:12\n   |\n21 |        "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Write your code here\n    let mut nums =\
    \ nums;\n    nums.sort_unstable_by(|a, b| {\n        if a.is_odd() == b.is_odd()\
    \ {\n            if a.is_even() {\n                b.checked_sub(a.to_digit().unwrap())\n\
    \            } else {\n                b.checked_sub(a.to_digit().unwrap() - b.to_digit().unwrap())\n\
    \            }\n        } else if a.is_even() {\n            b.checked_sub(a.to_digit().unwrap())\n\
    \        } else if b.is_even() {\n            a.checked_sub(b.to_digit().unwrap())\n\
    \        } else {\n            if a.is_odd() {\n                b.checked_sub(a.to_digit().unwrap()\
    \ - b.to_digit().unwrap())\n            } else {\n                b.checked_sub(a.to_digit().unwrap())\n\
    \            }\n        }\n    });\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_odd` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp_fr4ls2_.rs:12:14\n   |\n12 |         if a.is_odd()\
    \ == b.is_odd() {\n   |              ^^^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `is_odd` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmp_fr4ls2_.rs:12:28\n   |\n12 |         if a.is_odd() == b.is_odd()\
    \ {\n   |                            ^^^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `is_even` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmp_fr4ls2_.rs:13:18\n   |\n13 |             if a.is_even() {\n  \
    \ |                  ^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `to_digit` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmp_fr4ls2_.rs:14:33\n   |\n14 |                 b.checked_sub(a.to_digit().unwrap())\n\
    \   |                                 ^^^^^^^^ method not found in `&isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_fr4ls2_.rs:14:17\n   |\n14 |  \
    \               b.checked_sub(a.to_digit().unwrap())\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n              found enum `Option<isize>`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmp_fr4ls2_.rs:16:33\n   |\n16 |                 b.checked_sub(a.to_digit().unwrap()\
    \ - b.to_digit().unwrap())\n   |                                 ^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `to_digit` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmp_fr4ls2_.rs:16:57\n \
    \  |\n16 |                 b.checked_sub(a.to_digit().unwrap() - b.to_digit().unwrap())\n\
    \   |                                                         ^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_fr4ls2_.rs:16:17\n\
    \   |\n16 |                 b.checked_sub(a.to_digit().unwrap() - b.to_digit().unwrap())\n\
    \   |                 ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.iter().cloned().sort_by_key(|x| x.checked_digits().iter().cloned().sum()).collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n --> /tmp/tmp0t7oy372.rs:9:26\n  |\n9 |     nums.iter().cloned().sort_by_key(|x|\
    \ x.checked_digits().iter().cloned().sum()).collect()\n  |                   \
    \       ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum = nums.iter().map(|&i| {\n    \
    \    fn cmp(&i1, &i2: isize) -> isize {\n            let mut s = i1;\n       \
    \     for i in (0..i).rev() {\n                s *= 10;\n                if s\
    \ == i2 {\n                    return i;\n                }\n                s\
    \ += i;\n            }\n            return i2;\n        }\n        &cmp\n    }).sum();\n\
    \    nums.iter().cloned().sort(|&i1, &i2| {\n        match sum {\n           \
    \ Some(s) => cmp(*i1, *i2),\n            None => cmp(*i2, *i1),\n        }\n \
    \   });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n  \
    \  assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `:`, `@`, or `|`, found `,`\n  --> /tmp/tmprmjamr5v.rs:10:19\n\
    \   |\n10 |         fn cmp(&i1, &i2: isize) -> isize {\n   |                 \
    \  ^ expected one of `:`, `@`, or `|`\n   |\n   = note: anonymous parameters are\
    \ removed in the 2018 edition (see RFC 1685)\nhelp: if this is a `self` type,\
    \ give it a parameter name\n   |\n10 |         fn cmp(self: &i1, &i2: isize) ->\
    \ isize {\n   |                +++++\nhelp: if this is a parameter name, give\
    \ it a type\n   |\n10 |         fn cmp(i1: &TypeName, &i2: isize) -> isize {\n\
    \   |                ~~~~~~~~~~~~~\nhelp: if this is a type, explicitly ignore\
    \ the parameter name\n   |\n10 |         fn cmp(_: &i1, &i2: isize) -> isize {\n\
    \   |                ++\n\nerror[E0434]: can't capture dynamic environment in\
    \ a fn item\n  --> /tmp/tmprmjamr5v.rs:12:26\n   |\n12 |             for i in\
    \ (0..i).rev() {\n   |                          ^\n   |\n   = help: use the `||\
    \ { ... }` closure form instead\n\nerror[E0425]: cannot find function `cmp` in\
    \ this scope\n  --> /tmp/tmprmjamr5v.rs:25:24\n   |\n25 |             Some(s)\
    \ => cmp(*i1, *i2),\n   |                        ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `cmp` in this scope\n  --> /tmp/tmprmjamr5v.rs:26:21\n\
    \   |\n26 |             None => cmp(*i2, *i1),\n   |                     ^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `sort` found for struct\
    \ `Cloned` in the current scope\n  --> /tmp/tmprmjamr5v.rs:23:26\n   |\n23 | \
    \    nums.iter().cloned().sort(|&i1, &i2| {\n   |                          ^^^^\
    \ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0277]: the\
    \ trait bound `Option<_>: Sum<&fn([type error], isize) -> isize {order_by_points::{closure#0}::cmp}>`\
    \ is not satisfied\n    --> /tmp/tmprmjamr5v.rs:22:8\n     |\n22   |     }).sum();\n\
    \     |        ^^^ the trait `Sum<&fn([type error], isize) -> isize {order_by_points::{closure#0}::cmp}>`\
    \ is not implemented for `Option<_>`\n     |\n     = help: the trait `Sum<Option<U>>`\
    \ is implemented for `Option<T>`\nnote: required by a bound in `std::iter::Iterator::sum"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|&n, _| {\n        // Get sum\
    \ of digits.\n        let mut sum = 0;\n        for &d in n.to_string().chars()\
    \ {\n            sum += d;\n        }\n        sum\n    });\n    nums\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnbd722by.rs:12:13\n   |\n\
    12 |         for &d in n.to_string().chars() {\n   |             ^^    ---------------------\
    \ this expression has type `Option<char>`\n   |             |\n   |          \
    \   expected `char`, found reference\n   |             help: you can probably\
    \ remove the explicit borrow: `d`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbd722by.rs:15:9\n\
    \   |\n15 |         sum\n   |         ^^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sum = 0;\n    let mut nums_index\
    \ = 0;\n    for &num in nums {\n        nums_sum += num;\n        nums_index +=\
    \ 1;\n    }\n    debug_assert!(nums_sum != 0);\n\n    nums_sum.sort_unstable_by(|a,\
    \ b| {\n        let diff = b.checked_sub(a).unwrap();\n        if diff == 0 {\n\
    \            nums_index\n        } else {\n            diff\n        }\n    });\n\
    \    nums_sum\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3up84z52.rs:11:9\n   |\n\
    11 |     for &num in nums {\n   |         ^^^^    ---- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `sort_unstable_by` found for type `{integer}` in the current\
    \ scope\n  --> /tmp/tmp3up84z52.rs:17:14\n   |\n17 |     nums_sum.sort_unstable_by(|a,\
    \ b| {\n   |              ^^^^^^^^^^^^^^^^ method not found in `{integer}`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3up84z52.rs:25:5\n   |\n8  | fn\
    \ order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |                    \
    \                     ---------- expected `Vec<isize>` because of return type\n\
    ...\n25 |     nums_sum\n   |     ^^^^^^^^ expected struct `Vec`, found integer\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `{integer}`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = Vec::new();\n\n    //\
    \ We use 'isize' type because it will give us biggest value on 32-bit system\n\
    \    // and smallest on 64-bit system\n    for i in 0..nums.len() {\n        let\
    \ digits = nums.iter().map(|&n| n.to_digits()).collect::<Vec<Vec<isize>>>();\n\
    \        nums_sorted.push(digits);\n    }\n\n    let mut cur_sum = 0;\n    let\
    \ mut cur_max = nums.iter().cloned().max().unwrap();\n\n    for i in 0..nums_sorted.len()\
    \ {\n        let digits = nums_sorted[i].iter().cloned().collect::<Vec<isize>>();\n\
    \        let mut cur_cur = 0;\n        for d in digits.iter() {\n            cur_cur\
    \ += d;\n        }\n\n        if cur_cur < 0 {\n            cur_sum -= cur_cur;\n\
    \        } else {\n            if cur_sum != cur_max {\n                // We\
    \ found a new max\n                cur_sum += cur_max;\n                cur_max\
    \ = digits[digits.len() - 1];\n            }\n            cur_sum += cur_cur;\n\
    \        }\n    }\n\n    if cur_sum != 0 {\n        // We found a new max\n  \
    \      cur_sum += cur_max;\n    }\n\n    for i in 0..nums_sorted.len() {\n   \
    \     nums_sorted[i].iter().map(|&d| d.clone()).collect::<Vec<isize>>();\n   \
    \ }\n\n    cur_max\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpjep8boa8.rs:14:45\n   |\n14 |         let digits\
    \ = nums.iter().map(|&n| n.to_digits()).collect::<Vec<Vec<isize>>>();\n   |  \
    \                                           ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `Vec<isize>`\n    --> /tmp/tmpjep8boa8.rs:22:53\n    \
    \ |\n22   |         let digits = nums_sorted[i].iter().cloned().collect::<Vec<isize>>();\n\
    \     |                                                     ^^^^^^^ value of type\
    \ `Vec<isize>` cannot be built from `std::iter::Iterator<Item=Vec<isize>>`\n \
    \    |\n     = help: the trait `FromIterator<Vec<isize>>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `Vec<isize>`\n    -->\
    \ /tmp/tmpjep8boa8.rs:46:51\n     |\n46   |         nums_sorted[i].iter().map(|&d|\
    \ d.clone()).collect::<Vec<isize>>();\n     |                                \
    \                   ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=Vec<isize>>`\n\
    \     |\n     = help: the trait `FromIterator<Vec<isize>>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjep8boa8.rs:49:5\n   |\n8  | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                         ---------- expected\
    \ `Vec<isize>` because of return type\n...\n49 |     cur_max\n   |     ^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by(|a, b| {\n        let\
    \ mut sum: isize = a.to_digits().iter().filter(|&x| x > 0).sum();\n        sum\
    \ = sum.checked_add(b.to_digits().iter().filter(|&x| x > 0).sum()).unwrap();\n\
    \        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmphw48z4qx.rs:10:32\n   |\n10 |         let\
    \ mut sum: isize = a.to_digits().iter().filter(|&x| x > 0).sum();\n   |      \
    \                          ^^^^^^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmphw48z4qx.rs:11:33\n   |\n11 |         sum = sum.checked_add(b.to_digits().iter().filter(|&x|\
    \ x > 0).sum()).unwrap();\n   |                                 ^^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphw48z4qx.rs:12:9\n\
    \   |\n12 |         sum\n   |         ^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .sort_by_key(|(idx, num)| {\n            cmp::min(\n                idx,\n\
    \                num,\n                |&i, &j| nums.iter().enumerate().find(|&(j_idx,\
    \ j)| i == j).unwrap_or(i) - j,\n            )\n        })\n        .map(|(i,\
    \ num)| nums[idx])\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpn3by8plq.rs:13:13\n   |\n13 |             cmp::min(\n   |     \
    \        ^^^ use of undeclared crate or module `cmp`\n\nerror[E0425]: cannot find\
    \ value `idx` in this scope\n  --> /tmp/tmpn3by8plq.rs:19:30\n   |\n19 |     \
    \    .map(|(i, num)| nums[idx])\n   |                              ^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `sort_by_key` found for struct\
    \ `Enumerate` in the current scope\n  --> /tmp/tmpn3by8plq.rs:12:10\n   |\n12\
    \ |         .sort_by_key(|(idx, num)| {\n   |          ^^^^^^^^^^^ method not\
    \ found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror[E0277]: can't compare\
    \ `(usize, &isize)` with `&isize`\n  --> /tmp/tmpn3by8plq.rs:16:71\n   |\n16 |\
    \                 |&i, &j| nums.iter().enumerate().find(|&(j_idx, j)| i == j).unwrap_or(i)\
    \ - j,\n   |                                                                 \
    \      ^^ no implementation for `(usize, &isize) == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `(usize, &isize)`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     ()\n             (A, B, C, D, E, F, G, H, I, J, K, L)\n             (B,\
    \ C, D, E, F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J, K, L)\n\
    \             (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I, J, K,\
    \ L)\n             (F, G, H, I, J, K, L)\n             (G, H, I, J, K, L)\n  \
    \         and 5 others\n\nerror[E0369]: cannot subtract `_` from `(usize, &isize)`\n\
    \  --> /tmp/tmpn3by8plq.rs:16:90\n   |\n16 |                 |&i, &j| nums.iter().enumerate().find(|&(j_idx,\
    \ j)| i == j).unwrap_or(i) - j,\n   |                          ---------------------------------------------------------------\
    \ ^ - _\n   |                          |\n   |                          (usize,\
    \ &isize)\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0369, E0425, E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    // find\
    \ all sums of digits\n    let mut sum_of_digits = Vec::new();\n    for x in nums_copy\
    \ {\n        let mut sum_of_digits_x = 0.;\n        for y in nums_copy {\n   \
    \         if x != y {\n                sum_of_digits_x += y::digit(x);\n     \
    \       }\n        }\n        sum_of_digits.push(sum_of_digits_x);\n    }\n  \
    \  let mut sum_of_digits_sorted = sum_of_digits.clone();\n\n    // sort numbers\
    \ by sum digit\n    sum_of_digits_sorted.sort();\n\n    // sort numbers by position\n\
    \    let mut sorted_indexes = Vec::new();\n    for x in sum_of_digits_sorted.iter()\
    \ {\n        let mut index = 0;\n        for y in nums_copy {\n            if\
    \ x != y {\n                if y::digit(x) <= sum_of_digits_sorted[index] {\n\
    \                    index = y;\n                }\n            }\n        }\n\
    \        sorted_indexes.push(index);\n    }\n\n    nums_copy.sort_by_index(sorted_indexes);\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `y`\n\
    \  --> /tmp/tmp6i6_8cwa.rs:16:36\n   |\n16 |                 sum_of_digits_x +=\
    \ y::digit(x);\n   |                                    ^ use of undeclared crate\
    \ or module `y`\n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `y`\n  --> /tmp/tmp6i6_8cwa.rs:32:20\n   |\n32 |                 if y::digit(x)\
    \ <= sum_of_digits_sorted[index] {\n   |                    ^ use of undeclared\
    \ crate or module `y`\n\nerror[E0277]: the trait bound `{float}: Ord` is not satisfied\n\
    \   --> /tmp/tmp6i6_8cwa.rs:24:26\n    |\n24  |     sum_of_digits_sorted.sort();\n\
    \    |                          ^^^^ the trait `Ord` is not implemented for `{float}`\n\
    \    |\n    = help: the following other types implement trait `Ord`:\n       \
    \       i128\n              i16\n              i32\n              i64\n      \
    \        i8\n              isize\n              u128\n              u16\n    \
    \        and 4 others\nnote: required by a bound in `slice::<impl [T]>::sort`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6i6_8cwa.rs:31:21\n   |\n31 |\
    \             if x != y {\n   |                     ^ expected floating-point\
    \ number, found `isize`\n\nerror[E0277]: can't compare `&{float}` with `isize`\n\
    \  --> /tmp/tmp6i6_8cwa.rs:31:18\n   |\n31 |             if x != y {\n   |   \
    \               ^^ no implementation for `&{float} == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&{float}`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6i6_8cwa.rs:33:29\n   |\n29 |\
    \         let mut index = 0;\n   |                         - expected due to this\
    \ value\n...\n33 |                     index = y;\n   |                      \
    \       ^ expected `usize`, found `isize`\n\nerror[E0599]: no method named `sort_by_index`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = nums.clone();\n\
    \    let mut sums: Vec<isize> = vec![0; result.len()];\n\n    for (i, &x) in result.iter().enumerate()\
    \ {\n        sums[i] += x;\n    }\n\n    for i in (0..result.len()).rev() {\n\
    \        if sums[i] != sums[i - 1] {\n            result.swap(i, i - 1);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpy2zkfipv.rs:17:28\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut nums_copy: Vec<isize> = nums.clone();\n    debug_assert_eq!(nums_copy.len(),\
    \ nums.len());\n    debug_assert!(nums_copy.iter().all(|&x| x >= 0));\n    let\
    \ mut sums: Vec<isize> = nums_copy.iter().map(|x| x * (10 as isize)).collect();\n\
    \    debug_assert!(sums.iter().all(|&x| x >= 0));\n    let mut min: isize = (nums_copy.len()\
    \ as isize);\n    let mut min_index = 0;\n    for index in 0..(sums.len() - 1)\
    \ {\n        if sums[index] <= 0 {\n            continue;\n        }\n       \
    \ if min > sums[index] {\n            min = sums[index];\n            min_index\
    \ = index;\n        }\n    }\n    nums_copy[min_index] = nums_copy[min_index].unwrap()\
    \ + min;\n    if nums_copy.len() > 1 {\n        nums_copy.sort_by_key(|&x| nums_copy.iter().zip(nums.iter()).filter(|(&a,\
    \ &b)| a == b).count());\n    }\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpem6m93me.rs:17:26\n\
    \   |\n17 |     let mut min: isize = (nums_copy.len() as isize);\n   |       \
    \                   ^                        ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n17 -     let mut min: isize\
    \ = (nums_copy.len() as isize);\n17 +     let mut min: isize = nums_copy.len()\
    \ as isize;\n   | \n\nerror[E0599]: no method named `unwrap` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpem6m93me.rs:28:49\n   |\n28 |     nums_copy[min_index]\
    \ = nums_copy[min_index].unwrap() + min;\n   |                               \
    \                  ^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sum = nums.iter().map(|x| x.to_digit()).sum();\n\
    \    nums.sort_unstable_by(|a, b| {\n        match nums_sum {\n            0 =>\
    \ a.to_digit() < b.to_digit(),\n            a => a.to_digit() > b.to_digit(),\n\
    \            b => b.to_digit() < a.to_digit(),\n        }\n    });\n    nums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digit` found for reference `&isize` in\
    \ the current scope\n --> /tmp/tmpk3mocjgq.rs:9:46\n  |\n9 |     let mut nums_sum\
    \ = nums.iter().map(|x| x.to_digit()).sum();\n  |                            \
    \                  ^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method\
    \ named `to_digit` found for reference `&isize` in the current scope\n  --> /tmp/tmpk3mocjgq.rs:12:20\n\
    \   |\n12 |             0 => a.to_digit() < b.to_digit(),\n   |              \
    \      ^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method named\
    \ `to_digit` found for reference `&isize` in the current scope\n  --> /tmp/tmpk3mocjgq.rs:12:35\n\
    \   |\n12 |             0 => a.to_digit() < b.to_digit(),\n   |              \
    \                     ^^^^^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk3mocjgq.rs:12:18\n   |\n12 |             0 => a.to_digit()\
    \ < b.to_digit(),\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `bool`\n\nerror[E0599]: no method named `to_digit`\
    \ found for type `{integer}` in the current scope\n  --> /tmp/tmpk3mocjgq.rs:13:20\n\
    \   |\n13 |             a => a.to_digit() > b.to_digit(),\n   |              \
    \      ^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named\
    \ `to_digit` found for reference `&isize` in the current scope\n  --> /tmp/tmpk3mocjgq.rs:13:35\n\
    \   |\n13 |             a => a.to_digit() > b.to_digit(),\n   |              \
    \                     ^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `to_digit` found for type `{integer}` in the current scope\n  -->\
    \ /tmp/tmpk3mocjgq.rs:14:20\n   |\n14 |             b => b.to_digit() < a.to_digit(),\n\
    \   |                    ^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpk3mocjgq.rs:14:35\n   |\n14 |             b => b.to_digit() < a.to_digit(),\n\
    \   |                                   ^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 8 previous errors\n\nSome er"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .map(|&x| x.checked_add(&x.checked_multiply(10))?)?\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_s6lqg8q.rs:12:15\n   |\n\
    12 |         .map(|&x| x.checked_add(&x.checked_multiply(10))?)?\n   |       \
    \        ^--\n   |               ||\n   |               |expected due to this\n\
    \   |               expected `isize`, found reference\n   |               help:\
    \ did you mean `x`: `&isize`\n   |\n   = note:   expected type `isize`\n     \
    \      found reference `&_`\n\nerror[E0277]: the `?` operator can only be applied\
    \ to values that implement `Try`\n  --> /tmp/tmp_s6lqg8q.rs:9:5\n   |\n9  | /\
    \     nums\n10 | |         .iter()\n11 | |         .cloned()\n12 | |         .map(|&x|\
    \ x.checked_add(&x.checked_multiply(10))?)?\n   | |___________________________________________________________^\
    \ the `?` operator cannot be applied to type `Map<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmp_s6lqg8q.rs:12:14: 12:58]>`\n   |\n   = help: the\
    \ trait `Try` is not implemented for `Map<Cloned<std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmp_s6lqg8q.rs:12:14: 12:58]>`\n\nerror[E0277]: the `?` operator\
    \ can only be used in a function that returns `Result` or `Option` (or another\
    \ type that implements `FromResidual`)\n  --> /tmp/tmp_s6lqg8q.rs:12:59\n   |\n\
    8  | / fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n9  | |     nums\n\
    10 | |         .iter()\n11 | |         .cloned()\n12 | |         .map(|&x| x.checked_add(&x.checked_multiply(10))?)?\n\
    \   | |                                                           ^ cannot use\
    \ the `?` operator in a function that returns `Vec<isize>`\n13 | |         .collect::<Vec<_>>()\n\
    14 | | }\n   | |_- this function should return `Result` or `Option` to accept\
    \ `?`\n   |\n   = help: the trait `FromResidual<_>` is not implemented for `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut sum_so_far:\
    \ isize = 0;\n    let mut i = 1;\n    for num in nums {\n        let digit = num\
    \ % 10;\n        ret.push(i);\n        if digit >= sum_so_far {\n            sum_so_far\
    \ = digit;\n        }\n        i += 1;\n    }\n    ret.sort_unstable_by_key(|&x|\
    \ sum_so_far + x);\n    ret\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp0owopg0k.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_len = nums.len();\n    let mut\
    \ sum = 0;\n    let mut nums_sorted = nums.clone();\n    loop {\n        let index\
    \ = nums_sorted.iter().position(|x| *x > sum);\n        if index == nums_len {\n\
    \            break;\n        }\n        sum = sum + nums_sorted[index];\n    \
    \    nums_sorted.swap(index, nums_len--);\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpiokzlt8b.rs:18:43\n\
    \   |\n18 |         nums_sorted.swap(index, nums_len--);\n   |               \
    \                            ^ expected expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiokzlt8b.rs:14:21\n   |\n14 |         if index == nums_len\
    \ {\n   |                     ^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n14 |         if index == Some(nums_len)\
    \ {\n   |                     +++++        +\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `Option<usize>`\n  --> /tmp/tmpiokzlt8b.rs:17:21\n   |\n\
    17 |         sum = sum + nums_sorted[index];\n   |                     ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<usize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<usize>>` for\
    \ `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut points: Vec<isize> = nums.clone();\n\
    \    points.sort_by_key(|x| x.checked_add(-x).unwrap());\n    points\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp7d9bi9c2.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return vec![];\n\
    \    }\n    let mut sum = nums[0].checked_mul(10).unwrap();\n    for &n in nums\
    \ {\n        let m = sum.checked_mul(10).unwrap();\n        if m.checked_add((n\
    \ as isize).checked_mul(10).unwrap()).is_less_than(&m) {\n            sum = (n\
    \ as isize).checked_mul(10).unwrap();\n        }\n    }\n    let mut indexes =\
    \ vec![];\n    for n in nums {\n        let m = sum.checked_mul(10).unwrap();\n\
    \        if m.checked_add((n as isize).checked_mul(10).unwrap()).is_less_than(&m)\
    \ {\n            indexes.push(n - 1);\n        }\n    }\n    indexes.sort_unstable();\n\
    \    indexes\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprpt1ocgw.rs:13:9\n   |\n\
    13 |     for &n in nums {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `is_less_than` found for enum `Option` in the current scope\n  --> /tmp/tmprpt1ocgw.rs:15:65\n\
    \   |\n15 |         if m.checked_add((n as isize).checked_mul(10).unwrap()).is_less_than(&m)\
    \ {\n   |                                                                 ^^^^^^^^^^^^\
    \ method not found in `Option<isize>`\n\nerror[E0599]: no method named `is_less_than`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmprpt1ocgw.rs:22:65\n\
    \   |\n22 |         if m.checked_add((n as isize).checked_mul(10).unwrap()).is_less_than(&m)\
    \ {\n   |                                                                 ^^^^^^^^^^^^\
    \ method not found in `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by_key(|n| {\n        //\
    \ Convert n to base 10 representation in u8, then to i32 representation in u64,\n\
    \        // then to u64 in order to compare them with 0\n        let mut v: Vec<u64>\
    \ = nums.iter().map(|&x| u8_to_u64(x)).collect();\n        v.reverse();\n    \
    \    v.iter().map(|x| x.to_le()).sum()\n    });\n    nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `u8_to_u64` in this scope\n  --> /tmp/tmpx36zmbjf.rs:12:52\n\
    \   |\n12 |         let mut v: Vec<u64> = nums.iter().map(|&x| u8_to_u64(x)).collect();\n\
    \   |                                                    ^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted = nums.clone();\n    let mut\
    \ sum_so_far = nums.iter().fold(0, |sum, i| sum + i);\n    for n in nums.iter()\
    \ {\n        while sum_so_far >= n {\n            sorted.remove(&n);\n       \
    \     sum_so_far -= n;\n        }\n    }\n    sorted\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4zer4mf.rs:12:29\n   |\n\
    12 |         while sum_so_far >= n {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    12 |         while sum_so_far >= *n {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpx4zer4mf.rs:13:27\n   |\n13 |  \
    \           sorted.remove(&n);\n   |                           ^^ expected `usize`,\
    \ found `&&isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Calculate the sum of the digits of all the\
    \ numbers\n    let mut sum: isize = 0;\n    for &n in nums {\n        if n > 0\
    \ {\n            sum += *n % 10;\n            *n /= 10;\n        }\n    }\n  \
    \  // Sort by increasing sums\n    nums.sort_unstable_by(|n1, n2| sum - n1 + n2);\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmlst8fu_.rs:11:9\n   |\n\
    11 |     for &n in nums {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmlst8fu_.rs:18:36\n   |\n18 |     nums.sort_unstable_by(|n1, n2|\
    \ sum - n1 + n2);\n   |                                    ^^^^^^^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_with_indices = vec![];\n    let\
    \ mut num_sum = 0;\n    for num in nums {\n        nums_with_indices.push(num);\n\
    \        num_sum += num;\n    }\n    debugln!(\"[nums_with_indices] = {:?}\",\
    \ nums_with_indices);\n    if num_sum > 0 {\n        let mut min_index = 1;\n\
    \        let mut max_index = nums.len();\n        while min_index <= max_index\
    \ {\n            let mut min_sum = num_sum;\n            let mut best_index =\
    \ min_index;\n            for index in min_index..=max_index {\n             \
    \   if min_sum > num_sum {\n                    break;\n                }\n  \
    \              min_sum += nums_with_indices[index];\n                if min_sum\
    \ < num_sum {\n                    best_index = index;\n                }\n  \
    \          }\n            min_index = best_index + 1;\n            max_index -=\
    \ 1;\n        }\n        for num in nums_with_indices.iter_mut() {\n         \
    \   *num = nums_with_indices[num - min_index];\n        }\n    }\n    debugln!(\"\
    [nums] = {:?}\", nums);\n    return nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmpwsrxfkb4.rs:15:5\n\
    \   |\n15 |     debugln!(\"[nums_with_indices] = {:?}\", nums_with_indices);\n\
    \   |     ^^^^^^^\n\nerror: cannot find macro `debugln` in this scope\n  --> /tmp/tmpwsrxfkb4.rs:38:5\n\
    \   |\n38 |     debugln!(\"[nums] = {:?}\", nums);\n   |     ^^^^^^^\n\nerror[E0369]:\
    \ cannot subtract `usize` from `&mut isize`\n  --> /tmp/tmpwsrxfkb4.rs:35:42\n\
    \   |\n35 |             *num = nums_with_indices[num - min_index];\n   |     \
    \                                 --- ^ --------- usize\n   |                \
    \                      |\n   |                                      &mut isize\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // first sum all digits\n    let mut sum =\
    \ 0;\n    for i in nums.iter() {\n        sum += i;\n    }\n\n    // sort according\
    \ to sum\n    nums.sort_by_key(|x| {\n        sum - x.to_digits() as i64\n   \
    \ });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp4u6m1pwf.rs:17:17\n   |\n17 |         sum\
    \ - x.to_digits() as i64\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .filter(|(i, num)| num > 0)\n        .map(|(i, num)| num as isize)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5mhsv7rc.rs:12:34\n   |\n\
    12 |         .filter(|(i, num)| num > 0)\n   |                               \
    \   ^ expected `&&isize`, found integer\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmp5mhsv7rc.rs:13:25\n   |\n13 |         .map(|(i, num)|\
    \ num as isize)\n   |                         ---^^^^^^^^^\n   |             \
    \            |\n   |                         cannot cast `&isize` as `isize`\n\
    \   |                         help: dereference the expression: `*num`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a, b| a.partial_cmp(b))\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpaf77e0b8.rs:9:25\n  |\n9 |\
    \     nums.sort_by(|a, b| a.partial_cmp(b))\n  |                         ^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n  |\n  = note: expected\
    \ enum `std::cmp::Ordering`\n             found enum `Option<std::cmp::Ordering>`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpaf77e0b8.rs:9:5\n  |\n8 | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n  |                                         ----------\
    \ expected `Vec<isize>` because of return type\n9 |     nums.sort_by(|a, b| a.partial_cmp(b))\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter = nums.clone();\n    loop {\n\
    \        if counter.len() > 0 {\n            counter.sort();\n            let\
    \ mut i = 0;\n            for i in 0..=counter.len() {\n                if counter[i]\
    \ != i {\n                    counter[i] = i;\n                    break;\n  \
    \              }\n            }\n        }\n        else {\n            break;\n\
    \        }\n    }\n    counter.clone_without_zeros() // remove duplicates\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp66bbh3g1.rs:15:34\n   |\n\
    15 |                 if counter[i] != i {\n   |                              \
    \    ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n15 |     \
    \            if counter[i] != i.try_into().unwrap() {\n   |                  \
    \                 ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp66bbh3g1.rs:16:34\n   |\n16 |                     counter[i] = i;\n\
    \   |                     ----------   ^ expected `isize`, found `usize`\n   |\
    \                     |\n   |                     expected due to the type of\
    \ this binding\n\nerror[E0599]: no method named `clone_without_zeros` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp66bbh3g1.rs:25:13\n\
    \   |\n25 |     counter.clone_without_zeros() // remove duplicates\n   |     \
    \        ^^^^^^^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Create a map from digits to their corresponding\
    \ index\n    let mut digits: Vec<isize> = nums.iter().map(|x| x % 10).collect();\n\
    \    let mut digits_map: HashMap<isize, usize> = HashMap::new();\n    for i in\
    \ 0..digits.len() {\n        if digits_map.contains_key(&digits[i]) {\n      \
    \      digits_map.insert(digits[i], digits_map.get(&digits[i]).unwrap() + 1);\n\
    \        } else {\n            digits_map.insert(digits[i], i);\n        }\n \
    \   }\n\n    // Sort the list by its index\n    let mut index = 0;\n    let mut\
    \ sorted_nums = nums.clone();\n    digits_map.sort_unstable_by_key(|k, _| {\n\
    \        // Sum digits of the key\n        let s = k.iter().fold(0, |sum, x| sum\
    \ + (*x as i8));\n        // Index of the current number in the sorted list\n\
    \        let mut index = digits_map.get(&s).unwrap();\n        // If the sum of\
    \ digits is less than the current one, swap them\n        if s > sorted_nums[index]\
    \ {\n            std::mem::swap(&mut sorted_nums[index], &mut sorted_nums[digits_map.get(&s).unwrap()]);\n\
    \        }\n        index\n    });\n    sorted_nums\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmppvi7iqmr.rs:11:25\n\
    \   |\n11 |     let mut digits_map: HashMap<isize, usize> = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmppvi7iqmr.rs:11:49\n\
    \   |\n11 |     let mut digits_map: HashMap<isize, usize> = HashMap::new();\n\
    \   |                                                 ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .map(|x| x.checked_add(0,\
    \ &mut 0))\n        .enumerate()\n        .fold(Vec::new(), |mut res, (n, v)|\
    \ {\n            res\n                .push(*v)\n                .sort_by(|a,\
    \ b| a.checked_add(&b).unwrap());\n            res\n        })\n        .iter()\n\
    \        .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpa1tdh26g.rs:11:20\n    |\n11  |         .map(|x| x.checked_add(0,\
    \ &mut 0))\n    |                    ^^^^^^^^^^^ -  ------ supplied 2 arguments\n\
    \    |                    |\n    |                    expected 1 argument\n  \
    \  |\nnote: associated function defined here\n    = note: this error originates\
    \ in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace for\
    \ more info)\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpa1tdh26g.rs:15:23\n   |\n15 |                 .push(*v)\n   |      \
    \                 ^^\n\nerror[E0599]: no method named `sort_by` found for unit\
    \ type `()` in the current scope\n  --> /tmp/tmpa1tdh26g.rs:16:18\n   |\n16 |\
    \                 .sort_by(|a, b| a.checked_add(&b).unwrap());\n   |         \
    \         ^^^^^^^ method not found in `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0599, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by_key(|&x| {\n        let\
    \ mut sum = 0;\n        for x in nums.iter() {\n            sum += *x;\n     \
    \   }\n        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n --> /tmp/tmpa4cyv1ss.rs:9:33\n  |\n9 |\
    \     nums.sort_unstable_by_key(|&x| {\n  |                                 ^\
    \ help: if this is intentional, prefix it with an underscore: `_x`\n  |\n  = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0596]: cannot borrow `nums`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpa4cyv1ss.rs:9:5\n\
    \   |\n8  |   fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |     \
    \                 ---- help: consider changing this to be mutable: `mut nums`\n\
    9  | /     nums.sort_unstable_by_key(|&x| {\n10 | |         let mut sum = 0;\n\
    11 | |         for x in nums.iter() {\n12 | |             sum += *x;\n13 | | \
    \        }\n14 | |         sum\n15 | |     });\n   | |______^ cannot borrow as\
    \ mutable\n\nerror[E0502]: cannot borrow `nums` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmpa4cyv1ss.rs:9:31\n   |\n9  |       nums.sort_unstable_by_key(|&x|\
    \ {\n   |       -    -------------------- ^^^^ immutable borrow occurs here\n\
    \   |       |    |\n   |  _____|    mutable borrow later used by call\n   | |\n\
    10 | |         let mut sum = 0;\n11 | |         for x in nums.iter() {\n   | |\
    \                  ---- second borrow occurs due to use of `nums` in closure\n\
    12 | |             sum += *x;\n13 | |         }\n14 | |         sum\n15 | |  \
    \   });\n   | |______- mutable borrow occurs here\n\nerror: aborting due to 2\
    \ previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0502, E0596.\nFor more information about an error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut digits = nums.iter().map(|x| *x as\
    \ usize).collect::<Vec<usize>>();\n    let mut sum: usize = 0;\n    for digit\
    \ in &digits {\n        sum += digit;\n    }\n    digits.sort_unstable_by(|a,\
    \ b| sum.partial_cmp(a + b).unwrap_or(-1));\n    digits.iter()\n        .map(|x|\
    \ x as isize)\n        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpajxfzi_o.rs:14:52\n   |\n\
    14 |     digits.sort_unstable_by(|a, b| sum.partial_cmp(a + b).unwrap_or(-1));\n\
    \   |                                                    ^^^^^\n   |         \
    \                                           |\n   |                          \
    \                          expected `&usize`, found `usize`\n   |            \
    \                                        help: consider borrowing here: `&(a +\
    \ b)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpajxfzi_o.rs:14:69\n   |\n\
    14 |     digits.sort_unstable_by(|a, b| sum.partial_cmp(a + b).unwrap_or(-1));\n\
    \   |                                                                     ^^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror[E0606]: casting `&usize` as\
    \ `isize` is invalid\n  --> /tmp/tmpajxfzi_o.rs:16:18\n   |\n16 |         .map(|x|\
    \ x as isize)\n   |                  -^^^^^^^^^\n   |                  |\n   |\
    \                  cannot cast `&usize` as `isize`\n   |                  help:\
    \ dereference the expression: `*x`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut map = HashMap::new();\n    for &num\
    \ in nums {\n        let len = to_string(num).chars().count();\n        let mut\
    \ sub = map.entry(len).or_insert(num);\n        if num > sub {\n            sub\
    \ = num;\n        }\n    }\n    let mut sorted = Vec::new();\n    for len in map.keys()\
    \ {\n        sorted.push(map.remove(len).unwrap());\n    }\n    sorted\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp20o28j94.rs:9:19\n  |\n9 |     let mut map = HashMap::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0425]: cannot\
    \ find function `to_string` in this scope\n  --> /tmp/tmp20o28j94.rs:11:19\n \
    \  |\n11 |         let len = to_string(num).chars().count();\n   |           \
    \        ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp20o28j94.rs:10:9\n   |\n10 |     for &num in nums {\n   |     \
    \    ^^^^    ---- this expression has type `Option<isize>`\n   |         |\n \
    \  |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `num`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    let mut sums: Vec<isize> = nums.iter().map(|x| x as isize).collect();\n\
    \    let mut sum: isize = nums[0].checked_add::<isize>(&mut sums).unwrap();\n\n\
    \    for num in nums.iter().rev() {\n        let mut digits = num.checked_div::<isize>(&mut\
    \ sum).unwrap();\n        if digits.is_zero() {\n            sum -= digits;\n\
    \        } else {\n            sum += digits;\n            sum -= digits;\n  \
    \      }\n    }\n\n    nums.reverse();\n    nums.sort_unstable_by(|a, b| sums[a]\
    \ - sums[b]);\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0107]: this associated function takes 0 generic arguments but 1\
    \ generic argument was supplied\n  --> /tmp/tmp8g4pdts4.rs:14:34\n   |\n14 | \
    \    let mut sum: isize = nums[0].checked_add::<isize>(&mut sums).unwrap();\n\
    \   |                                  ^^^^^^^^^^^--------- help: remove these\
    \ generics\n   |                                  |\n   |                    \
    \              expected 0 generic arguments\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8g4pdts4.rs:14:55\n   |\n14 |     let mut sum: isize = nums[0].checked_add::<isize>(&mut\
    \ sums).unwrap();\n   |                                                      \
    \ ^^^^^^^^^ expected `isize`, found `&mut Vec<isize>`\n   |\n   = note:      \
    \     expected type `isize`\n           found mutable reference `&mut Vec<isize>`\n\
    \nerror[E0107]: this associated function takes 0 generic arguments but 1 generic\
    \ argument was supplied\n  --> /tmp/tmp8g4pdts4.rs:17:30\n   |\n17 |         let\
    \ mut digits = num.checked_div::<isize>(&mut sum).unwrap();\n   |            \
    \                  ^^^^^^^^^^^--------- help: remove these generics\n   |    \
    \                          |\n   |                              expected 0 generic\
    \ arguments\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8g4pdts4.rs:17:51\n\
    \   |\n17 |         let mut digits = num.checked_div::<isize>(&mut sum).unwrap();\n\
    \   |                                                   ^^^^^^^^ expected `isize`,\
    \ found `&mut isize`\n   |\nhelp: consider removing the borrow\n   |\n17 -   \
    \      let mut digits = num.checked_div::<isize>(&mut sum).unwrap();\n17 +   \
    \      let mut digits = num.checked_div::<isize>(sum).unwrap();\n   | \n\nerror[E0599]:\
    \ no method named `is_zero` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp8g4pdts4.rs:18:19\n   |\n18 |         if digits.is_zero() {\n   |  \
    \                 ^^^^^^^ method not found in `isize`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp8g4pdts4.rs:27:34\n \
    \  |\n27 |     nums.sort_unstable_by(|a, b| sums[a] - sums[b]);\n   |        \
    \                          ^^^^^^^ slice indices are"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::with_capacity(nums.len());\n\
    \n    for n in nums {\n        let mut min_idx = -1;\n        let mut max_idx\
    \ = 0;\n        for i in 0..=n {\n            if nums[i] > nums[min_idx] {\n \
    \               min_idx = i;\n            }\n            if nums[i] < nums[max_idx]\
    \ {\n                max_idx = i;\n            }\n        }\n        if min_idx\
    \ == max_idx {\n            ret.push(n);\n        } else {\n            ret.push(*min_idx);\n\
    \            ret.push(*max_idx);\n        }\n    }\n\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmjx3v35v.rs:15:16\n\
    \   |\n15 |             if nums[i] > nums[min_idx] {\n   |                ^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpmjx3v35v.rs:12:27\n\
    \   |\n12 |         let mut min_idx = -1;\n   |                           ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmjx3v35v.rs:16:27\n   |\n12 |         let mut min_idx =\
    \ -1;\n   |                           -- expected due to this value\n...\n16 |\
    \                 min_idx = i;\n   |                           ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpmjx3v35v.rs:18:16\n   |\n18 |             if nums[i] < nums[max_idx]\
    \ {\n   |                ^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmjx3v35v.rs:19:27\n\
    \   |\n13 |         let mut max_idx = 0;\n   |                           - expected\
    \ due to this value\n...\n19 |                 max_idx = i;\n   |            \
    \               ^ expected `usize`, found `isize`\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmpmjx3v35v.rs:25:22\n   |\n25 |        \
    \     ret.push(*min_idx);\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .flat_map(|(idx, item)| {\n            let (idx, item) = (idx, item);\n\
    \            let mut num = 0;\n            let mut digits = Vec::new();\n    \
    \        while item > 0 {\n                num += item;\n                digits.insert(0,\
    \ num % 10);\n                item = num / 10;\n            }\n            nums.push(idx);\n\
    \            nums.extend_from_slice(&digits);\n            nums\n        })\n\
    \        .cloned()\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3le5uc2.rs:16:26\n   |\n\
    16 |             while item > 0 {\n   |                          ^\n   |     \
    \                     |\n   |                          expected `&isize`, found\
    \ integer\n   |                          help: consider borrowing here: `&0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_3le5uc2.rs:19:24\n   |\n13 |\
    \             let (idx, item) = (idx, item);\n   |                       ----\
    \ expected due to the type of this binding\n...\n19 |                 item = num\
    \ / 10;\n   |                        ^^^^^^^^\n   |                        |\n\
    \   |                        expected `&isize`, found `isize`\n   |          \
    \              help: consider borrowing here: `&(num / 10)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_3le5uc2.rs:21:23\n   |\n21 |             nums.push(idx);\n\
    \   |                       ^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n21 |             nums.push(idx.try_into().unwrap());\n   |      \
    \                    ++++++++++++++++++++\n\nerror[E0271]: type mismatch resolving\
    \ `<FlatMap<Enumerate<std::slice::Iter<'_, isize>>, Vec<isize>, [closure@/tmp/tmp_3le5uc2.rs:12:19:\
    \ 24:10]> as Iterator>::Item == &_`\n    --> /tmp/tmp_3le5uc2.rs:25:10\n     |\n\
    25   |         .cloned()\n     |          ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_3le5uc2.rs:9:5\n   |\n8  |   fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                           ---------- expected\
    \ `Vec<isize>` because of return type\n9  | /     nums\n10 | |         .iter()\n\
    11 | |         .enumerate()\n12 | |         .flat_map(|(idx, item)| {\n...  |\n\
    24 | |         })\n25 | |         .cloned()\n   | |_________________^ expected\
    \ struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Clo"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sums: Vec<isize> = Vec::new();\n  \
    \  for i in nums {\n        sums.push(sum(i));\n    }\n    sums.sort();\n    let\
    \ mut res = Vec::new();\n    for i in nums.iter() {\n        if sums.iter().any(|&v|\
    \ v == i) {\n            res.push(i);\n        }\n    }\n    return res;\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum` in this scope\n  --> /tmp/tmptz8yrtiv.rs:11:19\n\
    \   |\n11 |         sums.push(sum(i));\n   |                   ^^^ help: a local\
    \ variable with a similar name exists: `sums`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptz8yrtiv.rs:16:38\n   |\n16 |         if sums.iter().any(|&v| v\
    \ == i) {\n   |                                      ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |        \
    \ if sums.iter().any(|&v| v == *i) {\n   |                                   \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptz8yrtiv.rs:20:12\n   |\n\
    8  | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |              \
    \                           ---------- expected `Vec<isize>` because of return\
    \ type\n...\n20 |     return res;\n   |            ^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut v = vec![0; nums.len()];\n    let mut\
    \ digits = vec![];\n    for i in 0..nums.len() {\n        v.push(*nums.iter()[i].unwrap());\n\
    \        digits.push(nums.iter()[i].unwrap() as isize);\n    }\n    v.sort_unstable_by_key(|&d|\
    \ digits.iter().position(|&d| *d == d).unwrap_or(std::cmp::Ordering::Less));\n\
    \    v\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `std::slice::Iter<'_, isize>`\n\
    \  --> /tmp/tmpwvfkjm73.rs:12:17\n   |\n12 |         v.push(*nums.iter()[i].unwrap());\n\
    \   |                 ^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `std::slice::Iter<'_, isize>`\n  --> /tmp/tmpwvfkjm73.rs:13:21\n   |\n\
    13 |         digits.push(nums.iter()[i].unwrap() as isize);\n   |            \
    \         ^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvfkjm73.rs:15:80\n\
    \   |\n15 |     v.sort_unstable_by_key(|&d| digits.iter().position(|&d| *d ==\
    \ d).unwrap_or(std::cmp::Ordering::Less));\n   |                             \
    \                                                   ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found enum `std::cmp::Ordering`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.iter().group_by(|n| n % 10).sort_by(|_,\
    \ v| v.len() as u32)\n        .map(|(k, v)| v.iter().sum::<isize>().unwrap())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmpj05ctxnh.rs:9:17\n  |\n9 |     nums.iter().group_by(|n|\
    \ n % 10).sort_by(|_, v| v.len() as u32)\n  |                 ^^^^^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.into_iter().cloned().collect();\n\
    \    let mut points: Vec<_> = nums.windows(3).collect();\n    let mut sums: Vec<_>\
    \ = nums.windows(3).collect();\n    while points.len() > 0 {\n        sums.push(points.clone());\n\
    \        nums.remove(0);\n        points.remove(0);\n    }\n    let mut last_sum\
    \ = 0;\n    for i in 0..nums.len() {\n        last_sum += nums[i];\n        if\
    \ sums.iter().any(|&x| *x != last_sum) {\n            points.push(i);\n      \
    \      sums.push(*last_sum);\n        }\n    }\n    points.clone()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpaez97lkx.rs:9:37\n     |\n9    |     let mut nums =\
    \ nums.into_iter().cloned().collect();\n     |                               \
    \      ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `isize`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpaez97lkx.rs:9:46\n  \
    \ |\n9  |       let mut nums = nums.into_iter().cloned().collect();\n   |    \
    \                                            ^^^^^^^ method cannot be called on\
    \ `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror[E0277]: can't compare `[_]` with `{integer}`\n  --> /tmp/tmpaez97lkx.rs:20:36\n\
    \   |\n20 |         if sums.iter().any(|&x| *x != last_sum) {\n   |          \
    \                          ^^ no implementation for `[_] == {integer}`\n   |\n\
    \   = help: the trait `PartialEq<{integer}>` is not implemented for `[_]`\n  \
    \ = help: the following other types implement trait `PartialEq<Rhs>`:\n      \
    \       <&[B] as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U, A>>>\n\
    \             <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as PartialEq<Vec<U,\
    \ A>>>\n             <[A; N] as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut\
    \ [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpaez97lkx.rs:22:23\n   |\n22 |             sums.push(*last_sum);\n\
    \   |                       ^^^^^^^^^\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone(); // we need a mutable\
    \ reference\n    let mut digit_sums = vec![0; nums.len()];\n    for &x in nums\
    \ {\n        let mut d = x - isize::from(0);\n        d /= 10;\n        digit_sums[d]\
    \ += 1;\n    }\n    let mut num_s = vec![0; digit_sums.len()];\n    let mut num:\
    \ Vec<isize> = Vec::with_capacity(nums.len());\n    // we go through all digits\
    \ one by one\n    for &d in digit_sums.iter_mut() {\n        *d += 1;\n    }\n\
    \    let mut cur_sum = 0;\n    for &d in &digit_sums {\n        cur_sum += d;\n\
    \        num.push(cur_sum % 10);\n        cur_sum -= d % 10;\n    }\n    vec_sort_by_key(nums,\
    \ num);\n    num.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vec_sort_by_key` in this scope\n  -->\
    \ /tmp/tmpmkhumm58.rs:28:5\n   |\n28 |     vec_sort_by_key(nums, num);\n   | \
    \    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmkhumm58.rs:11:9\n   |\n11 |     for &x in nums {\n   |       \
    \  ^^    ---- this expression has type `Option<isize>`\n   |         |\n   | \
    \        expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmkhumm58.rs:19:9\n\
    \   |\n19 |     for &d in digit_sums.iter_mut() {\n   |         ^^    ---------------------\
    \ this expression has type `Option<&mut {integer}>`\n   |         |\n   |    \
    \     types differ in mutability\n   |         help: you can probably remove the\
    \ explicit borrow: `d`\n   |\n   = note: expected mutable reference `&mut {integer}`\n\
    \                      found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut sum = 0;\n\
    \    for &i in nums {\n        sum += i;\n        res.push(i);\n    }\n    let\
    \ mut temp_sum = 0;\n    let mut index = res.len() - 1;\n    while index > 0 {\n\
    \        temp_sum += &res[index];\n        index -= 1;\n        if temp_sum >\
    \ sum {\n            res.swap(index, index + 1);\n            index += 1;\n  \
    \      }\n    }\n    res\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qxsjl_f.rs:11:9\n   |\n\
    11 |     for &i in nums {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut total_points = nums.iter().fold(0, |sum, x| sum + x);\n  \
    \  let mut nums_copy = nums.clone();\n    num_big_digits(&mut nums_copy).for_each(|num_points|\
    \ {\n        total_points += num_points;\n    });\n    nums_copy.sort_unstable_by(|a,\
    \ b| {\n        num_big_digits(&[a, b]).for_each(|num_big| {\n            total_points\
    \ -= num_big;\n        })\n    });\n    nums_copy.clone()\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `num_big_digits` in this scope\n  -->\
    \ /tmp/tmpai64cjvd.rs:14:5\n   |\n14 |     num_big_digits(&mut nums_copy).for_each(|num_points|\
    \ {\n   |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `num_big_digits` in this scope\n  --> /tmp/tmpai64cjvd.rs:18:9\n  \
    \ |\n18 |         num_big_digits(&[a, b]).for_each(|num_big| {\n   |         ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort();\n\n    let mut sorted_nums = nums.clone();\n\
    \    let mut sorted_points = Vec::new();\n    for &num in sorted_nums {\n    \
    \    sorted_points.push((nums.iter().cloned().find(|&p| p == num).unwrap()).unwrap());\n\
    \    }\n\n    sorted_points\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz4wm1848.rs:13:9\n   |\n\
    13 |     for &num in sorted_nums {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: no method named `unwrap` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpz4wm1848.rs:14:80\n   |\n14 |         sorted_points.push((nums.iter().cloned().find(|&p|\
    \ p == num).unwrap()).unwrap());\n   |                                       \
    \                                         ^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut map = Vec::new();\n    for n in nums\
    \ {\n        if map.contains_key(&n.to_digits()) {\n            map.insert(n,\
    \ map.get(&n.to_digits()).unwrap() + n);\n        } else {\n            map.insert(n,\
    \ n);\n        }\n    }\n    let mut sorted_map = map.into_iter().map(|(_, value)|\
    \ value).collect();\n    sorted_map.sort();\n    sorted_map.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains_key` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmphwj63fj8.rs:11:16\n   |\n11 |         if\
    \ map.contains_key(&n.to_digits()) {\n   |                ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `contains`\n\nerror[E0599]: no\
    \ method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmphwj63fj8.rs:11:32\n   |\n11 |         if map.contains_key(&n.to_digits())\
    \ {\n   |                                ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphwj63fj8.rs:12:24\n   |\n12 |\
    \             map.insert(n, map.get(&n.to_digits()).unwrap() + n);\n   |     \
    \                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    12 |             map.insert(n.try_into().unwrap(), map.get(&n.to_digits()).unwrap()\
    \ + n);\n   |                         ++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmphwj63fj8.rs:12:38\n   |\n12 |             map.insert(n, map.get(&n.to_digits()).unwrap()\
    \ + n);\n   |                                      ^^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphwj63fj8.rs:14:24\n\
    \   |\n14 |             map.insert(n, n);\n   |                        ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |             map.insert(n.try_into().unwrap(),\
    \ n);\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphwj63fj8.rs:17:47\n   |\n17 |     let mut sorted_map =\
    \ map.into_iter().map(|(_, value)| value).collect();\n   |                   \
    \                            ^^^^^^^^^-\n   |                                \
    \               |        |\n   |                                             \
    \  |        expected due to this\n   |                                       \
    \        expected `isize`, foun"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .clone()\n \
    \       .sort_by_key(|&x| x.checked_mul(x.checked_digits(10).unwrap()).unwrap())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmppp5o08t9.rs:12:10\n   |\n12 |         .sort_by_key(|&x|\
    \ x.checked_mul(x.checked_digits(10).unwrap()).unwrap())\n   |          ^^^^^^^^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // find out all possible sums\n    let mut\
    \ sum = Vec::new();\n    let mut ans = Vec::new();\n    for i in 0..10 {\n   \
    \     for j in 0..10 {\n            sum.push(nums.len() * j + i);\n        }\n\
    \    }\n\n    // sort according to the sum\n    ans.sort();\n\n    for i in 0..nums.len()\
    \ {\n        ans[i] = nums[i] + sum[ans[i] as usize];\n    }\n\n    ans\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi6oos9kj.rs:22:28\n   |\n\
    22 |         ans[i] = nums[i] + sum[ans[i] as usize];\n   |                  \
    \          ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot add `usize` to `isize`\n  --> /tmp/tmpi6oos9kj.rs:22:26\n   |\n22 | \
    \        ans[i] = nums[i] + sum[ans[i] as usize];\n   |                      \
    \    ^ no implementation for `isize + usize`\n   |\n   = help: the trait `Add<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n\n   \
    \ for &i in nums.iter() {\n        let nums_copy: Vec<isize> = nums_sorted.clone();\n\
    \        let mut sum = 0;\n        for &d in &nums_copy {\n            sum +=\
    \ d as isize;\n        }\n        if nums_sorted.len() < 2 || sum < 0 {\n    \
    \        nums_sorted.push(i);\n        } else {\n            for d in &nums_sorted\
    \ {\n                if *d > i {\n                    nums_sorted.remove(d);\n\
    \                    nums_sorted.push(i);\n                    break;\n      \
    \          }\n            }\n        }\n    }\n    return nums_sorted;\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgt_uc474.rs:22:40\n   |\n\
    22 |                     nums_sorted.remove(d);\n   |                        \
    \                ^ expected `usize`, found `&isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort();\n\n    // Initialize new array\
    \ to store our result\n    let mut result = vec![nums.len()].into_iter().collect();\n\
    \n    // Iterate over the original list and fill in the result\n    for (i, num)\
    \ in nums.into_iter().enumerate() {\n        // Get a slice of the original list\
    \ which consists of the original item\n        let mut slice = nums.iter().skip(i).take(1).collect::<Vec<_>>();\n\
    \        // Sum up the digits and compare it to the current number\n        if\
    \ slice.iter().sum::<u8>() >= num {\n            result[i] = num;\n        }\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `u8: Sum<&&isize>` is not satisfied\n   \
    \ --> /tmp/tmp99e8rzjl.rs:19:25\n     |\n19   |         if slice.iter().sum::<u8>()\
    \ >= num {\n     |                         ^^^ the trait `Sum<&&isize>` is not\
    \ implemented for `u8`\n     |\n     = help: the following other types implement\
    \ trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n               <f32 as\
    \ Sum>\n               <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n  \
    \             <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n        \
    \       <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n             and 20\
    \ others\nnote: required by a bound in `std::iter::Iterator::sum`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp99e8rzjl.rs:19:40\n   |\n19 |         if slice.iter().sum::<u8>()\
    \ >= num {\n   |                                        ^^^ expected `u8`, found\
    \ `isize`\n   |\nhelp: you can convert `slice.iter().sum::<u8>()` from `u8` to\
    \ `isize`, matching the type of `num`\n   |\n19 |         if isize::from(slice.iter().sum::<u8>())\
    \ >= num {\n   |            ++++++++++++                        +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(len(nums) > 0);\n    let mut\
    \ min_sum = nums[0] as isize;\n    let mut min_idx = nums.len();\n    for &n in\
    \ &nums {\n        let mut cur = *n as isize;\n        if cur < min_sum {\n  \
    \          min_sum = cur;\n            min_idx = nums.iter().position(|&x| x ==\
    \ cur);\n        }\n    }\n    nums.drain(min_idx, |&n| {\n        if n == min_sum\
    \ {\n            0\n        } else {\n            *n as isize\n        }\n   \
    \ });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `len` in this scope\n --> /tmp/tmprns0f1x1.rs:9:19\n\
    \  |\n9 |     debug_assert!(len(nums) > 0);\n  |                   ^^^ not found\
    \ in this scope\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmprns0f1x1.rs:13:23\n\
    \   |\n13 |         let mut cur = *n as isize;\n   |                       ^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprns0f1x1.rs:16:23\n   |\n11 |\
    \     let mut min_idx = nums.len();\n   |                       ---------- expected\
    \ due to this value\n...\n16 |             min_idx = nums.iter().position(|&x|\
    \ x == cur);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<usize>`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmprns0f1x1.rs:19:10\n     |\n19\
    \   |       nums.drain(min_idx, |&n| {\n     |  __________^^^^^_-------__-\n \
    \    | |          |\n     | |          expected 1 argument\n20   | |         if\
    \ n == min_sum {\n21   | |             0\n22   | |         } else {\n23   | |\
    \             *n as isize\n24   | |         }\n25   | |     });\n     | |_____-\
    \ supplied 2 arguments\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0425, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a, b| {\n        if a < 0 {\n\
    \            a\n        } else if a == 0 {\n            b\n        } else {\n\
    \            a - b\n        }\n    });\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz71y3ct4.rs:10:16\n   |\n\
    10 |         if a < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz71y3ct4.rs:11:13\n\
    \   |\n11 |             a\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  -->\
    \ /tmp/tmpz71y3ct4.rs:12:21\n   |\n12 |         } else if a == 0 {\n   |     \
    \                ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz71y3ct4.rs:13:13\n   |\n13 |\
    \             b\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz71y3ct4.rs:15:13\n\
    \   |\n15 |             a - b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut digits\
    \ = vec![0];\n    let mut running_sum = 0;\n    for n in nums {\n        while\
    \ n > 0 {\n            running_sum += n % 10; // % means integer division\n  \
    \          n /= 10;\n        }\n        digits.push(running_sum);\n    }\n   \
    \ for n in nums {\n        if n > 0 {\n            while digits.len() <= n {\n\
    \                digits.insert(0, 0);\n            }\n            while digits[n\
    \ - 1] != 0 {\n                running_sum += digits[n - 1];\n               \
    \ digits.remove(n - 1);\n            }\n            result.push((n - 1) as isize\
    \ + running_sum);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpobzysdkc.rs:21:35\n   |\n\
    21 |             while digits.len() <= n {\n   |                             \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n21 |      \
    \       while digits.len() <= n.try_into().unwrap() {\n   |                  \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpobzysdkc.rs:24:19\n   |\n24 |         \
    \    while digits[n - 1] != 0 {\n   |                   ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpobzysdkc.rs:25:32\n   |\n25 |            \
    \     running_sum += digits[n - 1];\n   |                                ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpobzysdkc.rs:26:31\n   |\n26 |              \
    \   digits.remove(n - 1);\n   |                               ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n26 |                 digits.remove((n\
    \ - 1).try_into().unwrap());\n   |                               +     +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = nums.iter().cloned().collect();\n\
    \    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp3lfg2v25.rs:10:5\n\
    \   |\n9  |     let mut res = nums.iter().cloned().collect();\n   |         -------\
    \ consider giving `res` a type\n10 |     res.sort();\n   |     ^^^ cannot infer\
    \ type\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Create a dictionary to store sums and their\
    \ corresponding index\n    // for easy look-up\n    let mut sum_to_idx: HashMap<isize,\
    \ usize> = HashMap::new();\n    // Create a list of unique sums\n    let mut unique_sums\
    \ = Vec::new();\n    for i in 0..nums.len() {\n        let sum = nums.iter().skip(i).sum();\n\
    \        // Add index to dict and sum to the list\n        sum_to_idx.insert(sum,\
    \ i);\n        unique_sums.push(sum);\n    }\n    unique_sums.sort();\n    //\
    \ Reverse the list to get the result in the correct order\n    unique_sums.reverse();\n\
    \    // Create a list for the result\n    let mut result = Vec::new();\n    for\
    \ (idx, sum) in sum_to_idx.into_iter().zip(unique_sums) {\n        // Get the\
    \ corresponding index and add it to the result\n        result.push(nums[idx]\
    \ + sum);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpi_w1ioiw.rs:11:25\n\
    \   |\n11 |     let mut sum_to_idx: HashMap<isize, usize> = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpi_w1ioiw.rs:11:49\n\
    \   |\n11 |     let mut sum_to_idx: HashMap<isize, usize> = HashMap::new();\n\
    \   |                                                 ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // sort by sum of digits\n    let mut nums_sorted\
    \ = nums.into_iter().cloned().sort_by_key(|x| x.checksum_digits()).collect::<Vec<_>>();\n\
    \    // reorder in original order\n    nums_sorted.reverse();\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp0ftpflvg.rs:10:44\n     |\n10   |     let mut nums_sorted\
    \ = nums.into_iter().cloned().sort_by_key(|x| x.checksum_digits()).collect::<Vec<_>>();\n\
    \     |                                            ^^^^^^ expected reference,\
    \ found `isize`\n     |\n     = note: expected reference `&_`\n              \
    \       found type `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for struct `Cloned` in the current scope\n\
    \  --> /tmp/tmp0ftpflvg.rs:10:53\n   |\n10 |     let mut nums_sorted = nums.into_iter().cloned().sort_by_key(|x|\
    \ x.checksum_digits()).collect::<Vec<_>>();\n   |                            \
    \                         ^^^^^^^^^^^ method not found in `Cloned<std::vec::IntoIter<isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums: Vec<isize> = nums.clone(); //\
    \ clone to avoid borrow check\n    nums.sort_unstable_by(|x, y| {\n        assert!(x\
    \ > y);\n        let x = x - y;\n        if x <= 10 {\n            1\n       \
    \ } else {\n            x\n        }\n    });\n    nums\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx7f3g3lk.rs:14:13\n   |\n\
    14 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx7f3g3lk.rs:16:13\n\
    \   |\n16 |             x\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .map(|n| n.to_digits().sum::<usize>())\n        .sort_unstable()\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n  \
    \  assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmppkuvrp23.rs:12:20\n   |\n12 |         .map(|n|\
    \ n.to_digits().sum::<usize>())\n   |                    ^^^^^^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `sort_unstable` found for\
    \ struct `Map` in the current scope\n  --> /tmp/tmppkuvrp23.rs:13:10\n   |\n13\
    \ |         .sort_unstable()\n   |          ^^^^^^^^^^^^^ method not found in\
    \ `Map<Cloned<std::slice::Iter<'_, isize>>, _>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut nums_sum = nums.iter().cloned().sum();\n    let mut nums_digits\
    \ = nums.iter().cloned().map(|n| n.to_string()).collect::<Vec<String>>();\n  \
    \  let mut num_sorted = vec![];\n    for (i, num) in nums.iter().enumerate() {\n\
    \        let digits = nums_digits[i];\n        let diff = num - nums_sum;\n  \
    \      if diff < 0 {\n            // -diff < num < -diff + num\n            if\
    \ diff > 0 {\n                num_sorted.push(-diff);\n                nums_sum\
    \ = num + nums_sum;\n            } else {\n                num_sorted.push(-diff);\n\
    \                nums_sum += num;\n            }\n        } else {\n         \
    \   // diff < num < diff + num\n            if diff > 0 {\n                num_sorted.push(diff);\n\
    \                nums_sum += num;\n            } else {\n                num_sorted.push(diff);\n\
    \                nums_sum += -num;\n            }\n        }\n    }\n    // if\
    \ nums_sum != 0, the list is sorted, otherwise it is empty\n    if nums_sum !=\
    \ 0 {\n        let mut last_nums = nums.iter().cloned().skip(1).collect::<Vec<_>>();\n\
    \        num_sorted.extend_from_slice(&last_nums);\n    }\n    num_sorted\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpkkd8o46g.rs:21:33\n\
    \   |\n17 |         let diff = num - nums_sum;\n   |             ---- consider\
    \ giving `diff` a type\n...\n21 |                 num_sorted.push(-diff);\n  \
    \ |                                 ^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by(|a,\
    \ b| {\n        let (a_digits, b_digits) = a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| (*a, *b)).collect();\n        let total_digits = a_digits.iter().fold(0,\
    \ |sum, item| {\n            sum + item.to_digit(10).unwrap()\n        });\n \
    \       (total_digits, b_digits)\n    });\n    sorted_nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpgk19m40t.rs:11:99\n\
    \   |\n11 |         let (a_digits, b_digits) = a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| (*a, *b)).collect();\n   |                                             \
    \                                                      ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpgk19m40t.rs:11:103\n   |\n11 |\
    \         let (a_digits, b_digits) = a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| (*a, *b)).collect();\n   |                                             \
    \                                                          ^^\n\nerror[E0277]:\
    \ a value of type `(_, _)` cannot be built from an iterator over elements of type\
    \ `_`\n    --> /tmp/tmpgk19m40t.rs:11:108\n     |\n11   |         let (a_digits,\
    \ b_digits) = a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| (*a,\
    \ *b)).collect();\n     |                                                    \
    \                                                        ^^^^^^^ value of type\
    \ `(_, _)` cannot be built from `std::iter::Iterator<Item=_>`\n     |\n     =\
    \ help: the trait `FromIterator<_>` is not implemented for `(_, _)`\n     = help:\
    \ the trait `FromIterator<()>` is implemented for `()`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgk19m40t.rs:15:9\n\
    \   |\n15 |         (total_digits, b_digits)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found tuple\n   |\n   = note: expected enum\
    \ `std::cmp::Ordering`\n             found tuple `(_, _)`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut curr = nums[0];\n    let mut next: isize = 0;\n\n    let\
    \ mut ret = vec![curr];\n\n    let mut cur_idx = 1;\n    let mut next_idx = 1;\n\
    \n    for n in nums {\n        let d = n % 10;\n        let s = d + 10*cur_idx;\n\
    \        let t = s + next_idx;\n\n        if t < curr {\n            next = t;\n\
    \            next_idx = 1;\n        } else {\n            let idx = cur_idx;\n\
    \            let curr = curr;\n            next_idx = next_idx;\n            ret.push(idx);\n\
    \        }\n\n        cur_idx += 1;\n    }\n\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3, 4, 5]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpobi4w44r.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut points: Vec<isize> = Vec::new();\n    let mut digit_sums:\
    \ Vec<isize> = Vec::new();\n    for i in nums.iter() {\n        points.push(i\
    \ % 10);\n        digit_sums.push(i);\n    }\n    let mut max_so_far = &digit_sums[0];\n\
    \    for i in &digit_sums[1..] {\n        let mut cur = *i;\n        if cur >\
    \ max_so_far {\n            max_so_far = cur;\n        }\n    }\n    let mut min_so_far\
    \ = &digit_sums[0];\n    for i in &digit_sums[1..] {\n        let mut cur = *i;\n\
    \        if cur < min_so_far {\n            min_so_far = cur;\n        }\n   \
    \ }\n    points.sort_unstable_by(|x, y| {\n        digit_sum(x + y) - digit_sum(x\
    \ + max_so_far) - digit_sum(y + min_so_far)\n    });\n    points\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `digit_sum` in this scope\n  --> /tmp/tmpmfofbn1z.rs:33:9\n\
    \   |\n33 |         digit_sum(x + y) - digit_sum(x + max_so_far) - digit_sum(y\
    \ + min_so_far)\n   |         ^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `digit_sums`\n\nerror[E0425]: cannot find function `digit_sum`\
    \ in this scope\n  --> /tmp/tmpmfofbn1z.rs:33:28\n   |\n33 |         digit_sum(x\
    \ + y) - digit_sum(x + max_so_far) - digit_sum(y + min_so_far)\n   |         \
    \                   ^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `digit_sums`\n\nerror[E0425]: cannot find function `digit_sum` in this scope\n\
    \  --> /tmp/tmpmfofbn1z.rs:33:56\n   |\n33 |         digit_sum(x + y) - digit_sum(x\
    \ + max_so_far) - digit_sum(y + min_so_far)\n   |                            \
    \                            ^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `digit_sums`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmfofbn1z.rs:16:25\n\
    \   |\n16 |         digit_sums.push(i);\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    16 |         digit_sums.push(*i);\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmfofbn1z.rs:21:18\n   |\n21 |         if cur\
    \ > max_so_far {\n   |                  ^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |         if cur > *max_so_far\
    \ {\n   |                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmfofbn1z.rs:22:26\n\
    \   |\n18 |     let mut max_so_far = &digit_sums[0];\n   |                   \
    \       -------------- expected due to this value\n...\n22 |             max_so_far\
    \ = cur;\n   |                          ^^^\n   |                          |\n\
    \   |                          expected `&isize`, found `isize`\n   |        \
    \                  help: consider borrowing here: `&cur`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmfofbn1z.rs:28:18\n   |\n28 |         if cur < min_so_far\
    \ {\n   |                  ^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: con"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut sum:\
    \ isize = 0;\n    for num in nums.iter() {\n        sum += num;\n        result.push(sum);\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-12, 0, 1, 11, 12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmprwesucl9.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|x| {\n        // Sum digits\
    \ of x\n        let mut digits = x.to_string().chars().map(|x| *x).collect::<Vec<_>>();\n\
    \        digits.sort_by(|x, y| x.partial_cmp(&y).unwrap());\n        digits.iter().sum()\n\
    \    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp76gpn55g.rs:11:56\n\
    \   |\n11 |         let mut digits = x.to_string().chars().map(|x| *x).collect::<Vec<_>>();\n\
    \   |                                                        ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Calculate the sum of the digits of each\
    \ number\n    let mut sums = vec![];\n    for n in nums {\n        let mut s =\
    \ n.to_digits();\n        s.push((0));\n        sums.push(s[0] + s[1] + s[2] +\
    \ s[3]);\n    }\n\n    // Sort the numbers based on their sum\n    sums.sort_by_key(|n|\
    \ n.partial_cmp(&0));\n    // Return the sorted numbers according to their index\n\
    \    nums.iter().cloned().zip(sums.cloned()).map(|(n, _)| n)\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpv_zqrkf9.rs:13:16\n\
    \   |\n13 |         s.push((0));\n   |                ^ ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n13 -         s.push((0));\n\
    13 +         s.push(0);\n   | \n\nerror[E0599]: no method named `to_digits` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpv_zqrkf9.rs:12:23\n   |\n\
    12 |         let mut s = n.to_digits();\n   |                       ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_zqrkf9.rs:20:5\n\
    \   |\n8  | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \                                  ---------- expected `Vec<isize>` because of\
    \ return type\n...\n20 |     nums.iter().cloned().zip(sums.cloned()).map(|(n,\
    \ _)| n)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `Map`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Map<Zip<Cloned<std::slice::Iter<'_, isize>>, _>,\
    \ [closure@/tmp/tmpv_zqrkf9.rs:20:49: 20:59]>`\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    let mut sum = nums.iter().map(|x| x as isize).sum();\n    if sum\
    \ < 0 {\n        sum = sum + 10;\n    }\n\n    let mut nums_rev = nums.rev();\n\
    \    let mut index_sorted = vec![];\n\n    for i in 0..nums.len() {\n        let\
    \ mut j = i;\n        let mut k = 1;\n        while j < nums.len() && sum == nums_rev[j]\
    \ {\n            j = j + 1;\n            k = k + 1;\n        }\n        index_sorted.push(nums_rev[j]);\n\
    \        nums_rev[j] = nums_rev[j + k - 1];\n    }\n\n    index_sorted.reverse();\n\
    \    nums_rev\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp9qfbfigx.rs:18:29\n\
    \    |\n18  |       let mut nums_rev = nums.rev();\n    |                    \
    \           ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0606]:\
    \ casting `&isize` as `isize` is invalid\n  --> /tmp/tmp9qfbfigx.rs:13:39\n  \
    \ |\n13 |     let mut sum = nums.iter().map(|x| x as isize).sum();\n   |     \
    \                                  -^^^^^^^^^\n   |                          \
    \             |\n   |                                       cannot cast `&isize`\
    \ as `isize`\n   |                                       help: dereference the\
    \ expression: `*x`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0606.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut nums_sorted = nums.clone();\n    let mut i = 0;\n    let mut\
    \ j = nums.len();\n    while i < j {\n        while i < j && nums_sorted[i] <\
    \ nums_sorted[j] {\n            i += 1;\n        }\n        while i < j && nums_sorted[i]\
    \ > nums_sorted[j] {\n            j -= 1;\n        }\n        if i == j {\n  \
    \          break;\n        }\n        let tmp = nums_sorted[i];\n        nums_sorted[i]\
    \ = nums_sorted[j];\n        nums_sorted[j] = tmp;\n        i += 1;\n        j\
    \ -= 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmpkgb71ekm.rs:16:41\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ans = Vec::new();\n    let mut sorted_digits\
    \ = vec![];\n    let mut num_digits = nums.len();\n    let mut num_digits_sum\
    \ = 0;\n    let mut min_digits = nums.iter().map(|i| i as isize).min();\n    let\
    \ mut max_digits = nums.iter().map(|i| i as isize).max();\n    let mut min_digits_index\
    \ = -1;\n    let mut max_digits_index = -1;\n    let mut cur_digits = vec![];\n\
    \    let mut cur_digit_sum = 0;\n    let mut cur_digits_index = -1;\n    while\
    \ num_digits > 0 {\n        let current_digit_sum = num_digits_sum + num_digits;\n\
    \        if current_digit_sum < cur_digits_index {\n            cur_digits_index\
    \ = current_digit_sum;\n        }\n        if cur_digits_index == min_digits_index\
    \ {\n            if min_digits < cur_digits {\n                min_digits = cur_digits;\n\
    \                min_digits_index = 0;\n            }\n            cur_digits_index\
    \ = num_digits;\n        }\n        if cur_digits_index == max_digits_index {\n\
    \            if max_digits > cur_digits {\n                max_digits = cur_digits;\n\
    \                max_digits_index = num_digits;\n            }\n            cur_digits_index\
    \ = num_digits;\n        }\n        cur_digits = cur_digits.clone();\n       \
    \ cur_digit_sum = cur_digits_sum + num_digits;\n        let mut current_digit\
    \ = num_digits;\n        if num_digits > 1 {\n            while current_digit\
    \ > 0 {\n                if cur_digits[current_digit - 1] >= 10 {\n          \
    \          cur_digits[current_digit - 1] -= 10;\n                } else {\n  \
    \                  break;\n                }\n                current_digit--;\n\
    \            }\n            if cur_digits[cur_digits_index] > 0 {\n          \
    \      if cur_digits[cur_digits_index] == 1 {\n                    cur_digits[cur_digits_index]\
    \ = 0;\n                } else {\n                    cur_digits[cur_digits_index]\
    \ -= 1;\n                }\n            }\n        }\n        if cur_digits_index\
    \ > 0 {\n            cur_digit_sum = cur_digits_sum;\n        }\n        ans.push(*cur_digits.clone());\n\
    \        num_digits -= 1;\n        num_digits_sum += cur_digits_sum;\n    }\n\
    \    ans.push(min_digits[min_digits_index]);\n    ans.push(max_digits[max_digits_index]);\n\
    \    ans\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpppxa7jza.rs:49:32\n\
    \   |\n49 |                 current_digit--;\n   |                           \
    \     ^ expected expression\n\nerror[E0425]: cannot find value `cur_digits_sum`\
    \ in this scope\n  --> /tmp/tmpppxa7jza.rs:40:25\n   |\n40 |         cur_digit_sum\
    \ = cur_digits_sum + num_digits;\n   |                         ^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `cur_digit_sum`\n\nerror[E0425]:\
    \ cannot find value `cur_digits_sum` in this scope\n  --> /tmp/tmpppxa7jza.rs:60:29\n\
    \   |\n60 |             cur_digit_sum = cur_digits_sum;\n   |                \
    \             ^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `cur_digit_sum`\n\nerror[E0425]: cannot find value `cur_digits_sum` in this\
    \ scope\n  --> /tmp/tmpppxa7jza.rs:64:27\n   |\n64 |         num_digits_sum +=\
    \ cur_digits_sum;\n   |                           ^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `cur_digit_sum`\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpppxa7jza.rs:19:32\n   |\n\
    19 |     let mut cur_digits_index = -1;\n   |                                ^^\
    \ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpppxa7jza.rs:15:32\n\
    \   |\n15 |     let mut min_digits_index = -1;\n   |                         \
    \       ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpppxa7jza.rs:26:29\n   |\n26 |  \
    \           if min_digits < cur_digits {\n   |                             ^^^^^^^^^^\
    \ expe"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sum = nums.iter().map(|n| n.to_digits()).sum();\n\
    \    nums.sort();\n    nums.reverse();\n    nums.iter().map(|n| {\n        match\
    \ nums_sum {\n            0 => isize::from_digits(n, 10),\n            n => isize::from_digits(n,\
    \ 10),\n            _ => panic!(\"Sum of digits must be 0, but got {}\", nums_sum),\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n --> /tmp/tmpvtj8chja.rs:9:46\n  |\n9 |     let mut nums_sum\
    \ = nums.iter().map(|n| n.to_digits()).sum();\n  |                           \
    \                   ^^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ function or associated item named `from_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpvtj8chja.rs:14:25\n   |\n14 |             0 =>\
    \ isize::from_digits(n, 10),\n   |                         ^^^^^^^^^^^ function\
    \ or associated item not found in `isize`\n\nerror[E0599]: no function or associated\
    \ item named `from_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpvtj8chja.rs:15:25\n   |\n15 |             n => isize::from_digits(n,\
    \ 10),\n   |                         ^^^^^^^^^^^ function or associated item not\
    \ found in `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    let mut cur_sum = 0;\n\n    for &i in nums {\n        cur_sum +=\
    \ i;\n    }\n\n    let mut ret: Vec<isize> = nums.clone();\n\n    // Iterate through\
    \ the vector in descending order.\n    for i in 0..(ret.size() - 1) {\n      \
    \  // Check if the sum of current vector number is greater than the previous\n\
    \        // vector number, and if yes update the current sum.\n        if cur_sum\
    \ > ret[ret.len() - i - 1] {\n            cur_sum -= ret[ret.len() - i - 1];\n\
    \            ret[ret.len() - i] = i;\n        }\n    }\n\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb423ojia.rs:15:9\n   |\n\
    15 |     for &i in nums {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `size` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpb423ojia.rs:22:22\n\
    \   |\n22 |     for i in 0..(ret.size() - 1) {\n   |                      ^^^^\
    \ help: there is an associated function with a similar name: `resize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb423ojia.rs:27:34\n   |\n27 |             ret[ret.len()\
    \ - i] = i;\n   |             ------------------   ^ expected `isize`, found `usize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut total_num\
    \ = 0;\n    for num in nums {\n        total_num += num as isize;\n        result.push(num);\n\
    \    }\n    let mut counter = Vec::new();\n    for num in nums.iter() {\n    \
    \    if let Some(pos) = result.iter().position(|&x| x == num) {\n            counter[pos]\
    \ += 1;\n        }\n    }\n    for pos in 0..total_num {\n        if counter[pos]\
    \ > 0 {\n            result.swap(pos, total_num);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyu6tizn9.rs:17:61\n   |\n\
    17 |         if let Some(pos) = result.iter().position(|&x| x == num) {\n   |\
    \                                                             ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |  \
    \       if let Some(pos) = result.iter().position(|&x| x == *num) {\n   |    \
    \                                                         +\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpyu6tizn9.rs:22:12\n \
    \  |\n22 |         if counter[pos] > 0 {\n   |            ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyu6tizn9.rs:23:25\n\
    \   |\n23 |             result.swap(pos, total_num);\n   |                   \
    \      ^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n23 |      \
    \       result.swap(pos.try_into().unwrap(), total_num);\n   |               \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyu6tizn9.rs:23:30\n\
    \   |\n23 |             result.swap(pos, total_num);\n   |                   \
    \           ^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    23 |             result.swap(pos, total_num.try_into().unwrap());\n   |      \
    \                                 ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort();\n\n    let mut ret = vec![];\n\
    \    let mut cur_sum = 0;\n    for &x in nums.iter() {\n        cur_sum += x;\n\
    \        cur_sum = cur_sum % 10;\n        if cur_sum == 0 {\n            ret.push(x);\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `nums` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmp9upp205i.rs:9:5\n  |\n8 | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n  |                    ---- help: consider changing this to\
    \ be mutable: `mut nums`\n9 |     nums.sort();\n  |     ^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sums: Vec<isize> = nums.into_iter().map(|x|\
    \ x.checked_mul(10).unwrap()).collect();\n    sums.sort();\n    let mut nums_reordered\
    \ = nums.into_iter().map(|x| x.checked_mul(10).unwrap()).collect();\n    nums_reordered.sort_by(|a,\
    \ b| sums[a] - sums[b]);\n    nums_reordered\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpvbp6phyj.rs:12:5\n\
    \   |\n11 |     let mut nums_reordered = nums.into_iter().map(|x| x.checked_mul(10).unwrap()).collect();\n\
    \   |         ------------------ consider giving `nums_reordered` a type\n12 |\
    \     nums_reordered.sort_by(|a, b| sums[a] - sums[b]);\n   |     ^^^^^^^^^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    let mut sum:\
    \ usize = 0;\n\n    for n in nums {\n        sum += *n as usize;\n    }\n\n  \
    \  let mut tmp: Vec<isize> = Vec::new();\n\n    for n in nums.iter() {\n     \
    \   if *n % 10 < sum {\n            tmp.push(n);\n        }\n    }\n\n    tmp.sort();\n\
    \n    nums.clear();\n    nums.extend(tmp);\n\n    nums\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp4wo9hv3_.rs:13:16\n\
    \   |\n13 |         sum += *n as usize;\n   |                ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4wo9hv3_.rs:19:22\n   |\n19 |         if *n\
    \ % 10 < sum {\n   |                      ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if *n % 10 < sum.try_into().unwrap() {\n\
    \   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4wo9hv3_.rs:20:22\n   |\n20 |             tmp.push(n);\n\
    \   |                      ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |             tmp.push(*n);\n   |       \
    \               +\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .filter_map(|(index, &item)| {\n            // If two or more elements\
    \ have the same sum,\n            // order them based on their original index\n\
    \            match nums[index] {\n                Some(&n) if n == item => Some(index),\n\
    \                Some(_) => None,\n                None => Some(index),\n    \
    \        }\n        })\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiv5nj29x.rs:16:17\n   |\n\
    15 |             match nums[index] {\n   |                   ----------- this\
    \ expression has type `isize`\n16 |                 Some(&n) if n == item => Some(index),\n\
    \   |                 ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n \
    \  = note: expected type `isize`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiv5nj29x.rs:17:17\n   |\n15 |             match\
    \ nums[index] {\n   |                   ----------- this expression has type `isize`\n\
    16 |                 Some(&n) if n == item => Some(index),\n17 |             \
    \    Some(_) => None,\n   |                 ^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiv5nj29x.rs:18:17\n   |\n15 |\
    \             match nums[index] {\n   |                   ----------- this expression\
    \ has type `isize`\n...\n18 |                 None => Some(index),\n   |     \
    \            ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiv5nj29x.rs:9:5\n   |\n8  |   fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          \
    \ ---------- expected `Vec<isize>` because of return type\n9  | /     nums\n10\
    \ | |         .iter()\n11 | |         .enumerate()\n12 | |         .filter_map(|(index,\
    \ &item)| {\n...  |\n20 | |         })\n21 | |         .collect::<Vec<_>>()\n\
    \   | |____________________________^ expected `isize`, found `usize`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut sorted_nums = nums.clone();\n    sorted_nums.sort();\n \
    \   sorted_nums.sort_unstable();\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-12, -11, -1, 1, 11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpi9g0m1hk.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_iter = nums.into_iter().cloned();\n\
    \    let mut nums_iter2 = nums_iter.cloned().collect::<Vec<_>>();\n    let mut\
    \ nums_iter3 = nums_iter2.clone();\n    let mut min_idx = nums_iter3.min_by_key(|&x|\
    \ x.partial_sum());\n    let mut max_idx = nums_iter3.max_by_key(|&x| x.partial_sum());\n\
    \    while let Some(mut idx) = (min_idx, max_idx) {\n        swap(idx, min_idx,\
    \ nums_iter2);\n        swap(idx, max_idx, nums_iter3);\n        min_idx = nums_iter3.min_by_key(|&x|\
    \ x.partial_sum());\n        max_idx = nums_iter3.max_by_key(|&x| x.partial_sum());\n\
    \    }\n    nums_iter2\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpk0eccwyv.rs:15:9\n\
    \   |\n15 |         swap(idx, min_idx, nums_iter2);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmpk0eccwyv.rs:16:9\n   |\n16\
    \ |         swap(idx, max_idx, nums_iter3);\n   |         ^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0271]: type mismatch resolving\
    \ `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n    --> /tmp/tmpk0eccwyv.rs:9:42\n\
    \     |\n9    |     let mut nums_iter = nums.into_iter().cloned();\n     |   \
    \                                       ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `cloned`\
    \ exists for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpk0eccwyv.rs:10:36\n   |\n10 |       let mut\
    \ nums_iter2 = nums_iter.cloned().collect::<Vec<_>>();\n   |                 \
    \                     ^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk0eccwyv.rs:14:15\n   |\n14 |     while let\
    \ Some(mut idx) = (min_idx, max_idx) {\n   |               ^^^^^^^^^^^^^   ------------------\
    \ this expression has type `(_, _)`\n   |               |\n   |              \
    \ expected tuple, found enum `Option`\n   |\n   = note: expected tuple `(_, _)`\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut total: isize = 0;\n    for num in nums.iter()\
    \ {\n        let digit = num % 10;\n        total += digit as isize;\n       \
    \ num = (num / 10) as isize;\n    }\n    if total == 0 {\n        return nums;\n\
    \    }\n    order_by_digits(total, 0, nums)\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `order_by_digits` in this scope\n  -->\
    \ /tmp/tmpoud55ck0.rs:18:5\n   |\n18 |     order_by_digits(total, 0, nums)\n \
    \  |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoud55ck0.rs:13:15\n   |\n10 |     for num in nums.iter() {\n  \
    \ |         --- expected due to the type of this binding\n...\n13 |         num\
    \ = (num / 10) as isize;\n   |               ^^^^^^^^^^^^^^^^^^^\n   |       \
    \        |\n   |               expected `&isize`, found `isize`\n   |        \
    \       help: consider borrowing here: `&((num / 10) as isize)`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .map(|(idx, val)| {\n            let mut sum = 0;\n            for &num\
    \ in &nums[idx] {\n                sum += num;\n            }\n            (val,\
    \ sum)\n        })\n        .sort_by(|(val1, sum1), (val2, sum2)| {\n        \
    \    let val1 = val1.to_digits();\n            let val2 = val2.to_digits();\n\
    \            if val1 == val2 {\n                sum1.cmp(&sum2)\n            }\
    \ else {\n                if sum1 > sum2 {\n                    Ordering::Greater\n\
    \                } else if sum1 < sum2 {\n                    Ordering::Less\n\
    \                } else {\n                    Ordering::Equal\n             \
    \   }\n            }\n        })\n        .map(|(val, sum)| {\n            val.to_digits()\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmptbrfnwr3.rs:26:21\n   |\n26 |                     Ordering::Greater\n\
    \   |                     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmptbrfnwr3.rs:28:21\n\
    \   |\n28 |                     Ordering::Less\n   |                     ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmptbrfnwr3.rs:30:21\n   |\n30 |    \
    \                 Ordering::Equal\n   |                     ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0277]: `&isize` is not an iterator\n  --> /tmp/tmptbrfnwr3.rs:14:25\n\
    \   |\n14 |             for &num in &nums[idx] {\n   |                       \
    \  ^^^^^^^^^^ `&isize` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&isize`\n\nerror[E0599]: no method named\
    \ `sort_by` found for struct `Map` in the current scope\n  --> /tmp/tmptbrfnwr3.rs:19:10\n\
    \   |\n19 |         .sort_by(|(val1, sum1), (val2, sum2)| {\n   |          ^^^^^^^\
    \ method not found in `Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmptbrfnwr3.rs:12:14:\
    \ 18:10]>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    \n    let mut index = 0;\n    let mut cur = nums[0];\n    let mut\
    \ s = Vec::<isize>::new();\n    \n    for n in nums {\n        loop {\n      \
    \      index %= 10;\n            if n == cur {\n                s.push(n);\n \
    \               break;\n            }\n            s.push(n);\n            \n\
    \            cur += ((n - cur) * 10) as isize;\n            index = (cur * 10\
    \ + index) as isize;\n        }\n    }\n    \n    order_by_points(s)\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpuydte8_n.rs:27:22\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    // get the digit sum for each item\n    let mut digit_sum = vec![0;\
    \ nums.len()];\n    for i in nums {\n        digit_sum[i] += i % 10 as isize;\n\
    \    }\n\n    // sort and return the result\n    let mut sorted_nums = vec![];\n\
    \    for i in nums {\n        if digit_sum[i] == 0 {\n            sorted_nums.push(i);\n\
    \        }\n    }\n\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmppov4916a.rs:16:9\n   |\n16 |         digit_sum[i] += i % 10 as isize;\n\
    \   |         ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmppov4916a.rs:22:12\n\
    \   |\n22 |         if digit_sum[i] == 0 {\n   |            ^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = nums.clone();\n    for idx\
    \ in 0..nums.len() {\n        let mut sum = 0;\n        let mut digit = nums[idx];\n\
    \        while digit != 0 {\n            sum += digit % 10;\n            digit\
    \ /= 10;\n        }\n        if sum != 0 {\n            result[idx] = sum;\n \
    \       }\n    }\n    result.sort_by_key(|x| x);\n    result\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: lifetime may not live long enough\n  --> /tmp/tmp1zvpogx9.rs:21:28\n\
    \   |\n21 |     result.sort_by_key(|x| x);\n   |                         -- ^\
    \ returning this value requires that `'1` must outlive `'2`\n   |            \
    \             ||\n   |                         |return type of closure is &'2\
    \ isize\n   |                         has type `&'1 isize`\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Calculate the sum of all digits in the original\
    \ list.\n    let mut sum = nums.iter().map(|n| n.to_digits()).sum();\n\n    //\
    \ Sort numbers in ascending order according to the sum of their digits.\n    nums.sort_unstable_by_key(|n|\
    \ {\n        n.to_digits().iter().cloned().map(|&d| d * &d + &mut sum).sum::<isize>()\n\
    \    });\n\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmprxm3ispx.rs:10:41\n   |\n10 |     let mut\
    \ sum = nums.iter().map(|n| n.to_digits()).sum();\n   |                      \
    \                   ^^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `to_digits` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmprxm3ispx.rs:14:11\n   |\n14 |         n.to_digits().iter().cloned().map(|&d|\
    \ d * &d + &mut sum).sum::<isize>()\n   |           ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for n in nums {\n   \
    \     sum += *n;\n    }\n    if sum < 0 {\n        let mut nums = nums.clone();\n\
    \        let n = nums.len() - 1;\n        let mut i = 0;\n        for n in &mut\
    \ nums[i..] {\n            *n += *n;\n        }\n        let mut sum = 0;\n  \
    \      while i < n {\n            sum += nums[i];\n            nums[i] = -sum;\n\
    \            i += 1;\n        }\n        nums = nums.clone();\n        for n in\
    \ &nums[..] {\n            *n += *n;\n        }\n    }\n    let mut nums = nums.clone();\n\
    \    let mut nums_sorted = vec![];\n    let mut i = nums.len() - 1;\n    while\
    \ i >= 0 {\n        let n = nums[i];\n        let j = 0;\n        while j + 1\
    \ < nums.len() {\n            let m = nums[j];\n            if *n < m {\n    \
    \            nums_sorted.push(*n);\n                nums.remove(j);\n        \
    \    } else if *n > m {\n                nums_sorted.push(m);\n              \
    \  nums.remove(j + 1);\n            } else {\n                break;\n       \
    \     }\n            j += 1;\n        }\n        nums_sorted.push(*n);\n     \
    \   nums.remove(i - 1);\n        i -= 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp9zqgnciv.rs:11:16\n\
    \   |\n11 |         sum += *n;\n   |                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp9zqgnciv.rs:39:16\n   |\n39 |        \
    \     if *n < m {\n   |                ^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp9zqgnciv.rs:40:34\n   |\n40 |               \
    \  nums_sorted.push(*n);\n   |                                  ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp9zqgnciv.rs:42:23\n   |\n\
    42 |             } else if *n > m {\n   |                       ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp9zqgnciv.rs:50:26\n   |\n\
    50 |         nums_sorted.push(*n);\n   |                          ^^\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut s = 0.0;\n    let mut m = 0.0;\n  \
    \  for &n in nums {\n        m += n;\n        s += n.pow(10.0);\n    }\n    OrderBy::new(s,\
    \ m, nums).unwrap()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `OrderBy`\n  -->\
    \ /tmp/tmpwa3skbxw.rs:15:5\n   |\n15 |     OrderBy::new(s, m, nums).unwrap()\n\
    \   |     ^^^^^^^ use of undeclared type `OrderBy`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwa3skbxw.rs:11:9\n   |\n11 |     for &n in nums {\n   |\
    \         ^^    ---- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_sum: isize = nums.iter().sum();\n\
    \    let mut min_sum: isize = nums.iter().sum();\n    for &num in nums.iter()\
    \ {\n        let mut sum: isize = num.iter().sum();\n        if sum < min_sum\
    \ {\n            min_sum = sum;\n        }\n        if sum > max_sum {\n     \
    \       max_sum = sum;\n        }\n    }\n    nums\n        .iter()\n        .zip(min_sum..iter())\n\
    \        .map(|(num, min_sum)| {\n            // if there are several items with\
    \ similar sum of their digits,\n            // order them based on their index\
    \ in original list\n            if num == min_sum {\n                num\n   \
    \         } else {\n                num\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `iter` in this scope\n  --> /tmp/tmpynrxrx2f.rs:22:23\n\
    \   |\n22 |         .zip(min_sum..iter())\n   |                       ^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `iter` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpynrxrx2f.rs:12:34\n   |\n12 |         let\
    \ mut sum: isize = num.iter().sum();\n   |                                  ^^^^\
    \ method not found in `isize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpynrxrx2f.rs:26:20\n   |\n26 |             if num == min_sum {\n\
    \   |                    ^^ no implementation for `&isize == isize`\n   |\n  \
    \ = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpynrxrx2f.rs:32:10\n     |\n\
    32   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(nums.len() > 0);\n\n    let mut\
    \ nums_copy = nums.clone();\n    let mut res = vec![];\n    let mut digits = vec![0];\n\
    \    let mut sum_of_digits = 0;\n    let mut digit = nums_copy.first();\n    for\
    \ i in 1..nums_copy.len() {\n        let sum = digit + nums_copy[i];\n       \
    \ digits.push(digit);\n        digit = sum;\n        sum_of_digits += digit;\n\
    \    }\n    let mut i = 0;\n    while i < nums_copy.len() {\n        if sum_of_digits\
    \ == nums_copy[i] {\n            digits.push(nums_copy[i]);\n            i +=\
    \ 1;\n        } else {\n            let mut j = i;\n            while j < nums_copy.len()\
    \ {\n                if sum_of_digits < nums_copy[j] {\n                    j\
    \ = j + 1;\n                }\n                if sum_of_digits == nums_copy[j]\
    \ {\n                    break;\n                }\n                digits.push(nums_copy[j]);\n\
    \                j += 1;\n            }\n            if j < nums_copy.len() {\n\
    \                digits.push(nums_copy[j]);\n            }\n        }\n    }\n\
    \    for i in 0..digits.len() {\n        res.push(digits[i]);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `isize` to `Option<&isize>`\n  --> /tmp/tmpb9iagdmo.rs:17:25\n\
    \   |\n17 |         let sum = digit + nums_copy[i];\n   |                   -----\
    \ ^ ------------ isize\n   |                   |\n   |                   Option<&isize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb9iagdmo.rs:18:21\n   |\n18 |\
    \         digits.push(digit);\n   |                     ^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<&isize>`\n\nerror[E0277]: cannot add-assign `Option<&isize>`\
    \ to `{integer}`\n  --> /tmp/tmpb9iagdmo.rs:20:23\n   |\n20 |         sum_of_digits\
    \ += digit;\n   |                       ^^ no implementation for `{integer} +=\
    \ Option<&isize>`\n   |\n   = help: the trait `AddAssign<Option<&isize>>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_slice = nums.clone();\n\n    //\
    \ Sort by ascending sum of digits first\n    nums_slice.sort_by(|a, b| a.checked_add(b).unwrap());\n\
    \n    // Sort by ascending index of item\n    nums_slice.sort_by(|a, b| a.cmp(b));\n\
    \n    nums_slice\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphjmhl2pj.rs:12:45\n   |\n\
    12 |     nums_slice.sort_by(|a, b| a.checked_add(b).unwrap());\n   |         \
    \                                    ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n12 |     nums_slice.sort_by(|a,\
    \ b| a.checked_add(*b).unwrap());\n   |                                      \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphjmhl2pj.rs:12:31\n\
    \   |\n12 |     nums_slice.sort_by(|a, b| a.checked_add(b).unwrap());\n   |  \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n\n    for\
    \ num in nums {\n        let sum = nums.iter().filter(|x| x % 10 == 0).sum::<isize>();\n\
    \        sorted_list.push(sum);\n    }\n    sorted_list.sort();\n\n    for i in\
    \ 0..nums.len() {\n        let sum = nums[i].pow(2).unwrap();\n        if sum\
    \ != sorted_list[i] {\n            sorted_list[i] = sum;\n        }\n    }\n \
    \   sorted_list\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp4kflj3q1.rs:12:44\n\
    \   |\n12 |         let sum = nums.iter().filter(|x| x % 10 == 0).sum::<isize>();\n\
    \   |                                          - ^ -- {integer}\n   |        \
    \                                  |\n   |                                   \
    \       &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference `x`\n\
    \   |\n12 |         let sum = nums.iter().filter(|x| *x % 10 == 0).sum::<isize>();\n\
    \   |                                          +\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmp4kflj3q1.rs:18:34\n\
    \   |\n18 |         let sum = nums[i].pow(2).unwrap();\n   |                 \
    \                 ^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums\n\
    \    }\n\n    let mut nums = nums.clone();\n    loop {\n        let mut i = nums.iter().sum::<isize>();\n\
    \        let j = nums.iter().rev().sum::<isize>();\n        if i != j {\n    \
    \        nums.swap(i, j);\n            break;\n        }\n    }\n    return nums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_nmo92h2.rs:18:23\n   |\n\
    18 |             nums.swap(i, j);\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |             nums.swap(i.try_into().unwrap(),\
    \ j);\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_nmo92h2.rs:18:26\n   |\n18 |             nums.swap(i,\
    \ j);\n   |                          ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |             nums.swap(i, j.try_into().unwrap());\n \
    \  |                           ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // First, store all items with equal sum of\
    \ digits as keys and values\n    let mut sorted = HashMap::new();\n    for num\
    \ in nums {\n        let sum: usize = num.digits().sum();\n        let mut value\
    \ = 0;\n        loop {\n            if value + num.digits()[sum - 1 - value] ==\
    \ 0 {\n                break;\n            }\n            value += 1;\n      \
    \  }\n        sorted.insert(sum, num);\n    }\n\n    // Now sort based on the\
    \ keys\n    let mut res = vec![];\n    let mut prev_sum = 0;\n    for key_value\
    \ in sorted.iter() {\n        let key = key_value.0;\n        let value = key_value.1;\n\
    \        // Add all the values with same key as 0\n        let mut tmp_sum = prev_sum\
    \ + key.digits().sum();\n        loop {\n            if tmp_sum - value.digits().sum()\
    \ == 0 {\n                break;\n            }\n            tmp_sum += value.digits().sum();\n\
    \        }\n        prev_sum = tmp_sum;\n        res.push(value);\n    }\n   \
    \ res.sort();\n    for num in nums {\n        sorted.remove(&num.digits().sum());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp0scc5nz1.rs:10:22\n   |\n10 |     let mut sorted = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp0scc5nz1.rs:12:30\n   |\n12 |         let sum: usize = num.digits().sum();\n\
    \   |                              ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp0scc5nz1.rs:15:28\n   |\n15 |             if value + num.digits()[sum\
    \ - 1 - value] == 0 {\n   |                            ^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `digits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp0scc5nz1.rs:42:28\n   |\n42 |         sorted.remove(&num.digits().sum());\n\
    \   |                            ^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a, b| {\n        a.checked_add(a).partial_cmp(&b.checked_add(b)).unwrap()\n\
    \    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpldz50n7n.rs:10:23\n   |\n\
    10 |         a.checked_add(a).partial_cmp(&b.checked_add(b)).unwrap()\n   |  \
    \                     ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n10 |         a.checked_add(*a).partial_cmp(&b.checked_add(b)).unwrap()\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpldz50n7n.rs:10:53\n\
    \   |\n10 |         a.checked_add(a).partial_cmp(&b.checked_add(b)).unwrap()\n\
    \   |                                                     ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |  \
    \       a.checked_add(a).partial_cmp(&b.checked_add(*b)).unwrap()\n   |      \
    \                                               +\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum: isize = 0;\n    for n in nums\
    \ {\n        sum += n % 10;\n    }\n    OrderByPoints(&mut sum).sort(|a, b| nums.iter().zip(b).filter(|(&x,\
    \ &y)| *x == *y).count());\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `OrderByPoints`\
    \ in this scope\n  --> /tmp/tmp1da_uj6s.rs:13:5\n   |\n13 |     OrderByPoints(&mut\
    \ sum).sort(|a, b| nums.iter().zip(b).filter(|(&x, &y)| *x == *y).count());\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp1da_uj6s.rs:13:78\n   |\n13 |     OrderByPoints(&mut\
    \ sum).sort(|a, b| nums.iter().zip(b).filter(|(&x, &y)| *x == *y).count());\n\
    \   |                                                                        \
    \      ^^\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1da_uj6s.rs:8:41\n \
    \ |\n8 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n  |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sum = nums.iter().fold(0isize,\
    \ |sum, i| sum + i);\n    let mut new_nums = nums.iter().map(|&i| i as isize).collect();\n\
    \    new_nums.sort_unstable_by_key(|&i| {\n        nums_sum.clone() < i ? nums_sum\
    \ : i;\n    });\n    new_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `nums_sum`\n\
    \  --> /tmp/tmp_uul57nm.rs:12:32\n   |\n12 |         nums_sum.clone() < i ? nums_sum\
    \ : i;\n   |                                ^^^^^^^^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror[E0282]: type annotations needed\n  --> /tmp/tmp_uul57nm.rs:11:5\n\
    \   |\n10 |     let mut new_nums = nums.iter().map(|&i| i as isize).collect();\n\
    \   |         ------------ consider giving `new_nums` a type\n11 |     new_nums.sort_unstable_by_key(|&i|\
    \ {\n   |     ^^^^^^^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by(|a, b| point_sum(*a).cmp(&point_sum(*b)));\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `point_sum` in this scope\n --> /tmp/tmpib4g7kun.rs:9:34\n\
    \  |\n9 |     nums.sort_unstable_by(|a, b| point_sum(*a).cmp(&point_sum(*b)));\n\
    \  |                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `point_sum` in this scope\n --> /tmp/tmpib4g7kun.rs:9:53\n\
    \  |\n9 |     nums.sort_unstable_by(|a, b| point_sum(*a).cmp(&point_sum(*b)));\n\
    \  |                                                     ^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .filter(|(i, _)| nums[i].is_positive())\n        .map(|(i, _)| nums[i])\n\
    \        .enumerate()\n        .fold(Vec::new(), |mut v, &(_, val)| {\n      \
    \      v.push(*val);\n            v\n        })\n        .sorted()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&usize`\n  --> /tmp/tmpmg1otcw1.rs:12:26\n\
    \   |\n12 |         .filter(|(i, _)| nums[i].is_positive())\n   |            \
    \              ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&usize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmg1otcw1.rs:15:35\n   |\n15 |\
    \         .fold(Vec::new(), |mut v, &(_, val)| {\n   |                       \
    \            ^^^^^^^^-\n   |                                   |       |\n   |\
    \                                   |       expected due to this\n   |       \
    \                            expected tuple, found reference\n   |\n   = note:\
    \  expected tuple `(usize, isize)`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Vec<_>` in the current scope\n  -->\
    \ /tmp/tmpmg1otcw1.rs:19:10\n   |\n19 |         .sorted()\n   |          ^^^^^^\
    \ help: there is an associated function with a similar name: `is_sorted`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .sort_by(|a, b| a.checked_sub(b).expect(\"invalid value\").partial_cmp(&0))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpvsu7veaw.rs:12:10\n   |\n12 |         .sort_by(|a,\
    \ b| a.checked_sub(b).expect(\"invalid value\").partial_cmp(&0))\n   |       \
    \   ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    let\
    \ mut num_set = nums.iter().cloned().collect::<HashSet<_>>();\n\n    let mut sums\
    \ = sorted_nums.iter().map(|x| x.checked_mul(10).unwrap()).collect::<Vec<_>>();\n\
    \    sums.sort_by_key(|x| x);\n\n    let mut cur = 0;\n    let mut min_sum = sums[0]\
    \ as isize;\n    let mut max_sum = sums.last().unwrap() as isize;\n\n    while\
    \ sums.len() > 1 {\n        // for each pair of equal sums, sort by the original\
    \ order\n        for &x in sorted_nums[..] {\n            if let Some(mut cur)\
    \ = num_set.find(x.checked_mul(10).unwrap()) {\n                let sum = (cur\
    \ + x.checked_mul(10).unwrap()) / 10;\n                if sum > min_sum {\n  \
    \                  min_sum = sum;\n                }\n                if sum <\
    \ max_sum {\n                    max_sum = sum;\n                }\n         \
    \   }\n        }\n\n        // delete all equal sums\n        for &x in sorted_nums[..]\
    \ {\n            if let Some(mut cur) = num_set.find(x.checked_mul(10).unwrap())\
    \ {\n                let sum = (cur + x.checked_mul(10).unwrap()) / 10;\n    \
    \            if sum < min_sum {\n                    min_sum = sum;\n        \
    \        }\n                if sum > max_sum {\n                    max_sum =\
    \ sum;\n                }\n                num_set.remove(cur);\n            }\n\
    \        }\n\n        // add back the minimum sum to all numbers\n        for\
    \ &x in sorted_nums[..] {\n            if let Some(mut cur) = num_set.find(x.checked_mul(10).unwrap())\
    \ {\n                let sum = (cur + x.checked_mul(10).unwrap()) / 10;\n    \
    \            sums.push(sum);\n            }\n        }\n    }\n\n    sorted_nums.iter().cloned().collect::<Vec<_>>().cloned().sort_by(|a,\
    \ b| sums.iter().position(|s| s == a + b).unwrap_or(std::cmp::Ordering::Equal));\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpnqfbeiy0.rs:10:54\n\
    \   |\n10 |     let mut num_set = nums.iter().cloned().collect::<HashSet<_>>();\n\
    \   |                                                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmpnqfbeiy0.rs:21:19\n   |\n21 |         for &x\
    \ in sorted_nums[..] {\n   |                   ^^^^^^^^^^^^^^^ expected an implementor\
    \ of trait `IntoIterator`\n   |\n   = note: the trait bound `[isize]: IntoIterator`\
    \ is not satisfied\n   = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `[isize]`\nhelp: consider borrowing here\n   |\n21 | \
    \        for &x in &sorted_nums[..] {\n   |                   +\n21 |        \
    \ for &x in &mut sorted_nums[..] {\n   |                   ++++\n\nerror[E0277]:\
    \ `[isize]` is not an iterator\n  --> /tmp/tmpnqfbeiy0.rs:21:19\n   |\n21 |  \
    \       for &x in sorted_nums[..] {\n   |                   ^^^^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[isize]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[isize]`\nhelp: consider borrowing here\n\
    \   |\n21 |         for &x in &sorted_nums[..] {\n   |                   +\n21\
    \ |         for &x in &mut sorted_nums[..] {\n   |                   ++++\n\n\
    error[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpnqfbeiy0.rs:34:19\n   |\n34 |         for &x in sorted_nums[..]\
    \ {\n   |                   ^^^^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[isize]: IntoIterator` is not satisfied\n \
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `[isize]`\nhelp: consider borrowing here\n   |\n34 |         for &x in &sorted_nums[..]\
    \ {\n   |                   +\n34 |         for &x in &mut sorted_nums"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut current_sum = 0;\n    let mut last_digit_idx = 0;\n    for &num in nums_copy\
    \ {\n        let digit = num % 10;\n        current_sum += digit;\n        if\
    \ last_digit_idx != 0 {\n            // update last digit index\n            last_digit_idx\
    \ = digits.len() - 1;\n        }\n    }\n    if current_sum < 0 {\n        //\
    \ first item should be first\n        nums_copy.swap(0, 1);\n    }\n    for &num\
    \ in nums_copy {\n        let digit = num % 10;\n        let mut tmp = digit;\n\
    \        if current_sum > digit {\n            current_sum -= digit;\n       \
    \     last_digit_idx--;\n        }\n        if current_sum == 0 {\n          \
    \  nums_copy.swap(last_digit_idx, nums_copy.len() - 1);\n            return nums_copy;\n\
    \        }\n    }\n    nums_copy.swap(0, nums_copy.len() - 1);\n    return nums_copy;\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpungbs23e.rs:29:29\n\
    \   |\n29 |             last_digit_idx--;\n   |                             ^\
    \ expected expression\n\nerror[E0425]: cannot find value `digits` in this scope\n\
    \  --> /tmp/tmpungbs23e.rs:17:30\n   |\n17 |             last_digit_idx = digits.len()\
    \ - 1;\n   |                              ^^^^^^ help: a local variable with a\
    \ similar name exists: `digit`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpungbs23e.rs:12:9\n\
    \   |\n12 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpungbs23e.rs:24:9\n   |\n24 |   \
    \  for &num in nums_copy {\n   |         ^^^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut digit_sums:\
    \ Vec<isize> = nums.into_iter().map(|x| x as isize).collect();\n    for d in &mut\
    \ digit_sums.iter_mut() {\n        d += 10usize;\n    }\n    let mut d = 10usize;\n\
    \    let mut pos = 0;\n    while *d > 0 {\n        if pos == nums.len() {\n  \
    \          break;\n        }\n        let mut cur_digits = nums[pos].to_string().chars().enumerate().filter(|&(d,\
    \ _)| d < 10).collect::<Vec<_>>();\n        let mut cur_sum = cur_digits.iter().map(|&(_,\
    \ x)| x as isize).sum::<isize>();\n        if d != 10usize {\n            cur_sum\
    \ += 10usize;\n        }\n        if cur_sum > d {\n            d = cur_sum;\n\
    \            pos = pos;\n        }\n    }\n    result.push(nums[pos]);\n    if\
    \ pos < (nums.len() - 1) {\n        result.extend(&nums[pos + 1..]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut isize`\n  --> /tmp/tmpdzezau0c.rs:12:9\n   |\n12 |         d += 10usize;\n\
    \   |         -^^^^^^^^^^^\n   |         |\n   |         cannot use `+=` on type\
    \ `&mut isize`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpdzezau0c.rs:16:11\n\
    \   |\n16 |     while *d > 0 {\n   |           ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdzezau0c.rs:23:24\n   |\n23 |             cur_sum += 10usize;\n\
    \   |                        ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot add-assign `usize` to `isize`\n  --> /tmp/tmpdzezau0c.rs:23:21\n   |\n\
    23 |             cur_sum += 10usize;\n   |                     ^^ no implementation\
    \ for `isize += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzezau0c.rs:25:22\n\
    \   |\n25 |         if cur_sum > d {\n   |                      ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if cur_sum > d.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdzezau0c.rs:26:17\n   |\n14 |     let mut d = 10usize;\n\
    \   |                 ------- expected due to this value\n...\n26 |          \
    \   d = cur_sum;\n   |                 ^^^^^^^ expected `usize`, found `isize`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = nums.clone();\n    let mut sum\
    \ = 0;\n    for &i in &mut res {\n        sum += *i;\n    }\n    res.sort();\n\
    \    for &i in &res {\n        *i -= sum;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpon3na9w8.rs:11:9\n   |\n\
    11 |     for &i in &mut res {\n   |         ^^    -------- this expression has\
    \ type `Option<&mut isize>`\n   |         |\n   |         types differ in mutability\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpon3na9w8.rs:16:9\n\
    \   |\n16 |         *i -= sum;\n   |         ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for num in\
    \ nums {\n        let mut sum = 0;\n        for i in num {\n            sum +=\
    \ i;\n        }\n        result.push(num);\n    }\n    std::sort_unstable(&mut\
    \ result).unwrap();\n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_unstable` in crate `std`\n  -->\
    \ /tmp/tmpsixhpzbc.rs:17:10\n   |\n17 |     std::sort_unstable(&mut result).unwrap();\n\
    \   |          ^^^^^^^^^^^^^ not found in `std`\n\nerror[E0277]: `isize` is not\
    \ an iterator\n  --> /tmp/tmpsixhpzbc.rs:12:18\n   |\n12 |         for i in num\
    \ {\n   |                  ^^^ `isize` is not an iterator\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `isize`\n   = note: if you want to iterate\
    \ between `start` until a value `end`, use the exclusive range syntax `start..end`\
    \ or the inclusive range syntax `start..=end`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .sort_by(|(idx, (digit, num))| {\n            let mut sum = 0;\n    \
    \        for d in num {\n                sum += d * digit;\n            }\n  \
    \          sum\n        })\n        .map(|(idx, num)| num)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmp2t3yrtuw.rs:12:10\n   |\n12 |         .sort_by(|(idx,\
    \ (digit, num))| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.iter().enumerate().sort_by(|(i, &a)| {\n\
    \        a.checked_add(a.checked_mul(a.to_digits().len() as i64)).unwrap()\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n --> /tmp/tmp3c2ufxpq.rs:9:29\n  |\n9 |     nums.iter().enumerate().sort_by(|(i,\
    \ &a)| {\n  |                             ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut points: Vec<isize> = nums.iter().cloned().collect();\n\
    \    points.sort_by_key(|&x| sum_digits(x).unwrap());\n    points\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum_digits` in this scope\n  --> /tmp/tmpbuk2mhpp.rs:10:29\n\
    \   |\n10 |     points.sort_by_key(|&x| sum_digits(x).unwrap());\n   |       \
    \                      ^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut digits: Vec<_> = nums\n        .iter()\n\
    \        .map(|x| x.digits())\n        .collect();\n    let mut sums: Vec<_> =\
    \ digits;\n    sums.sort_unstable();\n    sums.into_iter().map(|x| x.unwrap()).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpw0pycpid.rs:11:20\n   |\n11 |         .map(|x|\
    \ x.digits())\n   |                    ^^^^^^ method not found in `&isize`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sums = vec![];\n    for i in nums {\n\
    \        sums.push(nums.iter().map(|x| x.checked_add(i).unwrap()).sum());\n  \
    \  }\n    sums.sort_unstable();\n    let mut index = vec![];\n    for sum in sums\
    \ {\n        index.append(sums.iter().position(|x| *x == sum).unwrap());\n   \
    \ }\n    index.sort_unstable();\n    let mut output = vec![];\n    for i in index\
    \ {\n        let x = nums[i];\n        output.push(x);\n    }\n    output\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwpzwzot.rs:16:22\n   |\n\
    16 |         index.append(sums.iter().position(|x| *x == sum).unwrap());\n   |\
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut\
    \ Vec<_>`, found `usize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n\
    \                           found type `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sums = Vec::new();\n    for &n in &nums\
    \ {\n        sums.push(n);\n    }\n    sums.sort_by_key(|n| {\n        let mut\
    \ sum = 0;\n        for &i in &nums {\n            if i == n {\n             \
    \   sum += 1;\n            }\n        }\n        sum\n    });\n    sums\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx6sn7ck_.rs:16:21\n   |\n\
    16 |             if i == n {\n   |                     ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |        \
    \     if i == *n {\n   |                     +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    let mut nums_sum\
    \ = 0;\n    let mut i = -1;\n\n    // sort from large to small numbers\n    while\
    \ i < nums.len() - 1 {\n        nums_sum = nums_sum.wrapping_add(nums[i]);\n \
    \       let j = i + 1;\n        while j < nums.len() {\n            if nums_sum\
    \ == nums[j] {\n                nums[j] = nums[j].wrapping_neg();\n          \
    \      j = j + 1;\n            } else {\n                break;\n            }\n\
    \        }\n        i = j;\n    }\n    nums_sum = nums_sum.wrapping_neg();\n\n\
    \    let mut res = Vec::new();\n    while i < nums.len() {\n        res.push(nums[i].wrapping_neg());\n\
    \        i = i + 1;\n    }\n    return res;\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpfuegko1l.rs:11:17\n\
    \   |\n11 |     let mut i = -1;\n   |                 ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0689]: can't call method `wrapping_add`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpfuegko1l.rs:15:29\n   |\n\
    15 |         nums_sum = nums_sum.wrapping_add(nums[i]);\n   |                \
    \             ^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `i32`\n   |\n10 |     let mut nums_sum: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0689.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // initialize min and max sum\n    let mut\
    \ min_sum = nums.iter().min().unwrap() as isize;\n    let mut max_sum = nums.iter().max().unwrap()\
    \ as isize;\n\n    // initialize map to count number of elements in each range\n\
    \    let mut num_elems = vec![0, 0, 0];\n\n    // calculate sum for each digit\n\
    \    for i in 0..nums.len() {\n        num_elems[i] = (nums[i] / 10) + num_elems[i];\n\
    \    }\n\n    // fill map with elements of each digit\n    for i in 0..10 {\n\
    \        if num_elems[i] < 2 {\n            continue;\n        }\n        let\
    \ max_range = i + 1;\n        let min_range = i;\n        if min_range*10 + 10\
    \ > max_sum {\n            min_sum += min_range;\n        } else {\n         \
    \   max_sum += max_range;\n        }\n        num_elems[i] -= 2;\n    }\n\n  \
    \  // add up sums to get final answer\n    let mut total_sum = nums.iter().sum().unwrap();\n\
    \    for i in 0..10 {\n        total_sum += num_elems[i];\n    }\n\n    // compare\
    \ sums\n    if total_sum < min_sum {\n        nums.iter_mut().for_each(|x| {\n\
    \            *x = *x % 10;\n        });\n        nums.sort_by_key(|x| order_by_points(&[*(x.clone(),\
    \ *x)]));\n    }\n    if total_sum > max_sum {\n        nums.iter_mut().for_each(|x|\
    \ {\n            *x = *x % 10;\n        });\n        nums.sort_by_key(|x| order_by_points(&[*(x.clone(),\
    \ *x)]));\n    }\n\n    nums.iter().map(|x| x).collect()\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpin_3spb5.rs:28:32\n   |\n\
    28 |         if min_range*10 + 10 > max_sum {\n   |                          \
    \      ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n28\
    \ |         if min_range*10 + 10 > max_sum.try_into().unwrap() {\n   |       \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpin_3spb5.rs:29:24\n   |\n29 |             min_sum += min_range;\n\
    \   |                        ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot add-assign `usize` to `isize`\n  --> /tmp/tmpin_3spb5.rs:29:21\n   |\n\
    29 |             min_sum += min_range;\n   |                     ^^ no implementation\
    \ for `isize += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin_3spb5.rs:31:24\n\
    \   |\n31 |             max_sum += max_range;\n   |                        ^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to\
    \ `isize`\n  --> /tmp/tmpin_3spb5.rs:31:21\n   |\n31 |             max_sum +=\
    \ max_range;\n   |                     ^^ no implementation for `isize += usize`\n\
    \   |\n   = help: the trait `AddAssign<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut digits:\
    \ Vec<isize> = nums.iter().map(|x| x as isize).collect();\n    digits.sort();\n\
    \    for i in 0..digits.len() {\n        result.push(digits[i]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmp71eg3gri.rs:10:54\n\
    \   |\n10 |     let mut digits: Vec<isize> = nums.iter().map(|x| x as isize).collect();\n\
    \   |                                                      -^^^^^^^^^\n   |  \
    \                                                    |\n   |                 \
    \                                     cannot cast `&isize` as `isize`\n   |  \
    \                                                    help: dereference the expression:\
    \ `*x`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums\n\
    \    }\n    let mut sum_of_digits = nums[0].checked_mul(10).unwrap();\n    for\
    \ i in 1..nums.len() {\n        let mut d = nums[i].checked_mul(10).unwrap();\n\
    \        while d > sum_of_digits {\n            sum_of_digits += d % 10;\n   \
    \         d /= 10;\n        }\n    }\n    let mut result: Vec<isize> = Vec::new();\n\
    \    for i in 0..nums.len() {\n        let mut j = i + 1;\n        while j < nums.len()\
    \ {\n            let mut d = nums[j].checked_mul(10).unwrap();\n            while\
    \ d > sum_of_digits {\n                sum_of_digits += d % 10;\n            \
    \    d /= 10;\n            }\n            if d == sum_of_digits {\n          \
    \      result.push(i);\n                j += 1;\n                break;\n    \
    \        }\n            j += 1\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqxgjhgjh.rs:30:29\n   |\n\
    30 |                 result.push(i);\n   |                             ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n30 |                 result.push(i.try_into().unwrap());\n\
    \   |                              ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum_of_digits = nums.iter().fold(0,\
    \ |mut sum, i| sum + i);\n    nums.iter().map(|x| x % 10).filter(|&x| x == 0).cloned().for_each(|&x|\
    \ {\n        sum_of_digits -= x;\n    });\n    nums.iter().cloned().filter(|&x|\
    \ x == 0).cloned().for_each(|&x| {\n        sum_of_digits += x;\n    });\n   \
    \ nums.iter().cloned().filter(|&x| x == 0).cloned().sorted().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmp2ox0xjzh.rs:10:21:\
    \ 10:31] as FnOnce<(&isize,)>>::Output == &_`\n  --> /tmp/tmp2ox0xjzh.rs:10:53\n\
    \   |\n10 |     nums.iter().map(|x| x % 10).filter(|&x| x == 0).cloned().for_each(|&x|\
    \ {\n   |                                                     ^^^^^^ expected\
    \ reference, found `isize`\n   |\n   = note: expected reference `&_`\n       \
    \            found type `isize`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp2ox0xjzh.rs:10:21:\
    \ 10:31]>`\n   = note: 1 redundant requirement hidden\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `Filter<Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmp2ox0xjzh.rs:10:21: 10:31]>, [closure@/tmp/tmp2ox0xjzh.rs:10:40:\
    \ 10:51]>`\n\nerror[E0631]: type mismatch in closure arguments\n  --> /tmp/tmp2ox0xjzh.rs:10:53\n\
    \   |\n10 |     nums.iter().map(|x| x % 10).filter(|&x| x == 0).cloned().for_each(|&x|\
    \ {\n   |                                        -----------  ^^^^^^ expected\
    \ signature of `for<'r> fn(&'r &_) -> _`\n   |                               \
    \         |\n   |                                        found signature of `for<'r>\
    \ fn(&'r isize) -> _`\n   |\n   = note: required because of the requirements on\
    \ the impl of `Iterator` for `Filter<Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp2ox0xjzh.rs:10:21:\
    \ 10:31]>, [closure@/tmp/tmp2ox0xjzh.rs:10:40: 10:51]>`\n\nerror[E0599]: the method\
    \ `for_each` exists for struct `Cloned<Filter<Map<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmp2ox0xjzh.rs:10:21: 10:31]>, [closure@/tmp/tmp2ox0xjzh.rs:10:40:\
    \ 10:51]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp2ox0xjzh.rs:10:62\n\
    \   |\n10 |        nums.iter().map(|x| x % 10).filter(|&x| x == 0).cloned().for_each(|&x|\
    \ {\n   |                                                                 ^^^^^^^^\
    \ method cannot be called on `Cloned<Filter<Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp2ox0xjzh.rs:10:21:\
    \ 10:31]>, [closure@/tmp/tmp2ox0xjzh.rs:10:40: 1"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for i in nums {\n   \
    \     sum += i;\n    }\n    let mut nums_new: Vec<isize> = Vec::new();\n    for\
    \ i in nums {\n        let mut num_to_remove = 0;\n        for j in 0..i {\n \
    \           if nums[j] > sum {\n                sum -= nums[j];\n            \
    \    num_to_remove += 1;\n            }\n        }\n        nums_new.push(i);\n\
    \        if num_to_remove > 0 {\n            nums_new.pop();\n        }\n    }\n\
    \    nums_new\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnwzflxku.rs:17:16\n\
    \   |\n17 |             if nums[j] > sum {\n   |                ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpnwzflxku.rs:18:24\n   |\n18 |  \
    \               sum -= nums[j];\n   |                        ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut sum_of_nums: isize = nums.iter().sum();\n    let mut nums_copy: Vec<isize>\
    \ = Vec::new();\n    for v in nums_copy {\n        nums_copy.push(v as isize);\n\
    \    }\n\n    nums_copy.sort();\n    for v in nums_copy {\n        nums.push(v\
    \ as isize);\n    }\n\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `nums_copy`\n --> /tmp/tmpndtr2d6l.rs:9:13\n\
    \  |\n9 |     let mut nums_copy = nums.clone();\n  |             ^^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_nums_copy`\n  |\n  =\
    \ note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable:\
    \ `sum_of_nums`\n  --> /tmp/tmpndtr2d6l.rs:10:13\n   |\n10 |     let mut sum_of_nums:\
    \ isize = nums.iter().sum();\n   |             ^^^^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_sum_of_nums`\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmpndtr2d6l.rs:9:9\n  |\n9 |     let mut nums_copy\
    \ = nums.clone();\n  |         ----^^^^^^^^^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpndtr2d6l.rs:10:9\n   |\n\
    10 |     let mut sum_of_nums: isize = nums.iter().sum();\n   |         ----^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow\
    \ of moved value: `nums_copy`\n   --> /tmp/tmpndtr2d6l.rs:13:9\n    |\n11  | \
    \    let mut nums_copy: Vec<isize> = Vec::new();\n    |         -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |     for v in nums_copy {\n    |              ---------\
    \ `nums_copy` moved due to this implicit call to `.into_iter()`\n13  |       \
    \  nums_copy.push(v as isize);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `nums_copy`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12\
    \  |     for v in &nums_copy {\n    |              +\n\nerror[E0596]: cannot borrow\
    \ `nums` as mutable, as it is not declared as mutable\n  --> /tmp/tmpndtr2d6l.rs:18:9\n\
    \   |\n8  | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \             ---- help: consider changing this to be mutable: `mut nums`\n...\n\
    18 |         nums.push(v as isize);\n   |         ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .map(|num| {\n\
    \            num.checked_add(-num.leading_zeros()).expect(\"sum should be positive\"\
    )\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `u32`\n  --> /tmp/tmpzyya5nl2.rs:12:29\n\
    \   |\n12 |             num.checked_add(-num.leading_zeros()).expect(\"sum should\
    \ be positive\")\n   |                             ^^^^^^^^^^^^^^^^^^^^ cannot\
    \ apply unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzyya5nl2.rs:12:29\n   |\n12 |\
    \             num.checked_add(-num.leading_zeros()).expect(\"sum should be positive\"\
    )\n   |                             ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `u32`\n   |\nhelp: you can convert a `u32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |             num.checked_add((-num.leading_zeros()).try_into().unwrap()).expect(\"\
    sum should be positive\")\n   |                             +                \
    \    +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut total = 0;\n    let mut point: isize\
    \ = 0;\n    for n in nums {\n        total += n;\n        point += n;\n    }\n\
    \n    // find the item with the maximum sum\n    let mut cur = &nums[0];\n   \
    \ let mut max_sum = total;\n    for i in &nums[1..] {\n        if *i > cur {\n\
    \            if *i > max_sum {\n                max_sum = *i;\n              \
    \  cur = i;\n            }\n        }\n    }\n\n    // sort by point\n    let\
    \ mut reversed = nums.clone();\n    reversed.reverse();\n    let mut index = vec![0;\
    \ points.len()];\n    for i in 0..points.len() {\n        if points[index[i]]\
    \ == max_sum {\n            index[i] = reversed.len() - 1 - i;\n        } else\
    \ {\n            index[i] = i;\n        }\n    }\n\n    // reverse the result\n\
    \    let mut result = vec![0; nums.len()];\n    for i in 0..nums.len() {\n   \
    \     result[index[i]] = nums[i];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `points` in this scope\n  --> /tmp/tmp2swc32w7.rs:31:29\n\
    \   |\n31 |     let mut index = vec![0; points.len()];\n   |                 \
    \            ^^^^^^ help: a local variable with a similar name exists: `point`\n\
    \nerror[E0425]: cannot find value `points` in this scope\n  --> /tmp/tmp2swc32w7.rs:32:17\n\
    \   |\n32 |     for i in 0..points.len() {\n   |                 ^^^^^^ help:\
    \ a local variable with a similar name exists: `point`\n\nerror[E0425]: cannot\
    \ find value `points` in this scope\n  --> /tmp/tmp2swc32w7.rs:33:12\n   |\n33\
    \ |         if points[index[i]] == max_sum {\n   |            ^^^^^^ help: a local\
    \ variable with a similar name exists: `point`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2swc32w7.rs:20:17\n   |\n20 |         if *i > cur {\n   |     \
    \            ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n20 |         if *i > *cur {\n   |                 +\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a, b| {\n        let mut a =\
    \ a as isize;\n        let mut b = b as isize;\n        if a == b {\n        \
    \    0\n        } else if a < b {\n            a - b\n        } else {\n     \
    \       b - a\n        }\n    });\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6r3rw_mb.rs:13:13\n   |\n\
    13 |             0\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6r3rw_mb.rs:15:13\n\
    \   |\n15 |             a - b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6r3rw_mb.rs:17:13\n\
    \   |\n17 |             b - a\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  -->\
    \ /tmp/tmp6r3rw_mb.rs:10:21\n   |\n10 |         let mut a = a as isize;\n   |\
    \                     -^^^^^^^^^\n   |                     |\n   |           \
    \          cannot cast `&isize` as `isize`\n   |                     help: dereference\
    \ the expression: `*a`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n\
    \  --> /tmp/tmp6r3rw_mb.rs:11:21\n   |\n11 |         let mut b = b as isize;\n\
    \   |                     -^^^^^^^^^\n   |                     |\n   |       \
    \              cannot cast `&isize` as `isize`\n   |                     help:\
    \ dereference the expression: `*b`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .enumerate()\n        .fold(Vec::<isize>::new(), |mut vec, (i, item)|\
    \ {\n            let mut tmp_sum = 0;\n            vec.extend_from_slice(&[i +\
    \ 1isize]);\n            for i in 0..vec.len() {\n                tmp_sum += vec[i]*(i+1isize);\n\
    \            }\n            if tmp_sum < item {\n                vec.insert(i,\
    \ item);\n            }\n            vec\n        })\n        .iter()\n      \
    \  .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoui6akje.rs:15:41\n   |\n\
    15 |             vec.extend_from_slice(&[i + 1isize]);\n   |                 \
    \                        ^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoui6akje.rs:15:37\n   |\n15 |             vec.extend_from_slice(&[i\
    \ + 1isize]);\n   |                                     ^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |             vec.extend_from_slice(&[(i\
    \ + 1isize).try_into().unwrap()]);\n   |                                     +\
    \          +++++++++++++++++++++\n\nerror[E0277]: cannot add `isize` to `usize`\n\
    \  --> /tmp/tmpoui6akje.rs:15:39\n   |\n15 |             vec.extend_from_slice(&[i\
    \ + 1isize]);\n   |                                       ^ no implementation\
    \ for `usize + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoui6akje.rs:17:38\n\
    \   |\n17 |                 tmp_sum += vec[i]*(i+1isize);\n   |              \
    \                        ^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmpoui6akje.rs:17:37\n   |\n17 | \
    \                tmp_sum += vec[i]*(i+1isize);\n   |                         \
    \            ^ no implementation for `usize + isize`\n   |\n   = help: the trait\
    \ `Add<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n    \
    \         <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n      \
    \       <&'a i16 as Add<i16>>\n             <&'a i32 as "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums: Vec<isize> = nums.to_vec();\n\
    \n    let mut sum = 0;\n    for (i, num) in nums.iter().enumerate() {\n      \
    \  sum += num;\n        nums[i] = num;\n    }\n\n    let mut nums = nums.clone();\n\
    \    nums.sort_by_key(|num| {\n        sum_of_digits(&num).cmp(&sum)\n    });\n\
    \n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum_of_digits` in this scope\n  -->\
    \ /tmp/tmpvgol51w9.rs:19:9\n   |\n19 |         sum_of_digits(&num).cmp(&sum)\n\
    \   |         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvgol51w9.rs:14:19\n   |\n14 |         nums[i] = num;\n\
    \   |         -------   ^^^ expected `isize`, found `&isize`\n   |         |\n\
    \   |         expected due to the type of this binding\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |         nums[i] = *num;\n   |                   +\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    let mut nums_copy = nums.clone();\n    let mut sums: Vec<isize>\
    \ = vec![0];\n    while nums_copy.len() > 0 {\n        let mut cur_sum = nums_copy.remove(0)\
    \ + sums.last().unwrap();\n        sums.push(cur_sum);\n        if nums_copy.len()\
    \ > 0 {\n            nums_copy.extend(nums_copy.iter().cloned().collect::<Vec<_>>());\n\
    \        }\n    }\n\n    let mut res = vec![];\n    for i in sums.iter().cloned().rev()\
    \ {\n        res.insert(0, i);\n    }\n    res.reverse();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut sums\
    \ = Vec::new();\n    nums.iter().cloned().for_each(|x| {\n        let sum = x.to_string().chars().sum();\n\
    \        let index = sums.iter().position(|&s| s == sum).unwrap();\n        result.push(x);\n\
    \        if index >= 0 {\n            sums.push(sum);\n        } else {\n    \
    \        sums.clear();\n        }\n    });\n    result\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmprf1eibl5.rs:13:43\n\
    \   |\n13 |         let index = sums.iter().position(|&s| s == sum).unwrap();\n\
    \   |                                           ^^ consider giving this closure\
    \ parameter the explicit type `&T`, where the type parameter `T` is specified\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .enumerate()\n        .sort_by(|(idx, x), (y, _)| x.to_digits() + y.to_digits()).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmp9j2p6en0.rs:13:10\n   |\n13 |         .sort_by(|(idx,\
    \ x), (y, _)| x.to_digits() + y.to_digits()).collect::<Vec<_>>()\n   |       \
    \   ^^^^^^^ method not found in `Enumerate<Cloned<std::slice::Iter<'_, isize>>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .sort(|a, b| {\n            a as isize + b as isize -\n             \
    \   match a % 10 + b as isize {\n                    0 => 0,\n               \
    \     _ => a as isize < b as isize ? -1 : 1,\n                }\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: `<` is interpreted as a start of generic arguments for `isize`,\
    \ not a comparison\n  --> /tmp/tmp8ruf329q.rs:16:37\n   |\n16 |              \
    \       _ => a as isize < b as isize ? -1 : 1,\n   |                         \
    \            ^ ---- interpreted as generic arguments\n   |                   \
    \                  |\n   |                                     not interpreted\
    \ as comparison\n   |\nhelp: try comparing the cast value\n   |\n16 |        \
    \             _ => (a as isize) < b as isize ? -1 : 1,\n   |                 \
    \         +          +\n\nerror: casts cannot be followed by `?`\n  --> /tmp/tmp8ruf329q.rs:16:39\n\
    \   |\n16 |                     _ => a as isize < b as isize ? -1 : 1,\n   | \
    \                                      ^^^^^^^^^^\n   |\nhelp: try surrounding\
    \ the expression in parentheses\n   |\n16 |                     _ => a as isize\
    \ < (b as isize) ? -1 : 1,\n   |                                       +     \
    \     +\n\nerror: expected type, found `1`\n  --> /tmp/tmp8ruf329q.rs:16:57\n\
    \   |\n16 |                     _ => a as isize < b as isize ? -1 : 1,\n   | \
    \                      --                              - ^ expected type\n   |\
    \                       |                               |\n   |              \
    \         |                               tried to parse a type due to this\n\
    \   |                       while parsing the `match` arm starting here\n\nerror[E0599]:\
    \ no method named `sort` found for struct `Cloned` in the current scope\n  -->\
    \ /tmp/tmp8ruf329q.rs:12:10\n   |\n12 |         .sort(|a, b| {\n   |         \
    \ ^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut nums_copy = nums.clone();\n    let mut sums: Vec<_> = nums_copy.into_iter().map(|i|\
    \ i as isize).collect();\n    let mut sum: isize;\n    for i in 0..(sums.len()\
    \ - 1) {\n        if sums[i] != sums[i + 1] {\n            sum -= sums[i];\n \
    \           sum = sum + sums[i + 1];\n            nums_copy = nums_copy.drain(..i\
    \ + 1);\n            break;\n        }\n    }\n    nums_copy.sort();\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpllumoywg.rs:19:25\n   |\n\
    12 |     let mut nums_copy = nums.clone();\n   |                         ------------\
    \ expected due to this value\n...\n19 |             nums_copy = nums_copy.drain(..i\
    \ + 1);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found struct `std::vec::Drain`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `std::vec::Drain<'_, isize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    let mut min_idx = nums.iter().min().unwrap();\n    let mut min_value\
    \ = nums[min_idx];\n    let mut sorted_nums = Vec::with_capacity(nums.len());\n\
    \    for &x in nums {\n        if x >= min_value {\n            sorted_nums.push(x);\n\
    \        }\n    }\n\n    for i in 0..nums.len() {\n        for j in 0..i {\n \
    \           if sorted_nums[j] > sorted_nums[i] {\n                let tmp = sorted_nums[j];\n\
    \                sorted_nums[j] = sorted_nums[i];\n                sorted_nums[i]\
    \ = tmp;\n            }\n        }\n    }\n\n    sorted_nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpim7aeplh.rs:14:25\n\
    \   |\n14 |     let mut min_value = nums[min_idx];\n   |                     \
    \    ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpim7aeplh.rs:16:9\n   |\n16 | \
    \    for &x in nums {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|x, y| x.checked_add(&y).unwrap());\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgil_5dhf.rs:9:39\n  |\n9 |\
    \     nums.sort_by(|x, y| x.checked_add(&y).unwrap());\n  |                  \
    \                     ^^ expected `isize`, found `&&isize`\n  |\nhelp: consider\
    \ removing the `&` and dereferencing the borrow instead\n  |\n9 |     nums.sort_by(|x,\
    \ y| x.checked_add(*y).unwrap());\n  |                                       ~\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpgil_5dhf.rs:9:25\n  |\n9 |    \
    \ nums.sort_by(|x, y| x.checked_add(&y).unwrap());\n  |                      \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Initialize sum\n    let mut sum: isize =\
    \ 0;\n    // Initialize result\n    let mut res: Vec<isize> = nums.clone();\n\
    \    for i in res {\n        sum += i;\n    }\n    // Rearrange in ascending order\
    \ according to sum\n    res.sort();\n    // Return the result\n    res\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: variable `sum` is assigned to, but never used\n  --> /tmp/tmpqauki8cf.rs:10:13\n\
    \   |\n10 |     let mut sum: isize = 0;\n   |             ^^^\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n   = note: consider using `_sum`\
    \ instead\n\nerror[E0382]: borrow of moved value: `res`\n   --> /tmp/tmpqauki8cf.rs:17:5\n\
    \    |\n12  |     let mut res: Vec<isize> = nums.clone();\n    |         -------\
    \ move occurs because `res` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n13  |     for i in res {\n    |              --- `res` moved due\
    \ to this implicit call to `.into_iter()`\n...\n17  |     res.sort();\n    | \
    \    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `res`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n13  |     for i in &res {\n    |              +\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|n| n.to_digits().sum());\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n --> /tmp/tmpoaqu9o04.rs:9:28\n  |\n9 |     nums.sort_by_key(|n|\
    \ n.to_digits().sum());\n  |                            ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut new_nums: Vec<isize> = vec![];\n    let mut new_nums_len = 0;\n\n    while\
    \ nums_copy.len() > 0 {\n        let mut cur_sum = nums_copy.pop().unwrap();\n\
    \        let mut cnt = 0;\n\n        while nums_copy.len() > 0 {\n           \
    \ if cur_sum > nums_copy.pop().unwrap() {\n                break;\n          \
    \  }\n            cnt += 1;\n        }\n\n        if cnt > new_nums_len {\n  \
    \          new_nums_len = cnt;\n            new_nums.push(cur_sum);\n        }\
    \ else {\n            new_nums.last() = cur_sum;\n        }\n    }\n    new_nums.reverse();\n\
    \    new_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpsf35nrv8.rs:28:29\n\
    \   |\n28 |             new_nums.last() = cur_sum;\n   |             ---------------\
    \ ^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_iter = nums.iter().cloned();\n\
    \    let mut sums = vec![];\n    for num in nums_iter {\n        sums.push(num);\n\
    \    }\n    for i in 0..nums.len() {\n        for j in i..nums.len() {\n     \
    \       if nums_iter[i] > nums_iter[j] {\n                nums_iter[j] -= nums_iter[i];\n\
    \                nums_iter[i] += nums_iter[j];\n                nums_iter[j] +=\
    \ nums_iter[i];\n            }\n        }\n    }\n    nums_iter.iter().cloned().collect::<Vec<_>>().sort();\n\
    \    nums.iter().cloned().collect::<Vec<_>>().sort();\n    nums_iter\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmph4d1jxr_.rs:16:16\n   |\n16 |             if nums_iter[i]\
    \ > nums_iter[j] {\n   |                ^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Cloned<std::slice::Iter<'_, isize>>`\n  --> /tmp/tmph4d1jxr_.rs:16:31\n\
    \   |\n16 |             if nums_iter[i] > nums_iter[j] {\n   |               \
    \                ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `Cloned<std::slice::Iter<'_, isize>>`\n  --> /tmp/tmph4d1jxr_.rs:17:17\n   |\n\
    17 |                 nums_iter[j] -= nums_iter[i];\n   |                 ^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmph4d1jxr_.rs:17:33\n   |\n17 |                 nums_iter[j]\
    \ -= nums_iter[i];\n   |                                 ^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Cloned<std::slice::Iter<'_, isize>>`\n  -->\
    \ /tmp/tmph4d1jxr_.rs:18:17\n   |\n18 |                 nums_iter[i] += nums_iter[j];\n\
    \   |                 ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `Cloned<std::slice::Iter<'_, isize>>`\n  --> /tmp/tmph4d1jxr_.rs:18:33\n\
    \   |\n18 |                 nums_iter[i] += nums_iter[j];\n   |              \
    \                   ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `Cloned<std::slice::Iter<'_, isize>>`\n  --> /tmp/tmph4d1jxr_.rs:19:17\n\
    \   |\n19 |                 nums_iter[j] += nums_iter[i];\n   |              \
    \   ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmph4d1jxr_.rs:19:33\n   |\n19 |                 nums_iter[j]\
    \ += nums_iter[i];\n   |                                 ^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `iter` found for struct `Cloned` in the current scope\n  -->\
    \ /tmp/tmph4d1jxr_.rs:23:15\n   |\n23 |     nums_iter.iter().cloned().collect::<Vec<_>>().sort();\n\
    \   |               ^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph4d1j"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_set = nums.clone();\n    let mut\
    \ sum_of_digits = nums.iter().cloned().map(|x| x * x).sum::<isize>();\n    nums_set.sort();\n\
    \    match nums_set.len() {\n        0 => nums_set,\n        1 => vec![1],\n \
    \       _ => nums_set.iter().cloned().enumerate().filter(|(_, v)| v % 2 == 0).cloned().map(|(k,\
    \ v)| {\n            if sum_of_digits < k * v {\n                nums_set.swap(k,\
    \ sum_of_digits);\n                sum_of_digits -= k * v;\n                false\n\
    \            } else {\n                true\n            }\n        }).cloned().collect(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Filter<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpjwmmjy1u.rs:15:58: 15:77]> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpjwmmjy1u.rs:15:79\n     |\n15   |         _ => nums_set.iter().cloned().enumerate().filter(|(_,\
    \ v)| v % 2 == 0).cloned().map(|(k, v)| {\n     |                            \
    \                                                   ^^^^^^ expected reference,\
    \ found tuple\n     |\n     = note: expected reference `&_`\n                \
    \    found tuple `(usize, isize)`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `map` exists for struct `Cloned<Filter<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpjwmmjy1u.rs:15:58: 15:77]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpjwmmjy1u.rs:15:88\n   |\n15 |            _\
    \ => nums_set.iter().cloned().enumerate().filter(|(_, v)| v % 2 == 0).cloned().map(|(k,\
    \ v)| {\n   |                                                                \
    \                           ^^^ method cannot be called on `Cloned<Filter<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpjwmmjy1u.rs:15:58: 15:77]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<Enumerate<Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpjwmmjy1u.rs:15:58:\
    \ 15:77]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpjwmmjy1u.rs:15:58: 15:77]>>: Iterator`\n        \
    \   `Cloned<Filter<Enumerate<Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpjwmmjy1u.rs:15:58:\
    \ 15:77]>>: Iterator`\n           which is required by `&mut Cloned<Filter<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpjwmmjy1u.rs:15:58: 15:77]>>: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjwmmjy1u.rs:17:34\n   |\n17 |              \
    \   nums_set.swap(k, sum_of_digits);\n   |                                  ^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can c"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // find sum of every digit\n    let mut sums\
    \ = Vec::new();\n    for i in 0..nums.len() {\n        sums.push(nums[i] / digits::from_usize(nums[i]).unwrap());\n\
    \    }\n\n    // sort by sums\n    sums.iter().cloned().sorted().collect()\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `digits`\n\
    \  --> /tmp/tmpqka3dvj7.rs:12:29\n   |\n12 |         sums.push(nums[i] / digits::from_usize(nums[i]).unwrap());\n\
    \   |                             ^^^^^^ use of undeclared crate or module `digits`\n\
    \nerror[E0599]: no method named `sorted` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpqka3dvj7.rs:16:26\n   |\n16 |     sums.iter().cloned().sorted().collect()\n\
    \   |                          ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut total_sum: isize = 0;\n    for n in\
    \ nums {\n        total_sum += n.digits().fold(0, |sum, d| sum + d);\n    }\n\n\
    \    iter::repeat(0).take(total_sum as usize).cloned().chain(\n        iter::repeat(nums).take(total_sum\
    \ as usize),\n    )\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `iter`\n\
    \  --> /tmp/tmpzpl0nup5.rs:14:5\n   |\n14 |     iter::repeat(0).take(total_sum\
    \ as usize).cloned().chain(\n   |     ^^^^ use of undeclared crate or module `iter`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `iter`\n\
    \  --> /tmp/tmpzpl0nup5.rs:15:9\n   |\n15 |         iter::repeat(nums).take(total_sum\
    \ as usize),\n   |         ^^^^ use of undeclared crate or module `iter`\n\nerror[E0599]:\
    \ no method named `digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpzpl0nup5.rs:11:24\n   |\n11 |         total_sum += n.digits().fold(0,\
    \ |sum, d| sum + d);\n   |                        ^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum: isize = 0;\n    for (i, &d) in\
    \ nums.iter().enumerate() {\n        sum += d;\n    }\n    nums.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    nums.iter().map(|&x| x).collect()\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: variable `sum` is assigned to, but never used\n --> /tmp/tmpyxenjvgz.rs:9:13\n\
    \  |\n9 |     let mut sum: isize = 0;\n  |             ^^^\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n  = note: consider using `_sum` instead\n\nwarning: unused variable:\
    \ `i`\n  --> /tmp/tmpyxenjvgz.rs:10:10\n   |\n10 |     for (i, &d) in nums.iter().enumerate()\
    \ {\n   |          ^ help: if this is intentional, prefix it with an underscore:\
    \ `_i`\n\nerror[E0596]: cannot borrow `nums` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpyxenjvgz.rs:13:5\n   |\n8  | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                    ---- help: consider changing\
    \ this to be mutable: `mut nums`\n...\n13 |     nums.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n\n   \
    \ // sort by points from smallest to biggest digits\n    nums_sorted.sort_by_key(|&num|\
    \ {\n        if num == -1 {\n            -std::i32::MAX as isize\n        } else\
    \ {\n            std::mem::replace(nums[num], std::i32::MAX as isize)\n      \
    \  }\n    });\n\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpttbt26k7.rs:16:31\n\
    \   |\n16 |             std::mem::replace(nums[num], std::i32::MAX as isize)\n\
    \   |                               ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    let\
    \ mut nums_sorted_by_points: Vec<isize> = nums_copy.clone();\n    nums_sorted_by_points.sort_by_key(|x|\
    \ {\n        let mut max_digit = 0;\n        let mut current_digit = 0;\n    \
    \    for _ in 0..10 {\n            if let Some(digit) = x.checked_digit(10) {\n\
    \                max_digit = digit;\n            }\n            else\n       \
    \         break;\n        }\n        if max_digit < current_digit {\n        \
    \    Some(current_digit)\n        } else {\n            None\n        }\n    });\n\
    \    for x in nums_sorted_by_points {\n        nums_sorted_by_points.remove(x);\n\
    \    }\n    nums_sorted_by_points\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `break`\n  --> /tmp/tmpr4u31pgj.rs:19:17\n\
    \   |\n19 |                 break;\n   |                 ^^^^^ expected `{`\n\
    \   |\nhelp: try placing this code inside a block\n   |\n19 |                \
    \ { break; }\n   |                 +        +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr4u31pgj.rs:28:38\n   |\n28 |         nums_sorted_by_points.remove(x);\n\
    \   |                                      ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n28 |         nums_sorted_by_points.remove(x.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut map = HashMap::<isize, isize>::new();\n\
    \    for x in nums {\n        let mut y = x;\n        let mut sum = 0;\n     \
    \   while y > 0 {\n            sum += y % 10;\n            y /= 10;\n        }\n\
    \        map.insert((sum), x);\n    }\n    let mut result: Vec<isize> = Vec::new();\n\
    \    for x in map.iter() {\n        result.append(x.1);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpprfri1f8.rs:9:19\n  |\n9 |     let mut map = HashMap::<isize, isize>::new();\n\
    \  |                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmpprfri1f8.rs:17:20\n   |\n\
    17 |         map.insert((sum), x);\n   |                    ^   ^\n   |\n   =\
    \ note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n17 -         map.insert((sum), x);\n17 +         map.insert(sum, x);\n\
    \   | \n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum: isize = 0;\n    let mut index:\
    \ usize = 0;\n    nums.sort_by_key(|x| {\n        sum = sum + x;\n        index\
    \ += 1;\n        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `nums` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp2hp3lsuf.rs:11:5\n   |\n8  |   fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      ---- help: consider changing\
    \ this to be mutable: `mut nums`\n...\n11 | /     nums.sort_by_key(|x| {\n12 |\
    \ |         sum = sum + x;\n13 | |         index += 1;\n14 | |         sum\n15\
    \ | |     });\n   | |______^ cannot borrow as mutable\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n\n    //\
    \ Sort\n    nums_copy.sort_unstable_by(|a, b| {\n        // Find sum of both digits\n\
    \        let a = a.checked_mul(100).unwrap();\n        let b = b.checked_mul(100).unwrap();\n\
    \n        // If sums are equal - sort by index\n        if a == b {\n        \
    \    a.checked_add(b).unwrap()\n        } else {\n            // Otherwise sort\
    \ by sum\n            a.checked_add(b).unwrap()\n        }\n    });\n\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvbjzml6w.rs:19:13\n   |\n\
    19 |             a.checked_add(b).unwrap()\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvbjzml6w.rs:22:13\n   |\n22 |             a.checked_add(b).unwrap()\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return Vec::new();\n\
    \    }\n    let mut nums_sorted = nums.clone();\n    sort_helper(&mut nums_sorted);\n\
    \    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_helper` in this scope\n  --> /tmp/tmp82q0dy78.rs:13:5\n\
    \   |\n13 |     sort_helper(&mut nums_sorted);\n   |     ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .enumerate()\n        .filter_map(|(i, &num)| {\n            let mut\
    \ num = 0;\n            for d in num.chars().filter(|&d| d != '0') {\n       \
    \         num += d.to_digit(10);\n            }\n            Some((i, num))\n\
    \        })\n        .filter(|&(_, num)| nums.iter().any(|&x| x == num))\n   \
    \     .cloned()\n        .sort();\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5sans7qy.rs:13:26\n   |\n\
    13 |         .filter_map(|(i, &num)| {\n   |                          ^^^^- expected\
    \ due to this\n   |                          |\n   |                         \
    \ expected `isize`, found reference\n   |                          help: you can\
    \ probably remove the explicit borrow: `num`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0599]: no method named `chars`\
    \ found for type `{integer}` in the current scope\n  --> /tmp/tmp5sans7qy.rs:15:26\n\
    \   |\n15 |             for d in num.chars().filter(|&d| d != '0') {\n   |   \
    \                       ^^^^^ method not found in `{integer}`\n\nerror[E0271]:\
    \ type mismatch resolving `<[closure@/tmp/tmp5sans7qy.rs:13:21: 19:10] as FnOnce<((usize,\
    \ isize),)>>::Output == Option<&_>`\n  --> /tmp/tmp5sans7qy.rs:21:10\n   |\n21\
    \ |         .cloned()\n   |          ^^^^^^ expected reference, found tuple\n\
    \   |\n   = note: expected enum `Option<&_>`\n              found enum `Option<(usize,\
    \ isize)>`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `FilterMap<Enumerate<Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmp5sans7qy.rs:13:21:\
    \ 19:10]>`\n   = note: 1 redundant requirement hidden\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `Filter<FilterMap<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmp5sans7qy.rs:13:21: 19:10]>, [closure@/tmp/tmp5sans7qy.rs:20:17:\
    \ 20:59]>`\n\nerror[E0631]: type mismatch in closure arguments\n  --> /tmp/tmp5sans7qy.rs:21:10\n\
    \   |\n20 |         .filter(|&(_, num)| nums.iter().any(|&x| x == num))\n   |\
    \                 ------------------------------------------ found signature of\
    \ `for<'r> fn(&'r (usize, isize)) -> _`\n21 |         .cloned()\n   |        \
    \  ^^^^^^ expected signature of `for<'r> fn(&'r &_) -> _`\n   |\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `Filter<FilterMap<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmp5sans7qy.rs:13:21: 19:10]>, [closure@/tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sums = vec![0];\n    for x in nums\
    \ {\n        let sum = x.to_digits();\n        sums.push(sum.iter().sum::<isize>());\n\
    \    }\n    sums.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap_or(false));\n\
    \    sums.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpie5o1zug.rs:11:21\n   |\n11 |         let sum =\
    \ x.to_digits();\n   |                     ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpie5o1zug.rs:14:61\n   |\n14 |\
    \     sums.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap_or(false));\n   | \
    \                                                            ^^^^^ expected enum\
    \ `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Calculate the sum of each digit\n    let\
    \ mut sum_map = std::collections::HashMap::new();\n    for n in nums {\n     \
    \   let mut s = String::new();\n        while n != 0 {\n            s.push((n\
    \ % 10).to_string());\n            n /= 10;\n        }\n        let sum = sum_map.entry(s).or_insert(0);\n\
    \        sum_map.insert(sum, sum + n);\n    }\n\n    // Sort from low to high\n\
    \    let mut res = Vec::new();\n    let mut iters = sum_map.into_iter().rev().collect::<Vec<_>>();\n\
    \    for &(sum_n, _) in iters {\n        res.push(sum_n);\n    }\n\n    res\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4exm7jpe.rs:14:20\n   |\n\
    14 |             s.push((n % 10).to_string());\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp4exm7jpe.rs:18:24\n   |\n18 |         sum_map.insert(sum, sum +\
    \ n);\n   |                        ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&mut {integer}`\n\nerror[E0369]: cannot add `isize` to `&mut {integer}`\n\
    \  --> /tmp/tmp4exm7jpe.rs:18:33\n   |\n18 |         sum_map.insert(sum, sum +\
    \ n);\n   |                             --- ^ - isize\n   |                  \
    \           |\n   |                             &mut {integer}\n   |\nhelp: `+`\
    \ can be used on `{integer}`, you can dereference `sum`\n   |\n18 |         sum_map.insert(sum,\
    \ *sum + n);\n   |                             +\n\nerror[E0277]: the trait bound\
    \ `std::collections::hash_map::IntoIter<String, isize>: DoubleEndedIterator` is\
    \ not satisfied\n    --> /tmp/tmp4exm7jpe.rs:23:41\n     |\n23   |     let mut\
    \ iters = sum_map.into_iter().rev().collect::<Vec<_>>();\n     |             \
    \                            ^^^ the trait `DoubleEndedIterator` is not implemented\
    \ for `std::collections::hash_map::IntoIter<String, isize>`\n     |\nnote: required\
    \ by a bound in `rev`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Rev<std::collections::hash_map::IntoIter<String, isize>>`, but its trait bounds\
    \ were not satisfied\n    --> /tmp/tmp4exm7jpe.rs:23:47\n     |\n23   |      \
    \ let mut iters = sum_map.into_iter().rev().collect::<Vec<_>>();\n     |     \
    \                                            ^^^^^^^ method cannot be called on\
    \ `Rev<std::collections::hash_map::IntoIter<String, isize>>` due to unsatisfied\
    \ trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n\
    \             `std::collections::hash_map::IntoIter<String, isize>: DoubleEndedIterator`\n\
    \             which is required by `Rev<std::collections::hash_map::IntoIter<Strin"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_numbers = Vec::new();\n    let\
    \ mut last_point = 0;\n\n    for (i, point) in nums.iter().enumerate() {\n   \
    \     if point == 0 {\n            // We ignore zero points.\n            last_point\
    \ = 0;\n        } else {\n            // We add the last point if it is not 0.\n\
    \            if last_point != 0 {\n                sorted_numbers.push(last_point);\n\
    \            }\n            last_point = i;\n        }\n    }\n\n    if last_point\
    \ != 0 {\n        sorted_numbers.push(last_point);\n    }\n    sorted_numbers\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpivh8bj9k.rs:13:18\n\
    \   |\n13 |         if point == 0 {\n   |                  ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpivh8bj9k.rs:28:5\n   |\n8  | fn order_by_points(nums: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                         ---------- expected\
    \ `Vec<isize>` because of return type\n...\n28 |     sorted_numbers\n   |    \
    \ ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_unstable();\n\
    \n    let mut nums_sorted = nums_copy.clone();\n    let mut sums: Vec<isize> =\
    \ Vec::new();\n    for &x in nums_sorted {\n        let mut sum = 0;\n       \
    \ for &d in x {\n            sum += d as isize;\n        }\n        sums.push(sum);\n\
    \    }\n    for (i, &sum) in sums.iter().enumerate() {\n        // remove elements\
    \ with same sum\n        if i > 0 && sum == sums[i - 1] {\n            nums_sorted.drain(..i).unwrap();\n\
    \        }\n    }\n\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjyib_sm2.rs:14:9\n   |\n\
    14 |     for &x in nums_sorted {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `x`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: no method named `unwrap` found for struct `std::vec::Drain` in the\
    \ current scope\n  --> /tmp/tmpjyib_sm2.rs:24:36\n   |\n24 |             nums_sorted.drain(..i).unwrap();\n\
    \   |                                    ^^^^^^ method not found in `std::vec::Drain<'_,\
    \ isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return vec![];\n\
    \    }\n\n    // Compute sum of digits of the integers up to nums[i]\n    let\
    \ mut sum_of_digits = nums[0] as isize;\n    for i in 1..nums.len() {\n      \
    \  sum_of_digits += nums[i] as isize;\n    }\n\n    // Build a new vector with\
    \ numbers in ascending order\n    // of sum of their digits.\n    let mut ret:\
    \ Vec<isize> = vec![];\n    let mut cur = nums[0];\n    for i in 1..nums.len()\
    \ {\n        if sum_of_digits < cur as isize {\n            ret.push(cur);\n \
    \           cur = nums[i];\n        } else {\n            ret.push(cur);\n   \
    \         cur = nums[i];\n            sum_of_digits -= cur as isize;\n       \
    \ }\n    }\n    ret.push(cur);\n    ret\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpt88h8pjv.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Sort the given list in descending order\
    \ according to sum of their digits\n    nums\n        .iter()\n        .cloned()\n\
    \        .sort_by(|a, b| {\n            // Get sum of digits of the given integers\n\
    \            let mut suma = |x: isize| x.to_digits();\n            suma(a) + suma(b)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpujpmg9q9.rs:13:10\n   |\n13 |         .sort_by(|a,\
    \ b| {\n   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `to_digits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpujpmg9q9.rs:15:41\n   |\n15 |          \
    \   let mut suma = |x: isize| x.to_digits();\n   |                           \
    \              ^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum_of_digits = nums\n        .iter()\n\
    \        .map(|x| x.log10()) // Calculate sum of digits in each number\n     \
    \   .sum();\n    // If there are several items with same sum, sort them based\
    \ on their index in original list\n    if sum_of_digits > 0 {\n        nums\n\
    \            .iter_mut()\n            .enumerate()\n            .sort_by(|(idx,\
    \ x)| sum_of_digits - x.log10())\n            .for_each(|(idx, x)| {\n       \
    \         if idx == nums.len() - 1 {\n                    // Last item\n     \
    \               nums[idx] = x;\n                } else {\n                   \
    \ // Other items\n                    nums[idx] = x;\n                }\n    \
    \        });\n    } else {\n        nums.sort_by_key(|x| x.log10());\n    }\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'int_log'\n  --> /tmp/tmpckk56a8o.rs:11:20\n\
    \   |\n11 |         .map(|x| x.log10()) // Calculate sum of digits in each number\n\
    \   |                    ^^^^^\n   |\n   = note: see issue #70887 <https://github.com/rust-lang/rust/issues/70887>\
    \ for more information\n\nerror[E0599]: no method named `sort_by` found for struct\
    \ `Enumerate` in the current scope\n  --> /tmp/tmpckk56a8o.rs:18:14\n   |\n18\
    \ |             .sort_by(|(idx, x)| sum_of_digits - x.log10())\n   |         \
    \     ^^^^^^^ method not found in `Enumerate<std::slice::IterMut<'_, isize>>`\n\
    \nerror[E0658]: use of unstable library feature 'int_log'\n  --> /tmp/tmpckk56a8o.rs:29:32\n\
    \   |\n29 |         nums.sort_by_key(|x| x.log10());\n   |                   \
    \             ^^^^^\n   |\n   = note: see issue #70887 <https://github.com/rust-lang/rust/issues/70887>\
    \ for more information\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0658.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums\n\
    \    }\n\n    // first pass to sort by sum of their digits\n    let mut sums:\
    \ Vec<isize> = vec![0; nums.len()];\n    let mut pos = 0;\n    for i in nums {\n\
    \        sums[pos] += i as isize;\n        pos += 1;\n    }\n    // second pass\
    \ to sort in original order\n    let mut res: Vec<isize> = vec![nums[0]; nums.len()];\n\
    \    for i in 0..nums.len() {\n        let j = sums[i];\n        let mut tmp =\
    \ 0;\n        for j in 0..j {\n            tmp += nums[j];\n        }\n      \
    \  res[i] = tmp;\n    }\n\n    // return sorted list\n    res\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpuna9omtk.rs:26:20\n\
    \   |\n26 |             tmp += nums[j];\n   |                    ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by(|a, b| {\n        let\
    \ mut a_digits = a / 10;\n        let mut b_digits = b / 10;\n        if a_digits\
    \ < b_digits {\n            return 1;\n        }\n        if a_digits > b_digits\
    \ {\n            return -1;\n        }\n        if a_digits == b_digits {\n  \
    \          return a.partial_cmp(b).unwrap();\n        }\n        return a_digits.partial_cmp(b_digits).unwrap();\n\
    \    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8g_iedjt.rs:13:20\n   |\n\
    13 |             return 1;\n   |                    ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8g_iedjt.rs:21:37\n\
    \   |\n21 |         return a_digits.partial_cmp(b_digits).unwrap();\n   |    \
    \                                 ^^^^^^^^\n   |                             \
    \        |\n   |                                     expected `&isize`, found\
    \ `isize`\n   |                                     help: consider borrowing here:\
    \ `&b_digits`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .map(|x| x.to_string())\n\
    \        .sort_by(|a, b| {\n            let len = (&b).len();\n            let\
    \ mut i = cmp::Ordering::Less as i32;\n            let mut j = cmp::Ordering::Less\
    \ as i32;\n\n            for i in 0..len {\n                let digit = (&b)[i\
    \ as usize].chars().nth(i as usize).unwrap();\n                let d = digit.to_digit(10);\n\
    \                let d_i = d.to_digit(10);\n                let d_j = d.to_digit(10);\n\
    \n                if d_i < d_j {\n                    j = cmp::Ordering::Less\
    \ as i32;\n                } else if d_i == d_j {\n                    j = cmp::Ordering::Equal\
    \ as i32;\n                } else if d_i > d_j {\n                    i = cmp::Ordering::Less\
    \ as i32;\n                }\n            }\n\n            cmp::Ordering::Equal\
    \ as i32\n                .compare(&i.to_string(), &j.to_string())\n         \
    \       .unwrap()\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmprdo0qjqx.rs:32:13\n\
    \   |\n32 |             cmp::Ordering::Equal as i32\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\nhelp: try surrounding the expression in parentheses\n   |\n32 |       \
    \      (cmp::Ordering::Equal as i32)\n   |             +                     \
    \      +\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmprdo0qjqx.rs:14:25\n   |\n14 |             let mut i = cmp::Ordering::Less\
    \ as i32;\n   |                         ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmprdo0qjqx.rs:15:25\n   |\n15 |             let mut j = cmp::Ordering::Less\
    \ as i32;\n   |                         ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmprdo0qjqx.rs:24:25\n   |\n24 |                     j = cmp::Ordering::Less\
    \ as i32;\n   |                         ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmprdo0qjqx.rs:26:25\n   |\n26 |                     j = cmp::Ordering::Equal\
    \ as i32;\n   |                         ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmprdo0qjqx.rs:28:25\n   |\n28 |                     i = cmp::Ordering::Less\
    \ as i32;\n   |                         ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmprdo0qjqx.rs:32:13\n   |\n32 |             cmp::Ordering::Equal\
    \ as i32\n   |             ^^^ use of undeclared crate or module `cmp`\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `Map` in the current scope\n  -->\
    \ /tmp/tmprdo0qjqx.rs:12:10\n   |\n12 |         .sort_by(|a, b| {\n   |      \
    \    ^^^^^^^ method not found in `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmprdo0qjqx.rs:11:14:\
    \ 11:31]>`\n\nerror: aborting du"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, &num)| {\n            let mut sum: isize = 0;\n           \
    \ let mut last: isize = 0;\n\n            for &c in num.chars() {\n          \
    \      sum += *c as isize;\n                if last < 0 {\n                  \
    \  last = *c as isize;\n                }\n            }\n\n            i {\n\
    \                sum: sum,\n                last: last,\n            }\n     \
    \   })\n        .sort_by_key(|(_, item)| item.sum)\n        .map(|(_, item)| item.last)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0574]: expected struct, variant or union type, found local variable\
    \ `i`\n  --> /tmp/tmpeoiy5jm8.rs:23:13\n   |\n23 |             i {\n   |     \
    \        ^ not a struct, variant or union type\n\nerror[E0599]: no method named\
    \ `chars` found for type `isize` in the current scope\n  --> /tmp/tmpeoiy5jm8.rs:16:27\n\
    \   |\n16 |             for &c in num.chars() {\n   |                        \
    \   ^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Map` in the current scope\n  --> /tmp/tmpeoiy5jm8.rs:28:10\n\
    \   |\n28 |         .sort_by_key(|(_, item)| item.sum)\n   |          ^^^^^^^^^^^\
    \ method not found in `Map<Enumerate<std::slice::Iter<'_, isize>>, _>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0574, E0599.\nFor more information about an error, try `rustc --explain E0574`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut num_groups = nums.len() / digits_for_sum::<isize>().0;\n \
    \   let mut curr = nums[..];\n    let mut currs = vec![0; num_groups];\n    let\
    \ mut max_currs = vec![0; num_groups];\n    let mut max_curr = 0;\n    for (i,\
    \ curr) in nums.iter().enumerate() {\n        let mut cur_sum = 0;\n        for\
    \ ch in curr {\n            cur_sum += *ch.to_string().parse().unwrap();\n   \
    \     }\n        if i == 0 {\n            currs[0] = cur_sum;\n        } else\
    \ {\n            for (j, curr) in currs.iter().enumerate() {\n               \
    \ if cur_sum == curr {\n                    currs[j] = currs[j] + 1;\n       \
    \             break;\n                }\n            }\n        }\n        if\
    \ curr.len() > max_curr {\n            max_curr = curr.len();\n        }\n   \
    \     if i >= nums.len() / num_groups {\n            break;\n        }\n    }\n\
    \    for (i, curr) in nums.iter().enumerate() {\n        let mut cur_sum = 0;\n\
    \        for ch in curr {\n            cur_sum += *ch.to_string().parse().unwrap();\n\
    \        }\n        if i == 0 {\n            max_currs = vec![cur_sum; num_groups];\n\
    \        } else {\n            for (j, curr) in max_currs.iter().enumerate() {\n\
    \                if cur_sum == curr {\n                    max_currs[j] = currs[j]\
    \ + 1;\n                    break;\n                }\n            }\n       \
    \ }\n    }\n    let mut max_idx = 1;\n    let mut curr = nums[..];\n    for (i,\
    \ curr) in max_currs.iter().enumerate() {\n        if curr > max_idx {\n     \
    \       max_idx = curr;\n        }\n    }\n    curr = nums[..];\n    for (i, curr)\
    \ in currs.iter().enumerate() {\n        if curr > max_idx {\n            max_idx\
    \ = curr;\n        }\n    }\n    curr = nums[..];\n    for (i, curr) in max_currs.iter().enumerate()\
    \ {\n        if curr > max_idx {\n            max_idx = curr;\n        }\n   \
    \ }\n    curr = nums[..];\n    for (i, curr) in max_currs.iter().enumerate() {\n\
    \        if curr > max_idx {\n            max_idx = curr;\n        }\n    }\n\
    \    curr = nums[..];\n    for (i, curr) in currs.iter().enumerate() {\n     \
    \   if curr > max_idx {\n            max_idx = curr;\n        }\n    }\n    curr\
    \ = nums[..];\n    for (i, curr) in currs.iter().enumerate() {\n        if curr\
    \ > max_idx {\n            max_idx = curr;\n        }\n    }\n\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `digits_for_sum` in this scope\n  -->\
    \ /tmp/tmpdp828xxy.rs:12:39\n   |\n12 |     let mut num_groups = nums.len() /\
    \ digits_for_sum::<isize>().0;\n   |                                       ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the size for values of type `[isize]`\
    \ cannot be known at compilation time\n  --> /tmp/tmpdp828xxy.rs:13:9\n   |\n\
    13 |     let mut curr = nums[..];\n   |         ^^^^^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n\
    \   |\n13 |     let mut curr = &nums[..];\n   |                    +\n\nerror[E0277]:\
    \ `&isize` is not an iterator\n  --> /tmp/tmpdp828xxy.rs:19:19\n   |\n19 |   \
    \      for ch in curr {\n   |                   ^^^^ `&isize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&isize`\n\
    \nerror[E0277]: can't compare `{integer}` with `&{integer}`\n  --> /tmp/tmpdp828xxy.rs:26:28\n\
    \   |\n26 |                 if cur_sum == curr {\n   |                       \
    \     ^^ no implementation for `{integer} == &{integer}`\n   |\n   = help: the\
    \ trait `PartialEq<&{integer}>` is not implemented for `{integer}`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0599]: no method named `len` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpdp828xxy.rs:32:17\n   |\n32 |         if curr.len() > max_curr\
    \ {\n   |                 ^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `len` found for reference `&isize` in the current scope\n  -->\
    \ /tmp/tmpdp828xxy.rs:33:29\n   |\n33 |             max_curr = curr.len();\n \
    \  |                             ^"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut sorted_list = nums.clone();\n\n    sorted_list.sort();\n\
    \n    sorted_list.sort_by(|a, b| {\n        let mut sum = 0;\n\n        // Calculate\
    \ the sum of digits\n        for i in 0..(std::mem::size_of::<isize>()) {\n  \
    \          sum += a.digits(i).unwrap();\n            sum += b.digits(i).unwrap();\n\
    \        }\n\n        sum\n    });\n\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpnmgfz0gh.rs:22:22\n   |\n22 |             sum\
    \ += a.digits(i).unwrap();\n   |                      ^^^^^^ method not found\
    \ in `&isize`\n\nerror[E0599]: no method named `digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpnmgfz0gh.rs:23:22\n   |\n23 |          \
    \   sum += b.digits(i).unwrap();\n   |                      ^^^^^^ method not\
    \ found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnmgfz0gh.rs:26:9\n\
    \   |\n26 |         sum\n   |         ^^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums = nums.clone();\n    // initialize\
    \ `bucket` with empty buckets\n    let mut bucket = Vec::with_capacity(nums.len());\n\
    \    for (index, num) in nums.into_iter().enumerate() {\n        let mut sum =\
    \ 0;\n        // accumulate sum of digits\n        for digit in num {\n      \
    \      sum += digit;\n        }\n        // store sum to bucket\n        if !bucket.contains(&sum)\
    \ {\n            bucket.push(sum);\n        }\n    }\n    nums.sort_unstable_by(|a,\
    \ b| {\n        match bucket.iter().position(|&b| *b > a) {\n            Some(index)\
    \ => bucket[index],\n            None => a,\n        }\n    });\n    nums\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmptsr_g80i.rs:15:22\n\
    \   |\n15 |         for digit in num {\n   |                      ^^^ `isize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmptsr_g80i.rs:24:43\n   |\n24 |         match bucket.iter().position(|&b|\
    \ *b > a) {\n   |                                           ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptsr_g80i.rs:25:28\n   |\n25 |             Some(index)\
    \ => bucket[index],\n   |                            ^^^^^^^^^^^^^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = nums.clone();\n\
    \    if nums.is_empty() {\n        result.clear();\n        return result;\n \
    \   }\n    let mut digit_sums: Vec<isize> = Vec::new();\n    for &n in nums {\n\
    \        let mut digit_sum = 0;\n        for &d in &n {\n            digit_sum\
    \ += d as isize;\n        }\n        digit_sums.push(digit_sum);\n    }\n    let\
    \ mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|n| {\n       \
    \ let mut digit_sum = 0;\n        for &d in &n {\n            digit_sum += d as\
    \ isize;\n        }\n        digit_sum\n    });\n    for (i, &n) in sorted_nums.into_iter().enumerate()\
    \ {\n        result.insert(i, n);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03sbkl2r.rs:15:9\n   |\n\
    15 |     for &n in nums {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: `&&isize` is\
    \ not an iterator\n  --> /tmp/tmp03sbkl2r.rs:25:19\n   |\n25 |         for &d\
    \ in &n {\n   |                   ^^ `&&isize` is not an iterator\n   |\n   =\
    \ help: the trait `Iterator` is not implemented for `&&isize`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&&isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp03sbkl2r.rs:30:13\n   |\n30 |  \
    \   for (i, &n) in sorted_nums.into_iter().enumerate() {\n   |             ^^\
    \     ----------------------------------- this expression has type `Option<(usize,\
    \ isize)>`\n   |             |\n   |             expected `isize`, found reference\n\
    \   |             help: you can probably remove the explicit borrow: `n`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_copy: Vec<isize> = nums.to_vec();\n\
    \    let mut sum: isize = 0;\n    for i in nums_copy {\n        sum += i;\n  \
    \  }\n    if sum < 0 {\n        nums_copy.push((-sum) as isize);\n    }\n    nums_copy.sort();\n\
    \    nums_copy.to_owned()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmpmawqv6dh.rs:15:9\n\
    \    |\n9   |     let mut nums_copy: Vec<isize> = nums.to_vec();\n    |      \
    \   ------------- move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n10  |     let mut sum: isize = 0;\n11 \
    \ |     for i in nums_copy {\n    |              --------- `nums_copy` moved due\
    \ to this implicit call to `.into_iter()`\n...\n15  |         nums_copy.push((-sum)\
    \ as isize);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for i in &nums_copy\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum = nums.iter().map(|x| x as isize).sum();\n\
    \    sum -= nums.iter().filter(|&x| x < 0).count();\n    let mut num = nums.iter().filter(|&x|\
    \ x > 0).count();\n    num = num - sum;\n    nums.sort();\n    nums.rev();\n \
    \   nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb449ldd2.rs:10:40\n   |\n\
    10 |     sum -= nums.iter().filter(|&x| x < 0).count();\n   |                \
    \                        ^\n   |                                        |\n  \
    \ |                                        expected `&isize`, found integer\n\
    \   |                                        help: consider borrowing here: `&0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb449ldd2.rs:11:47\n   |\n11 |\
    \     let mut num = nums.iter().filter(|&x| x > 0).count();\n   |            \
    \                                   ^\n   |                                  \
    \             |\n   |                                               expected `&isize`,\
    \ found integer\n   |                                               help: consider\
    \ borrowing here: `&0`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   -->\
    \ /tmp/tmpb449ldd2.rs:14:10\n    |\n14  |       nums.rev();\n    |           \
    \ ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<isize>: Iterator`\n           \
    \ which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n\
    \            which is required by `&mut [isize]: Iterator`\n\nerror[E0606]: casting\
    \ `&isize` as `isize` is invalid\n --> /tmp/tmpb449ldd2.rs:9:39\n  |\n9 |    \
    \ let mut sum = nums.iter().map(|x| x as isize).sum();\n  |                  \
    \                     -^^^^^^^^^\n  |                                       |\n\
    \  |                                       cannot cast `&isize` as `isize`\n \
    \ |                                       help: dereference the expression: `*x`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    fn digits(i: isize) -> Vec<isize> {\n     \
    \   let mut v = Vec::new();\n        while i >= 10 {\n            v.push(i/10);\n\
    \            i -= (i/10)*10;\n        }\n        v.push(i);\n        v.reverse();\n\
    \        v\n    }\n    \n    fn compare_sums(a: isize, b: isize) -> bool {\n \
    \       let a = digits(a);\n        let b = digits(b);\n        let mut sum =\
    \ 0;\n        \n        for i in 0 .. a.len() {\n            sum += a[i];\n  \
    \      }\n        \n        for i in 0 .. b.len() {\n            sum += b[i];\n\
    \        }\n        \n        sum <=> b\n    }\n    \n    nums.sort_by_key(compare_sums);\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: invalid comparison operator `<=>`\n  --> /tmp/tmp3b2wto8x.rs:33:13\n\
    \   |\n33 |         sum <=> b\n   |             ^^^ `<=>` is not a valid comparison\
    \ operator, use `std::cmp::Ordering`\n\nerror[E0593]: function is expected to\
    \ take 1 argument, but it takes 2 arguments\n   --> /tmp/tmp3b2wto8x.rs:36:22\n\
    \    |\n20  |     fn compare_sums(a: isize, b: isize) -> bool {\n    |     -------------------------------------------\
    \ takes 2 arguments\n...\n36  |     nums.sort_by_key(compare_sums);\n    |   \
    \       ----------- ^^^^^^^^^^^^ expected function that takes 1 argument\n   \
    \ |          |\n    |          required by a bound introduced by this call\n \
    \   |\nnote: required by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3b2wto8x.rs:33:17\n   |\n33 |         sum <=>\
    \ b\n   |                 ^ expected `isize`, found struct `Vec`\n   |\n   = note:\
    \ expected type `isize`\n            found struct `Vec<isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0593.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // Get sum of the digits\n    let mut sum =\
    \ 0;\n    let mut nums_copy = nums.clone();\n    while nums_copy.len() > 0 {\n\
    \        sum += nums_copy.remove(0);\n    }\n    sum\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9opcxyey.rs:15:5\n   |\n\
    8  | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |              \
    \                           ---------- expected `Vec<isize>` because of return\
    \ type\n...\n15 |     sum\n   |     ^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .clone()\n \
    \       .sort_by_key(|n| n.digits().sum::<usize>())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpkn151kmw.rs:12:10\n   |\n12 |         .sort_by_key(|n|\
    \ n.digits().sum::<usize>())\n   |          ^^^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .cloned()\n\
    \        .enumerate()\n        .filter_map(|(idx, num)| {\n            if num\
    \ % 10 == 0 {\n                Ok(Some(idx))\n            } else {\n         \
    \       Ok(None)\n            }\n        })\n        .map(|opt| opt.unwrap_or(0))\n\
    \        .fold(Vec::new, |mut acc, i| {\n            let num = nums[i];\n    \
    \        let mut accum = acc;\n            while accum.len() < num {\n       \
    \         let mut i = 0;\n                while accum.len() < num && i < acc.len()\
    \ {\n                    accum[i] += acc[i];\n                    i += 1;\n  \
    \              }\n                accum.push(0);\n            }\n            for\
    \ i in 0..num {\n                accum[i] -= num;\n            }\n           \
    \ acc\n        })\n        .to_vec()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg9rcx1xs.rs:15:17\n   |\n\
    15 |                 Ok(Some(idx))\n   |                 ^^^^^^^^^^^^^ expected\
    \ enum `Option`, found enum `Result`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found enum `Result<Option<usize>, _>`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n15 |                 Some(Ok(Some(idx)))\n   |            \
    \     +++++             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9rcx1xs.rs:17:17\n\
    \   |\n17 |                 Ok(None)\n   |                 ^^^^^^^^ expected enum\
    \ `Option`, found enum `Result`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found enum `Result<Option<_>, _>`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n17 |                 Some(Ok(None))\n   |                 +++++\
    \        +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // The maximum sum of digits we can have\n\
    \    let max_digits = nums.iter().map(|&n| n as isize).max();\n    // The possible\
    \ values of sum of digits we can have\n    let mut digits = vec![0isize; max_digits\
    \ + 1usize];\n    // The current sum of digits\n    let mut sum = 0isize;\n  \
    \  // The index of the items with most similar sum of digits\n    let mut best_index\
    \ = nums.len();\n    // The sum of the digits of most similar items\n    let mut\
    \ best_sum = 0isize;\n    // The index of most similar item\n    let mut best_index\
    \ = nums.len();\n\n    // Reset the possible sum of digits\n    for i in 0..max_digits\
    \ {\n        digits[i] = 0isize;\n    }\n\n    for n in &nums {\n        let sum\
    \ = (*n as isize).checked_mul(10).unwrap() + sum;\n        let digit = (*n as\
    \ isize).checked_div(10).unwrap();\n\n        // Update the sum of digits\n  \
    \      if digit < digits[sum as usize].checked_sub(1)\n            .unwrap()\n\
    \            .unwrap()\n        {\n            digits[sum as usize].checked_add(digit\
    \ as usize)\n                .unwrap();\n        }\n\n        // Update the index\
    \ of most similar item\n        if best_sum < sum {\n            best_sum = sum;\n\
    \            best_index = nums.iter().position(|&x| x != n);\n        }\n    }\n\
    \    let mut ans = Vec::new();\n    for i in 0..best_index {\n        ans.push(*nums[i\
    \ as usize]);\n    }\n    ans\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `usize` to `Option<isize>`\n  --> /tmp/tmp0kv3a73r.rs:12:46\n\
    \   |\n12 |     let mut digits = vec![0isize; max_digits + 1usize];\n   |    \
    \                               ---------- ^ ------ usize\n   |              \
    \                     |\n   |                                   Option<isize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0kv3a73r.rs:23:17\n   |\n23 |\
    \     for i in 0..max_digits {\n   |                 ^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<isize>`\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmp0kv3a73r.rs:34:14\n   |\n\
    34 |             .unwrap()\n   |              ^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0kv3a73r.rs:36:46\n   |\n36 |\
    \             digits[sum as usize].checked_add(digit as usize)\n   |         \
    \                                     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n36 |             digits[sum as usize].checked_add((digit\
    \ as usize).try_into().unwrap())\n   |                                       \
    \       +              +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0kv3a73r.rs:43:57\n   |\n43 |             best_index = nums.iter().position(|&x|\
    \ x != n);\n   |                                                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    43 |             best_index = nums.iter().position(|&x| x != *n);\n   |      \
    \                                                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0kv3a73r.rs:43:26\n   |\n20 |     let mut best_index =\
    \ nums.len();\n   |                          ---------- expected due to this value\n\
    ...\n43 |             best_index = nums.iter().position(|&x| x != n);\n   |  \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n   \
    \ let mut digits: Vec<isize> = nums.iter().cloned().map(|n| n.digits()).collect();\n\
    \    let mut sum = 0;\n    for i in digits {\n        sum += *i;\n        res.push(sum);\n\
    \    }\n    let mut i = 0;\n    while i < res.len() {\n        for j in 0..i.i+1\
    \ {\n            if res[j] > res[j+1] {\n                let t = res[j];\n   \
    \             res[j] = res[j+1];\n                res[j+1] = t;\n            }\n\
    \        }\n        i += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpfugjnhrp.rs:10:65\n   |\n10 |     let mut digits: Vec<isize>\
    \ = nums.iter().cloned().map(|n| n.digits()).collect();\n   |                \
    \                                                 ^^^^^^ method not found in `isize`\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpfugjnhrp.rs:13:16\n\
    \   |\n13 |         sum += *i;\n   |                ^^\n\nerror[E0610]: `usize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpfugjnhrp.rs:18:23\n\
    \   |\n18 |         for j in 0..i.i+1 {\n   |                       ^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0610, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .sort_by(|(idx, elm), (_, elm2)| {\n            elm.to_digits() + elm2.to_digits()\n\
    \        })\n        .map(|(idx, elm)| idx)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmptifppih1.rs:12:10\n   |\n12 |         .sort_by(|(idx,\
    \ elm), (_, elm2)| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut nums_copy = nums;\n    let mut num_to_sort = nums_copy[0];\n\
    \n    let mut cur_sum = 0;\n    for &n in &mut nums_copy {\n        cur_sum +=\
    \ n;\n        if num_to_sort == 0 {\n            num_to_sort = n;\n        }\n\
    \        if cur_sum == num_to_sort {\n            nums_sorted = nums_copy;\n \
    \           return nums_sorted;\n        }\n    }\n\n    return nums_copy;\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `nums_sorted` in this scope\n  --> /tmp/tmpf6jjk_sy.rs:23:13\n\
    \   |\n23 |             nums_sorted = nums_copy;\n   |             ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `nums_sorted` in\
    \ this scope\n  --> /tmp/tmpf6jjk_sy.rs:24:20\n   |\n24 |             return nums_sorted;\n\
    \   |                    ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf6jjk_sy.rs:17:9\n   |\n17 |     for &n in &mut\
    \ nums_copy {\n   |         ^^    -------------- this expression has type `Option<&mut\
    \ isize>`\n   |         |\n   |         types differ in mutability\n   |     \
    \    help: you can probably remove the explicit borrow: `n`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n\n    // Find the index of the smallest number\n    let mut min_idx =\
    \ nums.iter().min().unwrap();\n\n    // Initialize an empty vector to store the\
    \ index\n    // of all numbers with the same sum of their digits\n    let mut\
    \ result = Vec::with_capacity(nums.len());\n\n    // Iterate over the numbers\
    \ vector and add them\n    // to the result vector if their sum matches the\n\
    \    // smallest number from step 1.\n    for &n in nums {\n        if n == min_idx\
    \ {\n            result.push(n);\n        } else {\n            // If this number\
    \ matches one of the numbers in the\n            // result vector, update the\
    \ smallest number\n            // to match the sum of the digits of the next\n\
    \            // number and remove it from our results vector.\n            for\
    \ (i, &r) in result.iter().enumerate() {\n                if n == r {\n      \
    \              min_idx = nums[i];\n                    result.remove(i);\n   \
    \                 break;\n                }\n            }\n        }\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxv0jm99r.rs:23:9\n   |\n\
    23 |     for &n in nums {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxv0jm99r.rs:33:31\n   |\n14 |     let mut min_idx = nums.iter().min().unwrap();\n\
    \   |                       -------------------------- expected due to this value\n\
    ...\n33 |                     min_idx = nums[i];\n   |                       \
    \        ^^^^^^^\n   |                               |\n   |                 \
    \              expected `&isize`, found `isize`\n   |                        \
    \       help: consider borrowing here: `&nums[i]`\n\nerror[E0277]: can't compare\
    \ `isize` with `&isize`\n  --> /tmp/tmpxv0jm99r.rs:24:14\n   |\n24 |         if\
    \ n == min_idx {\n   |              ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut points: Vec<isize> = nums.iter().cloned().collect();\n   \
    \ let mut sum: isize = nums[0].digits().iter().sum();\n    for i in 1..points.len()\
    \ {\n        if points[i-1].digits().iter().sum() < sum {\n            sum = points[i-1].digits().iter().sum();\n\
    \        }\n        points[i] = points[i-1];\n    }\n    return points;\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp0iwqjxzz.rs:13:34\n   |\n13 |     let mut sum: isize =\
    \ nums[0].digits().iter().sum();\n   |                                  ^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `digits` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmp0iwqjxzz.rs:15:24\n   |\n\
    15 |         if points[i-1].digits().iter().sum() < sum {\n   |              \
    \          ^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `digits` found for type `isize` in the current scope\n  --> /tmp/tmp0iwqjxzz.rs:16:31\n\
    \   |\n16 |             sum = points[i-1].digits().iter().sum();\n   |       \
    \                        ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums;\n\
    \    }\n    let mut nums_copy = nums.clone();\n    let mut sorted_nums = nums_copy.clone();\n\
    \    let mut last_digit_total = 0;\n    while nums_copy.len() > 0 {\n        let\
    \ mut new_num_vec: Vec<isize> = vec![];\n        for num in nums_copy {\n    \
    \        last_digit_total += num;\n            new_num_vec.push(num);\n      \
    \  }\n        if last_digit_total < nums_copy[0] {\n            sorted_nums.swap(0,\
    \ nums_copy.len() - 1);\n        }\n        last_digit_total = 0;\n        nums_copy\
    \ = new_num_vec;\n    }\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmptfv8rf1w.rs:21:31\n\
    \    |\n12  |     let mut nums_copy = nums.clone();\n    |         -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |         for num in nums_copy {\n    |         \
    \           --------- `nums_copy` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |         if last_digit_total < nums_copy[0] {\n    |               \
    \                ^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `nums_copy`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n17  |         for num in &nums_copy {\n    |            \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut cur = 0u64;\n    let mut result = Vec::new();\n\
    \    for &num in nums {\n        let mut carry = 0;\n        let mut digits =\
    \ num.clone();\n        while digits != 0 {\n            let digit = digits %\
    \ 10;\n            digits = (digits / 10).clone() + 1;\n            carry = digit;\n\
    \            if carry > 0 {\n                result.push(carry);\n           \
    \     cur += carry;\n            }\n        }\n        cur += num;\n        if\
    \ result.len() > 0 {\n            result.pop();\n        }\n        cur %= 10;\n\
    \    }\n    if cur > 0 {\n        result.push(cur);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpciv4zi2s.rs:11:9\n   |\n\
    11 |     for &num in nums {\n   |         ^^^^    ---- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpciv4zi2s.rs:32:5\n   |\n8  | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                         ----------\
    \ expected `Vec<isize>` because of return type\n...\n32 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `u64`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<u64>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    // use std::cmp::Ordering;\n    // use std::collections::HashMap;\n\
    \n    let mut map = HashMap::new();\n    let mut result = Vec::new();\n\n    for\
    \ v in nums {\n        map.insert(sum::<isize>(v), v);\n    }\n\n    for v in\
    \ map.values() {\n        result.push(v.0);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwbpegxvb.rs:12:19\n   |\n12 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find function `sum` in this scope\n  --> /tmp/tmpwbpegxvb.rs:16:20\n\
    \   |\n16 |         map.insert(sum::<isize>(v), v);\n   |                    ^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = nums.clone();\n\n   \
    \ let mut curr_sum = 0;\n    let mut index = 0;\n    while sorted_list.len() >\
    \ 0 {\n        curr_sum += sorted_list.remove(0);\n        index = sorted_list.iter().position(|&x|\
    \ x == curr_sum).unwrap();\n    }\n\n    sorted_list.sort_by_key(|&x| x.cmp(&index));\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_mwr6xb.rs:18:40\n   |\n\
    18 |     sorted_list.sort_by_key(|&x| x.cmp(&index));\n   |                  \
    \                      ^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected reference `&isize`\n              found reference `&usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums\n        .iter()\n        .enumerate()\n\
    \        .sort_by(|(i, n)| {\n            let mut total: isize = 0;\n        \
    \    n.iter().for_each(|digit| {\n                total += *digit;\n         \
    \   });\n            total\n        });\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmphjpkj5dp.rs:12:10\n   |\n12 |         .sort_by(|(i,\
    \ n)| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    nums.iter().enumerate().sort_by(|(idx, _),\
    \ x| x.1.to_digits(10).sum())\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n --> /tmp/tmphgn872p1.rs:9:29\n  |\n9 |     nums.iter().enumerate().sort_by(|(idx,\
    \ _), x| x.1.to_digits(10).sum())\n  |                             ^^^^^^^ method\
    \ not found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut list = nums.clone();\n    let mut sum\
    \ = 0;\n    let mut point: usize = 1;\n    for x in list {\n        sum += *x;\n\
    \        if sum == 0 {\n            point += 1;\n            sum = 1;\n      \
    \  }\n        if point == list.len() {\n            point -= 1;\n        }\n \
    \   }\n    if sum == 0 {\n        return vec![];\n    }\n    let mut cur = vec![];\n\
    \    for x in list {\n        let y = *x - (sum as isize);\n        sum -= y;\n\
    \        cur.push(y);\n    }\n    cur.reverse();\n    cur\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpgkarky4e.rs:13:16\n\
    \   |\n13 |         sum += *x;\n   |                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpgkarky4e.rs:27:17\n   |\n27 |        \
    \ let y = *x - (sum as isize);\n   |                 ^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    let mut points = vec![nums[0]];\n    let mut sum = 0;\n\n    for\
    \ &x in nums.iter().rev() {\n        points.append(x);\n        sum += *x;\n \
    \   }\n\n    let mut sorted = vec![];\n\n    for i in 0..points.len() {\n    \
    \    for j in 0..points.len() {\n            if points[i] < points[j] && i !=\
    \ j {\n                let mut tmp_point = points[i];\n                points[i]\
    \ = points[j];\n                points[j] = tmp_point;\n            }\n      \
    \  }\n    }\n\n    for x in points.iter() {\n        sorted.push(x);\n    }\n\n\
    \    sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6zg_hquj.rs:17:23\n   |\n\
    17 |         points.append(x);\n   |                       ^ expected `&mut Vec<isize>`,\
    \ found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n\
    \                           found type `isize`\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp6zg_hquj.rs:18:16\n   |\n18 |         sum +=\
    \ *x;\n   |                ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6zg_hquj.rs:37:5\n\
    \   |\n8  | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \                                  ---------- expected `Vec<isize>` because of\
    \ return type\n...\n37 |     sorted\n   |     ^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    if nums.is_empty() {\n        return nums\n\
    \    }\n\n    let mut nums_copy = nums.clone();\n\n    for digit in &nums_copy\
    \ {\n        if digit < 0 {\n            nums_copy.swap_remove(digit);\n     \
    \   }\n    }\n\n    let mut nums_copy2 = nums_copy.clone();\n\n    nums_copy.sort_unstable_by(|a,\
    \ b| {\n        if *a > *b {\n            1\n        } else {\n            0\n\
    \        }\n    });\n\n    nums_copy2.sort_unstable_by(|a, b| {\n        if *a\
    \ > *b {\n            -1\n        } else {\n            0\n        }\n    });\n\
    \n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnprui3o5.rs:16:20\n   |\n\
    16 |         if digit < 0 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `&isize`, found integer\n   |        \
    \            help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnprui3o5.rs:17:35\n   |\n17 |             nums_copy.swap_remove(digit);\n\
    \   |                                   ^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnprui3o5.rs:25:13\n   |\n25 |\
    \             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnprui3o5.rs:27:13\n\
    \   |\n27 |             0\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnprui3o5.rs:33:13\n\
    \   |\n33 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnprui3o5.rs:35:13\n\
    \   |\n35 |             0\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sums: Vec<isize> = nums_sorted.iter().cloned().map(|x| x.to_digits()).collect();\n\
    \    sums.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));\n\
    \    let mut idxs: Vec<usize> = nums_sorted.iter().cloned().map(|x| x.to_digits()).collect();\n\
    \    idxs.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));\n\
    \    for i in 0..nums.len() {\n        if nums_sorted[i] == sums[nums_sorted.len()\
    \ - 1 - i] {\n            idxs[nums_sorted.len() - 1 - i] = nums.len() - 1 - i;\n\
    \        }\n    }\n    nums_sorted.iter().cloned().map(|x| nums[idxs[x.to_digits()]]).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp4j85cny4.rs:10:70\n   |\n10 |     let mut sums:\
    \ Vec<isize> = nums_sorted.iter().cloned().map(|x| x.to_digits()).collect();\n\
    \   |                                                                      ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `to_digits` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmp4j85cny4.rs:12:70\n   |\n\
    12 |     let mut idxs: Vec<usize> = nums_sorted.iter().cloned().map(|x| x.to_digits()).collect();\n\
    \   |                                                                      ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `to_digits` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmp4j85cny4.rs:19:53\n   |\n\
    19 |     nums_sorted.iter().cloned().map(|x| nums[idxs[x.to_digits()]]).collect::<Vec<_>>()\n\
    \   |                                                     ^^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = nums;\n    let mut num_sum =\
    \ 0;\n    let mut num_point = 0;\n    for n in &mut res {\n        if *n > 0 {\n\
    \            *n /= 10;\n            num_sum += *n;\n            num_point += 1;\n\
    \        }\n    }\n\n    for n in &mut res {\n        if *n != 0 {\n         \
    \   *n = *n / num_sum * num_point;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, -2, -22, -24]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpmd48y9va.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_sum = nums.len();\n    let mut\
    \ min_idx = nums.iter().min_by_key(|&x| point_sum(x)).unwrap();\n    for i in\
    \ 0..min_sum {\n        if i != nums[min_idx].checked_sub(point_sum(nums[min_idx])).unwrap()\
    \ {\n            min_sum = min_sum as isize;\n            min_idx = i;\n     \
    \   }\n    }\n\n    let mut min_sum_point: Vec<isize> = Vec::new();\n    for i\
    \ in 0..nums.len() {\n        if i == min_idx {\n            append_to_vec(min_sum_point,\
    \ nums[i]);\n        } else {\n            append_to_vec(min_sum_point, nums[i]);\n\
    \        }\n    }\n    min_sum_point\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `point_sum` in this scope\n  --> /tmp/tmpafww9706.rs:10:51\n\
    \   |\n10 |     let mut min_idx = nums.iter().min_by_key(|&x| point_sum(x)).unwrap();\n\
    \   |                                                   ^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_sum`\n\nerror[E0425]: cannot find\
    \ function `point_sum` in this scope\n  --> /tmp/tmpafww9706.rs:12:43\n   |\n\
    12 |         if i != nums[min_idx].checked_sub(point_sum(nums[min_idx])).unwrap()\
    \ {\n   |                                           ^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `min_sum`\n\nerror[E0425]: cannot find function\
    \ `append_to_vec` in this scope\n  --> /tmp/tmpafww9706.rs:21:13\n   |\n21 | \
    \            append_to_vec(min_sum_point, nums[i]);\n   |             ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `append_to_vec`\
    \ in this scope\n  --> /tmp/tmpafww9706.rs:23:13\n   |\n23 |             append_to_vec(min_sum_point,\
    \ nums[i]);\n   |             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpafww9706.rs:12:17\n\
    \   |\n12 |         if i != nums[min_idx].checked_sub(point_sum(nums[min_idx])).unwrap()\
    \ {\n   |                 ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpafww9706.rs:12:53\n   |\n12 |         if i != nums[min_idx].checked_sub(point_sum(nums[min_idx])).unwrap()\
    \ {\n   |                                                     ^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the require"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sum: usize = nums.iter().map(|&n| n.digits()).sum();\n\
    \    let mut nums: Vec<isize> = nums.iter().cloned().collect();\n    loop {\n\
    \        if sum == 0 {\n            break;\n        }\n        let index = nums.iter().position(|&n|\
    \ *n == sum);\n        if index == nums.len() {\n            break;\n        }\n\
    \        nums[index], nums[nums.len() - 1] = nums[nums.len() - 1], nums[index];\n\
    \        sum -= nums[index];\n    }\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpe_8u4hd3.rs:19:20\n   |\n19 |         nums[index], nums[nums.len()\
    \ - 1] = nums[nums.len() - 1], nums[index];\n   |                    ^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0599]: no method named `digits`\
    \ found for type `isize` in the current scope\n --> /tmp/tmpe_8u4hd3.rs:9:49\n\
    \  |\n9 |     let mut sum: usize = nums.iter().map(|&n| n.digits()).sum();\n \
    \ |                                                 ^^^^^^ method not found in\
    \ `isize`\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpe_8u4hd3.rs:15:47\n\
    \   |\n15 |         let index = nums.iter().position(|&n| *n == sum);\n   |  \
    \                                             ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe_8u4hd3.rs:16:21\n   |\n16 |         if index == nums.len() {\n\
    \   |                     ^^^^^^^^^^ expected enum `Option`, found `usize`\n \
    \  |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n16 |         if index == Some(nums.len())\
    \ {\n   |                     +++++          +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
