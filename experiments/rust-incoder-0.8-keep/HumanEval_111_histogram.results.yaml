name: HumanEval_111_histogram
language: rust
results:
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for s in test.split('\
    \ ') {\n        if let Some(count) = histogram.get(&s) {\n            *count +=\
    \ 1;\n        } else {\n            histogram.insert(s, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4k0emwe7.rs:21:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n21 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freq = HashMap::new();\n    for letter in test.chars().filter(|&c|\
    \ !c.is_whitespace()).filter(|c| !c.is_ascii_whitespace()) {\n        let _ =\
    \ freq.entry(letter).or_insert(0);\n        freq.entry(letter).unwrap() += 1;\n\
    \    }\n    freq\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::collections::hash_map::Entry`\
    \ in the current scope\n  --> /tmp/tmpiypn2l1b.rs:16:28\n   |\n16 |         freq.entry(letter).unwrap()\
    \ += 1;\n   |                            ^^^^^^ method not found in `std::collections::hash_map::Entry<'_,\
    \ char, {integer}>`\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpiypn2l1b.rs:16:37\n   |\n16 |         freq.entry(letter).unwrap() +=\
    \ 1;\n   |         --------------------------- ^^\n   |         |\n   |      \
    \   cannot assign to this expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpiypn2l1b.rs:18:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n18 |     freq\n   |  \
    \   ^^^^ expected struct `String`, found `char`\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for char in test.chars()\
    \ {\n        let count = histogram.entry(char.to_string()).or_insert(0);\n   \
    \     *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp_pvp3szc.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    for ch in test.chars() {\n\
    \        let count = freqs.get(&ch).unwrap_or(0);\n        freqs.entry(ch.to_string()).and_modify(|_|\
    \ {\n            *_ += 1;\n        }).or_insert(1);\n    }\n    freqs\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpcrlviuad.rs:17:14\n   |\n17 |             *_ += 1;\n\
    \   |              ^ `_` not allowed here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcrlviuad.rs:15:46\n   |\n15 |         let count = freqs.get(&ch).unwrap_or(0);\n\
    \   |                                              ^\n   |                   \
    \                           |\n   |                                          \
    \    expected reference, found integer\n   |                                 \
    \             help: consider borrowing here: `&0`\n   |\n   = note: expected reference\
    \ `&_`\n                   found type `{integer}`\n\nerror[E0277]: the trait bound\
    \ `String: Borrow<char>` is not satisfied\n   --> /tmp/tmpcrlviuad.rs:15:27\n\
    \    |\n15  |         let count = freqs.get(&ch).unwrap_or(0);\n    |        \
    \                   ^^^ the trait `Borrow<char>` is not implemented for `String`\n\
    \    |\n    = help: the trait `Borrow<str>` is implemented for `String`\nnote:\
    \ required by a bound in `HashMap::<K, V, S>::get`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freq = HashMap::new();\n    for c in test.chars() {\n\
    \        let freq = freq.entry(c).or_insert(0);\n        freq += 1;\n    }\n \
    \   freq.clone()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmphdra4_nq.rs:16:9\n   |\n16 |         freq +=\
    \ 1;\n   |         ----^^^^^\n   |         |\n   |         cannot use `+=` on\
    \ type `&mut {integer}`\n   |\nhelp: `+=` can be used on `{integer}`, you can\
    \ dereference `freq`\n   |\n16 |         *freq += 1;\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphdra4_nq.rs:18:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n18 |     freq.clone()\n\
    \   |     ^^^^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<char,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    for c in test.chars() {\n\
    \        let count = result.entry(c.to_string()).or_insert(0);\n        *count\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp5acqlsq6.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n    for char in test.chars()\
    \ {\n        if let Some(&(_, occurences)) = counts.entry(char.clone()) {\n  \
    \          *occurences += 1;\n        } else {\n            counts.insert(char.clone(),\
    \ 1);\n        }\n    }\n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb4vtas1y.rs:15:16\n   |\n\
    15 |         if let Some(&(_, occurences)) = counts.entry(char.clone()) {\n  \
    \ |                ^^^^^^^^^^^^^^^^^^^^^^   -------------------------- this expression\
    \ has type `std::collections::hash_map::Entry<'_, char, _>`\n   |            \
    \    |\n   |                expected enum `std::collections::hash_map::Entry`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::collections::hash_map::Entry<'_,\
    \ char, _>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb4vtas1y.rs:21:5\n   |\n12 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n21 |     counts\n\
    \   |     ^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    test.split(\" \").for_each(|&s|\
    \ {\n        match result.entry(s) {\n            hash_map::Entry::Occupied(old)\
    \ => {\n                old.get_mut().unwrap().1 += 1;\n            },\n     \
    \       hash_map::Entry::Vacant(entry) => {\n                entry.insert(1, 1);\n\
    \            }\n        }\n    });\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmpras48w2n.rs:16:13\n   |\n16 |             hash_map::Entry::Occupied(old)\
    \ => {\n   |             ^^^^^^^^ use of undeclared crate or module `hash_map`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmpras48w2n.rs:19:13\n   |\n19 |             hash_map::Entry::Vacant(entry)\
    \ => {\n   |             ^^^^^^^^ use of undeclared crate or module `hash_map`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpras48w2n.rs:14:32\n   |\n14 |     test.split(\" \").for_each(|&s|\
    \ {\n   |                                ^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpras48w2n.rs:15:28\n\
    \    |\n15  |         match result.entry(s) {\n    |                      -----\
    \ ^ doesn't have a size known at compile-time\n    |                      |\n\
    \    |                      required by a bound introduced by this call\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `HashMap::<K, V, S>::entry`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpras48w2n.rs:13:22\n\
    \    |\n13  |     let mut result = HashMap::new();\n    |                    \
    \  ^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `HashMap::<K, V>::new`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmpras48w2n.rs:13:22\n    |\n13  |\
    \     let mut result = HashMap::new();\n    |                      ^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnot"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        *freqs.entry(letter).or_insert(0) += 1;\n    }\n \
    \   freqs\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmph7o0d_2i.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters: Vec<_> = test\n        .split_whitespace()\n\
    \        .map(|letter| letter.to_lowercase())\n        .collect();\n    letters\n\
    \        .into_iter()\n        .group_by(|letter| letter)\n        .for_each(|(_,\
    \ count)| {\n            let letter: String = count.keys().max_by(|k| *k).unwrap();\n\
    \            let count: isize = count.iter().fold(0, |memo, i| memo + i);\n  \
    \          letters.insert(letter, count);\n        });\n\n    letters\n      \
    \  .into_iter()\n        .fold(HashMap::new(), |mut acc, mut letter| {\n     \
    \       acc.entry(letter).or_insert(0) += 1;\n            acc\n        });\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp82sgs1tz.rs:19:10\n   |\n19 |         .group_by(|letter|\
    \ letter)\n   |          ^^^^^^^^ method not found in `std::vec::IntoIter<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp82sgs1tz.rs:23:28\n   |\n23 |\
    \             letters.insert(letter, count);\n   |                           \
    \ ^^^^^^ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp82sgs1tz.rs:23:36\n   |\n23 |             letters.insert(letter,\
    \ count);\n   |                                    ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                    |\n   |    \
    \                                expected struct `String`, found `isize`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmp82sgs1tz.rs:29:13\n   |\n29 |             acc.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------^^^^^\n   |          \
    \   |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `acc.entry(letter).or_insert(0)`\n\
    \   |\n29 |             *acc.entry(letter).or_insert(0) += 1;\n   |          \
    \   +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp82sgs1tz.rs:29:44\n\
    \   |\n29 |             acc.entry(letter).or_insert(0) += 1;\n   |           \
    \  ------------------------------ ^^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82sgs1tz.rs:12:31\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n...\n31 |         });\n   |           - help: remove this semicolon\n\
    \   |\n   = note: expected struct `HashMap<String, isize>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 6 previous errors\n\nSo"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut count: HashMap<String, isize> = HashMap::new();\n    test.split_whitespace().map(|word|\
    \ {\n        let mut letter = word.to_lowercase();\n        count.entry(letter).or_default()\
    \ += 1;\n    });\n    count\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut isize`\n  --> /tmp/tmpe0wdnjdk.rs:16:9\n   |\n16 |         count.entry(letter).or_default()\
    \ += 1;\n   |         --------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be used\
    \ on `isize`, you can dereference `count.entry(letter).or_default()`\n   |\n16\
    \ |         *count.entry(letter).or_default() += 1;\n   |         +\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpe0wdnjdk.rs:16:42\n   |\n\
    16 |         count.entry(letter).or_default() += 1;\n   |         --------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.split(\" \").collect::<Vec<String>>();\n\
    \    letters.sort_by_key(|&x| x.to_lowercase());\n\n    let mut letters = HashMap::new();\n\
    \    let mut letter_counts: HashMap<String, isize> = letters.clone();\n    for\
    \ (i, letter) in letters.iter().enumerate() {\n        if letter_counts.contains_key(&letter)\
    \ {\n            letter_counts.entry(&letter).or_insert(0) += 1;\n        } else\
    \ {\n            letter_counts.insert(letter, 1);\n        }\n    }\n    letter_counts\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpf1vz350j.rs:13:39\n     |\n13\
    \   |     let mut letters = test.split(\" \").collect::<Vec<String>>();\n    \
    \ |                                       ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the trait bound `String: Borrow<(&String,\
    \ &isize)>` is not satisfied\n   --> /tmp/tmpf1vz350j.rs:19:39\n    |\n19  | \
    \        if letter_counts.contains_key(&letter) {\n    |                     \
    \     ------------ ^^^^^^^ the trait `Borrow<(&String, &isize)>` is not implemented\
    \ for `String`\n    |                          |\n    |                      \
    \    required by a bound introduced by this call\n    |\n    = help: the trait\
    \ `Borrow<str>` is implemented for `String`\nnote: required by a bound in `HashMap::<K,\
    \ V, S>::contains_key`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf1vz350j.rs:20:33\n\
    \   |\n20 |             letter_counts.entry(&letter).or_insert(0) += 1;\n   |\
    \                                 ^^^^^^^ expected struct `String`, found reference\n\
    \   |\n   = note: expected struct `String`\n           found reference `&(&String,\
    \ &isize)`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut isize`\n  --> /tmp/tmpf1vz350j.rs:20:13\n   |\n20 |          \
    \   letter_counts.entry(&letter).or_insert(0) += 1;\n   |             -----------------------------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&mut isize`\n \
    \  |\nhelp: `+=` can be used on `isize`, you can dereference `letter_counts.entry(&letter).or_insert(0)`\n\
    \   |\n20 |             *letter_counts.entry(&letter).or_insert(0) += 1;\n   |\
    \             +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpf1vz350j.rs:20:55\n\
    \   |\n20 |             letter_counts.entry(&"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut occurrences = HashMap::new();\n\n    for letter in test.split_whitespace()\
    \ {\n        if let Some(count) = occurrences.get(&letter) {\n            *count\
    \ += 1;\n        } else {\n            occurrences.insert(letter, 1);\n      \
    \  }\n    }\n\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7cb8zho5.rs:23:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     occurrences\n   |     ^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.split(' ').map(|c| c.to_lowercase()).collect::<Vec<_>>();\n\
    \    let mut freqs: HashMap<String, isize> = HashMap::new();\n    for letter in\
    \ &letters {\n        freqs.entry(letter).and_modify(|count| *count += 1);\n \
    \   }\n    freqs\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpblmn1gdf.rs:16:21\n   |\n\
    16 |         freqs.entry(letter).and_modify(|count| *count += 1);\n   |      \
    \               ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                     |\n   |                     expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().fold(HashMap::new(), |mut acc, char| {\n        let\
    \ key = char.to_string();\n        acc.entry(key)\n            .or_insert(0)\n\
    \            .and_then(|count| count += 1)\n    });\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `and_then` found for mutable reference `&mut\
    \ {integer}` in the current scope\n  --> /tmp/tmp7ytizusd.rs:17:14\n   |\n17 |\
    \             .and_then(|count| count += 1)\n   |              ^^^^^^^^ method\
    \ not found in `&mut {integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ytizusd.rs:12:31\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n...\n18 |     });\n   |       - help: remove this semicolon\n  \
    \ |\n   = note: expected struct `HashMap<String, isize>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        match map.entry(letter).or_insert(0)\
    \ {\n            Some(count) => count += 1,\n            None => map.insert(letter,\
    \ 1)\n        }\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqphvxwip.rs:16:13\n   |\n\
    15 |         match map.entry(letter).or_insert(0) {\n   |               ------------------------------\
    \ this expression has type `&mut {integer}`\n16 |             Some(count) => count\
    \ += 1,\n   |             ^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqphvxwip.rs:17:13\n   |\n15 |\
    \         match map.entry(letter).or_insert(0) {\n   |               ------------------------------\
    \ this expression has type `&mut {integer}`\n16 |             Some(count) => count\
    \ += 1,\n17 |             None => map.insert(letter, 1)\n   |             ^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut _`\n  --> /tmp/tmpqphvxwip.rs:16:28\n \
    \  |\n16 |             Some(count) => count += 1,\n   |                      \
    \      -----^^^^^\n   |                            |\n   |                   \
    \         cannot use `+=` on type `&mut _`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letter_counter = HashMap::new();\n    let mut letter_count\
    \ = HashMap::new();\n    for letter in test.chars().chain(test.chars().skip(1))\
    \ {\n        let mut count = letter_counter.get(&letter).unwrap();\n        count\
    \ = count.checked_add(1).unwrap_or(0);\n        letter_counter.entry(letter).and_modify(|c|\
    \ c.set_val(count));\n        letter_count.entry(letter).and_modify(|c| c.set_val(1));\n\
    \    }\n    letter_counter.into_iter().map(|(letter, v)| {\n        let mut count\
    \ = letter_count.remove(&letter).unwrap();\n        count = count.checked_add(v).unwrap_or(0);\n\
    \        (letter, count)\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `HashMap<K, V>`\n  --> /tmp/tmpq4biau48.rs:16:40\n\
    \   |\n13 |     let mut letter_counter = HashMap::new();\n   |         ------------------\
    \ consider giving `letter_counter` the explicit type `HashMap<K, V>`, where the\
    \ type parameter `V` is specified\n...\n16 |         let mut count = letter_counter.get(&letter).unwrap();\n\
    \   |                                        ^^^ cannot infer type for type parameter\
    \ `V`\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.chars().map(|c| c.to_lowercase()).collect::<Vec<_>>();\n\
    \    letters.sort_by_key(|c| c.clone());\n    let mut counts = HashMap::new();\n\
    \    for (i, c) in letters.into_iter().enumerate() {\n        counts.entry(c).or_default()\
    \ = 0;\n        if i != 0 && c != letters[i - 1] {\n            counts.entry(c).and_modify(|x|\
    \ *x += 1);\n        }\n    }\n    counts\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `ToLowercase: Ord` is not satisfied\n   -->\
    \ /tmp/tmp7zk2y2u0.rs:14:25\n    |\n14  |     letters.sort_by_key(|c| c.clone());\n\
    \    |             ----------- ^^^^^^^^^^^^^ the trait `Ord` is not implemented\
    \ for `ToLowercase`\n    |             |\n    |             required by a bound\
    \ introduced by this call\n    |\nnote: required by a bound in `slice::<impl [T]>::sort_by_key`\n\
    \nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmp7zk2y2u0.rs:17:38\n\
    \   |\n17 |         counts.entry(c).or_default() = 0;\n   |         ----------------------------\
    \ ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0277]:\
    \ the trait bound `ToLowercase: Eq` is not satisfied\n   --> /tmp/tmp7zk2y2u0.rs:17:22\n\
    \    |\n17  |         counts.entry(c).or_default() = 0;\n    |               \
    \ ----- ^ the trait `Eq` is not implemented for `ToLowercase`\n    |         \
    \       |\n    |                required by a bound introduced by this call\n\
    \    |\nnote: required by a bound in `HashMap::<K, V, S>::entry`\n\nerror[E0277]:\
    \ the trait bound `ToLowercase: Hash` is not satisfied\n   --> /tmp/tmp7zk2y2u0.rs:17:22\n\
    \    |\n17  |         counts.entry(c).or_default() = 0;\n    |               \
    \ ----- ^ the trait `Hash` is not implemented for `ToLowercase`\n    |       \
    \         |\n    |                required by a bound introduced by this call\n\
    \    |\nnote: required by a bound in `HashMap::<K, V, S>::entry`\n\nerror[E0369]:\
    \ binary operation `!=` cannot be applied to type `ToLowercase`\n  --> /tmp/tmp7zk2y2u0.rs:18:24\n\
    \   |\n18 |         if i != 0 && c != letters[i - 1] {\n   |                 \
    \     - ^^ -------------- ToLowercase\n   |                      |\n   |     \
    \                 ToLowercase\n\nerror[E0599]: the method `entry` exists for struct\
    \ `HashMap<ToLowercase, _>`, but its trait bounds were not satisfied\n   --> /tmp/tmp7zk2y2u0.rs:19:20\n\
    \    |\n19  |             counts.entry(c).and_modify(|x| *x += 1);\n    |    \
    \                ^^^^^\n    |\n    = note: the following trait bounds were not\
    \ satisfied:\n            `ToLowercase: Eq`\n      "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut occurrences: HashMap<String, isize> = HashMap::new();\n\
    \    let mut letters = test.split_whitespace();\n    for letter in letters {\n\
    \        if let Some(count) = occurrences.get(&letter) {\n            occurrences.insert(letter,\
    \ count + 1);\n        } else {\n            occurrences.insert(letter, 1);\n\
    \        }\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<&str>` is not satisfied\n\
    \   --> /tmp/tmpp_j6uer0.rs:16:42\n    |\n16  |         if let Some(count) = occurrences.get(&letter)\
    \ {\n    |                                          ^^^ the trait `Borrow<&str>`\
    \ is not implemented for `String`\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp_j6uer0.rs:17:32\n   |\n17 |\
    \             occurrences.insert(letter, count + 1);\n   |                   \
    \             ^^^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |                                |\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp_j6uer0.rs:19:32\n\
    \   |\n19 |             occurrences.insert(letter, 1);\n   |                 \
    \               ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counter = HashMap::new();\n    for c in test.chars() {\n\
    \        *counter.entry(c).or_insert(0) += 1;\n    }\n    counter.into_iter().fold(HashMap::new(),\
    \ |mut acc, e| {\n        acc.entry(e.key()).or_insert(e.value() + acc.entry(e.key()).or_insert(0))\n\
    \    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `key` found for tuple `(char, {integer})`\
    \ in the current scope\n  --> /tmp/tmpzr6b9ukf.rs:18:21\n   |\n18 |         acc.entry(e.key()).or_insert(e.value()\
    \ + acc.entry(e.key()).or_insert(0))\n   |                     ^^^ method not\
    \ found in `(char, {integer})`\n\nerror[E0599]: no method named `value` found\
    \ for tuple `(char, {integer})` in the current scope\n  --> /tmp/tmpzr6b9ukf.rs:18:40\n\
    \   |\n18 |         acc.entry(e.key()).or_insert(e.value() + acc.entry(e.key()).or_insert(0))\n\
    \   |                                        ^^^^^ method not found in `(char,\
    \ {integer})`\n\nerror[E0599]: no method named `key` found for tuple `(char, {integer})`\
    \ in the current scope\n  --> /tmp/tmpzr6b9ukf.rs:18:62\n   |\n18 |         acc.entry(e.key()).or_insert(e.value()\
    \ + acc.entry(e.key()).or_insert(0))\n   |                                   \
    \                           ^^^ method not found in `(char, {integer})`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzr6b9ukf.rs:18:9\n   |\n18 |         acc.entry(e.key()).or_insert(e.value()\
    \ + acc.entry(e.key()).or_insert(0))\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `&mut isize`\n   |\n   = note:         expected\
    \ struct `HashMap<String, isize>`\n           found mutable reference `&mut isize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().collect()\n        .group_by(|x| x)\n        .fold(HashMap::new(),\
    \ |mut counts, (c: char, mut count): HashMap<String, isize> | {\n            counts.entry(c).and_modify(|x|\
    \ x.incr(count));\n            count\n        })\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> /tmp/tmp9vawirq4.rs:15:46\n\
    \   |\n15 |         .fold(HashMap::new(), |mut counts, (c: char, mut count): HashMap<String,\
    \ isize> | {\n   |                                              ^ expected one\
    \ of `)`, `,`, `@`, or `|`\n\nerror: expected one of `:`, `@`, or `|`, found `)`\n\
    \  --> /tmp/tmp9vawirq4.rs:15:63\n   |\n15 |         .fold(HashMap::new(), |mut\
    \ counts, (c: char, mut count): HashMap<String, isize> | {\n   |             \
    \                                                  ^ expected one of `:`, `@`,\
    \ or `|`\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.split_whitespace();\n    let mut counts\
    \ = HashMap::new();\n    for &letter in &letters {\n        if let Ok(count) =\
    \ counts.entry(letter).or_insert(0) {\n            *count += 1;\n        }\n \
    \   }\n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&SplitWhitespace<'_>` is not an iterator\n  --> /tmp/tmpc4vmtxnh.rs:15:20\n\
    \   |\n15 |     for &letter in &letters {\n   |                    -^^^^^^^\n\
    \   |                    |\n   |                    `&SplitWhitespace<'_>` is\
    \ not an iterator\n   |                    help: consider removing the leading\
    \ `&`-reference\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&SplitWhitespace<'_>`\n   = note: `Iterator` is implemented for `&mut std::str::SplitWhitespace<'_>`,\
    \ but not for `&std::str::SplitWhitespace<'_>`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&SplitWhitespace<'_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpc4vmtxnh.rs:16:16\n   |\n16 |  \
    \       if let Ok(count) = counts.entry(letter).or_insert(0) {\n   |         \
    \       ^^^^^^^^^   --------------------------------- this expression has type\
    \ `&mut {integer}`\n   |                |\n   |                expected integer,\
    \ found enum `Result`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Result<_, _>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut occurrences = HashMap::new();\n    for letter in test.chars().collect::<String>().trim().split(\"\
    \ \") {\n        if let Some(&count) = occurrences.get(&letter) {\n          \
    \  occurrences.entry(letter).and_modify(|count| *count += 1);\n        } else\
    \ {\n            occurrences.insert(letter, 1);\n        }\n    }\n    occurrences\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyzx1gl_c.rs:21:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n21 |     occurrences\n   |     ^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    for c in test.split(\" \"\
    ) {\n        freqs.entry(c.to_string()).or_insert(0) += 1;\n    }\n    freqs\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9rpn6rij.rs:15:9\n   |\n15 |         freqs.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         ---------------------------------------^^^^^\n   |     \
    \    |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `freqs.entry(c.to_string()).or_insert(0)`\n\
    \   |\n15 |         *freqs.entry(c.to_string()).or_insert(0) += 1;\n   |     \
    \    +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9rpn6rij.rs:15:49\n\
    \   |\n15 |         freqs.entry(c.to_string()).or_insert(0) += 1;\n   |      \
    \   --------------------------------------- ^^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars()\n        .chain(test.chars().map(|x| x.to_string()).collect::<Vec<_>>())\n\
    \        .chars()\n        .filter(|x| x.is_ascii_lowercase())\n        .map(|x|\
    \ (x.to_string(), 1))\n        .max_by_key(|&(k, _)| k)\n        .unwrap()\n \
    \       .clone()\n        .into_iter()\n        .cloned()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Vec<String> as IntoIterator>::Item\
    \ == char`\n   --> /tmp/tmpwlpfw_pt.rs:14:10\n    |\n14  |         .chain(test.chars().map(|x|\
    \ x.to_string()).collect::<Vec<_>>())\n    |          ^^^^^ expected `char`, found\
    \ struct `String`\n    |\nnote: required by a bound in `std::iter::Iterator::chain`\n\
    \nerror[E0599]: no method named `chars` found for struct `std::iter::Chain` in\
    \ the current scope\n  --> /tmp/tmpwlpfw_pt.rs:15:10\n   |\n15 |         .chars()\n\
    \   |          ^^^^^ method not found in `std::iter::Chain<Chars<'_>, std::vec::IntoIter<String>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.chars().collect::<HashSet<char>>();\n \
    \   let mut counts: HashMap<String, isize> = HashMap::new();\n    let mut max_occurrences\
    \ = 0;\n    let mut max_letters = &mut counts;\n    let mut current_letter = &mut\
    \ letters;\n    for letter in letters {\n        let count = counts.entry(letter).or_insert(0);\n\
    \        *current_letter = letter;\n        *count += 1;\n        if *count >\
    \ max_occurrences {\n            max_occurrences = *count;\n            max_letters\
    \ = &mut *count;\n        }\n    }\n    *max_letters -= 1;\n    counts\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpxq63my2p.rs:13:46\n\
    \   |\n13 |     let mut letters = test.chars().collect::<HashSet<char>>();\n \
    \  |                                              ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpxq63my2p.rs:18:19\n\
    \   |\n18 |     for letter in letters {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxq63my2p.rs:24:27\n   |\n16 |     let mut max_letters =\
    \ &mut counts;\n   |                           ----------- expected due to this\
    \ value\n...\n24 |             max_letters = &mut *count;\n   |              \
    \             ^^^^^^^^^^^ expected struct `HashMap`, found `isize`\n   |\n   =\
    \ note: expected mutable reference `&mut HashMap<String, isize>`\n           \
    \   found mutable reference `&mut isize`\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `HashMap<String, isize>`\n  --> /tmp/tmpxq63my2p.rs:27:5\n\
    \   |\n27 |     *max_letters -= 1;\n   |     ------------^^^^^\n   |     |\n \
    \  |     cannot use `-=` on type `HashMap<String, isize>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0368, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = String::new();\n    let mut counts = String::new();\n\
    \n    // Split the string into letters and counts\n    for letter in test.chars()\
    \ {\n        if let Some(count) = (letters.len() as i32).checked_sub(1).checked_sub(1).checked_sub(1).checked_sub(1)\
    \ {\n            let new_letters = letters.clone();\n            new_letters.push_str(&letter);\n\
    \            counts.push_str(&count.to_string());\n        }\n\n        // Append\
    \ letter to letters if it is not the first letter\n        if letters.len() !=\
    \ 0 {\n            letters.push_str(&letter);\n            counts.push_str(&count.to_string());\n\
    \        }\n    }\n\n    // Sort letters and counts\n    let mut letters_map:\
    \ HashMap<String, isize> = HashMap::new();\n    for (index, count) in counts.iter().enumerate()\
    \ {\n        letters_map.insert(letters[index].clone(), count.clone());\n    }\n\
    \n    // Return dictionary if all letters occur the same number of times\n   \
    \ let mut letters_map = letters_map.into_iter().collect::<Vec<_>>();\n    letters_map.sort_by_key(|&x|\
    \ x.0);\n    if letters_map.iter().count() == letters.len() {\n        return\
    \ letters_map;\n    }\n\n    // Return dictionary if some letters occur the same\
    \ number of times\n    letters_map.sort_by_key(|&x| x.0);\n    let mut min_letter_count\
    \ = 1;\n    let mut min_letter: &str = String::new();\n    for (index, letter)\
    \ in letters.iter().enumerate() {\n        let count = letters_map.get(&letter).unwrap();\n\
    \        if count < min_letter_count {\n            min_letter_count = count;\n\
    \            min_letter = &letter;\n        }\n    }\n\n    let mut letter_map\
    \ = HashMap::new();\n    for (index, count) in letters_map.iter().enumerate()\
    \ {\n        letter_map.insert(&min_letter[index].clone(), count.clone());\n \
    \   }\n\n    return letter_map;\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `count` in this scope\n  --> /tmp/tmp1cnrf51e.rs:27:30\n\
    \   |\n27 |             counts.push_str(&count.to_string());\n   |           \
    \                   ^^^^^ help: a local variable with a similar name exists: `counts`\n\
    \nerror[E0599]: no method named `checked_sub` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp1cnrf51e.rs:18:68\n   |\n18 |         if let Some(count)\
    \ = (letters.len() as i32).checked_sub(1).checked_sub(1).checked_sub(1).checked_sub(1)\
    \ {\n   |                                                                    ^^^^^^^^^^^\
    \ method not found in `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1cnrf51e.rs:20:34\n\
    \   |\n20 |             new_letters.push_str(&letter);\n   |                 \
    \                 ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1cnrf51e.rs:26:30\n   |\n26 |             letters.push_str(&letter);\n\
    \   |                              ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1cnrf51e.rs:33:34\n   |\n33 |     for (index, count) in\
    \ counts.iter().enumerate() {\n   |                                  ^^^^ method\
    \ not found in `String`\n   |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n33 |     for (index, count) in counts.chars().enumerate() {\n   |     \
    \                             ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1cnrf51e.rs:41:16\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n41 |         return letters_map;\n   |        \
    \        ^^^^^^^^^^^ expected struct `HashMap`, found struct `Vec`\n   |\n   =\
    \ note: expected struct `HashMap<String, i"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for i in test.split_whitespace().map(|c|\
    \ c.to_lowercase()) {\n        if histogram.contains_key(&i) {\n            histogram.insert(i,\
    \ histogram.get(&i) + 1);\n        } else {\n            histogram.insert(i, 1);\n\
    \        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `Option<&_>`\n  --> /tmp/tmpbx9d49hx.rs:16:51\n\
    \   |\n16 |             histogram.insert(i, histogram.get(&i) + 1);\n   |    \
    \                             ----------------- ^ - {integer}\n   |          \
    \                       |\n   |                                 Option<&_>\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // Split the test string on spaces and iterate over all characters\n\
    \    let mut char_counts = HashMap::new();\n    for ch in test.chars() {\n   \
    \     char_counts.entry(ch).or_insert(0) += 1;\n    }\n\n    // Sort and return\
    \ the counts in decreasing order\n    (char_counts.iter().map(|(_, counts)| counts).collect::<Vec<_>>().sort_by(|a,\
    \ b| b.cmp(a)).collect())\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmp6jchjxxc.rs:20:5\n\
    \   |\n20 |     (char_counts.iter().map(|(_, counts)| counts).collect::<Vec<_>>().sort_by(|a,\
    \ b| b.cmp(a)).collect())\n   |     ^                                        \
    \                                                           ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    20 -     (char_counts.iter().map(|(_, counts)| counts).collect::<Vec<_>>().sort_by(|a,\
    \ b| b.cmp(a)).collect())\n20 +     char_counts.iter().map(|(_, counts)| counts).collect::<Vec<_>>().sort_by(|a,\
    \ b| b.cmp(a)).collect()\n   | \n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&mut {integer}`\n  --> /tmp/tmp6jchjxxc.rs:16:9\n\
    \   |\n16 |         char_counts.entry(ch).or_insert(0) += 1;\n   |         ----------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `char_counts.entry(ch).or_insert(0)`\n\
    \   |\n16 |         *char_counts.entry(ch).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp6jchjxxc.rs:16:44\n\
    \   |\n16 |         char_counts.entry(ch).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0599]:\
    \ `()` is not an iterator\n  --> /tmp/tmp6jchjxxc.rs:20:96\n   |\n20 |     (char_counts.iter().map(|(_,\
    \ counts)| counts).collect::<Vec<_>>().sort_by(|a, b| b.cmp(a)).collect())\n \
    \  |                                                                         \
    \                       ^^^^^^^ `()` is not an iterator\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `(): Iterator`\n    \
    \       which is required by `&mut (): Iterator`\n\nerror: aborting due to 3 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0067,\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.split_whitespace();\n    let mut res =\
    \ HashMap::new();\n    for letter in letters.iter() {\n        if let Some(count)\
    \ = res.get(&letter) {\n            (*count) += 1;\n        } else {\n       \
    \     res.insert(letter, 1);\n        }\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmphochru7g.rs:15:27\n   |\n15 |     for letter\
    \ in letters.iter() {\n   |                           ^^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().filter_map(|c|\
    \ match c {\n        c => Some(c),\n        _ => None,\n    }) {\n        let\
    \ count = histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7o_9okzu.rs:21:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n21 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n\n    for char in test.chars().collect::<Vec<char>>()\
    \ {\n        histogram.insert(char, histogram.entry(char).or_insert(0));\n   \
    \ }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr9dhyeoc.rs:16:32\n   |\n\
    16 |         histogram.insert(char, histogram.entry(char).or_insert(0));\n   |\
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    16 |         histogram.insert(char, *histogram.entry(char).or_insert(0));\n  \
    \ |                                +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr9dhyeoc.rs:19:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n19 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut\
    \ occurrences: HashMap<String, isize> = HashMap::new();\n\n    for letter in letters\
    \ {\n        occurrences.entry(letter).or_default() = occurrences.entry(letter).or_insert(0);\n\
    \        occurrences.entry(letter).unwrap().1 += 1;\n    }\n\n    let mut max_occurrences\
    \ = occurrences.iter().max().unwrap();\n    let mut max_letters = occurrences.iter().filter(|&(k,\
    \ _)| k == max_occurrences).collect::<Vec<_>>();\n\n    for letter in max_letters\
    \ {\n        let count = occurrences.remove(&letter).unwrap();\n        if count\
    \ > max_occurrences {\n            max_occurrences = count;\n            max_letters\
    \ = vec![letter];\n        }\n    }\n\n    for (letter, _) in occurrences {\n\
    \        max_letters.push(letter);\n    }\n\n    let mut histogram = HashMap::new();\n\
    \n    for (letter, count) in occurrences {\n        if let Some(_) = histogram.get(&letter)\
    \ {\n            histogram.insert(letter, histogram.get(&letter).unwrap() + count);\n\
    \        } else {\n            histogram.insert(letter, count);\n        }\n \
    \   }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n   \
    \ assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpe_d6cpwt.rs:17:48\n\
    \   |\n17 |         occurrences.entry(letter).or_default() = occurrences.entry(letter).or_insert(0);\n\
    \   |         -------------------------------------- ^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe_d6cpwt.rs:17:27\n   |\n17 |         occurrences.entry(letter).or_default()\
    \ = occurrences.entry(letter).or_insert(0);\n   |                           ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \         |\n   |                           expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe_d6cpwt.rs:17:68\n   |\n17 |\
    \         occurrences.entry(letter).or_default() = occurrences.entry(letter).or_insert(0);\n\
    \   |                                                                    ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                                                  |\n   |                   \
    \                                                 expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe_d6cpwt.rs:18:27\n\
    \   |\n18 |         occurrences.entry(letter).unwrap().1 += 1;\n   |         \
    \                  ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                           |\n   |                           expected struct\
    \ `String`, found `char`\n\nerror[E0599]: no method named `unwrap` found for enum\
    \ `std::collections::hash_map::Entry` in the current scope\n  --> /tmp/tmpe_d6cpwt.rs:18:35\n\
    \   |\n18 |         occurrences.entry(letter).unwrap().1 += 1;\n   |         \
    \                          ^^^^^^ method not found in `std::collections::hash_map::Entry<'_,\
    \ String, isize>`\n\nerror[E0277]: can't compare `&String` with `(&String, &isize)`\n\
    \  --> /tmp/tmpe_d6cpwt.rs:22:65\n   |\n22 |     let mut max_letters = occurrences.iter().filter(|&(k,\
    \ _)| k == max_occurrences).collect::<Vec<_>>();\n   |                       \
    \                               "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let letters = test.split(' ').map(|l| l.to_lowercase());\n   \
    \ let mut occurrences: HashMap<String, isize> = HashMap::new();\n    for l in\
    \ &letters {\n        if let Some(i) = occurrences.get(&l) {\n            occurrences.insert(l,\
    \ i + 1);\n        } else {\n            occurrences.insert(l, 1);\n        }\n\
    \    }\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&Map<std::str::Split<'_, char>, [closure@/tmp/tmp_lbyr0in.rs:13:39:\
    \ 13:59]>` is not an iterator\n  --> /tmp/tmp_lbyr0in.rs:15:14\n   |\n15 |   \
    \  for l in &letters {\n   |              -^^^^^^^\n   |              |\n   |\
    \              `&Map<std::str::Split<'_, char>, [closure@/tmp/tmp_lbyr0in.rs:13:39:\
    \ 13:59]>` is not an iterator\n   |              help: consider removing the leading\
    \ `&`-reference\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&Map<std::str::Split<'_, char>, [closure@/tmp/tmp_lbyr0in.rs:13:39: 13:59]>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Map<std::str::Split<'_, char>, [closure@/tmp/tmp_lbyr0in.rs:13:39: 13:59]>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    for letter in test.split()\
    \ {\n        let letter = letter.to_string();\n        result.insert(letter, result.entry(letter).or_insert(0));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpj2za034z.rs:14:24\n     |\n14   |     for letter in test.split()\
    \ {\n     |                        ^^^^^- supplied 0 arguments\n     |       \
    \                 |\n     |                        expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpj2za034z.rs:16:31\n   |\n16 |         result.insert(letter, result.entry(letter).or_insert(0));\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |         result.insert(letter, *result.entry(letter).or_insert(0));\n\
    \   |                               +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for c in test.chars().chain(test.chars().skip_while(|&c|\
    \ c != ' ')) {\n        if histogram.contains_key(&c) {\n            histogram.entry(c).with_mut(|_|\
    \ {\n                *_.1 += 1;\n            });\n        } else {\n         \
    \   histogram.insert(c, 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpct12e0k6.rs:17:18\n   |\n17 |                 *_.1\
    \ += 1;\n   |                  ^ `_` not allowed here\n\nerror[E0599]: no method\
    \ named `with_mut` found for enum `std::collections::hash_map::Entry` in the current\
    \ scope\n  --> /tmp/tmpct12e0k6.rs:16:32\n   |\n16 |             histogram.entry(c).with_mut(|_|\
    \ {\n   |                                ^^^^^^^^ method not found in `std::collections::hash_map::Entry<'_,\
    \ char, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct12e0k6.rs:23:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \n    for word in words.clone() {\n        if let Ok(count) = freqs.get(&word)\
    \ {\n            *count += 1;\n        } else {\n            freqs.insert(word.clone(),\
    \ 1);\n        }\n    }\n    freqs\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsxx6kq51.rs:17:16\n   |\n\
    17 |         if let Ok(count) = freqs.get(&word) {\n   |                ^^^^^^^^^\
    \   ---------------- this expression has type `Option<&_>`\n   |             \
    \   |\n   |                expected enum `Option`, found enum `Result`\n   |\n\
    \   = note: expected enum `Option<&_>`\n              found enum `Result<_, _>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxx6kq51.rs:23:5\n   |\n12 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     freqs\n   |     ^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<&str, {integer}>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // Use a HashMap to store the letter and its frequency of the\
    \ word.\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n   \
    \ let words = test.split(\" \").collect::<Vec<String>>();\n\n    // For each word,\
    \ use a HashMap to store the letter as key and\n    // its count as the value.\n\
    \    for word in words {\n        for letter in word {\n            let count\
    \ = histogram.entry(letter).or_insert(0);\n            *count += 1;\n        }\n\
    \    }\n\n    // If the word has a single letter, return it with the highest frequency.\n\
    \    // Otherwise, return all of the letters with the highest frequency.\n   \
    \ if histogram.len() == 1 {\n        let (letter, count) = histogram.iter().max();\n\
    \        let result = histogram.entry(letter).or_insert(0);\n        result.cmp(&count).reverse();\n\
    \    } else {\n        histogram\n    }\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp0eysl3j5.rs:15:33\n     |\n15\
    \   |     let words = test.split(\" \").collect::<Vec<String>>();\n     |    \
    \                             ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp0eysl3j5.rs:20:23\n   |\n20 |   \
    \      for letter in word {\n   |                       ^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0eysl3j5.rs:29:13\n   |\n29 |         let (letter, count) = histogram.iter().max();\n\
    \   |             ^^^^^^^^^^^^^^^   ---------------------- this expression has\
    \ type `Option<(&String, &isize)>`\n   |             |\n   |             expected\
    \ enum `Option`, found tuple\n   |\n   = note: expected enum `Option<(&String,\
    \ &isize)>`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0eysl3j5.rs:28:29\n   |\n28 |       if histogram.len() == 1 {\n\
    \   |  _____________________________^\n29 | |         let (letter, count) = histogram.iter().max();\n\
    30 | |         let result = histogram.entry(letter).or_insert(0);\n31 | |    \
    \     result.cmp(&count).reverse();\n32 | |     } else {\n   | |_____^ expected\
    \ struct `HashMap`, found `()`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n           found unit type `()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test\n        .split_whitespace()\n        .filter_map(|x| x.chars().count())\n\
    \        .max()\n        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1a_kp8_3.rs:15:25\n   |\n\
    15 |         .filter_map(|x| x.chars().count())\n   |                        \
    \ ^^^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `usize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n15 |         .filter_map(|x| Some(x.chars().count()))\n   |\
    \                         +++++                 +\n\nerror[E0599]: `Option<_>`\
    \ is not an iterator\n   --> /tmp/tmp1a_kp8_3.rs:17:10\n    |\n17  |         \
    \  .collect()\n    |            ^^^^^^^ `Option<_>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<_>:\
    \ Iterator`\n            which is required by `&mut Option<_>: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    for letter in test.split('\
    \ ').collect::<Vec<&str>>() {\n        if let Some(count) = result.entry(letter).or_insert(0)\
    \ {\n            *count += 1;\n        } else {\n            result.insert(letter,\
    \ 1);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppvqm1tt0.rs:15:16\n   |\n\
    15 |         if let Some(count) = result.entry(letter).or_insert(0) {\n   |  \
    \              ^^^^^^^^^^^   --------------------------------- this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppvqm1tt0.rs:21:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n21 |     result\n   |\
    \     ^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n\n    for c in test.chars().cloned()\
    \ {\n        let letter = match c.to_ascii_lowercase().as_str() {\n          \
    \  \"a\" => 0,\n            \"b\" => 1,\n            \"c\" => 2,\n           \
    \ _ => panic!(\"unsupported letter: {:?}\", c),\n        };\n\n        map.entry(letter).or_insert(0)\
    \ += 1;\n    }\n\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp7fdeqyy8.rs:15:27\n     |\n15   |     for c in test.chars().cloned()\
    \ {\n     |                           ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmp7fdeqyy8.rs:15:14\n\
    \   |\n15 |     for c in test.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp7fdeqyy8.rs:15:14\n   |\n15 |     for c in test.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmp7fdeqyy8.rs:23:9\n   |\n23 |         map.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------^^^^^\n   |         |\n  \
    \ |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `map.entry(letter).or_insert(0)`\n\
    \   |\n23 |         *map.entry(letter).or_insert(0) += 1;\n   |         +\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp7fdeqyy8.rs:23:40\n\
    \   |\n23 |         map.entry(letter).or_insert(0) += 1;\n   |         ------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split_whitespace().map(|letter| {\n        letter\n     \
    \       .chars()\n            .chain(test\n                .chars()\n        \
    \        .enumerate()\n                .map(|(_, c)| (c, 1))\n               \
    \ .collect::<Vec<_>>())\n            .group_by(|&(c, _)| c)\n            .max_by(|&(letter,\
    \ _)| letter.count())\n            .map(|(_, count)| letter)\n            .collect::<HashMap<String,\
    \ isize>>()\n    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Vec<(char, {integer})> as IntoIterator>::Item\
    \ == char`\n   --> /tmp/tmp5_7bv_w7.rs:16:14\n    |\n16  |             .chain(test\n\
    \    |              ^^^^^ expected `char`, found tuple\n    |\n    = note: expected\
    \ type `char`\n              found tuple `(char, {integer})`\nnote: required by\
    \ a bound in `std::iter::Iterator::chain`\n\nerror[E0599]: no method named `group_by`\
    \ found for struct `std::iter::Chain` in the current scope\n  --> /tmp/tmp5_7bv_w7.rs:21:14\n\
    \   |\n21 |             .group_by(|&(c, _)| c)\n   |              ^^^^^^^^ method\
    \ not found in `std::iter::Chain<Chars<'_>, std::vec::IntoIter<(char, {integer})>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5_7bv_w7.rs:13:5\n   |\n12 | \
    \  fn histogram(test: String) -> HashMap<String, isize> {\n   |              \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n13 | /     test.split_whitespace().map(|letter| {\n14 | |  \
    \       letter\n15 | |             .chars()\n16 | |             .chain(test\n\
    ...  |\n24 | |             .collect::<HashMap<String, isize>>()\n25 | |     })\n\
    \   | |______^ expected struct `HashMap`, found struct `Map`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `Map<SplitWhitespace<'_>,\
    \ _>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split(' ').map(|c| c.to_lowercase().to_string()).collect()\n\
    \        .into_iter()\n        .group_by(|&x| x)\n        .max_by_key(|&(_, v)|\
    \ v)\n        .map(|(_, v)| {\n            test\n                .chars()\n  \
    \              .map(|c| c.to_lowercase().to_string())\n                .collect()\n\
    \                .iter()\n                .collect::<HashMap<String, isize>>()\n\
    \                .entry(c.to_string()).or_insert(v as isize)\n        })\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp5no5wxqr.rs:24:24\n\
    \   |\n24 |                 .entry(c.to_string()).or_insert(v as isize)\n   |\
    \                        ^ help: a local variable with a similar name exists:\
    \ `v`\n\nerror[E0282]: type annotations needed\n  --> /tmp/tmp5no5wxqr.rs:13:59\n\
    \   |\n13 |     test.split(' ').map(|c| c.to_lowercase().to_string()).collect()\n\
    \   |                                                           ^^^^^^^ cannot\
    \ infer type for type parameter `B` declared on the associated function `collect`\n\
    \   |\n   = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n   |\n13 |     test.split(' ').map(|c|\
    \ c.to_lowercase().to_string()).collect::<B>()\n   |                         \
    \                                         +++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0282, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    let mut occurrences = HashMap::new();\n\
    \    let mut current = \"\";\n    for letter in test.chars().skip(1) {\n     \
    \   let mut new_occurrences = occurrences;\n        if let Some(count) = occurrences.get(&letter)\
    \ {\n            new_occurrences = occurrences.entry(letter).or_insert(0) + count;\n\
    \        }\n        result.insert(letter, new_occurrences);\n        current =\
    \ letter;\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&{integer}` to `&mut {integer}`\n  --> /tmp/tmp4pu3u0ew.rs:19:70\n\
    \   |\n19 |             new_occurrences = occurrences.entry(letter).or_insert(0)\
    \ + count;\n   |                               --------------------------------------\
    \ ^ ----- &{integer}\n   |                               |\n   |             \
    \                  &mut {integer}\n   |\nhelp: `+` can be used on `{integer}`,\
    \ you can dereference `occurrences.entry(letter).or_insert(0)`\n   |\n19 |   \
    \          new_occurrences = *occurrences.entry(letter).or_insert(0) + count;\n\
    \   |                               +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4pu3u0ew.rs:22:19\n   |\n15 |     let mut current = \"\";\n   |    \
    \                   -- expected due to this value\n...\n22 |         current =\
    \ letter;\n   |                   ^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4pu3u0ew.rs:24:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n24 |     result\n\
    \   |     ^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, HashMap<char,\
    \ {integer}>>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    for letter in test.split('\
    \ ') {\n        if let Ok(count) = map.entry(letter).or_insert(0) {\n        \
    \    count += 1;\n        }\n    }\n    map\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo32fs09p.rs:15:16\n   |\n\
    15 |         if let Ok(count) = map.entry(letter).or_insert(0) {\n   |       \
    \         ^^^^^^^^^   ------------------------------ this expression has type\
    \ `&mut {integer}`\n   |                |\n   |                expected integer,\
    \ found enum `Result`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Result<_, _>`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&mut _`\n  --> /tmp/tmpo32fs09p.rs:16:13\n   |\n\
    16 |             count += 1;\n   |             -----^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `&mut _`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo32fs09p.rs:19:5\n   |\n12 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n19 |     map\n\
    \   |     ^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letter_counts: HashMap<String, isize> = HashMap::new();\n\
    \n    for letter in test.split_whitespace() {\n        match letter_counts.entry(letter).or_insert(0)\
    \ {\n            Some(ref count) => count += 1,\n            None => 0,\n    \
    \    }\n    }\n\n    letter_counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0xlonl8w.rs:16:35\n   |\n\
    16 |         match letter_counts.entry(letter).or_insert(0) {\n   |          \
    \                         ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                   |\n   |                              \
    \     expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0xlonl8w.rs:17:13\n   |\n16 |         match letter_counts.entry(letter).or_insert(0)\
    \ {\n   |               ---------------------------------------- this expression\
    \ has type `&mut isize`\n17 |             Some(ref count) => count += 1,\n   |\
    \             ^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0xlonl8w.rs:18:13\n   |\n16 |         match\
    \ letter_counts.entry(letter).or_insert(0) {\n   |               ----------------------------------------\
    \ this expression has type `&mut isize`\n17 |             Some(ref count) => count\
    \ += 1,\n18 |             None => 0,\n   |             ^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<_>`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `&_`\n  --> /tmp/tmp0xlonl8w.rs:17:32\n   |\n17 |          \
    \   Some(ref count) => count += 1,\n   |                                -----^^^^^\n\
    \   |                                |\n   |                                cannot\
    \ use `+=` on type `&_`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // Create a map and use HashMap::new()\n    let mut letters =\
    \ HashMap::new();\n    for (i, letter) in test.chars().enumerate() {\n       \
    \ // If key already exists, increment its value\n        if letters.contains_key(&letter)\
    \ {\n            letters.entry(letter).and_modify(|e| e.value += 1).or_insert(0);\n\
    \        } else {\n            // If key does not exist, insert it and give it\
    \ a value of 1\n            letters.insert(letter, 1);\n        }\n    }\n   \
    \ // Return the map value\n    letters\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&mut V`\n  --> /tmp/tmpv19j29t3.rs:18:47\n\
    \   |\n18 |             letters.entry(letter).and_modify(|e| e.value += 1).or_insert(0);\n\
    \   |                                               ^ consider giving this closure\
    \ parameter the explicit type `&mut V`, where the type parameter `V` is specified\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0609]: no field `value`\
    \ on type `&mut _`\n  --> /tmp/tmpv19j29t3.rs:18:52\n   |\n18 |             letters.entry(letter).and_modify(|e|\
    \ e.value += 1).or_insert(0);\n   |                                          \
    \          ^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0282, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // TODO: Use std::collections::HashMap\n    let mut letter_counter\
    \ = HashMap::new();\n\n    for letter in test.chars().filter(|c| c.is_whitespace())\
    \ {\n        let key = String::from(letter);\n        let value = letter_counter.entry(key).or_insert(0);\n\
    \        letter_counter.entry(key).and_modify(|e| *e += 1);\n    }\n\n    letter_counter\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `value`\n  --> /tmp/tmpngakr9rp.rs:18:13\n  \
    \ |\n18 |         let value = letter_counter.entry(key).or_insert(0);\n   |  \
    \           ^^^^^ help: if this is intentional, prefix it with an underscore:\
    \ `_value`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]:\
    \ use of moved value: `key`\n  --> /tmp/tmpngakr9rp.rs:19:30\n   |\n17 |     \
    \    let key = String::from(letter);\n   |             --- move occurs because\
    \ `key` has type `String`, which does not implement the `Copy` trait\n18 |   \
    \      let value = letter_counter.entry(key).or_insert(0);\n   |             \
    \                             --- value moved here\n19 |         letter_counter.entry(key).and_modify(|e|\
    \ *e += 1);\n   |                              ^^^ value used here after move\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut res = HashMap::new();\n    for letter in test.chars().filter(|c|\
    \ !c.is_whitespace()) {\n        res.entry(letter).or_insert(0) += 1;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpja4s4csm.rs:15:9\n   |\n15 |         res.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------^^^^^\n   |         |\n  \
    \ |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `res.entry(letter).or_insert(0)`\n\
    \   |\n15 |         *res.entry(letter).or_insert(0) += 1;\n   |         +\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpja4s4csm.rs:15:40\n\
    \   |\n15 |         res.entry(letter).or_insert(0) += 1;\n   |         ------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpja4s4csm.rs:17:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n17 |     res\n\
    \   |     ^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut chars = test.chars().collect::<Vec<_>>();\n    let mut\
    \ counts = chars.into_iter().fold(HashMap::new(), |mut map, char| {\n        map.entry(char).or_default()\
    \ += 1;\n        map\n    });\n    counts.into_iter().collect::<HashMap<String,\
    \ isize>>()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut _`\n  --> /tmp/tmp7ecl7x38.rs:15:9\n   |\n15 |         map.entry(char).or_default()\
    \ += 1;\n   |         ----------------------------^^^^^\n   |         |\n   |\
    \         cannot use `+=` on type `&mut _`\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmp7ecl7x38.rs:15:38\n   |\n15 |         map.entry(char).or_default()\
    \ += 1;\n   |         ---------------------------- ^^\n   |         |\n   |  \
    \       cannot assign to this expression\n\nerror[E0277]: a value of type `HashMap<String,\
    \ isize>` cannot be built from an iterator over elements of type `(char, _)`\n\
    \    --> /tmp/tmp7ecl7x38.rs:18:24\n     |\n18   |     counts.into_iter().collect::<HashMap<String,\
    \ isize>>()\n     |                        ^^^^^^^ value of type `HashMap<String,\
    \ isize>` cannot be built from `std::iter::Iterator<Item=(char, _)>`\n     |\n\
    \     = help: the trait `FromIterator<(char, _)>` is not implemented for `HashMap<String,\
    \ isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0277, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n\n    let mut letters = test.chars().collect::<Vec<char>>();\n\
    \    while let Some(letter) = letters.pop() {\n        let letter = &letter;\n\
    \n        if let Some(count) = histogram.entry(letter).or_insert(0) {\n      \
    \      *count += 1;\n        } else {\n            histogram.insert(letter, 1);\n\
    \        }\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp53mxhigj.rs:19:16\n   |\n\
    19 |         if let Some(count) = histogram.entry(letter).or_insert(0) {\n   |\
    \                ^^^^^^^^^^^   ------------------------------------ this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp53mxhigj.rs:26:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n26 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split(\"\
    \ \").collect::<Vec<_>>();\n    let mut current_letter = String::new();\n    letters.sort_by_key(|&a|\
    \ a.to_ascii_lowercase());\n    for letter in letters {\n        if let Some(count)\
    \ = histogram.entry(letter).or_insert(0) {\n            histogram[letter] = *count\
    \ + 1;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvyqtqrgc.rs:18:16\n   |\n\
    18 |         if let Some(count) = histogram.entry(letter).or_insert(0) {\n   |\
    \                ^^^^^^^^^^^   ------------------------------------ this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvyqtqrgc.rs:22:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n22 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n\n    for letter in test.split()\
    \ {\n        *histogram.entry(letter).or_insert(0) += 1;\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpmmq9h_wv.rs:15:24\n     |\n15   |     for letter in test.split()\
    \ {\n     |                        ^^^^^- supplied 0 arguments\n     |       \
    \                 |\n     |                        expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmmq9h_wv.rs:19:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n19 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    test.chars()\n      \
    \  .collect()\n        .filter_map(|c| {\n            histogram.entry(c.to_string()).or_insert(c.to_string().len());\n\
    \            Some(c.to_string().len())\n        })\n        .max()\n        .cloned()\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpb06oznim.rs:15:10\n\
    \   |\n15 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n15 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = String::from(test);\n    letters.trim();\n \
    \   let mut letters_counter = HashMap::new();\n\n    let mut letter = String::new();\n\
    \n    for c in letters.chars() {\n        letter = c.to_string();\n        if\
    \ let Some(&mut item) = letters_counter.entry(letter).or_insert(0) {\n       \
    \     *item += 1;\n        }\n    }\n    letters_counter\n}\n\nfn main() {\n \
    \   let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl8jr31o5.rs:21:16\n   |\n\
    21 |         if let Some(&mut item) = letters_counter.entry(letter).or_insert(0)\
    \ {\n   |                ^^^^^^^^^^^^^^^   ------------------------------------------\
    \ this expression has type `&mut {integer}`\n   |                |\n   |     \
    \           expected integer, found enum `Option`\n   |\n   = note: expected type\
    \ `{integer}`\n              found enum `Option<_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letter_counts: HashMap<String, isize> = HashMap::new();\n\
    \    for letter in test.split_whitespace() {\n        if letter_counts.contains_key(&letter)\
    \ {\n            letter_counts.entry(letter)\n                .or_insert(0) +=\
    \ 1;\n        } else {\n            letter_counts.insert(letter, 1);\n       \
    \ }\n    }\n    letter_counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<&str>` is not satisfied\n\
    \   --> /tmp/tmpknverb_i.rs:15:26\n    |\n15  |         if letter_counts.contains_key(&letter)\
    \ {\n    |                          ^^^^^^^^^^^^ the trait `Borrow<&str>` is not\
    \ implemented for `String`\n    |\n    = help: the trait `Borrow<str>` is implemented\
    \ for `String`\nnote: required by a bound in `HashMap::<K, V, S>::contains_key`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpknverb_i.rs:16:33\n   |\n16 |\
    \             letter_counts.entry(letter)\n   |                              \
    \   ^^^^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \                         |\n   |                                 expected struct\
    \ `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut isize`\n  --> /tmp/tmpknverb_i.rs:16:13\n   |\n16 |\
    \                letter_counts.entry(letter)\n   |   _____________^\n   |  |_____________|\n\
    \   | ||\n17 | ||                 .or_insert(0) += 1;\n   | ||_____________________________-____^\n\
    \   |  |_____________________________|\n   |                                cannot\
    \ use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be used on `isize`, you\
    \ can dereference `letter_counts.entry(letter)\n   |                         \
    \    .or_insert(0)`\n16 |             *letter_counts.entry(letter)\n   |     \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpknverb_i.rs:17:31\n\
    \   |\n16 | /             letter_counts.entry(letter)\n17 | |                \
    \ .or_insert(0) += 1;\n   | |                             - ^^\n   | |_____________________________|\n\
    \   |                               cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpknverb_i.rs:19:34\n   |\n19 |             letter_counts.insert(letter,\
    \ 1);\n   |                                  ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                  |\n   |      \
    \                            expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to 5 previous errors"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n    for char in test.chars().filter_map(|c|\
    \ {\n        if let Some(count) = (counts.get(&c).cloned()) {\n            (*count)\
    \ += 1;\n        } else {\n            counts.insert(c, 1);\n        }\n    })\
    \ {\n        let count = counts.entry(*char).or_insert(0);\n        (*count) +=\
    \ 1;\n    }\n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmp9zf45e7i.rs:15:30\n   |\n15 |         if let Some(count) = (counts.get(&c).cloned())\
    \ {\n   |                              ^                       ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    15 -         if let Some(count) = (counts.get(&c).cloned()) {\n15 +         if\
    \ let Some(count) = counts.get(&c).cloned() {\n   | \n\nerror[E0282]: type annotations\
    \ needed for `HashMap<K, V>`\n  --> /tmp/tmp9zf45e7i.rs:16:13\n   |\n13 |    \
    \ let mut counts = HashMap::new();\n   |         ---------- consider giving `counts`\
    \ the explicit type `HashMap<K, V>`, with the type parameters specified\n...\n\
    16 |             (*count) += 1;\n   |             ^^^^^^^^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9zf45e7i.rs:15:56\n   |\n15 |           if let Some(count)\
    \ = (counts.get(&c).cloned()) {\n   |  ________________________________________________________^\n\
    16 | |             (*count) += 1;\n17 | |         } else {\n   | |_________^ expected\
    \ enum `Option`, found `()`\n   |\n   = note:   expected enum `Option<_>`\n  \
    \         found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zf45e7i.rs:17:16\n\
    \   |\n17 |           } else {\n   |  ________________^\n18 | |             counts.insert(c,\
    \ 1);\n19 | |         }\n   | |_________^ expected enum `Option`, found `()`\n\
    \   |\n   = note:   expected enum `Option<_>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0282, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    test.split(' ').filter(|&c|\
    \ !c.is_whitespace()).collect::<Vec<&str>>().for_each(|c| {\n        histogram.insert(c,\
    \ histogram.entry(c).or_insert(0)).unwrap();\n    });\n    histogram\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_whitespace` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpidyyvlso.rs:14:36\n   |\n14 |     test.split('\
    \ ').filter(|&c| !c.is_whitespace()).collect::<Vec<&str>>().for_each(|c| {\n \
    \  |                                    ^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_ascii_whitespace`\n\nerror[E0599]: the\
    \ method `for_each` exists for struct `Vec<&str>`, but its trait bounds were not\
    \ satisfied\n   --> /tmp/tmpidyyvlso.rs:14:76\n    |\n14  |       test.split('\
    \ ').filter(|&c| !c.is_whitespace()).collect::<Vec<&str>>().for_each(|c| {\n \
    \   |                                                                        \
    \      ^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait\
    \ bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<&str>: Iterator`\n            which is required by `&mut Vec<&str>:\
    \ Iterator`\n            `[&str]: Iterator`\n            which is required by\
    \ `&mut [&str]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpidyyvlso.rs:15:29\n\
    \   |\n15 |         histogram.insert(c, histogram.entry(c).or_insert(0)).unwrap();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    15 |         histogram.insert(c, *histogram.entry(c).or_insert(0)).unwrap();\n\
    \   |                             +\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut res = HashMap::new();\n\n    for ch in test.chars() {\n\
    \        let count = res.entry(ch).or_insert(0);\n        *count += 1;\n    }\n\
    \n    res\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3hjex19w.rs:20:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n20 |     res\n   |     ^^^ expected struct `String`, found\
    \ `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n        \
    \      found struct `HashMap<char, {integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars()\n        .map(|c| c.to_string())\n        .fold(HashMap::new(),\
    \ |mut counts, c| {\n            let count = counts.get(c).unwrap_or(0);\n   \
    \         counts.entry(c).and_modify(|x| x += 1).or_insert(count);\n         \
    \   counts\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n   \
    \ assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw5wntx68.rs:16:36\n   |\n\
    16 |             let count = counts.get(c).unwrap_or(0);\n   |               \
    \                     ^\n   |                                    |\n   |     \
    \                               expected reference, found struct `String`\n  \
    \ |                                    help: consider borrowing here: `&c`\n \
    \  |\n   = note: expected reference `&_`\n                 found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw5wntx68.rs:16:49\n   |\n16 |\
    \             let count = counts.get(c).unwrap_or(0);\n   |                  \
    \                               ^\n   |                                      \
    \           |\n   |                                                 expected `&isize`,\
    \ found integer\n   |                                                 help: consider\
    \ borrowing here: `&0`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut isize`\n  --> /tmp/tmpw5wntx68.rs:17:44\n   |\n17 |\
    \             counts.entry(c).and_modify(|x| x += 1).or_insert(count);\n   | \
    \                                           -^^^^^\n   |                     \
    \                       |\n   |                                            cannot\
    \ use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be used on `isize`, you\
    \ can dereference `x`\n   |\n17 |             counts.entry(c).and_modify(|x| *x\
    \ += 1).or_insert(count);\n   |                                            +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw5wntx68.rs:17:62\n   |\n17 |\
    \             counts.entry(c).and_modify(|x| x += 1).or_insert(count);\n   | \
    \                                                             ^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |  \
    \           counts.entry(c).and_modify(|x| x += 1).or_insert(*count);\n   |  \
    \                                                            +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    for letter in test.chars()\
    \ {\n        match result.get(&letter) {\n            Some(count) => result.insert(letter.to_string(),\
    \ count + 1),\n            None => result.insert(letter.to_string(), 1),\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n\
    \   --> /tmp/tmp40wtfg7k.rs:15:22\n    |\n15  |         match result.get(&letter)\
    \ {\n    |                      ^^^ the trait `Borrow<char>` is not implemented\
    \ for `String`\n    |\n    = help: the trait `Borrow<str>` is implemented for\
    \ `String`\nnote: required by a bound in `HashMap::<K, V, S>::get`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp40wtfg7k.rs:15:9\n   |\n15 | /         match\
    \ result.get(&letter) {\n16 | |             Some(count) => result.insert(letter.to_string(),\
    \ count + 1),\n17 | |             None => result.insert(letter.to_string(), 1),\n\
    18 | |         }\n   | |         ^- help: consider using a semicolon here: `;`\n\
    \   | |_________|\n   |           expected `()`, found enum `Option`\n   |\n \
    \  = note: expected unit type `()`\n                   found enum `Option<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let letters = test.split(' ').collect::<Vec<_>>();\n    let mut\
    \ histogram = HashMap::new();\n    for l in &letters {\n        if histogram.contains_key(&l)\
    \ {\n            histogram.entry(l).or_insert(0) += 1;\n        } else {\n   \
    \         histogram.insert(l, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpj9lc7doi.rs:17:13\n   |\n17 |             histogram.entry(l).or_insert(0)\
    \ += 1;\n   |             -------------------------------^^^^^\n   |         \
    \    |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(l).or_insert(0)`\n\
    \   |\n17 |             *histogram.entry(l).or_insert(0) += 1;\n   |         \
    \    +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpj9lc7doi.rs:17:45\n\
    \   |\n17 |             histogram.entry(l).or_insert(0) += 1;\n   |          \
    \   ------------------------------- ^^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj9lc7doi.rs:22:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n22 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&&str`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&&str, {integer}>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n    for x in test.split(\" \"\
    ) {\n        let count = counts.entry(x).or_insert(0);\n        *count += 1;\n\
    \    }\n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfzbgyjfd.rs:18:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n18 |     counts\n   |     ^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<&str, {integer}>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freq = HashMap::new();\n    for letter in test.chars()\
    \ {\n        if let Some(count) = (&freq[letter] as Option<&mut usize>).cloned()\
    \ {\n            *count += 1;\n        } else {\n            freq.insert(letter,\
    \ 1);\n        }\n    }\n    freq\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpueg6e40k.rs:15:37\n   |\n\
    15 |         if let Some(count) = (&freq[letter] as Option<&mut usize>).cloned()\
    \ {\n   |                                     ^^^^^^\n   |                   \
    \                  |\n   |                                     expected reference,\
    \ found `char`\n   |                                     help: consider borrowing\
    \ here: `&letter`\n   |\n   = note: expected reference `&_`\n                \
    \   found type `char`\n\nerror[E0614]: type `usize` cannot be dereferenced\n \
    \ --> /tmp/tmpueg6e40k.rs:16:13\n   |\n16 |             *count += 1;\n   |   \
    \          ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpueg6e40k.rs:21:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n21 |     freq\n   |     ^^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<char, {integer}>`\n\nerror[E0605]: non-primitive\
    \ cast: `&{integer}` as `Option<&mut usize>`\n  --> /tmp/tmpueg6e40k.rs:15:30\n\
    \   |\n15 |         if let Some(count) = (&freq[letter] as Option<&mut usize>).cloned()\
    \ {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an\
    \ `as` expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0605, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().map(|c| {\n        let count: isize = test.chars().filter(|&x|\
    \ x == c).count();\n        (c.to_string(), count)\n    }).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqw637y2z.rs:14:28\n   |\n\
    14 |         let count: isize = test.chars().filter(|&x| x == c).count();\n  \
    \ |                    -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |                    |\n   |                    expected\
    \ due to this\n   |\nhelp: you can convert a `usize` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n14 |         let count: isize = test.chars().filter(|&x|\
    \ x == c).count().try_into().unwrap();\n   |                                 \
    \                                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test\n        .split(' ')\n        .map(|x| x.to_lowercase())\n\
    \        .collect()\n        .fold(HashMap::new(), |mut d, x| {\n            *d.entry(x).or_insert(0)\
    \ += 1;\n            d\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp5mbvyxsb.rs:16:10\n\
    \   |\n16 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n16 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    use std::collections::HashMap;\n\n    let mut letters: HashMap<String,\
    \ isize> = HashMap::new();\n    for letter in test.split(' ') {\n        let letter\
    \ = letter.to_lowercase();\n        if let Some(count) = letters.get(&letter)\
    \ {\n            letters.insert(letter, count + 1);\n        } else {\n      \
    \      letters.insert(letter, 1);\n        }\n    }\n\n    letters\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"c\": 1, \"a\": 2, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpcuo443a_.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().fold(HashMap::new(), |acc, x| {\n        if !x.is_ascii_whitespace()\
    \ {\n            acc.entry(x.to_ascii_lowercase()).or_insert(0)\n            \
    \    .into_mut()\n                .map(|count| count.checked_add(1))\n       \
    \ } else {\n            acc\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplf8ful8r.rs:15:23\n   |\n\
    15 |             acc.entry(x.to_ascii_lowercase()).or_insert(0)\n   |        \
    \               ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `char`\n\nerror[E0599]: no method named `into_mut` found for mutable reference\
    \ `&mut isize` in the current scope\n  --> /tmp/tmplf8ful8r.rs:16:18\n   |\n16\
    \ |                 .into_mut()\n   |                  ^^^^^^^^ method not found\
    \ in `&mut isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().group_by(|c| c.to_string()).count().collect()\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpj7a_x97b.rs:13:18\n   |\n13 |     test.chars().group_by(|c|\
    \ c.to_string()).count().collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters: Vec<&str> = test.split(\" \").collect();\n  \
    \  letters.sort_by(|a, b| b.cmp(a));\n    let mut counters = HashMap::new();\n\
    \    for letter in &letters {\n        counters.entry(letter).or_insert(0) as\
    \ isize += 1;\n    }\n    counters.iter().map(|(_, count)| count).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpu3w7p9q6.rs:17:54\n\
    \   |\n17 |         counters.entry(letter).or_insert(0) as isize += 1;\n   | \
    \        -------------------------------------------- ^^\n   |         |\n   |\
    \         cannot assign to this expression\n\nerror[E0277]: a value of type `HashMap<String,\
    \ isize>` cannot be built from an iterator over elements of type `&{integer}`\n\
    \    --> /tmp/tmpu3w7p9q6.rs:19:45\n     |\n19   |     counters.iter().map(|(_,\
    \ count)| count).collect()\n     |                                           \
    \  ^^^^^^^ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=&{integer}>`\n\
    \     |\n     = help: the trait `FromIterator<&{integer}>` is not implemented\
    \ for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K, V)>`\
    \ is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror[E0606]: casting `&mut {integer}` as `isize` is invalid\n  --> /tmp/tmpu3w7p9q6.rs:17:9\n\
    \   |\n17 |         counters.entry(letter).or_insert(0) as isize += 1;\n   | \
    \        -----------------------------------^^^^^^^^^\n   |         |\n   |  \
    \       cannot cast `&mut {integer}` as `isize`\n   |         help: dereference\
    \ the expression: `*counters.entry(letter).or_insert(0)`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0277,\
    \ E0606.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().fold1(HashMap::new,\n        |mut hash, e| {\n  \
    \          match hash.entry(e) {\n                Occupied(mut e) => hash[e.get_key()]\
    \ += 1,\n                Vacant(e) => hash[e] = 1,\n            }\n        }\n\
    \    )\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0531]: cannot find tuple struct or tuple variant `Occupied` in this\
    \ scope\n  --> /tmp/tmpl0esb6kr.rs:16:17\n   |\n16 |                 Occupied(mut\
    \ e) => hash[e.get_key()] += 1,\n   |                 ^^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::collections::btree_map::Entry::Occupied;\n\
    \   |\n1  | use std::collections::hash_map::Entry::Occupied;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Occupied;\n\
    \   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Vacant` in this\
    \ scope\n  --> /tmp/tmpl0esb6kr.rs:17:17\n   |\n17 |                 Vacant(e)\
    \ => hash[e] = 1,\n   |                 ^^^^^^ not found in this scope\n   |\n\
    help: consider importing one of these items\n   |\n1  | use std::collections::btree_map::Entry::Vacant;\n\
    \   |\n1  | use std::collections::hash_map::Entry::Vacant;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Vacant;\n\
    \   |\n\nerror[E0599]: no method named `fold1` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpl0esb6kr.rs:13:18\n   |\n13 |     test.chars().fold1(HashMap::new,\n\
    \   |                  ^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0531, E0599.\n\
    For more information about an error, try `rustc --explain E0531`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n\n    let mut counter = 0;\n  \
    \  for letter in test.chars().filter(|&x| x.is_alphabetic()) {\n        if let\
    \ Some(count) = map.get(&letter) {\n            *count += 1;\n        } else {\n\
    \            map.insert(letter, 1);\n            counter += 1;\n        }\n  \
    \  }\n\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfabcpxvv.rs:25:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     map\n   |     ^^^ expected struct `String`, found\
    \ `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n        \
    \      found struct `HashMap<char, {integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters: HashMap<String, isize> = HashMap::new();\n  \
    \  test.chars().for_each(|c| {\n        match letters.get(c.to_string()) {\n \
    \           Some(count) => letters.entry(c.to_string()).and_modify(|e| *e.1 +=\
    \ 1),\n            None => letters.entry(c.to_string()).and_modify(|e| *e.1 =\
    \ 0),\n        }\n    });\n    letters\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgtf1dw7.rs:15:27\n   |\n\
    15 |         match letters.get(c.to_string()) {\n   |                        \
    \   ^^^^^^^^^^^^^\n   |                           |\n   |                    \
    \       expected reference, found struct `String`\n   |                      \
    \     help: consider borrowing here: `&c.to_string()`\n   |\n   = note: expected\
    \ reference `&_`\n                 found struct `String`\n\nerror[E0609]: no field\
    \ `1` on type `&mut isize`\n  --> /tmp/tmprgtf1dw7.rs:16:75\n   |\n16 |      \
    \       Some(count) => letters.entry(c.to_string()).and_modify(|e| *e.1 += 1),\n\
    \   |                                                                        \
    \   ^\n\nerror[E0609]: no field `1` on type `&mut isize`\n  --> /tmp/tmprgtf1dw7.rs:17:68\n\
    \   |\n17 |             None => letters.entry(c.to_string()).and_modify(|e| *e.1\
    \ = 0),\n   |                                                                \
    \    ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprgtf1dw7.rs:15:9\n   |\n\
    15 | /         match letters.get(c.to_string()) {\n16 | |             Some(count)\
    \ => letters.entry(c.to_string()).and_modify(|e| *e.1 += 1),\n17 | |         \
    \    None => letters.entry(c.to_string()).and_modify(|e| *e.1 = 0),\n18 | |  \
    \       }\n   | |         ^- help: consider using a semicolon here: `;`\n   |\
    \ |_________|\n   |           expected `()`, found enum `std::collections::hash_map::Entry`\n\
    \   |\n   = note: expected unit type `()`\n                   found enum `std::collections::hash_map::Entry<'_,\
    \ String, isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.insert(letter, histogram.get(&letter) + 1);\n     \
    \   } else {\n            histogram.insert(letter, 1);\n        }\n    }\n   \
    \ histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `Option<&_>`\n  --> /tmp/tmp0h0iw_fy.rs:17:61\n\
    \   |\n17 |             histogram.insert(letter, histogram.get(&letter) + 1);\n\
    \   |                                      ---------------------- ^ - {integer}\n\
    \   |                                      |\n   |                           \
    \           Option<&_>\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split_whitespace().map(|&x| x.chars().group_by(|&b| b).count()).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpju9rh4pm.rs:13:35\n   |\n13 |     test.split_whitespace().map(|&x|\
    \ x.chars().group_by(|&b| b).count()).collect()\n   |                        \
    \           ^ doesn't have a size known at compile-time\n   |\n   = help: the\
    \ trait `Sized` is not implemented for `str`\n   = note: all local variables must\
    \ have a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\n\nerror[E0599]: no method named `group_by` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpju9rh4pm.rs:13:48\n   |\n13 |     test.split_whitespace().map(|&x|\
    \ x.chars().group_by(|&b| b).count()).collect()\n   |                        \
    \                        ^^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    use std::collections::HashMap;\n    let mut counts = HashMap::new();\n\
    \    for c in test.chars().count() {\n        if counts.contains_key(&c) {\n \
    \           counts.entry(c).and_modify(|e| *e += 1);\n        } else {\n     \
    \       counts.insert(c, 1);\n        }\n    }\n    counts\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmpd2vd87xt.rs:13:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n13 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0277]: `usize` is not an iterator\n  --> /tmp/tmpd2vd87xt.rs:15:14\n\
    \   |\n15 |     for c in test.chars().count() {\n   |              ^^^^^^^^^^^^^^^^^^^^\
    \ `usize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counter = HashMap::new();\n    let mut words = test.split('\
    \ ').collect::<Vec<_>>();\n    for word in words {\n        counter.entry(word.clone()).or_default().value\
    \ += 1;\n    }\n    counter // HashMap\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `HashMap<&str, V>`\n  --> /tmp/tmp866h02sz.rs:16:37\n\
    \   |\n13 |     let mut counter = HashMap::new();\n   |         ----------- consider\
    \ giving `counter` the explicit type `HashMap<_, V>`, where the type parameter\
    \ `V` is specified\n...\n16 |         counter.entry(word.clone()).or_default().value\
    \ += 1;\n   |                                     ^^^^^^^^^^ cannot infer type\
    \ for type parameter `V`\n   |\n   = note: type must be known at this point\n\n\
    error[E0609]: no field `value` on type `&mut _`\n  --> /tmp/tmp866h02sz.rs:16:50\n\
    \   |\n16 |         counter.entry(word.clone()).or_default().value += 1;\n   |\
    \                                                  ^^^^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0609.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counter = HashMap::new();\n    let mut tokens = test.split_whitespace();\n\
    \    for token in tokens {\n        counter.entry(token).or_insert(0) += 1;\n\
    \    }\n    counter\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp_0vfc15o.rs:16:9\n   |\n16 |         counter.entry(token).or_insert(0)\
    \ += 1;\n   |         ---------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `counter.entry(token).or_insert(0)`\n\
    \   |\n16 |         *counter.entry(token).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp_0vfc15o.rs:16:43\n\
    \   |\n16 |         counter.entry(token).or_insert(0) += 1;\n   |         ---------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_0vfc15o.rs:18:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n18 |     counter\n\
    \   |     ^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for letter in test.split()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.insert(letter,\
    \ histogram.get(&letter) + 1);\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpojp8mwsl.rs:14:24\n     |\n14   |     for letter in test.split()\
    \ {\n     |                        ^^^^^- supplied 0 arguments\n     |       \
    \                 |\n     |                        expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<&_>`\n  --> /tmp/tmpojp8mwsl.rs:16:61\n   |\n16 |             histogram.insert(letter,\
    \ histogram.get(&letter) + 1);\n   |                                      ----------------------\
    \ ^ - {integer}\n   |                                      |\n   |           \
    \                           Option<&_>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpojp8mwsl.rs:21:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n21 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histo = HashMap::new();\n    let mut chars: Vec<&str>\
    \ = test.split(\" \").collect();\n\n    for char in chars.iter() {\n        histo\n\
    \            .entry(char.to_string())\n            .or_insert(0)\n           \
    \ .inc();\n    }\n\n    histo\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `inc` found for mutable reference `&mut {integer}`\
    \ in the current scope\n  --> /tmp/tmp647gqphw.rs:20:14\n   |\n20 |          \
    \   .inc();\n   |              ^^^ method not found in `&mut {integer}`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars()\n        .group_by(|c| c.to_ascii_lowercase())\n\
    \        .into_iter()\n        .filter_map(|(letter, count)| {\n            count\
    \ > 1\n                ? Some((letter, count))\n                : None\n     \
    \   })\n        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `Some`\n\
    \  --> /tmp/tmplp2ep6br.rs:18:19\n   |\n18 |                 ? Some((letter, count))\n\
    \   |                   ^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0599]: no method named `group_by` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmplp2ep6br.rs:14:10\n   |\n14 |         .group_by(|c| c.to_ascii_lowercase())\n\
    \   |          ^^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n\
    \    for ch in test.chars().flat_map(|c| c as char) {\n        let count = histogram.entry(ch).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `char` is not an iterator\n    --> /tmp/tmpudq23uag.rs:14:37\n\
    \     |\n14   |     for ch in test.chars().flat_map(|c| c as char) {\n     | \
    \                           -------- ^^^^^^^^^^^^^ `char` is not an iterator\n\
    \     |                            |\n     |                            required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Iterator`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `char`\nnote: required by a bound in `flat_map`\n\
    \nerror[E0277]: `char` is not an iterator\n  --> /tmp/tmpudq23uag.rs:14:15\n \
    \  |\n14 |     for ch in test.chars().flat_map(|c| c as char) {\n   |        \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `char` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `char`\nnote:\
    \ required by a bound in `FlatMap`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    use std::collections::HashMap;\n\n    let mut char_count = HashMap::new();\n\
    \    for ch in test.chars() {\n        char_count.entry(ch).or_insert(0) += 1;\n\
    \    }\n\n    char_count\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmpfb8ily9a.rs:13:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n13 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmpfb8ily9a.rs:17:9\n   |\n17 |       \
    \  char_count.entry(ch).or_insert(0) += 1;\n   |         ---------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `char_count.entry(ch).or_insert(0)`\n\
    \   |\n17 |         *char_count.entry(ch).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpfb8ily9a.rs:17:43\n\
    \   |\n17 |         char_count.entry(ch).or_insert(0) += 1;\n   |         ---------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfb8ily9a.rs:20:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n20 |     char_count\n\
    \   |     ^^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<char,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0067, E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    for (letters, count) in test\n\
    \        .chars()\n        .group_by()\n        .map(|(_, group)| *group.len())\n\
    \        .max_by_key(|count| count)\n    {\n        map.insert(letters, count);\n\
    \    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpanfx309s.rs:16:10\n   |\n16 |         .group_by()\n\
    \   |          ^^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    use std::collections::HashMap;\n\n    // Split on spaces so that\
    \ we get ['a', 'b', 'c', 'a', 'b']\n    let mut split = test.chars().collect::<Vec<_>>();\n\
    \    split.truncate(test.len());\n\n    // Sort the letters so that we get ['a',\
    \ 'b', 'c', 'a']\n    split.sort_by_key(|&x| x.cmp(&x[0]));\n\n    // Map a letter\
    \ onto its occurrence count and build the resulting dictionary\n    let mut occurrences\
    \ = HashMap::new();\n    for i in split.iter() {\n        occurrences.entry(*i).or_insert(0)\
    \ += 1;\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmpeg4kzze9.rs:13:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n13 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0608]: cannot index into a value of type `char`\n  -->\
    \ /tmp/tmpeg4kzze9.rs:20:35\n   |\n20 |     split.sort_by_key(|&x| x.cmp(&x[0]));\n\
    \   |                                   ^^^^\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpeg4kzze9.rs:25:9\n\
    \   |\n25 |         occurrences.entry(*i).or_insert(0) += 1;\n   |         ----------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `occurrences.entry(*i).or_insert(0)`\n\
    \   |\n25 |         *occurrences.entry(*i).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpeg4kzze9.rs:25:44\n\
    \   |\n25 |         occurrences.entry(*i).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeg4kzze9.rs:27:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n27 |     occurrences\n\
    \   |     ^^^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<char,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0067, E0308, E0368, E0608.\nFor more\
    \ information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    let mut words = test\n\
    \        .split(' ')\n        .map(|c| c.to_string())\n        .collect::<Vec<_>>();\n\
    \    let mut current_letter = None;\n    let mut max_count = 1;\n    loop {\n\
    \        if let Some(letter) = words.pop() {\n            if let Some(count) =\
    \ histogram.get(&letter) {\n                if count > max_count {\n         \
    \           max_count = count;\n                }\n            } else {\n    \
    \            histogram.insert(letter, 1);\n            }\n        }\n        if\
    \ !words.is_empty() {\n            if let Some(letter) = words.pop() {\n     \
    \           if let Some(count) = histogram.get(&letter) {\n                  \
    \  if count > max_count {\n                        max_count = count;\n      \
    \              }\n                } else {\n                    histogram.insert(letter,\
    \ 1);\n                }\n            } else {\n                break;\n     \
    \       }\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&_` with `{integer}`\n  --> /tmp/tmpkbn5xamt.rs:23:26\n\
    \   |\n23 |                 if count > max_count {\n   |                     \
    \     ^ no implementation for `&_ < {integer}` and `&_ > {integer}`\n   |\n  \
    \ = help: the trait `PartialOrd<{integer}>` is not implemented for `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkbn5xamt.rs:24:33\n   |\n19 |     let mut max_count\
    \ = 1;\n   |                         - expected due to this value\n...\n24 | \
    \                    max_count = count;\n   |                                \
    \ ^^^^^ expected integer, found reference\n   |\n   = note:   expected type `{integer}`\n\
    \           found reference `&_`\nhelp: consider dereferencing the borrow\n  \
    \ |\n24 |                     max_count = *count;\n   |                      \
    \           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkbn5xamt.rs:33:32\n\
    \   |\n33 |                     if count > max_count {\n   |                 \
    \               ^^^^^^^^^\n   |                                |\n   |       \
    \                         expected reference, found integer\n   |            \
    \                    help: consider borrowing here: `&max_count`\n   |\n   = note:\
    \ expected reference `&_`\n                   found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkbn5xamt.rs:34:37\n   |\n19 |     let mut max_count\
    \ = 1;\n   |                         - expected due to this value\n...\n34 | \
    \                        max_count = count;\n   |                            \
    \         ^^^^^ expected integer, found `&{integer}`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                         max_count = *count;\n   |   \
    \                                  +\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars()\n        .map(|c| c.to_ascii_lowercase())\n     \
    \   .collect()\n        .fold(HashMap::new(), |acc, e| {\n            let mut\
    \ current_count = acc.entry(e).or_insert(0);\n            *current_count += 1;\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp9c1v83cf.rs:15:10\n\
    \   |\n15 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n15 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n\n    for c in test.chars()\
    \ {\n        histogram.entry(c.to_string()).or_insert(0usize).inc();\n    }\n\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `inc` found for mutable reference `&mut usize`\
    \ in the current scope\n  --> /tmp/tmpdk69zkdr.rs:16:58\n   |\n16 |         histogram.entry(c.to_string()).or_insert(0usize).inc();\n\
    \   |                                                          ^^^ method not\
    \ found in `&mut usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdk69zkdr.rs:19:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n19 |     histogram\n   |     ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n\
    \              found struct `HashMap<_, usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for c in test.chars()\
    \ {\n        let count = histogram.entry(c.to_string()).or_insert(0);\n      \
    \  *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"b\": 2, \"a\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp2uye2dz_.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.split_whitespace().collect::<Vec<_>>();\n\
    \    let mut letters_map = HashMap::new();\n    for &l in letters {\n        letters_map.entry(l.to_string()).or_insert(0)\
    \ as usize + 1;\n    }\n    letters_map\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp305zzmdh.rs:15:10\n   |\n15 |     for &l in letters {\n\
    \   |          ^ doesn't have a size known at compile-time\n   |\n   = help: the\
    \ trait `Sized` is not implemented for `str`\n   = note: all local variables must\
    \ have a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\n\nerror[E0606]: casting `&mut isize` as `usize` is invalid\n  --> /tmp/tmp305zzmdh.rs:16:9\n\
    \   |\n16 |         letters_map.entry(l.to_string()).or_insert(0) as usize + 1;\n\
    \   |         ---------------------------------------------^^^^^^^^^\n   |   \
    \      |\n   |         cannot cast `&mut isize` as `usize`\n   |         help:\
    \ dereference the expression: `*letters_map.entry(l.to_string()).or_insert(0)`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0606.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars()\n        .flat_map(|c| {\n            test.chars().map(|x|\
    \ (c, x))\n        })\n        .group_by(|(_, c), _| c)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmp_qxwste6.rs:17:10\n   |\n17 |         .group_by(|(_,\
    \ c), _| c)\n   |          ^^^^^^^^ method not found in `FlatMap<Chars<'_>, Map<Chars<'_>,\
    \ [closure@/tmp/tmp_qxwste6.rs:15:30: 15:40]>, [closure@/tmp/tmp_qxwste6.rs:14:19:\
    \ 16:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut count_map: HashMap<String, isize> = HashMap::new();\n\
    \    let mut words = test.split_whitespace();\n    for word in words.iter() {\n\
    \        if !count_map.contains_key(word) {\n            count_map.insert(word,\
    \ 1);\n        } else {\n            let count = count_map.entry(word).or_insert(0);\n\
    \            *count += 1;\n        }\n    }\n    let mut max_count = 0;\n    let\
    \ mut max_key = String::new();\n    for (word, count) in count_map.iter().take(count_map.len()\
    \ - 1).cloned() {\n        if *count > max_count {\n            max_count = *count;\n\
    \            max_key = word.clone();\n        }\n    }\n    let mut histogram\
    \ = HashMap::new();\n    for (word, count) in count_map.iter().cloned() {\n  \
    \      if *count == max_count {\n            histogram.insert(word, *count);\n\
    \        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpqkp4zsxk.rs:15:23\n   |\n15 |     for word\
    \ in words.iter() {\n   |                       ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqkp4zsxk.rs:17:30\n   |\n17 |\
    \             count_map.insert(word, 1);\n   |                              ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \            |\n   |                              expected struct `String`, found\
    \ reference\n   |\n   = note: expected struct `String`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkp4zsxk.rs:19:41\n  \
    \ |\n19 |             let count = count_map.entry(word).or_insert(0);\n   |  \
    \                                       ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                                         |\n   |       \
    \                                  expected struct `String`, found reference\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0271]: type mismatch resolving `<std::iter::Take<std::collections::hash_map::Iter<'_,\
    \ String, isize>> as Iterator>::Item == &_`\n    --> /tmp/tmpqkp4zsxk.rs:25:69\n\
    \     |\n25   |     for (word, count) in count_map.iter().take(count_map.len()\
    \ - 1).cloned() {\n     |                                                    \
    \                 ^^^^^^ expected reference, found tuple\n     |\n     = note:\
    \ expected reference `&_`\n                    found tuple `(&String, &isize)`\n\
    note: required by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving\
    \ `<std::iter::Take<std::collections::hash_map::Iter<'_, String, isize>> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpqkp4zsxk.rs:25:26\n   |\n25 |     for (word, count) in\
    \ count_map.iter().take(count_map.len() - 1).cloned() {\n   |                \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple,\
    \ found reference\n   |\n   = note:  expected tuple `(&String, &isize)`\n    \
    \       found reference `&_`\n   = not"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for letter in test.chars()\
    \ {\n        let count = (histogram.entry(letter).or_insert(0));\n        *count\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpq22zzars.rs:15:21\n\
    \   |\n15 |         let count = (histogram.entry(letter).or_insert(0));\n   |\
    \                     ^                                    ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    15 -         let count = (histogram.entry(letter).or_insert(0));\n15 +       \
    \  let count = histogram.entry(letter).or_insert(0);\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq22zzars.rs:18:5\n   |\n12 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n18 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = HashMap::new();\n    for letter in test.chars().cloned()\
    \ {\n        match letters.get(&letter) {\n            Some(count) => letters.insert(letter,\
    \ count + 1),\n            None => letters.insert(letter, 1)\n        }\n    }\n\
    \    letters\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpx0ofzetu.rs:14:32\n     |\n14   |     for letter in test.chars().cloned()\
    \ {\n     |                                ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpx0ofzetu.rs:14:19\n\
    \   |\n14 |     for letter in test.chars().cloned() {\n   |                  \
    \ ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpx0ofzetu.rs:14:19\n   |\n14 |     for letter in test.chars().cloned()\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx0ofzetu.rs:15:9\n   |\n15 | /\
    \         match letters.get(&letter) {\n16 | |             Some(count) => letters.insert(letter,\
    \ count + 1),\n17 | |             None => letters.insert(letter, 1)\n18 | |  \
    \       }\n   | |         ^- help: consider using a semicolon here: `;`\n   |\
    \ |_________|\n   |           expected `()`, found enum `Option`\n   |\n   = note:\
    \ expected unit type `()`\n                   found enum `Option<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        freqs.entry(letter).or_insert(0) += 1;\n    }\n  \
    \  freqs\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpq6kbr840.rs:15:9\n   |\n15 |         freqs.entry(letter).or_insert(0)\
    \ += 1;\n   |         --------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `freqs.entry(letter).or_insert(0)`\n\
    \   |\n15 |         *freqs.entry(letter).or_insert(0) += 1;\n   |         +\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpq6kbr840.rs:15:42\n\
    \   |\n15 |         freqs.entry(letter).or_insert(0) += 1;\n   |         --------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counter = HashMap::new();\n\n    for letter in test.chars().collect::<String>().iter()\
    \ {\n        counter.entry(letter).or_insert(0) += 1;\n    }\n    counter\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp533f0fjj.rs:15:52\n   |\n15 |     for letter in test.chars().collect::<String>().iter()\
    \ {\n   |                                                    ^^^^ method not found\
    \ in `String`\n   |\nhelp: because of the in-memory representation of `&str`,\
    \ to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n\
    15 |     for letter in test.chars().collect::<String>().chars() {\n   |      \
    \                                              ~~~~~\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmp533f0fjj.rs:16:9\n\
    \   |\n16 |         counter.entry(letter).or_insert(0) += 1;\n   |         ----------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `counter.entry(letter).or_insert(0)`\n\
    \   |\n16 |         *counter.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp533f0fjj.rs:16:44\n\
    \   |\n16 |         counter.entry(letter).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = String::new();\n    for c in test.chars() {\n\
    \        if let Some(c) = c.to_lowercase() {\n            letters.push(c);\n \
    \       }\n    }\n    let mut occurrences = HashMap::new();\n    for letter in\
    \ letters.chars().skip_while(|&x| !x.is_whitespace()) {\n        occurrences.entry(letter).and_modify(|count|\
    \ {\n            *count += 1;\n        }).or_insert(0);\n    }\n    occurrences\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmsgl6890.rs:15:16\n   |\n\
    15 |         if let Some(c) = c.to_lowercase() {\n   |                ^^^^^^^\
    \   ---------------- this expression has type `ToLowercase`\n   |            \
    \    |\n   |                expected struct `ToLowercase`, found enum `Option`\n\
    \   |\n   = note: expected struct `ToLowercase`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmsgl6890.rs:25:5\n   |\n12 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     occurrences\n   |     ^^^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut char_count = HashMap::new();\n    for char in test.chars()\
    \ {\n        char_count.entry(char).or_insert(0)\n    }\n    char_count\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvf6j6x2t.rs:15:9\n   |\n\
    15 |         char_count.entry(char).or_insert(0)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: consider using a semicolon here: `;`\n   |         |\n   |         expected\
    \ `()`, found `&mut {integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvf6j6x2t.rs:17:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n17 |     char_count\n   |     ^^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut res = HashMap::new();\n\n    test.split(|c| match c {\n\
    \        'a' => {\n            res.insert(c.to_string(), res.entry(c.to_string()).or_insert(0));\n\
    \        }\n        _ => (),\n    })\n    .filter(|&c| !c.is_whitespace())\n \
    \   .sort_by_key(|c| c.to_string().len() as isize)\n    .for_each(|c| {\n    \
    \    res.entry(c).and_modify(|v| *v += 1);\n    });\n\n    res\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoemo4rp4.rs:17:39\n   |\n\
    17 |             res.insert(c.to_string(), res.entry(c.to_string()).or_insert(0));\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             res.insert(c.to_string(), *res.entry(c.to_string()).or_insert(0));\n\
    \   |                                       +\n\nerror[E0271]: type mismatch resolving\
    \ `<[closure@/tmp/tmpoemo4rp4.rs:15:16: 20:6] as FnOnce<(char,)>>::Output == bool`\n\
    \    --> /tmp/tmpoemo4rp4.rs:15:10\n     |\n15   |     test.split(|c| match c\
    \ {\n     |          ^^^^^ expected `bool`, found `()`\n     |\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `[closure@/tmp/tmpoemo4rp4.rs:15:16:\
    \ 20:6]`\nnote: required by a bound in `core::str::<impl str>::split`\n\nerror[E0599]:\
    \ the method `filter` exists for struct `std::str::Split<'_, [closure@/tmp/tmpoemo4rp4.rs:15:16:\
    \ 20:6]>`, but its trait bounds were not satisfied\n   --> /tmp/tmpoemo4rp4.rs:21:6\n\
    \    |\n15  |       test.split(|c| match c {\n    |                  -----------\
    \ doesn't satisfy `_: Pattern<'_>`\n...\n21  |       .filter(|&c| !c.is_whitespace())\n\
    \    |        ^^^^^^ method cannot be called on `std::str::Split<'_, [closure@/tmp/tmpoemo4rp4.rs:15:16:\
    \ 20:6]>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `[closure@/tmp/tmpoemo4rp4.rs:15:16:\
    \ 20:6]: Pattern<'_>`\n            which is required by `std::str::Split<'_, [closure@/tmp/tmpoemo4rp4.rs:15:16:\
    \ 20:6]>: Iterator`\n            `std::str::Split<'_, [closure@/tmp/tmpoemo4rp4.rs:15:16:\
    \ 20:6]>: Iterator`\n            which is required by `&mut std::str::Split<'_,\
    \ [closure@/tmp/tmpoemo4rp4.rs:15:16: 20:6]>: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    for entry in test.split_whitespace()\
    \ {\n        map.entry(entry).or_insert(0)\n    }\n    map\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphqu89usu.rs:15:9\n   |\n\
    15 |         map.entry(entry).or_insert(0)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: consider using a semicolon here: `;`\n   |         |\n   |         expected\
    \ `()`, found `&mut {integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqu89usu.rs:17:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n17 |     map\n   |     ^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<&str, {integer}>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counters = HashMap::new();\n    let mut current_counter\
    \ = 0;\n\n    // iterate through the string and increment the counter for the\
    \ current letter\n    for (i, letter) in test.chars().enumerate() {\n        if\
    \ counters.contains_key(&letter) {\n            counters[&letter] += 1;\n    \
    \    } else {\n            counters[&letter] = 1;\n        }\n        current_counter\
    \ += counters[&letter];\n    }\n\n    counters\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n\
    \   --> /tmp/tmp_aksreuc.rs:18:21\n    |\n18  |         if counters.contains_key(&letter)\
    \ {\n    |                     ^^^^^^^^^^^^ the trait `Borrow<char>` is not implemented\
    \ for `String`\n    |\n    = help: the trait `Borrow<str>` is implemented for\
    \ `String`\nnote: required by a bound in `HashMap::<K, V, S>::contains_key`\n\n\
    error[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n  --> /tmp/tmp_aksreuc.rs:19:13\n\
    \   |\n19 |             counters[&letter] += 1;\n   |             ^^^^^^^^^^^^^^^^^\
    \ the trait `Borrow<char>` is not implemented for `String`\n   |\n   = help: the\
    \ trait `Borrow<str>` is implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `Index<&char>` for `HashMap<String, isize>`\n\
    \nerror[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n  -->\
    \ /tmp/tmp_aksreuc.rs:21:13\n   |\n21 |             counters[&letter] = 1;\n \
    \  |             ^^^^^^^^^^^^^^^^^ the trait `Borrow<char>` is not implemented\
    \ for `String`\n   |\n   = help: the trait `Borrow<str>` is implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `Index<&char>`\
    \ for `HashMap<String, isize>`\n\nerror[E0277]: the trait bound `String: Borrow<char>`\
    \ is not satisfied\n  --> /tmp/tmp_aksreuc.rs:23:28\n   |\n23 |         current_counter\
    \ += counters[&letter];\n   |                            ^^^^^^^^^^^^^^^^^ the\
    \ trait `Borrow<char>` is not implemented for `String`\n   |\n   = help: the trait\
    \ `Borrow<str>` is implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `Index<&char>` for `HashMap<String, isize>`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n    for word in test.split('\
    \ ').into_iter() {\n        let letter = &word[0];\n        let count = counts.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    counts\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpzuw9kp3y.rs:15:23\n\
    \   |\n15 |         let letter = &word[0];\n   |                       ^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `{integer}`\n   = note: you can use `.chars().nth()`\
    \ or `.bytes().nth()`\n           for more information, see chapter 8 in The Book:\
    \ <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzuw9kp3y.rs:19:5\n   |\n12 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n19 |     counts\n   |     ^^^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&_, {integer}>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut occurrences = HashMap::new();\n    let mut split = test.split_whitespace();\n\
    \    for letter in split.iter() {\n        occurrences.entry(letter).or_insert(0)\
    \ += 1;\n    }\n\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpkouh6s59.rs:15:25\n   |\n15 |     for letter\
    \ in split.iter() {\n   |                         ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmpkouh6s59.rs:16:9\n   |\n16 |         occurrences.entry(letter).or_insert(0)\
    \ += 1;\n   |         --------------------------------------^^^^^\n   |      \
    \   |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `occurrences.entry(letter).or_insert(0)`\n\
    \   |\n16 |         *occurrences.entry(letter).or_insert(0) += 1;\n   |      \
    \   +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpkouh6s59.rs:16:48\n\
    \   |\n16 |         occurrences.entry(letter).or_insert(0) += 1;\n   |       \
    \  -------------------------------------- ^^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    for letter in test.chars().flat_map(|c|\
    \ c as String).collect::<Vec<_>>() {\n        freqs.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    freqs\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n    --> /tmp/tmp6qeq7bvf.rs:14:41\n\
    \     |\n14   |     for letter in test.chars().flat_map(|c| c as String).collect::<Vec<_>>()\
    \ {\n     |                                -------- ^^^^^^^^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n     |              \
    \                  |\n     |                                required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `String`\n     = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `String`\nnote: required by a bound in `flat_map`\n\n\
    error[E0599]: the method `collect` exists for struct `FlatMap<Chars<'_>, String,\
    \ [closure@/tmp/tmp6qeq7bvf.rs:14:41: 14:56]>`, but its trait bounds were not\
    \ satisfied\n   --> /tmp/tmp6qeq7bvf.rs:14:58\n    |\n14  |       for letter in\
    \ test.chars().flat_map(|c| c as String).collect::<Vec<_>>() {\n    |        \
    \                                                    ^^^^^^^ method cannot be\
    \ called on `FlatMap<Chars<'_>, String, [closure@/tmp/tmp6qeq7bvf.rs:14:41: 14:56]>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `String: IntoIterator`\n            which is\
    \ required by `FlatMap<Chars<'_>, String, [closure@/tmp/tmp6qeq7bvf.rs:14:41:\
    \ 14:56]>: Iterator`\n            `FlatMap<Chars<'_>, String, [closure@/tmp/tmp6qeq7bvf.rs:14:41:\
    \ 14:56]>: Iterator`\n            which is required by `&mut FlatMap<Chars<'_>,\
    \ String, [closure@/tmp/tmp6qeq7bvf.rs:14:41: 14:56]>: Iterator`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmp6qeq7bvf.rs:15:9\n   |\n15 |         freqs.entry(letter).or_insert(0)\
    \ += 1;\n   |         --------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `freqs.entry(letter).or_insert(0)`\n\
    \   |\n15 |         *freqs.entry(letter).or_insert(0) += 1;\n   |         +\n\n\
    error[E0067]: inval"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    for (i, c) in test.chars().enumerate().filter_map(|(_,\
    \ c)| {\n        if c == ' ' { None } else { Some(c) }\n    }) {\n        let\
    \ count = freqs.get_mut(&c).unwrap();\n        *count += 1;\n    }\n    freqs.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy8d7ghvh.rs:14:9\n   |\n\
    14 |       for (i, c) in test.chars().enumerate().filter_map(|(_, c)| {\n   |\
    \  _________^^^^^^____-\n   | |         |\n   | |         expected `char`, found\
    \ tuple\n15 | |         if c == ' ' { None } else { Some(c) }\n16 | |     }) {\n\
    \   | |______- this expression has type `Option<char>`\n   |\n   = note: expected\
    \ type `char`\n             found tuple `(_, _)`\n\nerror[E0271]: type mismatch\
    \ resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpy8d7ghvh.rs:20:18\n     |\n20   |     freqs.iter().cloned().collect()\n\
    \     |                  ^^^^^^ expected reference, found tuple\n     |\n    \
    \ = note: expected reference `&_`\n                    found tuple `(&_, &_)`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::collections::hash_map::Iter<'_, _, _>>`, but its trait\
    \ bounds were not satisfied\n    --> /tmp/tmpy8d7ghvh.rs:20:27\n     |\n20   |\
    \       freqs.iter().cloned().collect()\n     |                             ^^^^^^^\
    \ method cannot be called on `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\
    \ due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds\
    \ were not satisfied:\n             `<std::collections::hash_map::Iter<'_, _,\
    \ _> as Iterator>::Item = &_`\n             which is required by `Cloned<std::collections::hash_map::Iter<'_,\
    \ _, _>>: Iterator`\n             `Cloned<std::collections::hash_map::Iter<'_,\
    \ _, _>>: Iterator`\n             which is required by `&mut Cloned<std::collections::hash_map::Iter<'_,\
    \ _, _>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().flat_map(|c|\n        test.chars().filter(|c| *c\
    \ == c as usize).count() as isize\n    ).collect()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhe34acw.rs:14:39\n   |\n\
    14 |         test.chars().filter(|c| *c == c as usize).count() as isize\n   |\
    \                                       ^^^^^^^^^^ expected `char`, found `usize`\n\
    \nerror[E0277]: `isize` is not an iterator\n    --> /tmp/tmplhe34acw.rs:13:27\n\
    \     |\n13   |       test.chars().flat_map(|c|\n     |  __________________--------_^\n\
    \     | |                  |\n     | |                  required by a bound introduced\
    \ by this call\n14   | |         test.chars().filter(|c| *c == c as usize).count()\
    \ as isize\n     | |__________________________________________________________________^\
    \ `isize` is not an iterator\n     |\n     = help: the trait `Iterator` is not\
    \ implemented for `isize`\n     = note: if you want to iterate between `start`\
    \ until a value `end`, use the exclusive range syntax `start..end` or the inclusive\
    \ range syntax `start..=end`\n     = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `isize`\nnote: required by a bound in `flat_map`\n\
    \nerror[E0599]: the method `collect` exists for struct `FlatMap<Chars<'_>, isize,\
    \ [closure@/tmp/tmplhe34acw.rs:13:27: 14:67]>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmplhe34acw.rs:15:7\n   |\n15 |       ).collect()\n  \
    \ |         ^^^^^^^ method cannot be called on `FlatMap<Chars<'_>, isize, [closure@/tmp/tmplhe34acw.rs:13:27:\
    \ 14:67]>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `isize: IntoIterator`\n           which\
    \ is required by `FlatMap<Chars<'_>, isize, [closure@/tmp/tmplhe34acw.rs:13:27:\
    \ 14:67]>: Iterator`\n           `FlatMap<Chars<'_>, isize, [closure@/tmp/tmplhe34acw.rs:13:27:\
    \ 14:67]>: Iterator`\n           which is required by `&mut FlatMap<Chars<'_>,\
    \ isize, [closure@/tmp/tmplhe34acw.rs:13:27: 14:67]>: Iterator`\n\nerror[E0606]:\
    \ casting `&char` as `usize` is invalid\n  --> /tmp/tmplhe34acw.rs:14:39\n   |\n\
    14 |         test.chars().filter(|c| *c == c as usize).count() as isize\n   |\
    \                                       ^^^^^^^^^^\n   |\n "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut res = HashMap::new();\n    for i in test.chars().collect::<Vec<_>>()\
    \ {\n        let count = res.entry(i).or_default().cloned();\n        res.entry(i).and_modify(|c|\
    \ { *c += 1 });\n    }\n    res\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `HashMap<char, V>`\n  --> /tmp/tmpfek5py54.rs:15:34\n\
    \   |\n13 |     let mut res = HashMap::new();\n   |         ------- consider giving\
    \ `res` the explicit type `HashMap<_, V>`, where the type parameter `V` is specified\n\
    14 |     for i in test.chars().collect::<Vec<_>>() {\n15 |         let count =\
    \ res.entry(i).or_default().cloned();\n   |                                  ^^^^^^^^^^\
    \ cannot infer type for type parameter `V`\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    for (i, item) in test.chars().enumerate()\
    \ {\n        map.entry(item)\n            .or_insert(0) // no entry for the first\
    \ item\n            .and_then(|x| {\n                // if the item already exists,\
    \ update it's count\n                let count = map.get(&item).unwrap();\n  \
    \              count += 1;\n                map.insert(item, count)\n        \
    \    });\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `and_then` found for mutable reference `&mut\
    \ {integer}` in the current scope\n  --> /tmp/tmpjhlpcilv.rs:17:14\n   |\n17 |\
    \             .and_then(|x| {\n   |              ^^^^^^^^ method not found in\
    \ `&mut {integer}`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `&{integer}`\n  --> /tmp/tmpjhlpcilv.rs:20:17\n   |\n20 |  \
    \               count += 1;\n   |                 -----^^^^^\n   |           \
    \      |\n   |                 cannot use `+=` on type `&{integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `count`\n   |\n20 |   \
    \              *count += 1;\n   |                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjhlpcilv.rs:21:34\n   |\n21 |                 map.insert(item,\
    \ count)\n   |                                  ^^^^^ expected integer, found\
    \ `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |    \
    \             map.insert(item, *count)\n   |                                 \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjhlpcilv.rs:24:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     map\n   |     ^^^ expected struct `String`, found\
    \ `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n        \
    \      found struct `HashMap<char, {integer}>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n\n    let mut chars = test.chars();\n\
    \n    while let Some(next) = chars.next() {\n        map.entry(next.to_string()).or_insert(0)\
    \ += 1;\n    }\n\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp7vb6vnlg.rs:18:9\n   |\n18 |         map.entry(next.to_string()).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `map.entry(next.to_string()).or_insert(0)`\n\
    \   |\n18 |         *map.entry(next.to_string()).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp7vb6vnlg.rs:18:50\n\
    \   |\n18 |         map.entry(next.to_string()).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().map(|c| c.to_ascii_lowercase()).collect()\n     \
    \   .fold(HashMap::new(), |mut map, char| map.entry(char).or_default() += 1)\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp91vig6j1.rs:13:50\n\
    \   |\n13 |     test.chars().map(|c| c.to_ascii_lowercase()).collect()\n   | \
    \                                                 ^^^^^^^ cannot infer type for\
    \ type parameter `B` declared on the associated function `collect`\n   |\n   =\
    \ note: type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n13 |     test.chars().map(|c| c.to_ascii_lowercase()).collect::<B>()\n\
    \   |                                                         +++++\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp91vig6j1.rs:14:76\n   |\n\
    14 |         .fold(HashMap::new(), |mut map, char| map.entry(char).or_default()\
    \ += 1)\n   |                                               ----------------------------\
    \ ^^\n   |                                               |\n   |             \
    \                                  cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0282.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split(' ')\n        .iter()\n        .map(|x| x.to_lowercase())\n\
    \        .map(|x| x.to_string())\n        .fold(HashMap::new(), |mut acc, x| {\n\
    \            acc.entry(x).or_insert(0) += 1;\n            acc\n        })\n  \
    \      .cloned()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmplj3_k6y4.rs:14:10\n   |\n14 |         .iter()\n\
    \   |          ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmplj3_k6y4.rs:18:39\n   |\n\
    18 |             acc.entry(x).or_insert(0) += 1;\n   |             -------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0599.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars()\n        .filter_map(|c| c.is_whitespace())\n   \
    \     .filter(|c| !c.is_ascii_lowercase())\n        .filter_map(|c| c.is_ascii_lowercase())\n\
    \        .fold(HashMap::new(), |mut map, c| {\n            *map.entry(c).or_insert(0)\
    \ += 1;\n            map\n        })\n        .collect()\n}\n\nfn main() {\n \
    \   let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkvq8r1u.rs:14:25\n   |\n\
    14 |         .filter_map(|c| c.is_whitespace())\n   |                        \
    \ ^^^^^^^^^^^^^^^^^ expected enum `Option`, found `bool`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `bool`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n14 |         .filter_map(|c| Some(c.is_whitespace()))\n   |\
    \                         +++++                 +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    let mut words = test\n\
    \        .split_whitespace()\n        .flat_map(|c| c.chars().collect::<Vec<char>>())\n\
    \        .collect::<Vec<char>>();\n\n    let mut counts = vec![];\n    words.into_iter().for_each(|c|\
    \ {\n        counts.push(*histogram.get(&c).unwrap_or(0));\n        histogram.insert(c,\
    \ 0);\n    });\n\n    while let Some(count) = counts.iter().max() {\n        let\
    \ (letter, count) = counts.iter().max_by_key(|c| c).unwrap();\n        let mut\
    \ iter = histogram.iter();\n        iter.for_each(|(_, count)| {\n           \
    \ if count > count {\n                let _ = iter.remove_by_key(&letter);\n \
    \           }\n        });\n        histogram.remove(&letter);\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9_va697t.rs:21:50\n   |\n\
    21 |         counts.push(*histogram.get(&c).unwrap_or(0));\n   |             \
    \                                     ^\n   |                                \
    \                  |\n   |                                                  expected\
    \ reference, found integer\n   |                                             \
    \     help: consider borrowing here: `&0`\n   |\n   = note: expected reference\
    \ `&_`\n                   found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9_va697t.rs:26:13\n   |\n26 |         let (letter, count)\
    \ = counts.iter().max_by_key(|c| c).unwrap();\n   |             ^^^^^^^^^^^^^^^\
    \   ---------------------------------------- this expression has type `&{integer}`\n\
    \   |             |\n   |             expected integer, found tuple\n   |\n  \
    \ = note: expected type `{integer}`\n             found tuple `(_, _)`\n\nerror[E0599]:\
    \ no method named `remove_by_key` found for struct `std::collections::hash_map::Iter`\
    \ in the current scope\n  --> /tmp/tmp9_va697t.rs:30:30\n   |\n30 |          \
    \       let _ = iter.remove_by_key(&letter);\n   |                           \
    \   ^^^^^^^^^^^^^ method not found in `std::collections::hash_map::Iter<'_, char,\
    \ {integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_va697t.rs:36:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n36 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().map(|c| c.to_string()).collect()\n        .group_by(|c|\
    \ c.to_string()).into_iter()\n        .fold(HashMap::new(), |mut acc, (letter,\
    \ count)| {\n            acc.entry(letter).or_insert(count).clone() += count;\n\
    \            acc\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp5a7hmeb6.rs:13:41\n\
    \   |\n13 |     test.chars().map(|c| c.to_string()).collect()\n   |          \
    \                               ^^^^^^^ cannot infer type for type parameter `B`\
    \ declared on the associated function `collect`\n   |\n   = note: type must be\
    \ known at this point\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n13 |     test.chars().map(|c| c.to_string()).collect::<B>()\n  \
    \ |                                                +++++\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmp5a7hmeb6.rs:16:56\n   |\n16 |  \
    \           acc.entry(letter).or_insert(count).clone() += count;\n   |       \
    \      ------------------------------------------ ^^\n   |             |\n   |\
    \             cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0282.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    let mut words = test.split(\"\
    \ \").collect::<Vec<_>>();\n    let mut counter = 1;\n    for word in words {\n\
    \        histogram.insert(word, counter);\n        counter = counter + 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qzily6z.rs:20:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n20 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // Split into words and remove duplicate words.\n    let words\
    \ = test.split(\" \").collect();\n    let mut letters = HashMap::new();\n    let\
    \ mut frequency = isize::zero();\n    for w in words {\n        if let Some(count)\
    \ = letters.get(&w) {\n            *count += 1;\n        } else {\n          \
    \  letters.insert(w, 1);\n            frequency = *frequency + 1;\n        }\n\
    \    }\n    letters\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `zero` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpova6g4li.rs:16:32\n   |\n16 |  \
    \   let mut frequency = isize::zero();\n   |                                ^^^^\
    \ function or associated item not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n    let mut result = HashMap::new();\n\
    \n    for i in test.chars() {\n        let count = counts.entry(i).or_insert(0);\n\
    \        *count += 1;\n        result.insert(i.to_string(), *count);\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpmramjtx4.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n\
    \    test.split(\" \").iter().cloned().for_each(|letter| {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.get_mut(&letter).unwrap() += 1;\n        } else {\n\
    \            histogram.insert(&letter, 1);\n        }\n    });\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpsua8s7ux.rs:14:21\n   |\n14 |     test.split(\"\
    \ \").iter().cloned().for_each(|letter| {\n   |                     ^^^^ method\
    \ not found in `std::str::Split<'_, &str>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut isize`\n  --> /tmp/tmpsua8s7ux.rs:16:13\n\
    \   |\n16 |             histogram.get_mut(&letter).unwrap() += 1;\n   |      \
    \       -----------------------------------^^^^^\n   |             |\n   |   \
    \          cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be used\
    \ on `isize`, you can dereference `histogram.get_mut(&letter).unwrap()`\n   |\n\
    16 |             *histogram.get_mut(&letter).unwrap() += 1;\n   |            \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpsua8s7ux.rs:16:49\n\
    \   |\n16 |             histogram.get_mut(&letter).unwrap() += 1;\n   |      \
    \       ----------------------------------- ^^\n   |             |\n   |     \
    \        cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsua8s7ux.rs:18:30\n   |\n18 |             histogram.insert(&letter,\
    \ 1);\n   |                              ^^^^^^^ expected struct `String`, found\
    \ reference\n   |\n   = note: expected struct `String`\n           found reference\
    \ `&_`\nhelp: consider removing the borrow\n   |\n18 -             histogram.insert(&letter,\
    \ 1);\n18 +             histogram.insert(letter, 1);\n   | \n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n\n    for i in test.chars().flat_map(|c|\
    \ c as char).collect::<Vec<String>>() {\n        if let Some(count) = map.get(i)\
    \ {\n            *count += 1;\n        } else {\n            map.insert(*i, 1);\n\
    \        }\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `char` is not an iterator\n    --> /tmp/tmpjjla0z03.rs:15:36\n\
    \     |\n15   |     for i in test.chars().flat_map(|c| c as char).collect::<Vec<String>>()\
    \ {\n     |                           -------- ^^^^^^^^^^^^^ `char` is not an\
    \ iterator\n     |                           |\n     |                       \
    \    required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Iterator` is not implemented for `char`\n     = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `char`\nnote: required by a bound\
    \ in `flat_map`\n\nerror[E0599]: the method `collect` exists for struct `FlatMap<Chars<'_>,\
    \ char, [closure@/tmp/tmpjjla0z03.rs:15:36: 15:49]>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpjjla0z03.rs:15:51\n   |\n15 |       for i in test.chars().flat_map(|c|\
    \ c as char).collect::<Vec<String>>() {\n   |                                \
    \                     ^^^^^^^ method cannot be called on `FlatMap<Chars<'_>, char,\
    \ [closure@/tmp/tmpjjla0z03.rs:15:36: 15:49]>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ IntoIterator`\n           which is required by `FlatMap<Chars<'_>, char, [closure@/tmp/tmpjjla0z03.rs:15:36:\
    \ 15:49]>: Iterator`\n           `FlatMap<Chars<'_>, char, [closure@/tmp/tmpjjla0z03.rs:15:36:\
    \ 15:49]>: Iterator`\n           which is required by `&mut FlatMap<Chars<'_>,\
    \ char, [closure@/tmp/tmpjjla0z03.rs:15:36: 15:49]>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut char_counts = HashMap::new();\n    for c in test.chars()\
    \ {\n        if !char_counts.contains_key(&c) {\n            char_counts.insert(c,\
    \ 0);\n        } else {\n            char_counts.entry(&c)\n                .or_insert(0)\
    \ += 1;\n        }\n    }\n    char_counts\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3wtgb7eb.rs:18:31\n   |\n\
    18 |             char_counts.entry(&c)\n   |                               ^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider removing the borrow\n \
    \  |\n18 -             char_counts.entry(&c)\n18 +             char_counts.entry(c)\n\
    \   | \n\nerror[E0368]: binary assignment operation `+=` cannot be applied to\
    \ type `&mut {integer}`\n  --> /tmp/tmp3wtgb7eb.rs:18:13\n   |\n18 |         \
    \       char_counts.entry(&c)\n   |   _____________^\n   |  |_____________|\n\
    \   | ||\n19 | ||                 .or_insert(0) += 1;\n   | ||_____________________________-____^\n\
    \   |  |_____________________________|\n   |                                cannot\
    \ use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used on `{integer}`,\
    \ you can dereference `char_counts.entry(&c)\n   |                           \
    \  .or_insert(0)`\n18 |             *char_counts.entry(&c)\n   |             +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp3wtgb7eb.rs:19:31\n\
    \   |\n18 | /             char_counts.entry(&c)\n19 | |                 .or_insert(0)\
    \ += 1;\n   | |                             - ^^\n   | |_____________________________|\n\
    \   |                               cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3wtgb7eb.rs:22:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n22 |     char_counts\n\
    \   |     ^^^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<char,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    let mut splitter = String::new();\n\
    \    for c in test.chars() {\n        histogram.insert(c.to_string(), histogram.entry(c).or_insert(0)\
    \ +);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpadn7igqj.rs:16:74\n\
    \   |\n16 |         histogram.insert(c.to_string(), histogram.entry(c).or_insert(0)\
    \ +);\n   |                                                                  \
    \        ^ expected expression\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n\n    for c in test.chars()\
    \ {\n        let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n\
    \    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr5f1oenj.rs:20:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n20 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map: HashMap<String, isize> = HashMap::new();\n    for\
    \ (ch) in test.chars().sorted() {\n        if let Some(i) = (map.entry(ch).or_insert(0))\
    \ {\n            *i += 1;\n        }\n    }\n    map\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around pattern\n  --> /tmp/tmpw3ufbz2d.rs:14:9\n\
    \   |\n14 |     for (ch) in test.chars().sorted() {\n   |         ^  ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n14 -     for (ch) in test.chars().sorted() {\n14 +     for ch in test.chars().sorted()\
    \ {\n   | \n\nwarning: unnecessary parentheses around `let` scrutinee expression\n\
    \  --> /tmp/tmpw3ufbz2d.rs:15:26\n   |\n15 |         if let Some(i) = (map.entry(ch).or_insert(0))\
    \ {\n   |                          ^                          ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n15 -         if let Some(i) = (map.entry(ch).or_insert(0))\
    \ {\n15 +         if let Some(i) = map.entry(ch).or_insert(0) {\n   | \n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpw3ufbz2d.rs:14:30\n   |\n14 |     for (ch) in test.chars().sorted()\
    \ {\n   |                              ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw3ufbz2d.rs:15:16\n   |\n15 |\
    \         if let Some(i) = (map.entry(ch).or_insert(0)) {\n   |              \
    \  ^^^^^^^   ---------------------------- this expression has type `&mut isize`\n\
    \   |                |\n   |                expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counter = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<String>>() {\n        counter.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpa52ieh0n.rs:15:9\n   |\n15 |         counter.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `counter.entry(letter).or_insert(0)`\n\
    \   |\n15 |         *counter.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpa52ieh0n.rs:15:44\n\
    \   |\n15 |         counter.entry(letter).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    let mut words = test\n\
    \        .split_whitespace()\n        .map(|w| w.to_lowercase())\n        .collect::<Vec<_>>();\n\
    \    for word in words {\n        if histogram.contains_key(&word) {\n       \
    \     histogram.get_mut(&word)->inc(1);\n        } else {\n            histogram.insert(word.to_string(),\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `->`\n\
    \  --> /tmp/tmp_y7wrmwe.rs:20:37\n   |\n20 |             histogram.get_mut(&word)->inc(1);\n\
    \   |                                     ^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for c in test.chars().map(|c|\
    \ c.to_string()) {\n        if histogram.contains_key(&c.to_string()) {\n    \
    \        histogram.entry(c.to_string()).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(c.to_string(), 1);\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpog13o_4m.rs:16:13\n   |\n16 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             -------------------------------------------^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n16 |             *histogram.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpog13o_4m.rs:16:57\n   |\n16 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test\n        .chars()\n        .filter(|c|\
    \ c.is_ascii_lowercase())\n        .collect::<Vec<_>>()\n        .join(\" \");\n\
    \n    // count how many times each letter appears in the test\n    let mut counts\
    \ = letters.chars().map(|c| c.to_ascii_lowercase()).count();\n\n    // sort the\
    \ letters by how many times they appear in the test\n    let mut sorted_counts\
    \ = counts.sort_by(|a, b| b.cmp(&a));\n\n    // for each letter that appears more\
    \ than once in the test, remove it from the\n    // hashmap and decrement the\
    \ count in the map\n    for i in sorted_counts.iter().take_while(|&(_, count)|\
    \ count > 1) {\n        let mut j = sorted_counts.binary_search(|&(_, count)|\
    \ count < 1);\n        if j < 0 {\n            // found a letter that appears\
    \ only once, remove it from the hashmap\n            counts.remove(&i);\n    \
    \    } else {\n            // found a letter that appears more than once in the\
    \ test, remove the\n            // most frequently occurring letter and decrement\
    \ its count\n            counts.remove(&sorted_counts[j]);\n            sorted_counts[j]\
    \ = (i.to_ascii_lowercase(), sorted_counts[j].1() - 1);\n        }\n    }\n\n\
    \    // put the letters back into the hashmap\n    sorted_counts.into_iter().map(|(_,\
    \ count)| {\n        (String::from(&i).to_ascii_lowercase(), count)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpo_5ff6ns.rs:42:24\n\
    \   |\n42 |         (String::from(&i).to_ascii_lowercase(), count)\n   |     \
    \                   ^ not found in this scope\n\nerror[E0599]: the method `join`\
    \ exists for struct `Vec<char>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpo_5ff6ns.rs:17:10\n   |\n17 |         .join(\" \");\n   |          ^^^^\
    \ method cannot be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `[char]:\
    \ Join<_>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // TODO: memoization\n    let mut result = HashMap::new();\n \
    \   let mut counts = HashMap::new();\n\n    for c in test.chars().collect::<Vec<char>>()\
    \ {\n        if let Ok(k) = counts.get(c) {\n            counts.entry(k).and_modify(|x|\
    \ *x += 1).or_insert(1);\n        } else {\n            counts.entry(c).or_insert(1);\n\
    \        }\n\n        if counts.entry(c).or_insert(1) > result.len() {\n     \
    \       result = counts.clone();\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyt9t9vzh.rs:18:35\n   |\n\
    18 |         if let Ok(k) = counts.get(c) {\n   |                            \
    \       ^\n   |                                   |\n   |                    \
    \               expected reference, found `char`\n   |                       \
    \            help: consider borrowing here: `&c`\n   |\n   = note: expected reference\
    \ `&_`\n                   found type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyt9t9vzh.rs:18:16\n   |\n18 |         if let Ok(k) = counts.get(c)\
    \ {\n   |                ^^^^^   ------------- this expression has type `Option<&_>`\n\
    \   |                |\n   |                expected enum `Option`, found enum\
    \ `Result`\n   |\n   = note: expected enum `Option<&_>`\n              found enum\
    \ `Result<_, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyt9t9vzh.rs:24:43\n\
    \   |\n24 |         if counts.entry(c).or_insert(1) > result.len() {\n   |   \
    \                                        ^^^^^^^^^^^^\n   |                  \
    \                         |\n   |                                           expected\
    \ `&mut _`, found `usize`\n   |                                           help:\
    \ consider mutably borrowing here: `&mut result.len()`\n   |\n   = note: expected\
    \ mutable reference `&mut _`\n                           found type `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpyt9t9vzh.rs:29:5\n   |\n12 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<char, {integer}>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    let mut counter: usize = 0;\n\
    \    for ch in test.chars().filter_map(|c| c.to_ascii_lowercase()) {\n       \
    \ let count = map.entry(ch.to_string()).or_insert(0);\n        *count += 1;\n\
    \        counter += 1;\n    }\n    map\n        .iter()\n        .cloned()\n \
    \       .map(|(_, v)| {\n            (\n                String::from_utf8(v.bytes())?\n\
    \                    .to_ascii_lowercase()\n                    .to_string(),\n\
    \                *v,\n            )\n        })\n        .collect::<Vec<_>>()\n\
    \        .sort_by_key(|(_, v)| v.1.partial_cmp(&v.0))\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvbk2okg2.rs:15:43\n   |\n\
    15 |     for ch in test.chars().filter_map(|c| c.to_ascii_lowercase()) {\n   |\
    \                                           ^^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `char`\nhelp: try wrapping the expression in `Some`\n   |\n\
    15 |     for ch in test.chars().filter_map(|c| Some(c.to_ascii_lowercase())) {\n\
    \   |                                           +++++                      +\n\
    \nerror[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_,\
    \ _, {integer}> as Iterator>::Item == &_`\n    --> /tmp/tmpvbk2okg2.rs:22:10\n\
    \     |\n22   |         .cloned()\n     |          ^^^^^^ expected reference,\
    \ found tuple\n     |\n     = note: expected reference `&_`\n                \
    \    found tuple `(&_, &{integer})`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `map` exists for struct `Cloned<std::collections::hash_map::Iter<'_,\
    \ _, {integer}>>`, but its trait bounds were not satisfied\n    --> /tmp/tmpvbk2okg2.rs:23:10\n\
    \     |\n23   |           .map(|(_, v)| {\n     |            ^^^ method cannot\
    \ be called on `Cloned<std::collections::hash_map::Iter<'_, _, {integer}>>` due\
    \ to unsatisfied trait bounds\n     |\n     = note: the following trait bounds\
    \ were not satisfied:\n             `<std::collections::hash_map::Iter<'_, _,\
    \ {integer}> as Iterator>::Item = &_`\n             which is required by `Cloned<std::collections::hash_map::Iter<'_,\
    \ _, {integer}>>: Iterator`\n             `Cloned<std::collections::hash_map::Iter<'_,\
    \ _, {integer}>>: Iterator`\n             which is required by `&mut Cloned<std::collections::hash_map::Iter<'_,\
    \ _, {integer}>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0271, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut count: isize = 0;\n    for c in test.chars() {\n        let count = map.get(c).cloned();\n\
    \        map.insert(c.to_string(), count + 1);\n        if count > count.max()\
    \ {\n            count = count.max();\n        }\n    }\n    map\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6b5qj5gh.rs:16:29\n   |\n\
    16 |         let count = map.get(c).cloned();\n   |                          \
    \   ^\n   |                             |\n   |                             expected\
    \ reference, found `char`\n   |                             help: consider borrowing\
    \ here: `&c`\n   |\n   = note: expected reference `&_`\n                   found\
    \ type `char`\n\nerror[E0369]: cannot add `{integer}` to `Option<isize>`\n  -->\
    \ /tmp/tmp6b5qj5gh.rs:17:41\n   |\n17 |         map.insert(c.to_string(), count\
    \ + 1);\n   |                                   ----- ^ - {integer}\n   |    \
    \                               |\n   |                                   Option<isize>\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp6b5qj5gh.rs:18:26\n    |\n18  |         if count > count.max()\
    \ {\n    |                          ^^^- supplied 0 arguments\n    |         \
    \                 |\n    |                          expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmp6b5qj5gh.rs:19:27\n \
    \   |\n19  |             count = count.max();\n    |                         \
    \  ^^^- supplied 0 arguments\n    |                           |\n    |       \
    \                    expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split(|c| c.chars().fold(0, |x, _| x + 1))\n        .group_by(|c|\
    \ c)\n        .max_by(|a, b| b.1.len())\n        .clone()\n        .iter()\n \
    \       .map(|(k, v)| (k, v))\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpbhag7oq6.rs:13:17\n\
    \   |\n13 |     test.split(|c| c.chars().fold(0, |x, _| x + 1))\n   |        \
    \         ^ consider giving this closure parameter a type\n   |\n   = note: type\
    \ must be known at this point\n\nerror[E0599]: no method named `group_by` found\
    \ for struct `std::str::Split` in the current scope\n  --> /tmp/tmpbhag7oq6.rs:14:10\n\
    \   |\n14 |         .group_by(|c| c)\n   |          ^^^^^^^^ method not found\
    \ in `std::str::Split<'_, _>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0282, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters: HashMap<String, isize> = HashMap::new();\n  \
    \  let mut counts: HashMap<String, isize> = HashMap::new();\n\n    for letter\
    \ in test.split() {\n        if let Some(i) = letters.get(&letter) {\n       \
    \     *i += 1;\n        } else {\n            letters.insert(letter, 1);\n   \
    \     }\n    }\n\n    for letter in letters {\n        if let Some(count) = get_most_frequent_count(&letters,\
    \ &counts) {\n            letters.remove(&letter);\n            letters.insert(letter,\
    \ count);\n        }\n    }\n    letters\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_most_frequent_count` in this scope\n\
    \  --> /tmp/tmpn67ujkmr.rs:25:30\n   |\n25 |         if let Some(count) = get_most_frequent_count(&letters,\
    \ &counts) {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmpn67ujkmr.rs:16:24\n     |\n16   |     for letter\
    \ in test.split() {\n     |                        ^^^^^- supplied 0 arguments\n\
    \     |                        |\n     |                        expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0277]: the trait bound\
    \ `String: Borrow<&str>` is not satisfied\n   --> /tmp/tmpn67ujkmr.rs:17:34\n\
    \    |\n17  |         if let Some(i) = letters.get(&letter) {\n    |         \
    \                         ^^^ the trait `Borrow<&str>` is not implemented for\
    \ `String`\n    |\n    = help: the trait `Borrow<str>` is implemented for `String`\n\
    note: required by a bound in `HashMap::<K, V, S>::get`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn67ujkmr.rs:20:28\n   |\n20 |             letters.insert(letter,\
    \ 1);\n   |                            ^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                            |\n   |                    \
    \        expected struct `String`, found `&str`\n\nerror[E0277]: the trait bound\
    \ `String: Borrow<(String, isize)>` is not satisfied\n   --> /tmp/tmpn67ujkmr.rs:26:28\n\
    \    |\n26  |             letters.remove(&letter);\n    |                    \
    \ ------ ^^^^^^^ the trait `Borrow<(String, isize)>` is not implemented for `String`\n\
    \    |                     |\n    |                     required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Borrow<str>` is implemented for\
    \ `String`\nnote: required by a bound in `HashMap::<K, V, S>::remove`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn67ujkmr.rs:27:28\n   |\n27 |             letters.insert(letter,\
    \ count);\n   |                            ^^^^^^ expected struct `String`, found\
    \ tuple\n   |\n   = note: expected struct `String`"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test\n        .chars()\n        .chain(test.chars().skip(1))\n\
    \        .fold(HashMap::new(), |mut acc, x| {\n            acc.entry(x).or_insert(0)\
    \ += 1;\n            acc\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpio71rkse.rs:17:23\n   |\n\
    17 |             acc.entry(x).or_insert(0) += 1;\n   |                       ^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \     |\n   |                       expected struct `String`, found `char`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ isize`\n  --> /tmp/tmpio71rkse.rs:17:13\n   |\n17 |             acc.entry(x).or_insert(0)\
    \ += 1;\n   |             -------------------------^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be\
    \ used on `isize`, you can dereference `acc.entry(x).or_insert(0)`\n   |\n17 |\
    \             *acc.entry(x).or_insert(0) += 1;\n   |             +\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpio71rkse.rs:17:39\n   |\n\
    17 |             acc.entry(x).or_insert(0) += 1;\n   |             -------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    use std::collections::HashMap;\n    let mut histogram = HashMap::new();\n\
    \    for x in test.chars().filter(|&x| !x.is_whitespace()) {\n        if let Some(count)\
    \ = histogram.entry(&x.to_string()).or_insert(0) {\n            *count += 1;\n\
    \        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmpxx2chmqn.rs:13:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n13 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxx2chmqn.rs:16:16\n\
    \   |\n16 |         if let Some(count) = histogram.entry(&x.to_string()).or_insert(0)\
    \ {\n   |                ^^^^^^^^^^^   --------------------------------------------\
    \ this expression has type `&mut {integer}`\n   |                |\n   |     \
    \           expected integer, found enum `Option`\n   |\n   = note: expected type\
    \ `{integer}`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxx2chmqn.rs:20:5\n   |\n12 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n20 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&String,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n    for ch in test.chars() {\n\
    \        if let Some(count) = counts.get(&ch.to_string()) {\n            counts.entry(ch.to_string()).and_modify(|x|\
    \ *x += 1);\n        } else {\n            counts.entry(ch.to_string()).and_increment();\n\
    \        }\n    }\n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `and_increment` found for enum `std::collections::hash_map::Entry`\
    \ in the current scope\n  --> /tmp/tmpu4f0jln0.rs:18:42\n   |\n18 |          \
    \   counts.entry(ch.to_string()).and_increment();\n   |                      \
    \                    ^^^^^^^^^^^^^ method not found in `std::collections::hash_map::Entry<'_,\
    \ String, _>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = String::new();\n    test\n        .split_whitespace()\n\
    \        .map(|&char| {\n            letters += char.to_string();\n          \
    \  char.to_string()\n        })\n        .collect()\n        .fold(HashMap::new(),\
    \ |acc, &mut char| {\n            let mut count = acc.get(&char).unwrap();\n \
    \           count += 1;\n            acc.insert(char.to_string(), count);\n  \
    \          acc\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpmz2oa7x5.rs:16:16\n   |\n16 |         .map(|&char| {\n \
    \  |                ^^^^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmz2oa7x5.rs:17:24\n\
    \   |\n17 |             letters += char.to_string();\n   |                   \
    \     ^^^^^^^^^^^^^^^^\n   |                        |\n   |                  \
    \      expected `&str`, found struct `String`\n   |                        help:\
    \ consider borrowing here: `&char.to_string()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    let mut occurences = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = occurences.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    for c in occurences.iter() {\n        if *c.1\
    \ == 1 {\n            map.insert(*c.0.to_string(), 1);\n        }\n    }\n   \
    \ map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmplzjrbhvf.rs:21:24\n    |\n21  |             map.insert(*c.0.to_string(),\
    \ 1);\n    |                 ------ ^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n    |                 |\n    |                 required by\
    \ a bound introduced by this call\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `HashMap::<K, V, S>::insert`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmplzjrbhvf.rs:13:19\n    |\n13  |     let mut map = HashMap::new();\n\
    \    |                   ^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `HashMap::<K, V>::new`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n   --> /tmp/tmplzjrbhvf.rs:13:19\n\
    \    |\n13  |     let mut map = HashMap::new();\n    |                   ^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `HashMap`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplzjrbhvf.rs:24:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n24 |     map\n\
    \   |     ^^^ expected struct `String`, found `str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<str, {integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters_counter = HashMap::new();\n    for letter in test.chars().collect::<Vec<_>>()\
    \ {\n        letters_counter.entry(letter).or_insert(0usize) += 1;\n    }\n  \
    \  letters_counter\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut usize`\n  --> /tmp/tmppzu129pz.rs:15:9\n   |\n15 |         letters_counter.entry(letter).or_insert(0usize)\
    \ += 1;\n   |         -----------------------------------------------^^^^^\n \
    \  |         |\n   |         cannot use `+=` on type `&mut usize`\n   |\nhelp:\
    \ `+=` can be used on `usize`, you can dereference `letters_counter.entry(letter).or_insert(0usize)`\n\
    \   |\n15 |         *letters_counter.entry(letter).or_insert(0usize) += 1;\n \
    \  |         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmppzu129pz.rs:15:57\n\
    \   |\n15 |         letters_counter.entry(letter).or_insert(0usize) += 1;\n  \
    \ |         ----------------------------------------------- ^^\n   |         |\n\
    \   |         cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppzu129pz.rs:17:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n17 |     letters_counter\n\
    \   |     ^^^^^^^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<char,\
    \ usize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0067, E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.to_string().split(' ').collect::<Vec<&str>>();\n\
    \    let mut count: HashMap<String, isize> = HashMap::new();\n\n    for &s in\
    \ letters {\n        count.entry(s).or_insert(0usize);\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx67zycsm.rs:17:21\n   |\n\
    17 |         count.entry(s).or_insert(0usize);\n   |                     ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                     |\n\
    \   |                     expected struct `String`, found `str`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpx67zycsm.rs:16:10\n   |\n16 |     for &s in letters {\n   |        \
    \  ^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx67zycsm.rs:17:34\n   |\n17 |         count.entry(s).or_insert(0usize);\n\
    \   |                                  ^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: change the type of the numeric literal from `usize` to `isize`\n\
    \   |\n17 |         count.entry(s).or_insert(0isize);\n   |                  \
    \                 ~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n\n    for letter in test.split_whitespace()\
    \ {\n        histogram.entry(letter).or_insert(0);\n        histogram.entry(letter).into_mut().1\
    \ += 1;\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `into_mut` found for enum `std::collections::hash_map::Entry`\
    \ in the current scope\n  --> /tmp/tmpjln2t1jw.rs:17:33\n   |\n17 |         histogram.entry(letter).into_mut().1\
    \ += 1;\n   |                                 ^^^^^^^^ method not found in `std::collections::hash_map::Entry<'_,\
    \ &str, {integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjln2t1jw.rs:20:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n20 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&str, {integer}>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.chars().collect::<Vec<char>>();\n    let\
    \ mut letters_count = vec![];\n\n    for letter in letters {\n        let letter_repetition\
    \ = letters_count.iter().position(|&i| i == letter).unwrap_or(0);\n        letters_count.push(letter_repetition);\n\
    \    }\n\n    letters_count.sort_unstable();\n\n    let mut letters_map = HashMap::new();\n\
    \n    for i in 0..letters_count.len() {\n        letters_map.insert(letters[i].to_string(),\
    \ letters_count[i]);\n    }\n\n    letters_map\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `usize` with `char`\n  --> /tmp/tmpe074cg7z.rs:17:70\n\
    \   |\n17 |         let letter_repetition = letters_count.iter().position(|&i|\
    \ i == letter).unwrap_or(0);\n   |                                           \
    \                           ^^ no implementation for `usize == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe074cg7z.rs:29:5\n   |\n12 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n29 |     letters_map\n   |     ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    for c in test.chars() {\n\
    \        *freqs.entry(c).or_insert(0) += 1;\n    }\n    freqs\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6scb37tc.rs:17:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n17 |     freqs\n   |     ^^^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<char, {integer}>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    let mut letters = test\n\
    \        .chars()\n        .flat_map(|c| c.to_string().chars())\n        .collect::<Vec<char>>();\n\
    \    while let Some(letter) = letters.last_mut() {\n        let occurrences =\
    \ histogram.get(&letter);\n        if let Some(occurrences) = occurrences {\n\
    \            histogram.insert(letter, occurrences + 1);\n        } else {\n  \
    \          histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_37aevbt.rs:26:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&mut char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&mut char, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counter = HashMap::new();\n\n    for letter in test.chars().skip(1)\
    \ {\n        if let Some(count) = (counter.entry(letter).or_insert(0) + (*counter\
    \ as usize)) {\n            counter.entry(letter).and_modify(|v| v += 1).or_insert(count);\n\
    \        } else {\n            counter.insert(letter, 1);\n        }\n    }\n\n\
    \    counter\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmpaujii_vt.rs:16:30\n   |\n16 |         if let Some(count) = (counter.entry(letter).or_insert(0)\
    \ + (*counter as usize)) {\n   |                              ^              \
    \                                          ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n16 -         if let Some(count)\
    \ = (counter.entry(letter).or_insert(0) + (*counter as usize)) {\n16 +       \
    \  if let Some(count) = counter.entry(letter).or_insert(0) + (*counter as usize)\
    \ {\n   | \n\nerror[E0614]: type `HashMap<char, {integer}>` cannot be dereferenced\n\
    \  --> /tmp/tmpaujii_vt.rs:16:69\n   |\n16 |         if let Some(count) = (counter.entry(letter).or_insert(0)\
    \ + (*counter as usize)) {\n   |                                             \
    \                        ^^^^^^^^\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpaujii_vt.rs:17:50\n\
    \   |\n17 |             counter.entry(letter).and_modify(|v| v += 1).or_insert(count);\n\
    \   |                                                  -^^^^^\n   |          \
    \                                        |\n   |                             \
    \                     cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `v`\n   |\n17 |            \
    \ counter.entry(letter).and_modify(|v| *v += 1).or_insert(count);\n   |      \
    \                                            +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaujii_vt.rs:23:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n23 |     counter\n   |\
    \     ^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0308, E0368, E0614.\nFor"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().map(|c| { test::KeyValue::new(c, 1)})\n        .collect::<HashMap<String,\
    \ isize>>()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `test`\n\
    \  --> /tmp/tmpa802ly2f.rs:13:28\n   |\n13 |     test.chars().map(|c| { test::KeyValue::new(c,\
    \ 1)})\n   |                            ^^^^ use of undeclared crate or module\
    \ `test`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().fold(HashMap::new(), |mut acc, c| {\n        let\
    \ count = acc.entry(c).or_insert(0);\n        *count += 1;\n        acc\n    })\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqfon48nr.rs:14:31\n   |\n\
    14 |         let count = acc.entry(c).or_insert(0);\n   |                    \
    \           ^- help: try using a conversion method: `.to_string()`\n   |     \
    \                          |\n   |                               expected struct\
    \ `String`, found `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let letters = test.split_whitespace().map(|char| char.chars().next().unwrap()).collect();\n\
    \    letters.iter().cloned().map(|count| {\n        let mut result = HashMap::new();\n\
    \        for char in letters {\n            result\n                .entry(char)\n\
    \                .or_insert(0)\n                .and_then(|mut count| {\n    \
    \                count = count.checked_add(1).ok_or(\"Unable to increment count\"\
    )?;\n                    Some(count)\n                })\n                .ok_or(\"\
    Invalid input for histogram.\")\n        })\n        .max_by_key(|count| count.expect(\"\
    No letter with most occurrence\"))\n        .map(|(_, count)| count)\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `)`\n  --> /tmp/tmpfm8heni1.rs:14:41\n\
    \   |\n14 |     letters.iter().cloned().map(|count| {\n   |                  \
    \                       ^ unclosed delimiter\n...\n25 |         })\n   |     \
    \     ^ mismatched closing delimiter\n\nerror[E0282]: type annotations needed\n\
    \  --> /tmp/tmpfm8heni1.rs:14:5\n   |\n13 |     let letters = test.split_whitespace().map(|char|\
    \ char.chars().next().unwrap()).collect();\n   |         ------- consider giving\
    \ `letters` a type\n14 |     letters.iter().cloned().map(|count| {\n   |     ^^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror[E0599]:\
    \ no method named `and_then` found for mutable reference `&mut {integer}` in the\
    \ current scope\n  --> /tmp/tmpfm8heni1.rs:20:18\n   |\n20 |                 .and_then(|mut\
    \ count| {\n   |                  ^^^^^^^^ method not found in `&mut {integer}`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0599.\nFor more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    use std::collections::HashMap;\n\n    let mut histogram = HashMap::new();\n\
    \    for character in test.chars() {\n        let count = histogram.entry(character.to_string()).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \" \": 3, \"a\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp9sfcqhj3.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for x in test.chars()\
    \ {\n        histogram.insert(String::from_utf8(x).unwrap(), histogram.entry(x).or_insert(0).clone()\
    \ + 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplb0cu3db.rs:15:44\n   |\n\
    15 |         histogram.insert(String::from_utf8(x).unwrap(), histogram.entry(x).or_insert(0).clone()\
    \ + 1);\n   |                                            ^ expected struct `Vec`,\
    \ found `char`\n   |\n   = note: expected struct `Vec<u8>`\n                found\
    \ type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplb0cu3db.rs:15:73\n\
    \   |\n15 |         histogram.insert(String::from_utf8(x).unwrap(), histogram.entry(x).or_insert(0).clone()\
    \ + 1);\n   |                                                                \
    \         ^- help: try using a conversion method: `.to_string()`\n   |       \
    \                                                                  |\n   |   \
    \                                                                      expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counters = HashMap::new();\n    for letter in test.chars()\
    \ {\n        if let Some((_, counter)) = counters.entry(letter) {\n          \
    \  *counter += 1;\n        } else {\n            counters.insert(letter, 1);\n\
    \        }\n    }\n    counters\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpulrs0hwa.rs:15:16\n   |\n\
    15 |         if let Some((_, counter)) = counters.entry(letter) {\n   |      \
    \          ^^^^^^^^^^^^^^^^^^   ---------------------- this expression has type\
    \ `std::collections::hash_map::Entry<'_, char, _>`\n   |                |\n  \
    \ |                expected enum `std::collections::hash_map::Entry`, found enum\
    \ `Option`\n   |\n   = note: expected enum `std::collections::hash_map::Entry<'_,\
    \ char, _>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpulrs0hwa.rs:21:5\n   |\n12 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n21 |     counters\n\
    \   |     ^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().map(|c| c.to_ascii_lowercase()).group_by(|c| c).max_by(|(_,\
    \ count)| count).map(|(_, count)| count.clone())\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpt6dx5k_g.rs:13:50\n   |\n13 |     test.chars().map(|c|\
    \ c.to_ascii_lowercase()).group_by(|c| c).max_by(|(_, count)| count).map(|(_,\
    \ count)| count.clone())\n   |                                               \
    \   ^^^^^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpt6dx5k_g.rs:13:22:\
    \ 13:48]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.chars().collect::<Vec<char>>();\n    let\
    \ mut occurrence_counter = HashMap::new();\n    let mut i = 0;\n    while i <\
    \ letters.len() {\n        let letter = &letters[i];\n        let occurrence_count\
    \ = occurrence_counter.get(letter).unwrap();\n        occurrence_counter.insert(letter,\
    \ occurrence_count + 1);\n        i += 1;\n    }\n    occurrence_counter\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq7x_bnh5.rs:22:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n22 |     occurrence_counter\n   |     ^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&char, _>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut freqs = HashMap::new();\n    for ch in test.chars() {\n\
    \        freqs.entry(ch).or_insert(0)\n    }\n    freqs\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp02599s3v.rs:15:9\n   |\n\
    15 |         freqs.entry(ch).or_insert(0)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: consider using a semicolon here: `;`\n   |         |\n   |         expected\
    \ `()`, found `&mut {integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp02599s3v.rs:17:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n17 |     freqs\n   |     ^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n\n    for letter in test.chars()\
    \ {\n        let mut count = counts.entry(letter).or_insert(0);\n        *count\
    \ += 1;\n    }\n\n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9mdj91d.rs:20:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n20 |     counts\n   |     ^^^^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<char, {integer}>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for c in test.chars()\
    \ {\n        let mut c = c.to_string();\n        histogram.entry(c).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp286dv60_.rs:16:9\n   |\n16 |         histogram.entry(c).or_insert(0)\
    \ += 1;\n   |         -------------------------------^^^^^\n   |         |\n \
    \  |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(c).or_insert(0)`\n\
    \   |\n16 |         *histogram.entry(c).or_insert(0) += 1;\n   |         +\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp286dv60_.rs:16:41\n\
    \   |\n16 |         histogram.entry(c).or_insert(0) += 1;\n   |         -------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    let mut freq = HashMap::new();\n\
    \    for ch in test.chars() {\n        if let Some(count) = (map.entry(ch.to_string()).or_insert(0)).and_then(|c|\
    \ c.get_mut()) {\n            *count += 1;\n        }\n        else {\n      \
    \      map.entry(ch.to_string()).or_insert(1);\n            freq.entry(ch.to_string()).or_insert(1);\n\
    \        }\n    }\n    freq\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `and_then` found for mutable reference `&mut\
    \ {integer}` in the current scope\n  --> /tmp/tmpplwhsrv7.rs:16:71\n   |\n16 |\
    \         if let Some(count) = (map.entry(ch.to_string()).or_insert(0)).and_then(|c|\
    \ c.get_mut()) {\n   |                                                       \
    \                ^^^^^^^^ method not found in `&mut {integer}`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split(' ').map(|char| char.chars().count()).\n        fold(HashMap::new(),\
    \ |mut accum, char| {\n            accum\n                .entry(char.to_string())\n\
    \                .or_insert(char.chars().count())\n        });\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpdgj6hg43.rs:17:33\n   |\n17 |                 .or_insert(char.chars().count())\n\
    \   |                                 ^^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdgj6hg43.rs:15:13\n   |\n15 | /            \
    \ accum\n16 | |                 .entry(char.to_string())\n17 | |             \
    \    .or_insert(char.chars().count())\n   | |________________________________________________^\
    \ expected struct `HashMap`, found `&mut _`\n   |\n   = note:         expected\
    \ struct `HashMap<String, _>`\n           found mutable reference `&mut _`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdgj6hg43.rs:12:31\n   |\n12 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |    ---------     \
    \             ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n \
    \  |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n...\n18 |         });\n   |           - help: remove this semicolon\n\
    \   |\n   = note: expected struct `HashMap<String, isize>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n\
    \    for letter in test.chars().filter(|c| c != ' ').cloned() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpt5e1j0ft.rs:14:45\n\
    \   |\n14 |     for letter in test.chars().filter(|c| c != ' ').cloned() {\n \
    \  |                                             ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0271]:\
    \ type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmpt5e1j0ft.rs:14:39:\
    \ 14:51]> as Iterator>::Item == &_`\n    --> /tmp/tmpt5e1j0ft.rs:14:53\n     |\n\
    14   |     for letter in test.chars().filter(|c| c != ' ').cloned() {\n     |\
    \                                                     ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]:\
    \ type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmpt5e1j0ft.rs:14:39:\
    \ 14:51]> as Iterator>::Item == &_`\n  --> /tmp/tmpt5e1j0ft.rs:14:19\n   |\n14\
    \ |     for letter in test.chars().filter(|c| c != ' ').cloned() {\n   |     \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Filter<Chars<'_>, [closure@/tmp/tmpt5e1j0ft.rs:14:39: 14:51]>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Filter<Chars<'_>, [closure@/tmp/tmpt5e1j0ft.rs:14:39: 14:51]>>`\n\
    \nerror[E0271]: type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmpt5e1j0ft.rs:14:39:\
    \ 14:51]> as Iterator>::Item == &_`\n  --> /tmp/tmpt5e1j0ft.rs:14:19\n   |\n14\
    \ |     for letter in test.chars().filter(|c| c != ' ').cloned() {\n   |     \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Filter<Chars<"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split(' ')\n        .map(|c| c.to_lowercase())\n        .fold(HashMap::new(),\
    \ |mut m, c| m.entry(c).or_insert(0) += 1);\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpwmrczw91.rs:15:42\n   |\n15 |         .fold(HashMap::new(),\
    \ |mut m, c| m.entry(c).or_insert(0) += 1);\n   |                            \
    \              -----------------------^^^^^\n   |                            \
    \              |\n   |                                          cannot use `+=`\
    \ on type `&mut {integer}`\n   |\nhelp: `+=` can be used on `{integer}`, you can\
    \ dereference `m.entry(c).or_insert(0)`\n   |\n15 |         .fold(HashMap::new(),\
    \ |mut m, c| *m.entry(c).or_insert(0) += 1);\n   |                           \
    \               +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpwmrczw91.rs:15:66\n   |\n15 |         .fold(HashMap::new(), |mut m,\
    \ c| m.entry(c).or_insert(0) += 1);\n   |                                    \
    \      ----------------------- ^^\n   |                                      \
    \    |\n   |                                          cannot assign to this expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwmrczw91.rs:12:31\n   |\n12 |\
    \ fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------  \
    \                ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n...\n15 |         .fold(HashMap::new(), |mut m, c| m.entry(c).or_insert(0)\
    \ += 1);\n   |                                                               \
    \        - help: remove this semicolon\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0308, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n    for c in test.chars() {\n\
    \        if counts.contains_key(&c) {\n            counts.entry(*c).or_insert(0)\
    \ += 1;\n        } else {\n            counts.insert(*c, 1);\n        }\n    }\n\
    \    counts\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpjgwq41pq.rs:16:26\n\
    \   |\n16 |             counts.entry(*c).or_insert(0) += 1;\n   |            \
    \              ^^\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `&mut {integer}`\n  --> /tmp/tmpjgwq41pq.rs:16:13\n   |\n16\
    \ |             counts.entry(*c).or_insert(0) += 1;\n   |             -----------------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `counts.entry(*c).or_insert(0)`\n\
    \   |\n16 |             *counts.entry(*c).or_insert(0) += 1;\n   |           \
    \  +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpjgwq41pq.rs:16:43\n\
    \   |\n16 |             counts.entry(*c).or_insert(0) += 1;\n   |            \
    \ ----------------------------- ^^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpjgwq41pq.rs:18:27\n   |\n18 |             counts.insert(*c, 1);\n\
    \   |                           ^^\n\nerror[E0277]: the trait bound `String: Borrow<char>`\
    \ is not satisfied\n   --> /tmp/tmpjgwq41pq.rs:15:19\n    |\n15  |         if\
    \ counts.contains_key(&c) {\n    |                   ^^^^^^^^^^^^ the trait `Borrow<char>`\
    \ is not implemented for `String`\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::contains_key`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0277, E0368, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters: Vec<String> = test.split_whitespace().collect();\n\
    \    let mut counts = HashMap::new();\n\n    for letter in letters {\n       \
    \ let count = counts.entry(letter).or_insert(0);\n        *count += 1;\n    }\n\
    \n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmplweodio2.rs:13:60\n     |\n13\
    \   |     let mut letters: Vec<String> = test.split_whitespace().collect();\n\
    \     |                                                            ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().\n        flat_map(|c| c.to_string()).\n        filter(|c|\
    \ c.is_lowercase()).\n        map(|c| (c, 1i)).\n        fold(HashMap::new(),\
    \ |mut acc, c| {\n            acc.entry(c).or_insert(0) += 1;\n            acc\n\
    \        })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `i` for number literal\n  --> /tmp/tmp6m41jm9n.rs:16:21\n\
    \   |\n16 |         map(|c| (c, 1i)).\n   |                     ^^ invalid suffix\
    \ `i`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror[E0277]: `String` is not an iterator\n    --> /tmp/tmp6m41jm9n.rs:14:18\n\
    \     |\n14   |         flat_map(|c| c.to_string()).\n     |         --------\
    \ ^^^^^^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \     |         |\n     |         required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Iterator` is not implemented for `String`\n \
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\nnote: required by a bound in `flat_map`\n\nerror[E0599]: the method\
    \ `filter` exists for struct `FlatMap<Chars<'_>, String, [closure@/tmp/tmp6m41jm9n.rs:14:18:\
    \ 14:35]>`, but its trait bounds were not satisfied\n   --> /tmp/tmp6m41jm9n.rs:15:9\n\
    \    |\n15  |           filter(|c| c.is_lowercase()).\n    |           ^^^^^^\
    \ method cannot be called on `FlatMap<Chars<'_>, String, [closure@/tmp/tmp6m41jm9n.rs:14:18:\
    \ 14:35]>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: IntoIterator`\n           \
    \ which is required by `FlatMap<Chars<'_>, String, [closure@/tmp/tmp6m41jm9n.rs:14:18:\
    \ 14:35]>: Iterator`\n            `FlatMap<Chars<'_>, String, [closure@/tmp/tmp6m41jm9n.rs:14:18:\
    \ 14:35]>: Iterator`\n            which is required by `&mut FlatMap<Chars<'_>,\
    \ String, [closure@/tmp/tmp6m41jm9n.rs:14:18: 14:35]>: Iterator`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp6m41jm9n.rs:18:39\n   |\n\
    18 |             acc.entry(c).or_insert(0) += 1;\n   |             -------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0277, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test\n        .chars()\n        .fold(HashMap::new(), |mut histogram:\
    \ HashMap<String, isize>, char: char| {\n            if let Some(count) = histogram.entry(char.to_string()).or_insert(0)\
    \ {\n                *count += 1;\n            }\n            histogram\n    \
    \    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi58gs_y4.rs:16:20\n   |\n\
    16 |             if let Some(count) = histogram.entry(char.to_string()).or_insert(0)\
    \ {\n   |                    ^^^^^^^^^^^   ----------------------------------------------\
    \ this expression has type `&mut isize`\n   |                    |\n   |     \
    \               expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    for letter in test.split()\
    \ {\n        map.entry(letter).or_insert(0) += 1;\n    }\n    map\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpeed8te47.rs:14:24\n     |\n14   |     for letter in test.split()\
    \ {\n     |                        ^^^^^- supplied 0 arguments\n     |       \
    \                 |\n     |                        expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpeed8te47.rs:15:9\n\
    \   |\n15 |         map.entry(letter).or_insert(0) += 1;\n   |         ------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `map.entry(letter).or_insert(0)`\n\
    \   |\n15 |         *map.entry(letter).or_insert(0) += 1;\n   |         +\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpeed8te47.rs:15:40\n\
    \   |\n15 |         map.entry(letter).or_insert(0) += 1;\n   |         ------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeed8te47.rs:17:5\n   |\n12 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n17 |     map\n\
    \   |     ^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0067, E0308, E0368.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for letter in test.split(\"\
    \ \") {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp0wqpc1pu.rs:16:13\n   |\n16 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n16 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp0wqpc1pu.rs:16:51\n\
    \   |\n16 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0wqpc1pu.rs:18:30\n   |\n18 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^ expected `&str`, found `str`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0wqpc1pu.rs:21:5\n   |\n12 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n21 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&&str, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut count: HashMap<String, isize> = HashMap::new();\n    for\
    \ i in test.chars().map(|c| c.to_string()).collect::<Vec<String>>() {\n      \
    \  if let Some(&entry) = count.entry(i) {\n            *entry.or_insert(0) +=\
    \ 1;\n        } else {\n            count.insert(i, 1);\n        }\n    }\n  \
    \  count\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitftpqrp.rs:15:16\n   |\n\
    15 |         if let Some(&entry) = count.entry(i) {\n   |                ^^^^^^^^^^^^\
    \   -------------- this expression has type `std::collections::hash_map::Entry<'_,\
    \ String, isize>`\n   |                |\n   |                expected enum `std::collections::hash_map::Entry`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::collections::hash_map::Entry<'_,\
    \ String, isize>`\n              found enum `Option<_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    for c in test.split(\" \"\
    ) {\n        match result.get_mut(&c) {\n            Some(count) => {\n      \
    \          *count += 1;\n            }\n            None => {\n              \
    \  result.insert(c, 1);\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9tbtl04q.rs:24:5\n   |\n\
    12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     result\n   |     ^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<&str, {integer}>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut occurrences = HashMap::new();\n    for letter in test.chars().filter(|c|\
    \ !c.is_whitespace()) {\n        occurrences.entry(letter).or_insert(0) += 1;\n\
    \    }\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmptd6_u4r0.rs:15:9\n   |\n15 |         occurrences.entry(letter).or_insert(0)\
    \ += 1;\n   |         --------------------------------------^^^^^\n   |      \
    \   |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `occurrences.entry(letter).or_insert(0)`\n\
    \   |\n15 |         *occurrences.entry(letter).or_insert(0) += 1;\n   |      \
    \   +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmptd6_u4r0.rs:15:48\n\
    \   |\n15 |         occurrences.entry(letter).or_insert(0) += 1;\n   |       \
    \  -------------------------------------- ^^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptd6_u4r0.rs:17:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n17 |     occurrences\n   |     ^^^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut occurrences = HashMap::new();\n    for character in test.chars().chain(test.chars().skip_while(|c|\
    \ !c.is_ascii_lowercase())) {\n        let occurrence = occurrences.get(&character).unwrap();\n\
    \        *occurrence += 1;\n        occurrences.insert(character.to_string(),\
    \ occurrence);\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n\
    \   --> /tmp/tmpghh0pfb5.rs:15:38\n    |\n15  |         let occurrence = occurrences.get(&character).unwrap();\n\
    \    |                                      ^^^ the trait `Borrow<char>` is not\
    \ implemented for `String`\n    |\n    = help: the trait `Borrow<str>` is implemented\
    \ for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpghh0pfb5.rs:17:51\n   |\n17 |         occurrences.insert(character.to_string(),\
    \ occurrence);\n   |                                                   ^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                                 |\n   |                                    \
    \               cyclic type of infinite size\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut hashmap = HashMap::new();\n    test.split(\" \").iter().for_each(|c|\
    \ {\n        if !hashmap.contains_key(&c) {\n            hashmap.insert(c, 1);\n\
    \        } else {\n            hashmap.entry(c).or_insert(1) += 1;\n        }\n\
    \    });\n    hashmap\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpz4doopfl.rs:14:21\n   |\n14 |     test.split(\"\
    \ \").iter().for_each(|c| {\n   |                     ^^^^ method not found in\
    \ `std::str::Split<'_, &str>`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpz4doopfl.rs:18:13\n\
    \   |\n18 |             hashmap.entry(c).or_insert(1) += 1;\n   |            \
    \ -----------------------------^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used on `{integer}`,\
    \ you can dereference `hashmap.entry(c).or_insert(1)`\n   |\n18 |            \
    \ *hashmap.entry(c).or_insert(1) += 1;\n   |             +\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpz4doopfl.rs:18:43\n   |\n18 |  \
    \           hashmap.entry(c).or_insert(1) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    let mut words = test.split('\
    \ ').collect::<Vec<_>>();\n    let mut current: Vec<_> = vec![];\n    for word\
    \ in words {\n        let mut counts = vec![];\n        for letter in word {\n\
    \            let mut count = 0;\n            if let Some(i) = current.iter().position(|&x|\
    \ x == letter) {\n                count += 1;\n            }\n            counts.push(count);\n\
    \        }\n        if counts.len() > result.len() {\n            result.clear();\n\
    \        }\n        result.insert(word, counts.max());\n        current = counts.clone();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmpg7g68tib.rs:18:23\n\
    \   |\n18 |         for letter in word {\n   |                       ^^^^ `&str`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `&str`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpg7g68tib.rs:28:36\n\
    \    |\n28  |         result.insert(word, counts.max());\n    |              \
    \                      ^^^- supplied 0 arguments\n    |                      \
    \              |\n    |                                    expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg7g68tib.rs:31:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n31 |     result\n   |\
    \     ^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, Vec<{integer}>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split(\" \").map(|word| {\n        let mut letters = HashMap::new();\n\
    \        let mut occurrences = HashMap::new();\n        word.chars().filter(|c|\
    \ c != ' ').for_each(|c| {\n            match letters.get_mut(&c) {\n        \
    \        Some(l) => {\n                    *l += 1;\n                    occurrences.get_mut(&c).unwrap().unwrap()\n\
    \                }\n                None => {\n                    letters.insert(c,\
    \ 1);\n                    occurrences.insert(c, HashMap::new());\n          \
    \      }\n            }\n        });\n\n        let mut max = occurrences.iter().max().unwrap();\n\
    \        for (remaining, value) in occurrences {\n            if value == *max\
    \ {\n                *max = remaining;\n            }\n        }\n\n        let\
    \ mut res = HashMap::new();\n        for (key, value) in occurrences {\n     \
    \       match letters.get_mut(&key) {\n                Some(l) => {\n        \
    \            *l += value;\n                    res.insert(key, *l);\n        \
    \        }\n                None => res.insert(key, *value),\n            }\n\
    \        }\n        res\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpo0cbm8fg.rs:16:35\n\
    \   |\n16 |         word.chars().filter(|c| c != ' ').for_each(|c| {\n   |   \
    \                                ^^ no implementation for `&char == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmpo0cbm8fg.rs:43:25\n   |\n38 | /\
    \             match letters.get_mut(&key) {\n39 | |                 Some(l) =>\
    \ {\n40 | |                     *l += value;\n41 | |                     res.insert(key,\
    \ *l);\n   | |                     --------------------\n   | |              \
    \       |                  |\n   | |                     |                  help:\
    \ consider removing this semicolon\n   | |                     this is found to\
    \ be of type `()`\n42 | |                 }\n43 | |                 None => res.insert(key,\
    \ *value),\n   | |                         ^^^^^^^^^^^^^^^^^^^^^^^ expected `()`,\
    \ found enum `Option`\n44 | |             }\n   | |_____________- `match` arms\
    \ have incompatible types\n   |\n   = note: expected unit type `()`\n        \
    \           found enum `Option<{integer}>`\n\nerror[E0277]: a value of type `HashMap<String,\
    \ isize>` cannot be built from an iterator over elements of type `HashMap<char,\
    \ {integer}>`\n    --> /tmp/tmpo0cbm8fg.rs:47:8\n     |\n47   |     }).collect()\n\
    \     |        ^^^^^^^ value of type `HashMap<String, isize>` cannot be built\
    \ from `std::iter::Iterator<Item=HashMap<char, {integer}>>`\n     |\n     = help:\
    \ the trait `FromIterator<HashMap<char, {integer}>>` is not implemented for `HashMap<String,\
    \ isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.split(' ').collect()\n        .map(|item| {\n           \
    \ let mut occurrence = item.chars().filter(|c| !c.is_whitespace()).count();\n\
    \            occurrence.map(|count| {\n                (item.chars(), count)\n\
    \            })\n            .max_by(|a, b| a.1.cmp(&b.1))\n            .map(|(_,\
    \ count)| count)\n        })\n        .collect()\n        .unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp3hpu_z1c.rs:13:21\n\
    \   |\n13 |     test.split(' ').collect()\n   |                     ^^^^^^^ cannot\
    \ infer type for type parameter `B` declared on the associated function `collect`\n\
    \   |\n   = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n   |\n13 |     test.split(' ').collect::<B>()\n\
    \   |                            +++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars()\n        .chain(test.chars().map(|c| char::to_ascii_lowercase(c)))\n\
    \        .group_by(|c| c)\n        .max_by_key(|(_, count)| count)\n        .cloned()\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6i97ycby.rs:14:62\n   |\n\
    14 |         .chain(test.chars().map(|c| char::to_ascii_lowercase(c)))\n   | \
    \                                                             ^\n   |        \
    \                                                      |\n   |               \
    \                                               expected `&char`, found `char`\n\
    \   |                                                              help: consider\
    \ borrowing here: `&c`\n\nerror[E0599]: no method named `group_by` found for struct\
    \ `std::iter::Chain` in the current scope\n  --> /tmp/tmp6i97ycby.rs:15:10\n \
    \  |\n15 |         .group_by(|c| c)\n   |          ^^^^^^^^ method not found in\
    \ `std::iter::Chain<Chars<'_>, Map<Chars<'_>, [closure@/tmp/tmp6i97ycby.rs:14:33:\
    \ 14:64]>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \    letters.sort();\n    let mut histogram = HashMap::new();\n    for letter\
    \ in letters {\n        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \        histogram.entry(letter).and_modify(|e| *e = histogram.get(letter).unwrap()\
    \ + 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdotcvc5q.rs:17:34\n   |\n\
    17 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpdotcvc5q.rs:18:67\n   |\n18 |         histogram.entry(letter).and_modify(|e|\
    \ *e = histogram.get(letter).unwrap() + 1);\n   |                            \
    \                                       ^^^^^^\n   |                         \
    \                                          |\n   |                           \
    \                                        expected reference, found struct `String`\n\
    \   |                                                                   help:\
    \ consider borrowing here: `&letter`\n   |\n   = note: expected reference `&_`\n\
    \                 found struct `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts = HashMap::new();\n    for c in test.chars() {\n\
    \        counts.entry(c.to_string()).or_insert(0) += 1;\n    }\n    counts\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpzbf8grqj.rs:15:9\n   |\n15 |         counts.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `counts.entry(c.to_string()).or_insert(0)`\n\
    \   |\n15 |         *counts.entry(c.to_string()).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpzbf8grqj.rs:15:50\n\
    \   |\n15 |         counts.entry(c.to_string()).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.split(' ');\n    let mut counters = HashMap::new();\n\
    \n    for letter in &letters {\n        if let Some(counter) = counters.get(letter)\
    \ {\n            counter.0 += 1;\n        } else {\n            counters.insert(letter,\
    \ (1, 1));\n        }\n    }\n\n    counters\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&std::str::Split<'_, char>` is not an iterator\n  --> /tmp/tmp18tpuwhn.rs:16:19\n\
    \   |\n16 |     for letter in &letters {\n   |                   -^^^^^^^\n  \
    \ |                   |\n   |                   `&std::str::Split<'_, char>` is\
    \ not an iterator\n   |                   help: consider removing the leading\
    \ `&`-reference\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&std::str::Split<'_, char>`\n   = note: `Iterator` is implemented for `&mut\
    \ std::str::Split<'_, char>`, but not for `&std::str::Split<'_, char>`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&std::str::Split<'_,\
    \ char>`\n\nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmp18tpuwhn.rs:18:21\n\
    \   |\n18 |             counter.0 += 1;\n   |                     ^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test\n        .chars()\n        .fold(HashMap::new(), |m, c| {\n\
    \            c.to_string().chars().fold(m, |mut m, char| {\n                let\
    \ count = m.entry(char).or_insert(0);\n                *count += 1;\n        \
    \        m\n            })\n        })\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo8kf_54c.rs:17:37\n   |\n\
    17 |                 let count = m.entry(char).or_insert(0);\n   |           \
    \                          ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                     |\n   |                            \
    \         expected struct `String`, found `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n\n    for ch in test.chars() {\n\
    \        map.entry(ch.to_string()).or_insert(0) += 1;\n    }\n\n    map\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpqqs9697o.rs:16:9\n   |\n16 |         map.entry(ch.to_string()).or_insert(0)\
    \ += 1;\n   |         --------------------------------------^^^^^\n   |      \
    \   |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `map.entry(ch.to_string()).or_insert(0)`\n\
    \   |\n16 |         *map.entry(ch.to_string()).or_insert(0) += 1;\n   |      \
    \   +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpqqs9697o.rs:16:48\n\
    \   |\n16 |         map.entry(ch.to_string()).or_insert(0) += 1;\n   |       \
    \  -------------------------------------- ^^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for i in test.chars().filter_map(|c|\
    \ {\n        if histogram.contains_key(&c.to_string()) {\n            histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(c.to_string(), 1);\n \
    \       }\n    }) {\n        if let Some(count) = histogram.get(&i) {\n      \
    \      histogram.insert(i.to_string(), *count + 1);\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdt0qwp7a.rs:16:13\n   |\n16 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             -------------------------------------------^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n16 |             *histogram.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpdt0qwp7a.rs:16:57\n   |\n16 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdt0qwp7a.rs:15:51\n   |\n15 |           if histogram.contains_key(&c.to_string())\
    \ {\n   |  ___________________________________________________^\n16 | |      \
    \       histogram.entry(c.to_string()).or_insert(0) += 1;\n17 | |         } else\
    \ {\n   | |_________^ expected enum `Option`, found `()`\n   |\n   = note:   expected\
    \ enum `Option<_>`\n           found unit type `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdt0qwp7a.rs:17:16\n   |\n17 |           } else {\n   |\
    \  ________________^\n18 | |             histogram.insert(c.to_string(), 1);\n\
    \   | |                                               - help: remove this semicolon\n\
    19 | |         }\n   | |_________^ expected enum `Option`, found `()`\n   |\n\
    \   = note:   expected enum `Option<_>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counters = HashMap::new();\n\n    for letter in test.chars()\
    \ {\n        if let Some(&value) = counters.entry(letter).or_insert(0) {\n   \
    \         *value += 1;\n        }\n    }\n\n    counters\n}\n\nfn main() {\n \
    \   let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9dkwgvoy.rs:16:16\n   |\n\
    16 |         if let Some(&value) = counters.entry(letter).or_insert(0) {\n   |\
    \                ^^^^^^^^^^^^   ----------------------------------- this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9dkwgvoy.rs:21:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n21 |     counters\n  \
    \ |     ^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().filter_map(|c| c.to_ascii_lowercase()).map(|c| c.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsk8_ec81.rs:13:33\n   |\n\
    13 |     test.chars().filter_map(|c| c.to_ascii_lowercase()).map(|c| c.to_string()).collect()\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     test.chars().filter_map(|c|\
    \ Some(c.to_ascii_lowercase())).map(|c| c.to_string()).collect()\n   |       \
    \                          +++++                      +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters: Vec<_> = test.chars().map(|c| c.to_string()).collect();\n\
    \    let mut occurrences = HashMap::new();\n    let mut counter = 0;\n    while\
    \ let Some(k) = letters.pop() {\n        if occurrences.contains_key(&k) {\n \
    \           occurrences.entry(k).or_insert(0usize) += 1;\n        } else {\n \
    \           occurrences.insert(k, counter);\n            counter += 1;\n     \
    \   }\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut usize`\n  --> /tmp/tmpk242nfmr.rs:18:13\n   |\n18 |             occurrences.entry(k).or_insert(0usize)\
    \ += 1;\n   |             --------------------------------------^^^^^\n   |  \
    \           |\n   |             cannot use `+=` on type `&mut usize`\n   |\nhelp:\
    \ `+=` can be used on `usize`, you can dereference `occurrences.entry(k).or_insert(0usize)`\n\
    \   |\n18 |             *occurrences.entry(k).or_insert(0usize) += 1;\n   |  \
    \           +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpk242nfmr.rs:18:52\n\
    \   |\n18 |             occurrences.entry(k).or_insert(0usize) += 1;\n   |   \
    \          -------------------------------------- ^^\n   |             |\n   |\
    \             cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk242nfmr.rs:24:5\n   |\n12 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n24 |     occurrences\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `HashMap<_, isize>`\n              found struct `HashMap<_, usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letter_counts: HashMap<String, isize> = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ letter_counts.entry(letter).or_insert(0);\n        *count += 1;\n    }\n   \
    \ letter_counts\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpyk_py6m5.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut count_map: HashMap<String, isize> = HashMap::new();\n\
    \    for letter in test.split(\" \").map(String::to_lowercase).collect::<Vec<_>>()\
    \ {\n        let count = count_map.entry(letter).or_insert(0);\n        *count\
    \ += 1;\n    }\n\n    count_map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `to_lowercase` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpv2ym676p.rs:14:47\n\
    \   |\n14 |     for letter in test.split(\" \").map(String::to_lowercase).collect::<Vec<_>>()\
    \ {\n   |                                               ^^^^^^^^^^^^ function\
    \ or associated item not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test.chars().group_by(|c| c).count().collect()\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpjr8_0y5a.rs:13:18\n   |\n13 |     test.chars().group_by(|c|\
    \ c).count().collect()\n   |                  ^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n\n    for letter in test.chars().flat_map(|c|\
    \ c.to_string()) {\n        *histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n    --> /tmp/tmpu_jbuybs.rs:15:41\n\
    \     |\n15   |     for letter in test.chars().flat_map(|c| c.to_string()) {\n\
    \     |                                -------- ^^^^^^^^^^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n     |              \
    \                  |\n     |                                required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `String`\n     = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `String`\nnote: required by a bound in `flat_map`\n\n\
    error[E0277]: `String` is not an iterator\n  --> /tmp/tmpu_jbuybs.rs:15:19\n \
    \  |\n15 |     for letter in test.chars().flat_map(|c| c.to_string()) {\n   |\
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\nnote: required by a bound in `FlatMap`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut counts: HashMap<String, isize> = HashMap::new();\n   \
    \ for ch in test.chars() {\n        let count = counts.entry(ch).or_insert(0);\n\
    \        *count += 1;\n    }\n    counts\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpplyi5b0z.rs:15:34\n   |\n\
    15 |         let count = counts.entry(ch).or_insert(0);\n   |                \
    \                  ^^- help: try using a conversion method: `.to_string()`\n \
    \  |                                  |\n   |                                \
    \  expected struct `String`, found `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    for ch in test.chars().cloned()\
    \ {\n        map.entry(ch).or_insert(0) += 1;\n    }\n    map\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpxa2rh0s7.rs:14:28\n     |\n14   |     for ch in test.chars().cloned()\
    \ {\n     |                            ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpxa2rh0s7.rs:14:15\n\
    \   |\n14 |     for ch in test.chars().cloned() {\n   |               ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpxa2rh0s7.rs:14:15\n   |\n14 |     for ch in test.chars().cloned()\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmpxa2rh0s7.rs:15:9\n   |\n15 |         map.entry(ch).or_insert(0)\
    \ += 1;\n   |         --------------------------^^^^^\n   |         |\n   |  \
    \       cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `map.entry(ch).or_insert(0)`\n   |\n15 |\
    \         *map.entry(ch).or_insert(0) += 1;\n   |         +\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpxa2rh0s7.rs:15:36\n   |\n15 |  \
    \       map.entry(ch).or_insert(0) += 1;\n   |         --------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0271, E0368."
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut char_histogram: HashMap<String, isize> = HashMap::new();\n\
    \    let mut chars = test.chars();\n    let mut count = 0;\n    let mut max_count\
    \ = 0isize;\n    let mut max_chars = test;\n\n    for char in chars.by_ref() {\n\
    \        if char_histogram.contains_key(char) {\n            char_histogram.entry(char).or_insert(0)\
    \ += 1;\n            count += 1;\n            if char_histogram.value_ref() >\
    \ max_count {\n                max_count = char_histogram.value_ref();\n     \
    \           max_chars = test;\n            }\n        } else {\n            char_histogram.insert(char,\
    \ 1isize);\n            count += 1;\n        }\n    }\n\n    for key, value in\
    \ char_histogram.iter_mut().enumerate() {\n        if value >= max_count {\n \
    \           max_count = value;\n            max_chars = test;\n        }\n   \
    \ }\n\n    char_histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: unexpected `,` in pattern\n  --> /tmp/tmpdfwjjvx9.rs:33:12\n   |\n\
    33 |     for key, value in char_histogram.iter_mut().enumerate() {\n   |     \
    \       ^\n   |\nhelp: try adding parentheses to match on a tuple\n   |\n33 |\
    \     for (key, value) in char_histogram.iter_mut().enumerate() {\n   |      \
    \   +          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdfwjjvx9.rs:20:40\n\
    \   |\n20 |         if char_histogram.contains_key(char) {\n   |             \
    \                           ^^^^\n   |                                       \
    \ |\n   |                                        expected reference, found `char`\n\
    \   |                                        help: consider borrowing here: `&char`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdfwjjvx9.rs:21:34\n   |\n21 |\
    \             char_histogram.entry(char).or_insert(0) += 1;\n   |            \
    \                      ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                  |\n   |                               \
    \   expected struct `String`, found `char`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut isize`\n  --> /tmp/tmpdfwjjvx9.rs:21:13\n\
    \   |\n21 |             char_histogram.entry(char).or_insert(0) += 1;\n   |  \
    \           ---------------------------------------^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be\
    \ used on `isize`, you can dereference `char_histogram.entry(char).or_insert(0)`\n\
    \   |\n21 |             *char_histogram.entry(char).or_insert(0) += 1;\n   | \
    \            +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdfwjjvx9.rs:21:53\n\
    \   |\n21 |             char_histogram.entry(char).or_insert(0) += 1;\n   |  \
    \           --------------------------------------- ^^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror[E0599]: no method named\
    \ `value_ref` found for struct `HashMap` in the current scope\n  --> /tmp/tmpdfwjjvx9.rs:23:31\n\
    \   |\n23 |             if "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histo = HashMap::new();\n\n    for char in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        let count = histo.entry(char).or_insert(0);\n\
    \        *count += 1;\n    }\n    histo\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpuh_24l3g.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // Split the test string into a Vec<String> of the individual\
    \ letters.\n    let mut letters = test.chars().collect::<Vec<String>>();\n   \
    \ // Initialize a HashMap from the letters.\n    let mut histogram = letters.iter().cloned().collect::<HashMap<String,\
    \ isize>>();\n    // Add the letters to the histogram as long as there are repetitions.\n\
    \    while let Some(letter) = letters.iter().max(|a, b| {\n            histogram.contains_key(&b).unwrap_or(false)\n\
    \        }) {\n        histogram.insert(letter, histogram.get(&letter)?.clone()\
    \ + 1);\n        // Remove letters from the HashMap as long as the count is not\
    \ zero.\n        letters.retain(|letter| histogram.contains_key(&letter).unwrap_or(false));\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmplmua5d2d.rs:14:36\n     |\n14\
    \   |     let mut letters = test.chars().collect::<Vec<String>>();\n     |   \
    \                                 ^^^^^^^ value of type `Vec<String>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0277]: a value of type `HashMap<String, isize>` cannot\
    \ be built from an iterator over elements of type `String`\n    --> /tmp/tmplmua5d2d.rs:16:49\n\
    \     |\n16   |     let mut histogram = letters.iter().cloned().collect::<HashMap<String,\
    \ isize>>();\n     |                                                 ^^^^^^^ value\
    \ of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented\
    \ for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\nerror[E0599]:\
    \ no method named `unwrap_or` found for type `bool` in the current scope\n  -->\
    \ /tmp/tmplmua5d2d.rs:19:40\n   |\n19 |             histogram.contains_key(&b).unwrap_or(false)\n\
    \   |                                        ^^^^^^^^^ method not found in `bool`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmplmua5d2d.rs:18:45\n     |\n18   |       while let Some(letter)\
    \ = letters.iter().max(|a, b| {\n     |  _____________________________________________^^^_-\n\
    \     | |                                             |\n     | |            \
    \                                 expected 0 arguments\n19   | |             histogram.contains_key(&b).unwrap_or(false)\n\
    20   | |         }) {\n     | |_________- supplied 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplmua5d2d.rs:21:26"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    test\n        .chars()\n        .chain(ascii_lowercase().chars())\n\
    \        .fold(HashMap::new(), |mut map, letter| {\n            map.entry(letter).or_insert(0)\n\
    \                .and_modify(|x| { x += 1 });\n            map\n        })\n \
    \       .cloned()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ascii_lowercase` in this scope\n  -->\
    \ /tmp/tmpvhr1e2i9.rs:15:16\n   |\n15 |         .chain(ascii_lowercase().chars())\n\
    \   |                ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `and_modify` found for mutable reference `&mut {integer}` in\
    \ the current scope\n  --> /tmp/tmpvhr1e2i9.rs:18:18\n   |\n18 |             \
    \    .and_modify(|x| { x += 1 });\n   |                  ^^^^^^^^^^ method not\
    \ found in `&mut {integer}`\n\nerror[E0599]: `HashMap<char, {integer}>` is not\
    \ an iterator\n   --> /tmp/tmpvhr1e2i9.rs:21:10\n    |\n21  |           .cloned()\n\
    \    |            ^^^^^^ `HashMap<char, {integer}>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `HashMap<char,\
    \ {integer}>: Iterator`\n            which is required by `&mut HashMap<char,\
    \ {integer}>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut count = HashMap::new();\n\n    let mut splitted = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut split = splitted.split_whitespace();\n\
    \    split.pop(); // remove the last empty string\n\n    let mut i = 0;\n    split.for_each(|c|\
    \ {\n        count.entry(c).or_insert(0) += 1;\n        i += 1;\n    });\n\n \
    \   count\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_whitespace` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmp0jxlowth.rs:16:30\n   |\n16 |     let mut\
    \ split = splitted.split_whitespace();\n   |                              ^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `split_at`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmp0jxlowth.rs:21:9\n   |\n21 |         count.entry(c).or_insert(0)\
    \ += 1;\n   |         ---------------------------^^^^^\n   |         |\n   | \
    \        cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `count.entry(c).or_insert(0)`\n   |\n21\
    \ |         *count.entry(c).or_insert(0) += 1;\n   |         +\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp0jxlowth.rs:21:37\n   |\n\
    21 |         count.entry(c).or_insert(0) += 1;\n   |         ---------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for c in test.chars()\
    \ {\n        histogram.entry(c.to_string()).or_insert(0) += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmplf6zxiyp.rs:15:9\n   |\n15 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n15 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmplf6zxiyp.rs:15:53\n\
    \   |\n15 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram = HashMap::new();\n    for c in test.chars()\
    \ {\n        histogram.insert(c.to_string(), histogram.get(&c).unwrap_or_else(||\
    \ 0) + 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n\
    \   --> /tmp/tmpg4e6p44b.rs:15:51\n    |\n15  |         histogram.insert(c.to_string(),\
    \ histogram.get(&c).unwrap_or_else(|| 0) + 1);\n    |                        \
    \                           ^^^ the trait `Borrow<char>` is not implemented for\
    \ `String`\n    |\n    = help: the trait `Borrow<str>` is implemented for `String`\n\
    note: required by a bound in `HashMap::<K, V, S>::get`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg4e6p44b.rs:15:77\n   |\n15 |         histogram.insert(c.to_string(),\
    \ histogram.get(&c).unwrap_or_else(|| 0) + 1);\n   |                         \
    \                                                    ^\n   |                 \
    \                                                            |\n   |         \
    \                                                                    expected\
    \ reference, found integer\n   |                                             \
    \                                help: consider borrowing here: `&0`\n   |\n \
    \  = note: expected reference `&_`\n                   found type `{integer}`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut letters = test.chars().map(|c| c.to_string());\n    letters.sort_by(|a,\
    \ b| a.cmp(b));\n    letters.into_iter().group_by(|c| c).count().collect()\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmptj6h0_d8.rs:14:13\n   |\n14 |     letters.sort_by(|a, b|\
    \ a.cmp(b));\n   |             ^^^^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmptj6h0_d8.rs:13:40:\
    \ 13:57]>`\n\nerror[E0599]: no method named `group_by` found for struct `Map`\
    \ in the current scope\n  --> /tmp/tmptj6h0_d8.rs:15:25\n   |\n15 |     letters.into_iter().group_by(|c|\
    \ c).count().collect()\n   |                         ^^^^^^^^ method not found\
    \ in `Map<Chars<'_>, [closure@/tmp/tmptj6h0_d8.rs:13:40: 13:57]>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histo = HashMap::new();\n    let mut words = test.chars().collect::<Vec<_>>();\n\
    \    histo\n        .into_iter()\n        .max_by_key(|k, _| words.iter().count(|w|\
    \ w == k));\n    histo\n}\n\nfn main() {\n    let candidate = histogram;\n   \
    \ assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0593]: closure is expected to take 1 argument, but it takes 2 arguments\n\
    \  --> /tmp/tmpj7wh0cvo.rs:17:10\n   |\n17 |         .max_by_key(|k, _| words.iter().count(|w|\
    \ w == k));\n   |          ^^^^^^^^^^ ------ takes 2 arguments\n   |         \
    \ |\n   |          expected closure that takes 1 argument\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpj7wh0cvo.rs:17:41\n\
    \    |\n17  |         .max_by_key(|k, _| words.iter().count(|w| w == k));\n  \
    \  |                                         ^^^^^ ---------- supplied 1 argument\n\
    \    |                                         |\n    |                      \
    \                   expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0593.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // Split the string into a vector of characters.\n    let mut\
    \ tests = test.split_whitespace();\n\n    // Initialize a HashMap of <letter,\
    \ isize>.\n    let mut histogram = HashMap::<String, isize>::new();\n\n    //\
    \ Fill the histogram with occurrences of each letter.\n    for (i, item) in tests.iter().enumerate()\
    \ {\n        // If the current letter is already in the histogram, increment its\
    \ count.\n        if histogram.contains_key(&item) {\n            histogram.insert(*item,\
    \ histogram.get_mut(item).unwrap() + 1);\n        } else {\n            // Otherwise,\
    \ add the letter to the histogram.\n            histogram.insert(*item, 1);\n\
    \        }\n    }\n\n    // Return the histogram.\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpe6jk9l1o.rs:20:28\n   |\n20 |     for (i,\
    \ item) in tests.iter().enumerate() {\n   |                            ^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0369]: cannot add `{integer}` to\
    \ `&mut isize`\n  --> /tmp/tmpe6jk9l1o.rs:23:70\n   |\n23 |             histogram.insert(*item,\
    \ histogram.get_mut(item).unwrap() + 1);\n   |                               \
    \      -------------------------------- ^ - {integer}\n   |                  \
    \                   |\n   |                                     &mut isize\n \
    \  |\nhelp: `+` can be used on `isize`, you can dereference `histogram.get_mut(item).unwrap()`\n\
    \   |\n23 |             histogram.insert(*item, *histogram.get_mut(item).unwrap()\
    \ + 1);\n   |                                     +\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut occurrences = HashMap::new();\n    let mut tests = test.chars().collect::<Vec<char>>();\n\
    \n    while tests.len() != 0 {\n        // Find first repeated character\n   \
    \     let mut repeated = HashMap::new();\n        for test in tests {\n      \
    \      if occurrences.contains_key(&test) {\n                let occurrence =\
    \ occurrences.remove(&test).unwrap();\n                let new_occurrence = occurrence\
    \ + 1;\n                occurrences.insert(&test, new_occurrence);\n         \
    \       repeated.insert(&test, new_occurrence);\n            }\n        }\n  \
    \      tests = repeated.keys();\n    }\n    occurrences\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpomrn3efl.rs:27:17\n   |\n\
    14 |     let mut tests = test.chars().collect::<Vec<char>>();\n   |          \
    \           ----------------------------------- expected due to this value\n...\n\
    27 |         tests = repeated.keys();\n   |                 ^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `std::collections::hash_map::Keys`\n   |\n   = note:\
    \ expected struct `Vec<char>`\n              found struct `std::collections::hash_map::Keys<'_,\
    \ &char, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpomrn3efl.rs:29:5\n\
    \   |\n12 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n29 |     occurrences\n   |     ^^^^^^^^^^^ expected\
    \ struct `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&char, _>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
