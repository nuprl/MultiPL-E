name: HumanEval_27_flip_case
language: rust
prompt: "/// For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n/// >>> flip_case('Hello')\n/// 'hELLO'\nfn flip_case(string: String)\
  \ -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\
  \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")),\
  \ String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent\
  \ delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\"));\n}\n"
completions: ["    let mut iter = string.chars().collect::<Vec<_>>();\n    for (i,\
    \ c) in iter.iter_mut().enumerate() {\n        *c = if i == 0 || c < 'a' || c\
    \ > 'z' {\n            c + 'A' - 'a'\n        } else {\n            c + 'a' -\
    \ 'A'\n        };\n    }\n    String::from_utf8(iter).unwrap()", "    let mut\
    \ string = string\n        .chars()\n        .map(|c| match c {\n            c\
    \ => match c {\n                'A' | 'a' => c == 'a' ? 'A' : 'a',\n         \
    \       _ => c,\n            },\n        })\n        .collect::<String>();\n\n\
    \    string.to_lowercase();\n    string.to_uppercase();\n    string", "    let\
    \ mut result = String::new();\n    for c in string.chars() {\n        if c.is_uppercase()\
    \ {\n            result.push((c as Char).to_lowercase());\n        } else {\n\
    \            result.push((c as Char).to_uppercase());\n        }\n    }\n    result",
  "    string\n        .chars()\n        .map(|c| match c {\n            c @ b'A'\
    \ as b'a' => b'a' as b'A',\n            c @ b'a' as b'A' => b'a' as b'A',\n  \
    \          c => c,\n        })\n        .collect::<String>()", "    string.chars().map(|c|\
    \ match c {\n        'A' .. 'Z' => c + 'a' - 'A',\n        'a' .. 'z' => c + 'A'\
    \ - 'a',\n        _ => c,\n    }).collect::<String>()", "    string.chars().map(|c|\
    \ match c {\n        'a' => c == 'A' ? 'B' : 'a',\n        'B' => c == 'a' ? 'A'\
    \ : 'B',\n        _ => c,\n    })\n    .collect::<String>()", "    string.chars()\n\
    \        .map(|c| match c {\n            c if c.is_lowercase() => c.to_uppercase(),\n\
    \            c if c.is_uppercase() => c.to_lowercase(),\n            _ => c,\n\
    \        })\n        .collect()", "    string.chars().map(|c| match c {\n    \
    \    'a' ..= 'A'\n        'b' ..= 'B'\n        'c' ..= 'C'\n        'd' ..= 'D'\n\
    \        'e' ..= 'E'\n        'f' ..= 'F'\n        'g' ..= 'G'\n        'h' ..=\
    \ 'H'\n        'i' ..= 'I'\n        'j' ..= 'J'\n        'k' ..= 'K'\n       \
    \ 'l' ..= 'L'\n        'm' ..= 'M'\n        'n' ..= 'N'\n        'o' ..= 'O'\n\
    \        'p' ..= 'P'\n        'q' ..= 'Q'\n        'r' ..= 'R'\n        's' ..=\
    \ 'S'\n        't' ..= 'T'\n        'u' ..= 'U'\n        'v' ..= 'V'\n       \
    \ 'w' ..= 'W'\n        'x' ..= 'X'\n        'y' ..= 'Y'\n        'z' ..= 'Z'\n\
    \        _ => c.to_string(),\n    }).collect()", "    string\n        .to_lowercase()\n\
    \        .chars()\n        .map(|c| match c {\n            c if c >= 'A' && c\
    \ <= 'Z' => c + 'a' - 'A' as u8,\n            c if c >= 'a' && c <= 'z' => c +\
    \ 'A' as u8,\n            _ => c,\n        })\n        .collect()", "    string.chars()\n\
    \        .map(|c| match c {\n            c @ b'A'..=b'Z' => c @ b'a'..=b'z',\n\
    \            c @ b'a'..=b'z' => c @ b'A'..=b'Z',\n            _ => c,\n      \
    \  })\n        .collect()", "    string\n        .chars()\n        .map(|c| c.to_ascii_lowercase().to_ascii_uppercase())\n\
    \        .collect::<String>()", "    string.chars().map(|c| match c {\n      \
    \  c if c.is_uppercase() => c.to_lowercase(),\n        c if c.is_lowercase() =>\
    \ c.to_uppercase(),\n        _ => c,\n    })\n    .collect()", "    string.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').map(|c| *c + 32).collect()\n        .to_string() + string.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').map(|c| *c - 32).collect()\n        .to_string()", " \
    \   // Return original string if all characters are lowercase.\n    if string.chars().all(|c|\
    \ *c >= 'a' && *c <= 'z') {\n        return string;\n    }\n\n    // Create a\
    \ buffer to store our result.\n    let mut buffer = vec![];\n\n    // Iterate\
    \ over each character in the string.\n    for (i, c) in string.chars().enumerate()\
    \ {\n        // Ignore non-alpha characters.\n        if *c < 'a' || *c > 'z'\
    \ {\n            continue;\n        }\n\n        // Flip character in string and\
    \ store in buffer.\n        *c = match &string[i] {\n            'a' ..= 'z' =>\
    \ c + 'A' - 'a'.to_ascii_lowercase(),\n            'A' ..= 'Z' => c + 'a' - 'A'.to_ascii_uppercase(),\n\
    \            _ => c,\n        };\n\n        // Add character to our buffer.\n\
    \        buffer.push(&string[i]);\n    }\n\n    // Return our result string.\n\
    \    String::from_utf8(buffer.into_iter().collect())", "    string.chars()\n \
    \       .map(|c| match c {\n            c if c.is_lowercase() => c.to_uppercase(),\n\
    \            _ => c.to_lowercase(),\n        })\n        .collect()", "    string\n\
    \        .chars()\n        .map(|c| match c {\n            'a' .. 'z' => c + '_'.to_string(),\n\
    \            'A' .. 'Z' => c + '_'.to_string(),\n            _ => c,\n       \
    \ })\n        .collect()", "    string\n        .chars()\n        .map(|c| match\
    \ c {\n            'a' .. 'z' => Char::Upper,\n            'A' .. 'Z' => Char::Lower,\n\
    \            _ => c,\n        })\n        .collect()", "    let mut res = string;\n\
    \    res.chars()\n        .map(|c| if c == 'A' { 'a' } else if c == 'a' { 'A'\
    \ } else { c })\n        .for_each(|c| res = res.replace(c, c));\n    res", " \
    \   string.chars()\n        .map(|c| match c.to_ascii_lowercase().to_ascii_uppercase()\
    \ {\n            Some(upper) => upper.to_ascii_lowercase(),\n            None\
    \ => c.to_ascii_uppercase(),\n        })\n        .collect()", "    let mut result\
    \ = String::new();\n    let mut string = string.to_string();\n    for ch in string.chars()\
    \ {\n        let c = match ch {\n            b'a' => {\n                match\
    \ ch {\n                    b'a' => b'A',\n                    b'b' => b'B',\n\
    \                    b'c' => b'C',\n                    b'd' => b'D',\n      \
    \              b'e' => b'E',\n                    b'f' => b'F',\n            \
    \        b'g' => b'G',\n                    b'h' => b'H',\n                  \
    \  b'i' => b'I',\n                    b'j' => b'J',\n                    b'k'\
    \ => b'K',\n                    b'l' => b'L',\n                    b'm' => b'M',\n\
    \                    b'n' => b'N',\n                    b'o' => b'O',\n      \
    \              b'p' => b'P',\n                    b'q' => b'Q',\n            \
    \        b'r' => b'R',\n                    b's' => b'S',\n                  \
    \  b't' => b'T',\n                    b'u' => b'U',\n                    b'v'\
    \ => b'V',\n                    b'w' => b'W',\n                    b'x' => b'X',\n\
    \                    b'y' => b'Y',\n                    b'z' => b'Z',\n      \
    \          }\n            }\n            b'A' => {\n                match ch {\n\
    \                    b'a' => b'a',\n                    b'b' => b'b',\n      \
    \              b'c' => b'c',\n                    b'd' => b'd',\n            \
    \        b'e' => b'e',\n                    b'f' => b'f',\n                  \
    \  b'g' => b'g',\n                    b'h' => b'h',\n                    b'i'\
    \ => b'i',\n                    b'j' => b'j',\n                    b'k' => b'k',\n\
    \                    b'l' => b'l',\n                    b'm' => b'm',\n      \
    \              b'n' => b'n',\n                    b'o' => b'o',\n            \
    \        b'p' => b'p',\n                    b'q' => b'q',\n                  \
    \  b'r' => b'r',\n                    b's' => b's',\n                    b't'\
    \ => b't',\n                    b'u' => b'u',\n                    b'v' => b'v',\n\
    \                    b'w' => b'w',\n                    b'x' => b'x',\n      \
    \              b'y' => b'y',\n                    b'z' => b'z',\n            \
    \    }\n            }\n            b => b,\n        };\n        result.push(c);\n\
    \    }\n    result", "    string.chars()\n        .map(|c| match c {\n       \
    \     'a' => (c as u32).to_ascii_lowercase().to_ascii_uppercase(),\n         \
    \   'A' => (c as u32).to_ascii_uppercase().to_ascii_lowercase(),\n           \
    \ _ => c,\n        })\n        .collect::<String>()", "    string.to_lowercase()\n\
    \        .rev()\n        .to_uppercase()\n        .rev()", "    let mut out =\
    \ String::with_capacity(string.len());\n    for c in string.chars() {\n      \
    \  if c.is_lowercase() {\n            out.push_uppercase();\n        } else {\n\
    \            out.push_lowercase();\n        }\n    }\n    out", "    string.chars()\n\
    \        .chain(string.chars().map(|c| if c >= 'A' && c <= 'Z' { 'A' } else {\
    \ c }))\n        .chain(string.chars().map(|c| if c >= 'a' && c <= 'z' { 'a' }\
    \ else { c }))\n        .collect()", '    string.to_ascii_lowercase().to_ascii_uppercase().into()',
  '    string.chars().enumerate().map(|(_, c)| (*c as char).to_ascii_lowercase()).collect::<String>().join("")',
  "    match string.chars() {\n        \"\" => string,\n        _ => string.to_uppercase().to_lowercase()\n\
    \    }", "    string.chars().map(|c| {\n        let (lower, upper) = match c {\n\
    \            ' ' => ('A' as usize, 'Z' as usize),\n            'a' => ('a', 'z'),\n\
    \            'A' => ('A', 'Z'),\n            _ => (c, c),\n        };\n      \
    \  upper + lower\n    }).collect()", "    let mut chars = string.to_lowercase();\n\
    \    for ch in chars.chars().rev() {\n        chars.insert(ch, chars.chars().find(|c|\
    \ *c != ch).unwrap());\n    }\n    chars", '    string.chars().chain(|c| if c.is_lowercase()
    { c.to_uppercase() } else { c.to_lowercase() })', "    let mut string = string.to_lowercase();\n\
    \    let mut iter = string.chars();\n    iter.for_each(|c| if c.is_upper() {\n\
    \        string = string.to_uppercase();\n    }\n    else {\n        string =\
    \ string.to_lowercase();\n    });\n    string", "    string.chars()\n        .map(|c|\
    \ match c {\n            'A'..='Z' => c + 'a' - 'a',\n            'a'..='z' =>\
    \ c + 'A' - 'A',\n            _ => c,\n        })\n        .collect()", "    string.chars().fold(String::new(),\
    \ |mut acc, c| {\n        if c.is_lower() {\n            acc.push(c.to_uppercase());\n\
    \        } else {\n            acc.push(c.to_lowercase());\n        }\n      \
    \  acc\n    })", "    let mut string = string.to_owned();\n    let mut buffer\
    \ = String::new();\n    for c in string.chars() {\n        if c.is_lowercase()\
    \ {\n            buffer.push(c.to_uppercase());\n        } else {\n          \
    \  buffer.push(c.to_lowercase());\n        }\n    }\n    buffer", "    string.chars()\n\
    \        .map(|c| if c.is_uppercase() { c.to_lowercase() } else { c.to_uppercase()\
    \ })\n        .collect()", "    string.chars().map(|c| match c {\n        c if\
    \ c.is_lowercase() => c.to_uppercase().to_string(),\n        c => c.to_lowercase().to_string(),\n\
    \    }).collect()", "    string.chars().map(|c| match c {\n        'A' .. 'Z'\
    \ | 'a' .. 'z' => c + c.to_ascii_lowercase(),\n        _ => c.to_ascii_uppercase(),\n\
    \    })\n    .collect()", "    match string.chars() {\n        chars => {\n  \
    \          let mut char_iter = chars.clone().map(|c| match c {\n             \
    \   c if c.is_ascii_lowercase() => c,\n                c if c.is_ascii_uppercase()\
    \ => c.to_ascii_lowercase(),\n                c => c.to_ascii_uppercase(),\n \
    \           });\n            char_iter = char_iter.chain(char_iter.map(|c| match\
    \ c {\n                c if c.is_ascii_uppercase() => c,\n                c if\
    \ c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n                c => c.to_ascii_lowercase(),\n\
    \            }));\n            char_iter.collect()\n        }\n    }", "    string\n\
    \        .chars()\n        .map(|c| match c {\n            c if c.is_lowercase()\
    \ => c.to_uppercase(),\n            c if c.is_uppercase() => c.to_lowercase(),\n\
    \            c => c,\n        })\n        .collect()", "    string.chars().map(|c|\
    \ match c {\n        c @ _ => c.to_upper(),\n        c => c.to_lower(),\n    }).collect()",
  "    string.chars().map(|c|\n        match c {\n            'a' .. 'z' => c.to_ascii_lowercase(),\n\
    \            _ => c.to_ascii_uppercase(),\n        }\n    ).collect()", "    string.chars()\n\
    \        .map(|c| if c.is_lowercase() || c.is_uppercase() { c } else { c.to_uppercase()\
    \ })\n        .collect()", "    match string.chars().map(|c| {\n        match\
    \ c {\n            c if c.is_lowercase() => c.to_uppercase(),\n            c if\
    \ c.is_uppercase() => c.to_lowercase(),\n            _ => c,\n        }\n    })\
    \ {\n        Some(ref mut result) => result.to_string(),\n        None => string,\n\
    \    }", "    match string.chars() {\n        Some(c) if c.is_lowercase() | c.is_uppercase()\
    \ => c.to_string().to_uppercase().to_string(),\n        _ => string,\n    }",
  "    string.chars().map(|c| match c {\n        c @ b'a' .. b'z' => b'A' ^ b'a' ^\
    \ b'z',\n        c @ b'A' .. b'Z' => b'a' ^ b'A' ^ b'Z',\n        _ => c,\n  \
    \  }).collect()", '    string.chars().map(|c| if c == c.to_lowercase() || c ==
    c.to_uppercase() { c.to_lowercase() } else { c }).collect()', "    string.chars()\n\
    \        .map(|c| if c == 'A' { 'B' } else if 'a' { 'b' } else { c })\n      \
    \  .collect()", "    // For each character in string\n    for ch in string.chars()\
    \ {\n        // if character is uppercase\n        if ch.is_uppercase() {\n  \
    \          // change to lowercase\n            ch.to_lowercase()\n        } else\
    \ {\n            // change to uppercase\n            ch.to_uppercase()\n     \
    \   }\n    }", '    string.chars().map(|c| if c.is_lowercase() => c.to_uppercase()
    else c.to_lowercase()).collect()', "    match string.chars() {\n        None =>\
    \ string,\n        Some(s) => match s.to_ascii_lowercase() {\n            None\
    \ => string,\n            Some(s) => s.to_ascii_uppercase(),\n        },\n   \
    \ }", "    string.chars().map(|c| match c {\n        'A'..='Z' => c as u8 | 64\
    \ as u8,\n        'a'..='z' => c as u8 | 97 as u8,\n        _ => c,\n    }).collect()",
  "    // Loop over string char by char\n    for c in string.chars() {\n        match\
    \ c {\n            // Lowercase letter\n            c if c.is_lowercase() => c.to_uppercase(),\n\
    \            // Uppercase letter\n            c if c.is_uppercase() => c.to_lowercase(),\n\
    \            _ => c,\n        }\n    }", "    string\n        .chars()\n     \
    \   .map(|c| match c {\n            'a' .. 'z' => c.to_ascii_lowercase(),\n  \
    \          _ => c.to_ascii_uppercase(),\n        })\n        .collect()", '    string.chars().map(|c|
    if c.is_lower() then c.to_uppercase() else c.to_lowercase()).collect()', "   \
    \ // Find the index of the last non-lowercase character in the string.\n    let\
    \ last_index = string.find_last_not_ascii_lowercase();\n\n    // If there is no\
    \ non-lowercase character in the string, just return the\n    // string with no\
    \ changes.\n    if last_index == string::npos {\n        return string;\n    }\n\
    \n    // Create two substrings, one from zero to last_index, and one from last_index\
    \ to\n    // the end of the string.\n    let first_half = string.to_string().split_last_mut().take(last_index\
    \ as usize);\n    let second_half = string.to_string().split_last_mut().skip(last_index\
    \ as usize);\n\n    // Swap the cases of the substrings, combining the two substrings\
    \ into the\n    // returned string.\n    first_half.swap(second_half);\n\n   \
    \ // Concatenate the two substrings back together into the return string.\n  \
    \  first_half.concat(&second_half).to_string()", "    string.to_lowercase().chars().map(|c|\
    \ match c {\n        'a' => \"A\",\n        'b' => \"B\",\n        'c' => \"C\"\
    ,\n        'd' => \"D\",\n        'e' => \"E\",\n        'f' => \"F\",\n     \
    \   'g' => \"G\",\n        'h' => \"H\",\n        'i' => \"I\",\n        'j' =>\
    \ \"J\",\n        'k' => \"K\",\n        'l' => \"L\",\n        'm' => \"M\",\n\
    \        'n' => \"N\",\n        'o' => \"O\",\n        'p' => \"P\",\n       \
    \ 'q' => \"Q\",\n        'r' => \"R\",\n        's' => \"S\",\n        't' =>\
    \ \"T\",\n        'u' => \"U\",\n        'v' => \"V\",\n        'w' => \"W\",\n\
    \        'x' => \"X\",\n        'y' => \"Y\",\n        'z' => \"Z\",\n       \
    \ 'A' => \"a\",\n        'B' => \"b\",\n        'C' => \"c\",\n        'D' =>\
    \ \"d\",\n        'E' => \"e\",\n        'F' => \"f\",\n        'G' => \"g\",\n\
    \        'H' => \"h\",\n        'I' => \"i\",\n        'J' => \"j\",\n       \
    \ 'K' => \"k\",\n        'L' => \"l\",\n        'M' => \"m\",\n        'N' =>\
    \ \"n\",\n        'O' => \"o\",\n        'P' => \"p\",\n        'Q' => \"q\",\n\
    \        'R' => \"r\",\n        'S' => \"s\",\n        'T' => \"t\",\n       \
    \ 'U' => \"u\",\n        'V' => \"v\",\n        'W' => \"w\",\n        'X' =>\
    \ \"x\",\n        'Y' => \"y\",\n        'Z' => \"z\",\n        _ => c,\n    }).collect()",
  "    string.chars().map(|c| match c {\n        c if ('A' <= c && c <= 'Z') => (c\
    \ as u8 - ('a' as u8) as u8) as char,\n        c if ('a' <= c && c <= 'z') =>\
    \ (c as u8 - ('A' as u8) as u8) as char,\n        _ => c,\n    }).collect()",
  "    string.chars().chain(\n        |c| match c {\n            c if c.is_lowercase()\
    \ => c.to_uppercase(),\n            c if c.is_uppercase() => c.to_lowercase(),\n\
    \            _ => c,\n        },\n    )\n    .collect::<String>()", "    string.chars().map(|c|\
    \ match c {\n        'A'..='Z' => c + &'a'..&'z',\n        'a'..='z' => c + &'A'..&'Z',\n\
    \        _ => c,\n    }).collect()", "    string.chars().map(|c| match c {\n \
    \       'A' .. 'Z' => c as u8 | 256 - c,\n        'a' .. 'z' => c as u8 | 256\
    \ - c,\n        _ => c,\n    })\n    .collect()", "    string.chars().map(|c|\
    \ match c {\n        c @ _ if c >= 'A' && c <= 'Z' => (c - 'A' + 'a' as u8) as\
    \ char,\n        c @ _ => (c - 'a' as u8) as char,\n        c => c,\n    })\n\
    \    .collect()", "    string\n        .chars()\n        .map(|c| (c as u32).to_ascii_uppercase().to_string())\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| c.to_string().to_ascii_lowercase())\n\
    \        .collect::<Vec<_>>()\n        .concat()", "    string.chars().map(|c|\n\
    \        c.to_ascii_lowercase()\n            .iter()\n            .fold(c, |mut\
    \ current, _| current.to_ascii_uppercase())\n            .collect()\n    )", " \
    \   if let (index, char) = string.chars().enumerate().find(|(_, c)| c.is_uppercase())\
    \ {\n        string.chars().rev().enumerate().find(|(_, i), _| i > index).map(|(_,\
    \ c)| c.to_lowercase()).unwrap_or(char)\n    } else {\n        string\n    }",
  "    string.chars().map(|c| match c {\n        c @ b'A' as b => b'A' as b'a' ||\
    \ b'a' as b,\n        c @ b'a' as b => b'a' as b'A' || b'A' as b,\n        _ =>\
    \ c,\n    }).collect()", "    string\n        .chars()\n        .map(|c| match\
    \ c {\n            c @ b'A' as b'a' => b'a' as b'A'\n            c @ b'a' as b'a'\
    \ => b'a' as b'a'\n            _ => c\n        })\n        .collect::<String>()",
  "    string.chars()\n        .map(|c| match c {\n            c @ 'a' @ 'A' => c\
    \ as u8 | 0x20,\n            c @ 'b' @ 'B' => c as u8 | 0x40,\n            c @\
    \ 'c' @ 'C' => c as u8 | 0x60,\n            c @ 'd' @ 'D' => c as u8 | 0x80,\n\
    \            c @ 'e' @ 'E' => c as u8 | 0xA0,\n            c @ 'f' @ 'F' => c\
    \ as u8 | 0xC0,\n            c @ 'g' @ 'G' => c as u8 | 0xE0,\n            c @\
    \ 'h' @ 'H' => c as u8 | 0xF0,\n            _ => c,\n        })\n        .collect()",
  "    string.chars()\n        .map(|c| if c.is_lowercase() && !c.is_uppercase() {\
    \ c } else { c.to_uppercase() })\n        .collect::<String>()", "    let mut\
    \ string = string.to_string();\n    for c in string.chars() {\n        match c\
    \ {\n            'A'..='Z' => string.push_str(c.to_ascii_uppercase()),\n     \
    \       'a'..='z' => string.push_str(c.to_ascii_lowercase()),\n            _ =>\
    \ string.push_str(c),\n        }\n    }\n    string", "    string.chars().map(|c|\n\
    \        match c {\n            'a' .. 'z' => c.to_uppercase(),\n            'A'\
    \ .. 'Z' => c.to_lowercase(),\n            _ => c,\n        }\n    ).collect()",
  "    string.chars()\n        .map(|c| match c {\n            'a' => String::from('z'),\n\
    \            'z' => String::from('A'),\n            _ => c,\n        })\n    \
    \    .collect()", "    match string {\n        \"a\" => \"A\",\n        \"b\"\
    \ => \"B\",\n        \"c\" => \"C\",\n        \"d\" => \"D\",\n        \"e\" =>\
    \ \"E\",\n        \"f\" => \"F\",\n        \"g\" => \"G\",\n        \"h\" => \"\
    H\",\n        \"i\" => \"I\",\n        \"j\" => \"J\",\n        \"k\" => \"K\"\
    ,\n        \"l\" => \"L\",\n        \"m\" => \"M\",\n        \"n\" => \"N\",\n\
    \        \"o\" => \"O\",\n        \"p\" => \"P\",\n        \"q\" => \"Q\",\n \
    \       \"r\" => \"R\",\n        \"s\" => \"S\",\n        \"t\" => \"T\",\n  \
    \      \"u\" => \"U\",\n        \"v\" => \"V\",\n        \"w\" => \"W\",\n   \
    \     \"x\" => \"X\",\n        \"y\" => \"Y\",\n        \"z\" => \"Z\",\n    \
    \    _ => string,\n    }", "    string\n        .chars()\n        .map(|c| if\
    \ c.is_lowercase() { c.to_uppercase() } else { c.to_lowercase() })\n        .collect::<String>()",
  "    string.chars()\n        .map(|c| match c {\n            c @ b'A' => (c as usize\
    \ - b'A' + b'a') as char,\n            c @ b'a' => (c as usize - b'a' + b'A')\
    \ as char,\n            c => c,\n        })\n        .collect::<String>()", " \
    \   string.chars().map(|c| match c {\n        'A'..='Z' => c + '_',\n        'a'..='z'\
    \ => c + '_',\n        '0'..='9' => c + '_',\n        _ => c,\n    }).collect()",
  "    string.chars().map(|c| match c {\n        c if c.is_upper() => c.to_ascii_lowercase(),\n\
    \        c if c.is_lower() => c.to_ascii_uppercase(),\n        _ => c,\n    }).collect()",
  "    string.chars()\n        .map(|c| if c.is_lowercase() then c.to_uppercase()\
    \ else c.to_lowercase())\n        .collect::<String>()", "    string\n       \
    \ .chars()\n        .map(|c| match c {\n            c if c.is_lowercase() => c.to_uppercase(),\n\
    \            c if c.is_uppercase() => c.to_lowercase(),\n            _ => c,\n\
    \        })\n        .collect()", "    string.chars()\n        .map(|c| match\
    \ c {\n            'a' .. 'z' => c + 'A' - 'a'.to_ascii_lowercase(),\n       \
    \     'A' .. 'Z' => c + 'a' - 'A'.to_ascii_lowercase(),\n            _ => c,\n\
    \        })\n        .collect()", "    string.chars().map(|c| match c {\n    \
    \    c if c.is_upper() => c.to_ascii_uppercase().to_string(),\n        c if c.is_lower()\
    \ => c.to_ascii_lowercase().to_string(),\n        c => c.to_string(),\n    }).collect()",
  "    if string.is_empty() {\n        return string;\n    }\n    let mut lowercase\
    \ = string;\n    let mut uppercase = string;\n    let mut char_index = 0;\n  \
    \  while char_index < string.len() {\n        if lowercase[char_index].is_lowercase()\
    \ {\n            uppercase[char_index] = uppercase[char_index].to_uppercase();\n\
    \        } else {\n            lowercase[char_index] = lowercase[char_index].to_lowercase();\n\
    \        }\n        char_index += 1;\n    }\n    lowercase", "    string\n   \
    \     .chars()\n        .map(|c| if c.is_uppercase() => c.to_lowercase() else\
    \ c.to_uppercase())\n        .collect()", "    match string.chars() {\n      \
    \  \"\" => string,\n        _ => string.chars().map(|c| match c {\n          \
    \  'a' | ' ' | 'A' => c.to_uppercase(),\n            'b' | ' ' | 'B' => c.to_lowercase(),\n\
    \            _ => c,\n        }).collect::<String>().into_owned(),\n    }", " \
    \   // Create a slice from the string slice.\n    let mut slice = string[..].to_lowercase();\n\
    \    slice = slice.chars().map(|c| if c.is_uppercase() {\n        c ^ 0x20\n \
    \   } else {\n        c\n    }).collect();\n    slice.iter().cloned().collect::<String>().to_lowercase()",
  "    string.chars().map(|c| match c {\n        'A' | 'a' => c.to_ascii_uppercase(),\n\
    \        'B' | 'b' => c.to_ascii_lowercase(),\n        _ => c.to_string(),\n \
    \   }).collect::<String>().to_ascii_lowercase()", "    string.chars()\n      \
    \  .map(|c| match c {\n            c if c.is_lowercase() => c.to_uppercase(),\n\
    \            c if c.is_uppercase() => c.to_lowercase(),\n            _ => c,\n\
    \        })\n        .collect()", "    string.chars().fold1(|mut c, _| {\n   \
    \     match c {\n            c if c.is_upper() => c.to_ascii_lowercase(),\n  \
    \          c if c.is_lower() => c.to_ascii_uppercase(),\n            _ => c,\n\
    \        }\n    })", "    string.chars().fold(String::new(), |s, c| s.push_str(c.to_ascii_uppercase()));\n\
    \    string.chars().fold(String::new(), |s, c| s.push_str(c.to_ascii_lowercase()));\n\
    \    s", '    string.chars().map(|c| if c.is_lower() then c.to_upper() else c.to_lower()).collect()',
  "    string.chars()\n        .chain(string.chars().map(|c| match c.to_ascii_lowercase()\
    \ {\n            Some(mut c) => c.to_ascii_uppercase(),\n            None => c,\n\
    \        }))\n        .collect::<String>()", "    string\n        .chars()\n \
    \       .map(|c| if c.is_lowercase() then c.to_uppercase() else c.to_lowercase())\n\
    \        .collect()", '    string.chars().map(|c| if c.is_upper() { c.to_lowercase()
    } else { c.to_uppercase() }).collect()', "    // Special case for the empty string\n\
    \    if string.is_empty() {\n        String::new()\n    } else {\n        let\
    \ mut buffer = String::new();\n        for c in string.chars() {\n           \
    \ if c.is_uppercase() {\n                buffer.push(c.to_lowercase());\n    \
    \        } else {\n                buffer.push(c.to_uppercase());\n          \
    \  }\n        }\n        buffer\n    }", "    string.chars()\n        .map(|c|\
    \ match c {\n            c @ _ if c.is_uppercase() => c.to_lowercase(),\n    \
    \        c @ _ if c.is_lowercase() => c.to_uppercase(),\n            _ => c,\n\
    \        })\n        .collect()", '    string.chars().map(|c| if c.is_lowercase()
    { c } else { c.to_uppercase() }).collect::<String>()', "    let mut buffer = String::new();\n\
    \n    for ch in string.chars() {\n        match ch {\n            'a' .. 'z' =>\
    \ buffer.push_str(&ch.to_string().to_uppercase()),\n            'A' .. 'Z' =>\
    \ buffer.push_str(&ch.to_string().to_lowercase()),\n            ch => buffer.push_str(&ch.to_string()),\n\
    \        }\n    }\n\n    buffer", "    string.chars()\n        .map(|c| match\
    \ c {\n            'a' => {\n                'A' as u8\n            }\n      \
    \      'b' => {\n                'B' as u8\n            }\n            'c' =>\
    \ {\n                'C' as u8\n            }\n            'd' => {\n        \
    \        'D' as u8\n            }\n            'e' => {\n                'E' as\
    \ u8\n            }\n            'f' => {\n                'F' as u8\n       \
    \     }\n            'g' => {\n                'G' as u8\n            }\n    \
    \        'h' => {\n                'H' as u8\n            }\n            'i' =>\
    \ {\n                'I' as u8\n            }\n            'j' => {\n        \
    \        'J' as u8\n            }\n            'k' => {\n                'K' as\
    \ u8\n            }\n            'l' => {\n                'L' as u8\n       \
    \     }\n            'm' => {\n                'M' as u8\n            }\n    \
    \        'n' => {\n                'N' as u8\n            }\n            'o' =>\
    \ {\n                'O' as u8\n            }\n            'p' => {\n        \
    \        'P' as u8\n            }\n            'q' => {\n                'Q' as\
    \ u8\n            }\n            'r' => {\n                'R' as u8\n       \
    \     }\n            's' => {\n                'S' as u8\n            }\n    \
    \        't' => {\n                'T' as u8\n            }\n            'u' =>\
    \ {\n                'U' as u8\n            }\n            'v' => {\n        \
    \        'V' as u8\n            }\n            'w' => {\n                'W' as\
    \ u8\n            }\n            'x' => {\n                'X' as u8\n       \
    \     }\n            'y' => {\n                'Y' as u8\n            }\n    \
    \        'z' => {\n                'Z' as u8\n            }\n            _ =>\
    \ {\n                'a' as u8\n            }\n        })\n        .collect()",
  "    string\n        .chars()\n        .map(|c| match c {\n            'a' | 'A'\
    \ => c.to_ascii_uppercase(),\n            'b' | 'B' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        })\n        .collect()", "    string.chars().map(|c|\
    \ match c {\n        'a' .. 'z' => c as u32 + 32 as u32,\n        _ => c,\n  \
    \  }).collect()", "    let mut chars = string.chars();\n\n    let mut result =\
    \ String::with_capacity(string.len());\n\n    for (char) in chars {\n        let\
    \ char_cap = char.to_ascii_lowercase();\n        let char_cap_up = char.to_ascii_uppercase();\n\
    \n        if char_cap != char_cap_up {\n            result.push(*char);\n    \
    \    } else {\n            result.push(*char_cap_up);\n        }\n    }\n\n  \
    \  result", "    let mut lowercase = String::new();\n    let mut uppercase = String::new();\n\
    \n    for c in string.chars() {\n        if c.is_lowercase() {\n            lowercase.append(c);\n\
    \        } else {\n            uppercase.append(c);\n        }\n    }\n\n    lowercase.append(uppercase)",
  "    // Step 1. Split string to chars\n    let char_array = string.chars().collect();\n\
    \n    // Step 2. Flip each char\n    for char in char_array {\n        char.swap();\n\
    \    }\n\n    // Step 3. Join chars to String\n    string.join(\"\")", "    string.chars().map(|c|\
    \ match c {\n        'a' .. 'z' => c as u8 - 'a' as u8,\n        'A' .. 'Z' =>\
    \ c as u8 - 'A' as u8,\n        _ => c,\n    }).collect::<String>().to_owned()",
  "    match string.len() {\n        0 => \"\",\n        _ => {\n            let mut\
    \ string = string.to_string();\n            for (i, char) in string.chars().enumerate()\
    \ {\n                let is_uppercase = (char >= 'a' && char <= 'z') || (char\
    \ >= 'A' && char <= 'Z');\n                if is_uppercase {\n               \
    \     string.swap(i, i + 1);\n                }\n            }\n            string\n\
    \        }\n    }", "    string\n        .chars()\n        .map(|c| if c == 'a'\
    \ { 'A' } else if c == 'b' { 'B' } else if c == 'c' { 'C' } else if c == 'd' {\
    \ 'D' } else if c == 'e' { 'E' } else if c == 'f' { 'F' } else if c == 'g' { 'G'\
    \ } else if c == 'h' { 'H' } else if c == 'i' { 'I' } else if c == 'j' { 'J' }\
    \ else if c == 'k' { 'K' } else if c == 'l' { 'L' } else if c == 'm' { 'M' } else\
    \ if c == 'n' { 'N' } else if c == 'o' { 'O' } else if c == 'p' { 'P' } else if\
    \ c == 'q' { 'Q' } else if c == 'r' { 'R' } else if c == 's' { 'S' } else if c\
    \ == 't' { 'T' } else if c == 'u' { 'U' } else if c == 'v' { 'V' } else if c ==\
    \ 'w' { 'W' } else if c == 'x' { 'X' } else if c == 'y' { 'Y' } else if c == 'z'\
    \ { 'Z' }else c)\n        .collect::<String>()", "    string.chars().map(|c| *c\
    \ < *c + '_' if c.is_upper() || *c < *c + '_').collect()", "    string\n     \
    \   .chars()\n        .chain()\n        .map(|c| match c {\n            'A'..='Z'\
    \ => c.to_ascii_lowercase(),\n            'a'..='z' => c.to_ascii_uppercase(),\n\
    \            _ => c,\n        })\n        .collect()", "    // Convert to lower\
    \ case first.\n    string.to_lowercase().chars()\n        .map(|c| match c {\n\
    \            c => c,\n            'a' => { 'A' },\n            'e' => { 'E' },\n\
    \            'i' => { 'I' },\n            'o' => { 'O' },\n            'u' =>\
    \ { 'U' },\n            _ => { 'a' }, // Any other character should be converted\
    \ to its uppercase equivalent.\n        })\n        .collect::<String>()\n   \
    \     .to_uppercase()", "    string.chars()\n        .map(|c| match c {\n    \
    \        c if c.is_lowercase() => c.to_uppercase(),\n            c if c.is_uppercase()\
    \ => c.to_lowercase(),\n            _ => c,\n        })\n        .collect()",
  "    string.chars().map(|c| match c {\n        'A'..='Z' => c - 'a',\n        'a'..='z'\
    \ => c + 0x5f - 'A'.to_ascii_lowercase().chars().unwrap(),\n        _ => c,\n\
    \    }).collect()", "    string.chars().map(|c| match c {\n        'A' => { 'a'\
    \ }\n        'B' => { 'b' }\n        'C' => { 'c' }\n        'D' => { 'd' }\n\
    \        'E' => { 'e' }\n        'F' => { 'f' }\n        'G' => { 'g' }\n    \
    \    'H' => { 'h' }\n        'I' => { 'i' }\n        'J' => { 'j' }\n        'K'\
    \ => { 'k' }\n        'L' => { 'l' }\n        'M' => { 'm' }\n        'N' => {\
    \ 'n' }\n        'O' => { 'o' }\n        'P' => { 'p' }\n        'Q' => { 'q'\
    \ }\n        'R' => { 'r' }\n        'S' => { 's' }\n        'T' => { 't' }\n\
    \        'U' => { 'u' }\n        'V' => { 'v' }\n        'W' => { 'w' }\n    \
    \    'X' => { 'x' }\n        'Y' => { 'y' }\n        'Z' => { 'z' }\n        _\
    \ => c,\n    })\n    .collect::<String>() + string", "    let mut result = string;\n\
    \    let mut buffer = String::with_capacity(result.chars().count());\n    for\
    \ &c in result.chars() {\n        if c.is_lowercase() {\n            buffer.push(c.to_uppercase());\n\
    \        } else {\n            buffer.push(c.to_lowercase());\n        }\n   \
    \ }\n    result.resize(buffer.len(), 0);\n    result", "    string\n        .chars()\n\
    \        .map(|c| if c.is_lowercase() { c.to_uppercase() } else { c.to_lowercase()\
    \ })\n        .collect::<String>()", "    string.to_lowercase().chars().map(|c|\
    \ if c == 'a' { 'A' } else if c == 'e' { 'E' } else if c == 'i' { 'I' } else if\
    \ c == 'o' { 'O' } else if c == 'u' { 'U' } else c ).collect::<String>().join(\"\
    \")", "    string.to_lowercase().chars().map(|c| match c {\n        'a' .. 'z'\
    \ => c,\n        'A' .. 'Z' => c + ('A' as u8)\n    })\n        .collect::<String>()\n\
    \        .to_uppercase()", "    string.to_lowercase().chars().collect::<String>().chain(|c|\
    \ {\n        match c {\n            'a' => \"A\".to_string(),\n            'b'\
    \ => \"B\".to_string(),\n            'c' => \"C\".to_string(),\n            'd'\
    \ => \"D\".to_string(),\n            'e' => \"E\".to_string(),\n            'f'\
    \ => \"F\".to_string(),\n            'g' => \"G\".to_string(),\n            'h'\
    \ => \"H\".to_string(),\n            'i' => \"I\".to_string(),\n            'j'\
    \ => \"J\".to_string(),\n            'k' => \"K\".to_string(),\n            'l'\
    \ => \"L\".to_string(),\n            'm' => \"M\".to_string(),\n            'n'\
    \ => \"N\".to_string(),\n            'o' => \"O\".to_string(),\n            'p'\
    \ => \"P\".to_string(),\n            'q' => \"Q\".to_string(),\n            'r'\
    \ => \"R\".to_string(),\n            's' => \"S\".to_string(),\n            't'\
    \ => \"T\".to_string(),\n            'u' => \"U\".to_string(),\n            'v'\
    \ => \"V\".to_string(),\n            'w' => \"W\".to_string(),\n            'x'\
    \ => \"X\".to_string(),\n            'y' => \"Y\".to_string(),\n            'z'\
    \ => \"Z\".to_string(),\n            _ => c.to_string(),\n        }\n    })",
  "    string.chars().fold(String::new(), |mut c, _| {\n        c += match c.to_lowercase().to_uppercase()\
    \ {\n            'A' => { 'a' },\n            'a' => { 'A' },\n            _ =>\
    \ unreachable!(),\n        };\n        c\n    })", "    let mut s = string.to_lowercase();\n\
    \    s.to_uppercase();\n    s", "    // TODO: implement me\n    \"\".to_string()",
  "    string.chars().map(|c| match c {\n        c @ _ if c.is_ascii_lowercase() =>\
    \ c.to_ascii_uppercase(),\n        c @ _ if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n\
    \        c => c\n    }).collect()", "    string.chars()\n        .map(|c| match\
    \ c {\n            'A' | 'a' => 'A',\n            'B' | 'b' => 'B',\n        \
    \    'C' | 'c' => 'C',\n            'D' | 'd' => 'D',\n            'E' | 'e' =>\
    \ 'E',\n            'F' | 'f' => 'F',\n            'G' | 'g' => 'G',\n       \
    \     'H' | 'h' => 'H',\n            'I' | 'i' => 'I',\n            'J' => 'J',\n\
    \            'K' | 'k' => 'K',\n            'L' | 'l' => 'L',\n            'M'\
    \ | 'm' => 'M',\n            'N' | 'n' => 'N',\n            'O' | 'o' => 'O',\n\
    \            'P' | 'p' => 'P',\n            'Q' | 'q' => 'Q',\n            'R'\
    \ | 'r' => 'R',\n            'S' | 's' => 'S',\n            'T' => 't',\n    \
    \        'U' | 'u' => 'U',\n            'V' => 'V',\n            'W' => 'W',\n\
    \            'X' => 'X',\n            'Y' => 'Y',\n            'Z' => 'Z',\n \
    \           '_' => '_',\n            c => c,\n        })\n        .collect::<String>()",
  "    string.to_lowercase().chars().map(|c| match c {\n        c if c.is_upper()\
    \ => c.to_uppercase(),\n        c if c.is_lower() => c.to_lowercase(),\n     \
    \   _ => c,\n    }).collect::<String>().to_owned()", "    string.chars().map(|c|\
    \ if c.is_lowercase() { c.to_uppercase() } else { c.to_lowercase() }).collect()\n\
    \        .iter()\n        .map(|c| match c {\n            c => c.to_string(),\n\
    \            _ => c,\n        })\n        .collect::<String>()", "    string.chars().map(|c|\
    \ match c {\n        'A'..='Z' => c,\n        'a'..='z' => c,\n        _ => c,\n\
    \    })\n    .collect::<String>()", "    string\n        .chars()\n        .map(|c|\
    \ match c {\n            'a' ..= 'z' | 'A' ..= 'Z' => {\n                match\
    \ c {\n                    'a' ..= 'A' => {\n                        'A' ..= 'a'\
    \ \n                    }\n                    'b' ..= 'B' => {\n            \
    \            'B' ..= 'b' \n                    }\n                    _ => c\n\
    \                }\n            }\n            _ => c\n        })\n        .collect()",
  "    string\n        .chars()\n        .map(|c| match c {\n            'A' ..= 'Z'\
    \ | 'a' ..= 'z' => c\n        })\n        .chain(string.chars().map(|c| match\
    \ c {\n            'a' ..= 'z' | 'A' ..= 'Z' => c.to_string()\n        }))\n \
    \       .collect()", "    match string.len() {\n        0 => \"\",\n        1\
    \ => string,\n        _ => {\n            let mut s = string;\n            for\
    \ (i, c) in s.chars().enumerate() {\n                if i > 0 && c >= 'a' && c\
    \ <= 'z' {\n                    s.swap(0, i);\n                }\n           \
    \     if i > 0 && c >= 'A' && c <= 'Z' {\n                    s.swap(0, i);\n\
    \                }\n            }\n            s\n        }\n    }", "    string.chars().map(|c|\
    \ match c {\n        'A' | 'a' => match c {\n            'a' => c.to_ascii_uppercase().to_string(),\n\
    \            _ => c,\n        },\n        'B' | 'b' => match c {\n           \
    \ 'b' => c.to_ascii_lowercase().to_string(),\n            _ => c,\n        },\n\
    \        _ => c.to_string(),\n    })\n    .collect()", "    string.chars().fold(String::new(),\
    \ |mut s, c| {\n        match c.to_ascii_lowercase() {\n            Some(c) =>\
    \ s.push_str(&c.to_ascii_uppercase()),\n            None => s.push_str(&c.to_ascii_lowercase()),\n\
    \        }\n    })", "    string.chars()\n        .map(|c| match c {\n       \
    \     c @ 'a' .. 'z' => (c as char).to_uppercase() as char,\n            c @ 'A'\
    \ .. 'Z' => (c as char).to_lowercase() as char,\n            _ => c,\n       \
    \ })\n        .collect()", "    let mut output = String::new();\n\n    for c in\
    \ string.chars() {\n        if c.is_lowercase() {\n            output.push((char::to_uppercase(c).unwrap()).into());\n\
    \        } else {\n            output.push((char::to_lowercase(c).unwrap()).into());\n\
    \        }\n    }\n\n    output", '    string.chars().map(|c| if c.is_lowercase()
    then c.to_uppercase() else c.to_lowercase()).collect()', "    string\n       \
    \ .chars()\n        .filter(|c| c.is_ascii_lowercase())\n        .map(|c| c.to_ascii_lowercase().to_uppercase())\n\
    \        .collect::<String>()\n        .join(\"\")", '    string.to_lowercase().to_uppercase()',
  "    let mut lowercase = string.clone();\n    let mut uppercase = string.clone();\n\
    \    let mut ascii_lowercase = string.clone();\n    let mut ascii_uppercase =\
    \ string.clone();\n\n    for c in lowercase.chars() {\n        if c.is_lowercase()\
    \ {\n            uppercase.set_char(c, c.to_uppercase());\n        }\n       \
    \ if c.is_uppercase() {\n            lowercase.set_char(c, c.to_lowercase());\n\
    \        }\n    }\n    for c in uppercase.chars() {\n        if c.is_lowercase()\
    \ {\n            ascii_lowercase.set_char(c, c.to_ascii_lowercase());\n      \
    \  }\n        if c.is_uppercase() {\n            ascii_uppercase.set_char(c, c.to_ascii_uppercase());\n\
    \        }\n    }\n    uppercase + ascii_uppercase + lowercase + ascii_lowercase",
  '    string.to_lowercase().to_uppercase()', "    string.chars().map(|c| match c\
    \ {\n        'a' .. 'z' => c.to_uppercase(),\n        _ => c.to_lowercase(),\n\
    \    }).collect()", "    string.chars()\n        .map(|c| match c {\n        \
    \    'a' .. 'z' => {\n                c as u8 + 'A' as u8\n            }\n   \
    \         'A' .. 'Z' => {\n                c as u8 + 'a' as u8\n            }\n\
    \            '*' => c\n        })\n        .collect()", "    string\n        .chars()\n\
    \        .map(|c| match c {\n            'a' .. 'z' => c as u8 ^ 0x20,\n     \
    \       'A' .. 'Z' => c as u8 ^ 0x21,\n            _ => c,\n        })\n     \
    \   .collect()", "    match string.chars() {\n        chars => chars.iter().map(|c|\
    \ match c {\n            c if c.is_uppercase() => c.to_lowercase(),\n        \
    \    c => c.to_uppercase(),\n        }).collect(),\n    }", "    string\n    \
    \    .chars()\n        .map(|c| match c {\n            'a' .. 'z' => c as u8 -\
    \ 32 as u8,\n            'A' .. 'Z' => c as u8 + 32 as u8,\n            _ => c,\n\
    \        })\n        .collect()", "    string.chars()\n        .map(|c| c.to_ascii_lowercase().to_string())\n\
    \        .chain(string.chars().map(|c| c.to_ascii_uppercase().to_string()))\n\
    \        .collect()", "    let mut buffer = String::new();\n    for ch in string.chars()\
    \ {\n        match ch {\n            'a' => buffer.push_str(\"A\"),\n        \
    \    'b' => buffer.push_str(\"B\"),\n            'c' => buffer.push_str(\"C\"\
    ),\n            'd' => buffer.push_str(\"D\"),\n            'e' => buffer.push_str(\"\
    E\"),\n            'f' => buffer.push_str(\"F\"),\n            'g' => buffer.push_str(\"\
    G\"),\n            'h' => buffer.push_str(\"H\"),\n            'i' => buffer.push_str(\"\
    I\"),\n            'j' => buffer.push_str(\"J\"),\n            'k' => buffer.push_str(\"\
    K\"),\n            'l' => buffer.push_str(\"L\"),\n            'm' => buffer.push_str(\"\
    M\"),\n            'n' => buffer.push_str(\"N\"),\n            'o' => buffer.push_str(\"\
    O\"),\n            'p' => buffer.push_str(\"P\"),\n            'q' => buffer.push_str(\"\
    Q\"),\n            'r' => buffer.push_str(\"R\"),\n            's' => buffer.push_str(\"\
    S\"),\n            't' => buffer.push_str(\"T\"),\n            'u' => buffer.push_str(\"\
    U\"),\n            'v' => buffer.push_str(\"V\"),\n            'w' => buffer.push_str(\"\
    W\"),\n            'x' => buffer.push_str(\"X\"),\n            'y' => buffer.push_str(\"\
    Y\"),\n            'z' => buffer.push_str(\"Z\"),\n            _ => buffer\n \
    \               .push_str(\n                    char::to_lowercase(&ch)\n    \
    \                    .chain(char::to_uppercase(&ch))\n                       \
    \ .collect::<String>()\n                ),\n        }\n    }\n    buffer", " \
    \   string.chars()\n        .map(|c| match c {\n            c if c.is_uppercase()\
    \ => c.to_lowercase(),\n            _ => c,\n        })\n        .collect()",
  "    let mut buffer = String::new();\n    for ch in string.chars() {\n        if\
    \ ch.is_lowercase() {\n            buffer.push(ch.to_uppercase());\n        }\
    \ else {\n            buffer.push(ch.to_lowercase());\n        }\n    }\n    buffer",
  "    let mut s = string.to_string();\n    for (i, c) in s.chars().enumerate() {\n\
    \        *s = c.to_uppercase() + (*s as char) + c.to_lowercase();\n    }\n   \
    \ s", "    string.chars()\n        .chain(string.chars().map(|c| match c {\n \
    \           c if c.is_ascii() => (char::to_ascii_uppercase(c) as char).to_string(),\n\
    \            _ => (char::to_ascii_lowercase(c) as char).to_string(),\n       \
    \ }))\n        .collect()", "    string.chars().map(|c| match c {\n        'a'\
    \ => (c.to_ascii_lowercase(), c.to_ascii_uppercase()),\n        'A' => (c.to_ascii_uppercase(),\
    \ c.to_ascii_lowercase()),\n        _ => (c, c),\n    })\n    .collect::<String>()",
  "    string.chars().chain().map(|c| c.to_ascii_lowercase()).collect()\n        .iter()\n\
    \        .map(|c| c.to_ascii_uppercase())\n        .collect::<String>()", "  \
    \  string.chars()\n        .map(|c| match c {\n            'a' => (c as u32 +\
    \ 'A' as u32).to_string(),\n            'A' => (c as u32 + 'a' as u32).to_string(),\n\
    \            _ => c,\n        })\n        .collect()", '    string.chars().map(|c|
    if c.is_lowercase() { c.to_uppercase() } else { c.to_lowercase() }).collect()',
  "    string.chars().map(|c| match c {\n        c if c.is_upper() => c.to_ascii_lowercase(),\n\
    \        c if c.is_lower() => c.to_ascii_uppercase(),\n        _ => c,\n    }).collect()",
  "    string.chars()\n        .filter(|c| c >= 'A' && c <= 'Z')\n        .map(|c|\
    \ c + ('A' - 'a'))\n        .collect::<String>()", "    if string.len() == 0 {\n\
    \        return string\n    }\n    let mut result = String::with_capacity(string.len());\n\
    \    let mut current_char = string.chars();\n    loop {\n        if current_char.is_empty()\
    \ {\n            return result;\n        }\n        let next_char = current_char.next().unwrap();\n\
    \        if next_char == char::MINUS_CHAR {\n            result.push('-');\n \
    \           current_char = current_char.clone();\n        } else {\n         \
    \   result.push(next_char.to_uppercase());\n        }\n    }", "    string.chars()\n\
    \        .map(|c| match c {\n            c => match c {\n                'a' =>\
    \ c.to_uppercase(),\n                'A' => c.to_lowercase(),\n              \
    \  _ => c,\n            },\n        })\n        .collect()", "    string.chars()\n\
    \        .map(|c| if c.is_lowercase() { c.to_uppercase() } else { c.to_lowercase()\
    \ })\n        .collect::<String>()", "    string.chars()\n        .map(|c| match\
    \ c {\n            'a' .. 'z' => c.to_uppercase(),\n            'A' .. 'Z' =>\
    \ c.to_lowercase(),\n            _ => c,\n        })\n        .collect()", " \
    \   string\n        .chars()\n        .map(|c| match c {\n            c @ b'A'\
    \ .. b'Z' => b'a' .. b'z' + c\n            c @ b'a' .. b'z' => b'A' .. b'Z' +\
    \ c\n            c => c\n        })\n        .collect()", "    string\n      \
    \  .chars()\n        .map(|c| match c {\n            b'a' | b'z' => c.to_ascii_lowercase(),\n\
    \            b'A' | b'Z' => c.to_ascii_uppercase(),\n            _ => c,\n   \
    \     })\n        .collect()", "    // TODO: Implement this function.\n    fmt.println!(\"\
    Implement me\");\n    string", "    string.chars().chain(\n        char::from_digit(|c|\
    \ char::from(c).to_uppercase().into()),\n    )\n    .chain(char::from_digit(|c|\
    \ char::from(c).to_lowercase().into()))\n    .collect()", "    string.chars()\n\
    \        .map(|c| match c {\n            'a' => { 'A' }\n            'A' => {\
    \ 'a' }\n            'b' => { 'B' }\n            'B' => { 'b' }\n            'c'\
    \ => { 'C' }\n            'C' => { 'c' }\n            _ => { *c }\n        })\n\
    \        .collect()", "    string.chars()\n        .map(|c| match c {\n      \
    \      'a' | ('A'..'Z') => c.to_ascii_uppercase(),\n            _ => c.to_ascii_lowercase(),\n\
    \        })\n        .collect::<String>()", "    string.to_lowercase().chars().map(|c|\
    \ match c {\n        c as char => char.into(),\n        c as u8 => c.to_uppercase().into(),\n\
    \        _ => c,\n    }).collect()", "    string.to_lowercase().chars().map(|c|\
    \ match c {\n        c if c.is_upper() => c.to_uppercase().to_string(),\n    \
    \    c if c.is_lower() => c.to_lowercase().to_string(),\n        c => c.to_string(),\n\
    \    }).collect::<String>().into()", "    string.chars()\n        .map(|c| match\
    \ c {\n            c @ b'a' .. b'z' => b'A' .. b'Z'\n            c @ b'A' .. b'Z'\
    \ => b'a' .. b'z'\n            c => c,\n        })\n        .collect()", "   \
    \ let mut buffer = String::with_capacity(string.len());\n    for ch in string.chars()\
    \ {\n        match ch {\n            c @ cc => buffer.push(c.to_lowercase()),\n\
    \            _ => buffer.push(ch),\n        }\n    }\n    buffer", "    let mut\
    \ buffer = String::new();\n    for (i, c) in string.chars().enumerate() {\n  \
    \      if c.is_lowercase() {\n            buffer.push_str(c.to_uppercase());\n\
    \        } else {\n            buffer.push_str(c.to_lowercase());\n        }\n\
    \    }\n    buffer", "    string.chars().map(|c| match c {\n        'a' .. 'z'\
    \ => {\n            'A' .. 'Z'.to_lowercase()\n        }\n        'A' .. 'Z' =>\
    \ {\n            'a' .. 'z'.to_uppercase()\n        }\n        _ => c,\n    }).collect()",
  "    string.chars().map(|c| match c {\n        c if c.is_ascii() => (c as u8).to_ascii_uppercase().to_string(),\n\
    \        _ => c.to_ascii_lowercase().to_string(),\n    }).collect()", "    string.chars().chain(|c|\
    \ match c {\n        c as u8 => c.to_string().to_uppercase().to_string(),\n  \
    \      c as u16 => c.to_string().to_lowercase().to_string(),\n        c as u32\
    \ => c.to_string().to_uppercase().to_string(),\n        c as u64 => c.to_string().to_lowercase().to_string(),\n\
    \        c as u128 => c.to_string().to_uppercase().to_string(),\n        _ =>\
    \ c.to_string()\n    }).collect::<String>().to_string()", "    string.chars().map(|c|\
    \ c.to_ascii_uppercase().to_string()).collect::<String>().into_iter()\n      \
    \  .chain(string.chars().map(|c| c.to_ascii_lowercase().to_string()).collect::<String>())\n\
    \        .collect::<String>()", "    string\n        .chars()\n        .map(|c|\
    \ match c {\n            c @ b'A' => b'Z',\n            c @ b'a' => b'z',\n  \
    \          c => c,\n        })\n        .collect::<String>()", "    string.chars()\n\
    \        .filter_map(|c| c.to_lowercase())\n        .map(|c| if c.is_uppercase()\
    \ {\n            c.to_uppercase()\n        } else {\n            c\n        })\n\
    \        .collect()", "    string.chars()\n        .map(|c| match c {\n      \
    \      c if c.is_lowercase() => c.to_uppercase(),\n            c if c.is_uppercase()\
    \ => c.to_lowercase(),\n            _ => c,\n        })\n        .collect()",
  "    string.chars()\n        .map(|c| if c.is_lowercase() then c.to_uppercase()\
    \ else c.to_lowercase())\n        .collect()", "    string.chars()\n        .map(|c|\
    \ match c {\n            'A' | 'a' => char::ToUpper(c),\n            'B' | 'b'\
    \ => char::ToLower(c),\n            _ => c,\n        })\n        .collect()",
  "    let mut string = string.to_lowercase();\n    string.chars().for_each(|c| if\
    \ c.is_lowercase() then c.to_uppercase() else c.to_lowercase())\n    .join(\"\"\
    )", "    string.chars()\n        .map(|c| if c == c.to_lower() { c.to_upper()\
    \ } else { c.to_lower() })\n        .collect()", "    string.chars()\n       \
    \ .filter_map(|c| match c {\n            c if c.is_uppercase() => Some(c.to_ascii_lowercase()),\n\
    \            c if c.is_lowercase() => Some(c.to_ascii_uppercase()),\n        \
    \    _ => None,\n        })\n        .collect::<String>()", "    string.chars().map(|c|\
    \ match c {\n        'a' => (c as u32).to_string() + ('z' as u32),\n        'z'\
    \ => (c as u32).to_string() + ('a' as u32),\n        _ => c,\n    }).collect::<String>()",
  "    string\n        .chars()\n        .chain(string.chars().enumerate().map(|(i,\
    \ _)| if i > 0 && i % 2 == 0 { char::from('a').to_uppercase() } else { char::from('A').to_lowercase()\
    \ }))\n        .collect::<String>()", "    let mut new_string: String = \"\".to_string();\n\
    \    for c in string.chars() {\n        if c.is_lowercase() {\n            new_string\
    \ += c.to_uppercase();\n        } else {\n            new_string += c.to_lowercase();\n\
    \        }\n    }\n    new_string", "    string.chars().map(|c| match c {\n  \
    \      c @ 'a' @ 'A' => c as u8,\n        c @ b'A' @ 'a' => c as u8,\n       \
    \ _ => c,\n    }).collect()", "    string.chars().chain(string.chars().map(|c|\
    \ match c {\n        'a' .. 'z' => (c as u8).to_ascii_uppercase() + (c as u8).to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()).collect()", "    string\n        .chars()\n\
    \        .map(|c| match c {\n            'a' .. 'z' => c as char,\n          \
    \  c => c.to_uppercase() as char,\n        })\n        .collect::<String>()",
  "    let mut result = String::with_capacity(string.len());\n    let mut lowercase\
    \ = true;\n    for ch in string.chars() {\n        if !lowercase {\n         \
    \   result += char::to_upper(ch).unwrap();\n        } else {\n            result\
    \ += char::to_lower(ch).unwrap();\n        }\n        lowercase = !lowercase;\n\
    \    }\n    result", "    string.chars().map(|c| match c {\n        'A' .. 'Z'\
    \ => c.to_ascii_uppercase(),\n        'a' .. 'z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect::<String>()", "    string\n        .chars()\n\
    \        .map(|c| match c {\n            'a' => (c as u32).to_ascii_lowercase().into(),\n\
    \            'A' => (c as u32).to_ascii_uppercase().into(),\n            _ =>\
    \ c,\n        })\n        .collect::<String>()", "    string.chars()\n       \
    \ .map(|c| c.to_ascii_lowercase().into())\n        .chain(string.chars().map(|c|\
    \ c.to_ascii_uppercase().into()))\n        .collect()", "    string.chars()\n\
    \        .map(|c| if c.is_upper() { c.to_lower() } else { c.to_upper() })\n  \
    \      .collect()", "    string\n        .chars()\n        .map(|c| match c {\n\
    \            c @ b'a' => b'A'.to_ascii_lowercase()\n            .to_ascii_uppercase()\n\
    \            .to_ascii_lowercase(),\n            _ => c,\n        })\n       \
    \ .collect()", "    string.chars()\n        .map(|c| match c {\n            'a'\
    \ .. 'z' => c.to_uppercase(),\n            _ => c.to_lowercase(),\n        })\n\
    \        .collect()", "    string.chars()\n        .chain(string)\n        .map(|c|\
    \ if c == 'A' { 'a' } else if c == 'a' { 'A' } else { c })\n        .collect::<String>()",
  "    string\n        .chars()\n        .map(|c| match c {\n            c @ b'A'\
    \ as b'a' => b'a' as b'A',\n            c @ b'a' as b'A' => b'A' as b'a',\n  \
    \          _ => c,\n        })\n        .collect::<String>()", "    string.chars().map(|c|\
    \ if c.is_uppercase() || c.is_lowercase() {\n        match c.to_uppercase() {\n\
    \            Some(' ') => ' ',\n            Some(c) => c,\n            None =>\
    \ c.to_lowercase().unwrap(),\n        }\n    } else {\n        c\n    }).collect()",
  "    string.chars()\n        .map(|c| match c {\n            'A' ..= 'Z' | 'a'..=\
    \ 'z' => c.to_ascii_lowercase(),\n            _ => c,\n        })\n        .collect::<String>()",
  "    string.chars()\n        .map(|c| match c {\n            'a' .. 'z' => c + '_',\n\
    \            'A' .. 'Z' => c + '_',\n            _ => c,\n        })\n       \
    \ .collect::<String>()", '    string.chars().map(|c| if c.is_lowercase() then
    c.to_uppercase() else c.to_lowercase()).collect()', "    string.to_lowercase().chars().chain(string.chars().map(|c|\
    \ match c {\n        'a' .. 'z' => c..='A'..'Z',\n        'A' .. 'Z' => c.to_uppercase(),\n\
    \        _ => c,\n    })).collect::<String>() + string.to_uppercase()"]
stop_tokens:
- "\n}"
