name: HumanEval_11_string_xor
language: rust
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
  \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    let mut result = String::new();\n    for (a, b) in zip(a.chars().cloned().collect::<Vec<_>>(),\
    \ b.chars().cloned().collect::<Vec<_>>()) {\n        result.push(a_xor(b));\n\
    \    }\n    result", "    let mut result = String::from(a);\n    result.chars().for_each(|c|\
    \ if a.chars().any(|x| *x == c) *b += c else *b += c);\n    result", "    let\
    \ mut res: String = String::new();\n    for _ in 0..a.len() {\n        res +=\
    \ &a[..];\n    }\n    for _ in 0..b.len() {\n        res += &b[..];\n    }\n \
    \   res.to_string()", "    if a.len() == b.len() {\n        let mut result = Vec::new();\n\
    \        for i in 0..a.len() {\n            result.push(a[i] ^ b[i]);\n      \
    \  }\n        return String::from_utf8(result.to_vec()).unwrap();\n    }\n   \
    \ format!(\"String length error!\", \"{}\", a)", "    assert!(a.len() == b.len());\n\
    \n    let mut res = String::with_capacity(a.len());\n    for i in 0..a.len() {\n\
    \        let c = a[i] ^ b[i];\n        if c > 9 {\n            res.push(c);\n\
    \        } else {\n            res.push('0' + (c as u32));\n        }\n    }\n\
    \n    res", "    let mut result = vec![];\n    let mut carry = 0;\n    for i in\
    \ 0..a.len() {\n        if a.chars().nth(i).unwrap() ^= b.chars().nth(i).unwrap()\
    \ >> 1 {\n            result.push(carry as char);\n            carry = 0;\n  \
    \      } else {\n            result.push(a.chars().nth(i).unwrap());\n       \
    \     carry = 1;\n        }\n    }\n    if carry != 0 {\n        result.push(carry\
    \ as char);\n    }\n    result.into_owned()", "    let mut res = String::new();\n\
    \n    for i in 0..a.len() {\n        res.push_str(if a[i] != '0' && b[i] != '0'\
    \ { b[i] } else { a[i] });\n    }\n\n    res.to_string()", '    format!("{}",
    (a[..].to_owned() & b[..].to_owned()).to_string())', "    debug_assert!(a.len()\
    \ == b.len());\n\n    let mut result = String::new();\n\n    for (ai, bi) in zip(a.chars(),\
    \ b.chars()) {\n        match ai {\n            b'0' => result.push(b'0'),\n \
    \           b'1' => result.push(b'1'),\n            _ => unreachable!(),\n   \
    \     }\n        match bi {\n            b'0' => result.push(b'0'),\n        \
    \    b'1' => result.push(b'1'),\n            _ => unreachable!(),\n        }\n\
    \    }\n\n    result", "    let a = a.as_bytes().to_vec();\n    let b = b.as_bytes().to_vec();\n\
    \    let mut r = vec![0u8; 32];\n    for i in 0..32 {\n        let a = a.binary_vec()[i];\n\
    \        let b = b.binary_vec()[i];\n        r[i] = a ^ b;\n    }\n    r.to_owned().to_string()",
  "    let mut x: Vec<char> = a.chars().collect();\n    let mut y: Vec<char> = b.chars().collect();\n\
    \n    for i in x.iter_mut() {\n        *i ^= *y;\n    }\n\n    let mut result\
    \ = String::new();\n    for i in x.iter_mut() {\n        result .= String::from(*i);\n\
    \    }\n    result", "    if a == \"0\" && b == \"1\" {\n        return \"0\"\n\
    \    }\n    if a == \"1\" && b == \"0\" {\n        return \"1\"\n    }\n    if\
    \ a.len() != b.len() {\n        return \"0\"\n    }\n    let mut res = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        let (ai, bi) = (a[i], b[i]);\n        res.push(ai\
    \ ^ bi);\n    }\n    res", "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .filter(|c| c == '1')\n        .collect::<Vec<_>>()\n        .iter()\n\
    \        .fold(\"\".to_string(), |mut acc, x| {\n            acc + x.to_string();\n\
    \            acc\n        })", "    // Convert to binary array and concatenate\
    \ binary array\n    let a = a.as_bytes();\n    let b = b.as_bytes();\n    let\
    \ mut result = [0; 4];\n    for i in 0..a.len() {\n        result[i as usize]\
    \ ^= a[i as usize] ^ b[i as usize];\n    }\n    // Convert to binary string\n\
    \    let result = format!(\"{:02b}\", result).into_owned();\n    if result.len()\
    \ < 4 { result += \"0\" };\n    result", "    let a_u8 = a.as_bytes();\n    let\
    \ b_u8 = b.as_bytes();\n    String::from_utf8(|bytes| {\n        let mut out =\
    \ Vec::<u8>::with_capacity(bytes);\n        for &b in bytes {\n            out.push((*b)\
    \ ^ (*a_u8));\n        }\n        out.into_iter().collect()\n    })", '    (a
    ^ b).to_string()', "    let mut result = String::new();\n    for c in a.chars()\
    \ {\n        if b[c.0 as usize] != c.1 {\n            result.push(c);\n      \
    \  }\n    }\n    result", '    (a.as_bytes() ^ b.as_bytes()).to_string_lossy().to_string()',
  "    let mut output: String = \"\";\n    for c in a.chars().chain(b.chars()) {\n\
    \        if *c != *c {\n            output += '0'\n        } else {\n        \
    \    output += '1'\n        }\n    }\n    output", "    a.chars().zip(b.chars()).filter_map(|(a,\
    \ b)| {\n        if *a == *b {\n            Ok((*a, *a))\n        } else {\n \
    \           Ok((*a, *b))\n        }\n    }).map(|(a, b)| String::from_utf8(a).unwrap().to_string()).collect()",
  "    let mut result = String::new();\n\n    for i in 0..a.len() {\n        result\
    \ .push_str(&if a.chars().nth(i) == b.chars().nth(i) {\n            '1'\n    \
    \    } else {\n            '0'\n        });\n    }\n\n    result", "    let mut\
    \ res = String::with_capacity(a.len());\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        if *a != *b {\n            res.push_str(&*a);\n        }\n    }\n\
    \    res", "    format!(\"{}{}\", a, b)\n        .chars()\n        .map(|c| if\
    \ c != b'\\x00' { c ^ b'\\x00' } else { b'\\x00' })\n        .collect::<Vec<Char>>()\n\
    \        .iter()\n        .map(String::from)\n        .collect::<String>()", " \
    \   let mut a = a.to_string();\n    let mut b = b.to_string();\n    while a.len()\
    \ >= b.len() {\n        a.pop();\n        b.pop();\n    }\n    while a.len() <\
    \ b.len() {\n        a.push('0');\n        b.push('0');\n    }\n    a.chars().zip(b.chars()).filter(|(&xa,\
    \ &xb)| xa != xb).map(|(&xa, &xb)| xa ^ xb).collect()", "    String::from_utf8(string_a_b(a)\
    \ ^ string_a_b(b))\n        .expect(\"failed to convert a_b result to String\"\
    )", "    assert!(b.len() == a.len(), \"input strings must have equal length\"\
    );\n    let mut result = String::with_capacity(a.len());\n    for (a, b) in zip(a.chars(),\
    \ b.chars()) {\n        if a != b {\n            result.push(a);\n        }\n\
    \    }\n    result", "    let mut a = a.to_owned();\n    let mut b = b.to_owned();\n\
    \    for (ix, elt) in a.iter().enumerate() {\n        *elt ^= *b[ix];\n    }\n\
    \    String::from(a)", "    let mut x: String = \"\".to_string();\n    let mut\
    \ y: String = \"\".to_string();\n    let mut r: String = \"\".to_string();\n\n\
    \    for i in 0..a.len() {\n        match a.chars().nth(i) {\n            '1'\
    \ => x += '0',\n            '0' => y += '0',\n            _ => panic!(),\n   \
    \     }\n    }\n\n    for i in 0..b.len() {\n        match b.chars().nth(i) {\n\
    \            '1' => x += '0',\n            '0' => y += '0',\n            _ =>\
    \ panic!(),\n        }\n    }\n\n    x += y;\n\n    for c in x.chars() {\n   \
    \     match c {\n            '0' => r += '1',\n            '1' => r += '0',\n\
    \            _ => panic!(),\n        }\n    }\n\n    r", "    let mut a: Vec<u8>\
    \ = a.as_bytes().to_vec();\n    let mut b: Vec<u8> = b.as_bytes().to_vec();\n\
    \    while a.len() > 0 || b.len() > 0 {\n        if a.len() == 0 {\n         \
    \   b.push(0);\n            a.push(0);\n        } else if b.len() == 0 {\n   \
    \         a.push(0);\n            b.push(0);\n        }\n        if a.last() ^\
    \ b.last() != 0 {\n            a.push(0);\n            b.push(0);\n        }\n\
    \    }\n    String::from_utf8_lossy(&a).unwrap()", "    let mut res = String::new();\n\
    \    for _ in 0..a.len() {\n        res.push_str(&b[a as usize] ^ b[(b as usize)\
    \ + 1]);\n        (b as usize) += 2;\n    }\n    res", "    let mut r = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n         \
    \   r.push('a');\n        } else {\n            r.push('0');\n        }\n    }\n\
    \    r", '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<String>()',
  "    if a.len() != b.len() {\n        panic!(\"Cannot xor string with non-matching\
    \ lengths. {} != {}\", a.len(), b.len());\n    }\n    let mut res = String::new();\n\
    \    for (x, y) in a.chars().zip(b.chars()) {\n        *res += if x == y { x }\
    \ else { x ^ y };\n    }\n    res", "    a.iter().zip(b.iter()).map(|(x, y)| {\n\
    \        let mut c = 0u8;\n        for x in x {\n            c ^= 1u8 & y;\n \
    \       }\n        c\n    }).collect::<String>(\"\")", "    let mut result: String\
    \ = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n        *result\
    \ |= c1 ^ *c2;\n    }\n    result", "    let mut res = String::new();\n    for\
    \ i in a.chars() {\n        res.push_str(&b[i % b.len()]);\n    }\n    res", '    String::from(format!("{:b}",
    a ^ b).to_string())', '    String::from(binary_xor_of_string(&a.chars(), &b.chars()).collect::<String>())',
  '    String::from("").into_iter().zip(b.into_iter()).filter(|(a, b)| a != b).map(|(a,
    b)| a.to_string()).collect::<Vec<_>>().join("")', "    let mut xor = String::new();\n\
    \    for &(ref ai, ref bi) in a.chars().zip(b.chars()) {\n        xor.push(*ai\
    \ ^ *bi);\n    }\n    xor", '    a.to_owned() & b.to_owned()', "    if a.len()\
    \ != b.len() {\n        panic!(\"length of input strings must be equal\");\n \
    \   }\n    let mut result = vec![];\n    for i in 0..a.len() {\n        result.append(a[i]\
    \ ^ b[i]);\n    }\n    result.into()", "    let mut s = String::new();\n    for\
    \ i in 0..a.len() {\n        s.push_str(a.chars().nth(i).unwrap().to_string());\n\
    \    }\n    for i in 0..b.len() {\n        s.push_str(b.chars().nth(i).unwrap().to_string());\n\
    \    }\n    s", "    let mut res = String::new();\n\n    for c in a.chars() {\n\
    \        if b.get(c) != '0' {\n            res.push_str(&format!(\"{:02}\", c));\n\
    \        } else {\n            res.push(c);\n        }\n    }\n\n    for c in\
    \ b.chars() {\n        if a.get(c) != '0' {\n            res.push_str(&format!(\"\
    {:02}\", c));\n        } else {\n            res.push(c);\n        }\n    }\n\n\
    \    res", '    bincode::bin_xor_i64(a.as_bytes(), b.as_bytes()).to_string()',
  '    String::from_utf8(a.encode_utf8() ^ b.encode_utf8()).unwrap()', '    a + &b[..std::cmp::min(a.len(),
    b.len())].iter().map(|&c| c.to_ne_byte()).sum::<u8>()', "    let mut sum: u32\
    \ = 0;\n    for i in a.chars().take(32).chain(b.chars().take(32)) {\n        sum\
    \ += i;\n    }\n    String::from_be_bytes(sum).to_string()", '    format!("{}{}",
    a, b).to_string()', "    if a.len() != b.len() {\n        panic!(\n          \
    \  \"Input strings a and b must have equal length. a: {}, b: {}\",\n         \
    \   a,\n            b\n        );\n    }\n\n    let mut res = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        match a.get(i) {\n            None => res.push_str(\"\
    0\"),\n            Some('0' | '1' | 'x') => {\n                match b.get(i)\
    \ {\n                    None => res.push_str(\"0\"),\n                    Some('0'\
    \ | '1' | 'x') => {\n                        let c = b'.get(i);\n            \
    \            let x = a.chars().nth(i).unwrap();\n                        let y\
    \ = b.chars().nth(i).unwrap();\n                        if c == '0' && x == '0'\
    \ && y == '0' {\n                            res.push_str(\"0\");\n          \
    \              }\n                        else if c == '0' && x == '0' && y !=\
    \ '0' {\n                            res.push_str(\"1\");\n                  \
    \      }\n                        else if c != '0' && x == '0' && y == '0' {\n\
    \                            res.push_str(&String::from(\"1\"));\n           \
    \             }\n                        else if c != '0' && x == '0' && y !=\
    \ '0' {\n                            res.push_str(&String::from(\"0\"));\n   \
    \                     }\n                        else if c != '0' && x != '0'\
    \ && y == '0' {\n                            res.push_str(&String::from(\"1\"\
    ));\n                        }\n                        else if c != '0' && x\
    \ != '0' && y != '0' {\n                            res.push_str(&String::from(\"\
    0\"));\n                        }\n                        else if c == '0' &&\
    \ x != '0' && y == '0' {\n                            res.push_str(&String::from(\"\
    1\"));\n                        }\n                        else if c == '0' &&\
    \ x != '0' && y != '0' {\n                            res.push_str(&String::from(\"\
    0\"));\n                        }\n                        else if c != '0' &&\
    \ x != '0' && y == '0' {\n                            res.push_str(&String::from(\"\
    1\"));\n                        }\n                        else if c != '0' &&\
    \ x != '0' && y != '0' {\n                            res.push_str(&String::from(\"\
    0\"));\n                        }\n                        else if c != '0' &&\
    \ x == '0' && y != '0' {\n                            res.push_str(&String::from(\"\
    1\"));\n                        }\n                        else if c != '0' &&\
    \ x == '0' && y == '0' {\n                            res.push_str(&String::from(\"\
    0\"));\n                        }\n                        else if c != '0' &&\
    \ x != '0' && y != '0' {\n                            ", '    string_to_int(a)
    ^ string_to_int(b)', "    if a == \"0000\" && b == \"0000\" {\n        return\
    \ a;\n    }\n    let mut res = String::new();\n    for i in (0..a.len() - 1) {\n\
    \        if a[i] != b[i] {\n            res.push_str(&format!(\"{}1\", a[i]));\n\
    \        }\n    }\n    res.push_str(&format!(\"{}1\", a[i]));\n    res.trim_end_matches('1');\n\
    \    res", "    binary_xor_iter(a, b, |&(a, b), &(b, rest)| {\n        if a !=\
    \ '0' || b != '0' {\n            a ^ b\n        } else {\n            rest\n \
    \       }\n    })", '    binary_xor_string::binary_xor_string(a, b)', "    assert_eq!(a.len(),\
    \ b.len());\n    assert!(a.is_ascii());\n    assert!(b == '0' || b == '1');\n\
    \    let mut res = Vec::new();\n    for i in a.chars().iter().rev().take(b.len()).cloned()\
    \ {\n        res.insert(0, *i ^ *b);\n    }\n    String::from_utf8(res)", "  \
    \  let mut res = String::new();\n    for &b in b.chars().skip(1) {\n        if\
    \ a.chars().any(|c| c == b) {\n            res.push_str(&b);\n        } else {\n\
    \            res.push_str(&a);\n        }\n    }\n    res.push_str(&a)", "   \
    \ a.chars().zip(b.chars()).fold(String::new(), |mut acc, (a, b)| {\n        let\
    \ c = a + b;\n        acc.push_str(c.to_digit(10).to_string());\n        acc\n\
    \    })", "    let mut res = vec![];\n    for i in 0..a.len() {\n        match\
    \ a[i] {\n            '0' => {\n                match b[i] {\n               \
    \     '1' => {\n                        res.push('a');\n                    },\n\
    \                    '0' => {\n                        res.push('b');\n      \
    \              }\n                }\n            },\n            '1' => {\n  \
    \              match b[i] {\n                    '1' => {\n                  \
    \      res.push('b');\n                    },\n                    '0' => {\n\
    \                        res.push('a');\n                    }\n             \
    \   }\n            },\n            _ => {}\n        }\n    }\n    res.collect()",
  "    // TODO: Check if string inputs are valid\n    let a = a.to_string();\n   \
    \ let b = b.to_string();\n    let mut result = \"\";\n    for &b in &b[..] {\n\
    \        result += '0' if *b == '1' else '1';\n    }\n    for &a in &a[..] {\n\
    \        result += '0' if *a == '1' else '1';\n    }\n    result", "    let mut\
    \ ret = String::new();\n    for (i, c) in a.chars().enumerate() {\n        if\
    \ b[i as usize] != c {\n            ret += c;\n        }\n    }\n    ret", " \
    \   let mut result = String::new();\n    for &c in &a { result.push((c ^ &b[0])\
    \ as char); }\n    for &c in &b { result.push((c ^ &a[0]) as char); }\n    result",
  "    assert!(\n        a.len() == b.len(),\n        \"Input strings must be same\
    \ length\",\n    );\n    let mut res = String::new();\n    for ch in a.chars()\
    \ {\n        res.push_str(&ch.to_string() ^ b.chars().next().unwrap().to_string());\n\
    \    }\n    res", "    if a.len() == 0 || b.len() == 0 {\n        \"\".to_string()\n\
    \    } else {\n        a.to_string() + b.to_string()\n    }", "    // If any one\
    \ is empty return empty string.\n    if a.is_empty() || b.is_empty() {\n     \
    \   return \"\";\n    }\n    if a.len() != b.len() {\n        return \"\";\n \
    \   }\n    let mut res: String = \"\";\n    let mut a_iter = a.chars();\n    let\
    \ mut b_iter = b.chars();\n\n    for a_val in a_iter {\n        if b_iter.any(|b_val|\
    \ a_val != b_val) {\n            break;\n        }\n        res.insert(0, a_val);\n\
    \    }\n    res", "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        let mut j = i;\n        while j < b.len() && b.starts_with(&a[j..]) {\n\
    \            res.push_str(&a[j..]);\n            j += 1; // Move on to the end\
    \ of the next letter\n        }\n        res.push_str(&b[j..]); // Only add chars\
    \ missing from a\n    }\n    res", "    let mut result = vec![];\n    let mut\
    \ len = a.len();\n    let mut carry = 0;\n    let mut a_len = a.chars().count();\n\
    \    let mut b_len = b.chars().count();\n\n    if a_len == 0 || b_len == 0 {\n\
    \        result.append(0);\n        return String::from_utf8(result.as_slice()).unwrap();\n\
    \    }\n\n    // First check for overflow\n    if b_len > a_len {\n        let\
    \ mut b_len = b_len;\n        let mut a_len = a_len;\n        let mut carry =\
    \ 0;\n    }\n\n    // Process the two strings in parallel\n    for i in a_len..(len\
    \ + 1) {\n        let mut a_char = a.chars().nth(i);\n        let mut b_char =\
    \ b.chars().nth(i);\n        // Do the actual XOR\n        let res = a_char.wrapping_xor(&b_char);\n\
    \        // Append result to result\n        result.append(res);\n        // Remember\
    \ the carry for the next iteration\n        carry = ((*res) + carry) & 0xff;\n\
    \    }\n\n    // If carry is > 0 add it to the result, if not, just move the result\
    \ to the end\n    if carry > 0 {\n        result.append(carry);\n    }\n\n   \
    \ // Reverse result\n    result.reverse();\n\n    return String::from_utf8(result.as_slice()).unwrap();",
  "    let mut result = String::new();\n    let mut carry = 0;\n\n    for (ix, &ch)\
    \ in a.chars().enumerate() {\n        let (q, r) = if let Some((x, _)) = b[ix].chars().next()\
    \ {\n            (carry + x * b, 0)\n        } else {\n            ((carry, 1),\
    \ 0)\n        };\n        if q != 0 {\n            result.push_str(&format!(\"\
    {}{}\", ch - '0', q % 10));\n        }\n        carry = r;\n    }\n\n    if carry\
    \ != 0 {\n        result.push_str(&format!(\"{}{}\", ch - '0', carry % 10));\n\
    \    }\n    result", "    let mut res = String::with_capacity(a.size());\n\n \
    \   for i in 0..a.len() {\n        if a[i] != b[i] {\n            res.push_str(&a[..i]);\n\
    \            break;\n        }\n        res.push_str(&b[..i]);\n    }\n\n    res.push_str(&a[a.len()..]);\n\
    \    res.to_string()", "    let mut result = String::new();\n    for i in &a as\
    \ &str {\n        let j = i as char;\n        if &b == &j {\n            result.push(j);\n\
    \        } else {\n            result.push('-');\n        }\n    }\n    result",
  "    a.to_string().chars().chain(b.to_string().chars()).filter(|c| c != '1').collect::<String>()",
  "    let mut result: String = \"\".to_string();\n    for i in (0..a.len() - b.len()).rev()\
    \ {\n        result.push(*a ^ *b + &mut result[i..]);\n    }\n    result", " \
    \   let mut result = String::new();\n    for i in 0..a.len() {\n        result.push_str(&(a[i]\
    \ ^ b[i]));\n    }\n    result", "    String::from(\n        a.to_owned()\n  \
    \          .iter()\n            .chain(b.to_owned().iter())\n            .map(|c|\
    \ c ^ 1)\n            .collect()\n            .collect::<String>() + b.to_owned().to_owned()\n\
    \    )", "    let mut result = String::new();\n    for i in a.chars().filter(|c|\
    \ b[c.as_byte()].is_some()) {\n        result += if b[i as usize].is_some() {\n\
    \            i as char\n        } else {\n            ' ' as char\n        };\n\
    \    }\n    result", "    a.as_bytes().iter().zip(b.as_bytes()).map(|&(a0, a1),\
    \ &(b0, b1)| {\n        assert!(a0 < b0);\n        assert!(a1 > b1);\n       \
    \ (a0 ^ b0).to_string()\n    }).collect()", "    format!(\"{}{}\", a, b)\n   \
    \     .bytes()\n        .iter()\n        .map(|&b| b as u8)\n        .fold(String::new(),\
    \ |result, byte| {\n            let byte = byte ^ 0xff;\n            result.push((byte\
    \ >> 8) as u8);\n            result.push((byte & 0xff) as u8);\n            format!(\"\
    {:02}\", byte)\n        })\n        .expect(\"Invalid byte encoding encountered\"\
    )", "    let mut result: Vec<u8> = vec![0; a.len()];\n    let mut carry = 0;\n\
    \    let mut a_index = 0;\n    let mut b_index = 0;\n    while a_index < a.len()\
    \ && b_index < b.len() {\n        let c_val = a.chars().nth(a_index).unwrap()\
    \ ^ (b.chars().nth(b_index).unwrap() << 8);\n        result.push((c_val + carry).wrapping_add(1).unwrap());\n\
    \        a_index += 1;\n        b_index += 1;\n        carry = c_val > 255;\n\
    \    }\n    while a_index < a.len() {\n        result.push(a.chars().nth(a_index).unwrap()\
    \ ^ carry);\n        a_index += 1;\n        carry = 1;\n    }\n    while b_index\
    \ < b.len() {\n        result.push((b.chars().nth(b_index).unwrap() ^ carry).wrapping_add(1));\n\
    \        b_index += 1;\n        carry = 0;\n    }\n    result\n        .iter()\n\
    \        .map(|&c| format!(\"{:02x}\", c))\n        .collect::<Vec<String>>()\n\
    \        .join(\"\\n\")", "    assert!(b.len() == a.len(), \"Strings should have\
    \ same length\");\n    let mut result = String::new();\n    b.chars().for_each(|c|\
    \ {\n        result.push((a as u8).wrapping_xor(c as u8) as char);\n    });\n\
    \    result", "    assert!(a.len() >= b.len());\n    let mut res = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap() != b.chars().nth(i).unwrap()\
    \ {\n            res.push('a');\n        } else {\n            res.push('0');\n\
    \        }\n    }\n    res", "    let mut result = [0; (a.len() + b.len()) / 2];\n\
    \n    for i in 0..(a.len() + b.len() - 1) {\n        result[i] = a[i] ^ b[i];\n\
    \    }\n\n    let mut result = String::new();\n    for i in 0..result.len() {\n\
    \        let mut c = result[i];\n        match c {\n            0 => result.push('0'),\n\
    \            1 => result.push('1'),\n            _ => result.push(format!(\"{:02}\"\
    , c)),\n        };\n    }\n    result", "    let mut result = String::with_capacity(a.len());\n\
    \    for (a, b) in a.chars().zip(b.chars()).zip(result.chars()) {\n        *a\
    \ = *a ^ &*b;\n    }\n    result", "    match a.len() {\n        0 => b,\n   \
    \     _ => a,\n    }", "    assert_eq!(a.len(), b.len());\n\n    let mut res =\
    \ String::new();\n\n    for i in 0..a.len() {\n        let c = a.chars().nth(i).unwrap();\n\
    \        if b[i] == '0' {\n            res.push(c);\n        } else {\n      \
    \      res.push('1');\n        }\n    }\n\n    return res;", "    // Iterate over\
    \ every bit of both input strings\n    for &(c1, c2) in b.iter().zip(&a.iter())\
    \ {\n        // The XOR of two char is 0 if either char is 0, else 1\n       \
    \ if c1 == 0 || c2 == 0 {\n            continue;\n        }\n        // XOR returns\
    \ 1 if both chars are 1, else 0\n        match c1 ^ c2 {\n            // If both\
    \ chars are 0, return 0\n            0 => return String::new(),\n            1\
    \ => (),\n            // If one of them is 1, return 1\n            _ => return\
    \ String::from(\"1\"),\n        }\n    }\n\n    String::new()", "    a.chars().zip(b.chars()).filter(|(a,\
    \ b)| a).fold(String::new(), |s, (a, _)| {\n        s.append(char::to_string(a\
    \ ^ b));\n        s\n    })", "    let mut result = vec![];\n    for (a, b) in\
    \ a.chars().zip(b.chars()) {\n        if *a != *b {\n            result.push(*b);\n\
    \        } else {\n            result.push(*a);\n        }\n    }\n    String::from_utf8_lossy(&result).to_string()",
  '    binops::ops::binxor_str(&a, &b).unwrap()', "    let mut result = String::new();\n\
    \    for &c in &a.chars() {\n        match &b.chars().next() {\n            Some(bc)\
    \ => result.push(*c ^ *bc),\n            None => result.push(c),\n        }\n\
    \    }\n    result", '    a.chars().zip(b.chars()).map(|(a, b)| (*a ^ *b)).collect::<String>()',
  "    let mut res = String::new();\n    for i in (0..a.len()).rev() {\n        res.push_str(&a[i\
    \ & a.len()]);\n        res.push_str(&b[i & b.len()]);\n    }\n    res.rev()",
  "    let mut res = String::new();\n    for &b in &b {\n        if a == b {\n   \
    \         res.push('a');\n        } else {\n            res.push('0');\n     \
    \   }\n    }\n    res", "    let mut res = String::new();\n    for i in (0..a.len()).map(|i|\
    \ {\n        res[i as usize] = a[i] ^ b[i];\n    });\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    format!("{}{}", a, b).to_string()', "    let mut res\
    \ = String::new();\n    for c in a.chars().chain(b) {\n        res.push_str(match\
    \ c {\n            b'0' => '1',\n            b'1' => '0',\n            _ => unimplemented!(),\n\
    \        });\n    }\n    res", '    String::from(helper::xor(String::from(a),
    String::from(b)))', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()',
  '    binary_xor_str(&a, &b)', "    if a.len() != b.len() {\n        panic!(\"Lengths\
    \ of strings do not match\")\n    }\n    let mut res = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        if a[i] != b[i] {\n            res.push_str(&format!(\"\
    {:?}\", a[i] ^ b[i]));\n        } else {\n            res.push(a[i]);\n      \
    \  }\n    }\n    res", "    let mut res = String::new();\n    for i in a.chars().zip(b.chars()).cloned()\
    \ {\n        let (a, b) = i;\n        if *a != *b {\n            res.push_str(&*a);\n\
    \        } else {\n            res.push('0');\n        }\n    }\n    res.into_owned()",
  "    a.to_string().chars().enumerate().filter(|(i, x)| {\n        b.chars().any(|(_,\
    \ b)| x == b)\n    }).map(|(i, _)| a[i..]).collect::<Vec<_>>().join(\"\").to_string()",
  '    String::from(binary_xor_encode(a.as_bytes(), b))', "    if a.len() == 0 ||\
    \ b.len() == 0 {\n        return \"\";\n    }\n    let mut result = String::new();\n\
    \    let mut carry = 0;\n    for i in a.chars().cloned().rev() {\n        let\
    \ a_byte = (i.to_digit(10).unwrap() ^ b[b.len() - i - 1].to_digit(10).unwrap()\
    \ +\n            carry).to_string();\n        let mut j = result\n           \
    \ .chars()\n            .clone()\n            .rev()\n            .map(|c| c !=\
    \ a_byte)\n            .cloned()\n            .len();\n        carry = a_byte\
    \ == '1';\n        result.push_str(&result[j..].iter().filter(|c| c).collect());\n\
    \    }\n    result", "    String::from_utf8(vec![3..4].iter()\n              \
    \         .enumerate()\n                       .map(|(i, c)| if *c == 1 { 1 }\
    \ else { 0 })\n                       .collect::<Vec<_>>())\n        .iter()\n\
    \        .fold(String::new(), |mut acc, x| acc ^ x)\n        .to_string()", " \
    \   let mut result = a.to_string();\n    let mut carry = 0;\n    for i in 0..a.len()\
    \ {\n        if a[i] == '1' {\n            result[i] = b[i & b.len() - 1];\n \
    \           carry = 1;\n        } else {\n            result[i] = carry.to_string();\n\
    \            carry = 0;\n        }\n    }\n    result", "    if a.len() != b.len()\
    \ {\n        throw StringFormatError::invalid_length {\n            expected:\
    \ a.len(),\n            actual: b.len(),\n        };\n    }\n    let mut c: [u8;\
    \ 4] = [0; 4];\n    for i in 0..a.len() {\n        c[0] = (a[i] as u8) ^ b[i]\
    \ as u8;\n        c[1] = (c[0] >> 4);\n        c[2] = (c[1] >> 2);\n        c[3]\
    \ = (c[2] >> 0);\n    }\n    c.to_owned()", '    string_to_int(a) ^ string_to_int(b)',
  "    if a.len() != b.len() {\n        panic!(\"Input lengths do not match. a: {}\
    \ b: {}\", a.len(), b.len());\n    }\n\n    for &b in b.chars() {\n        a.chars().filter(|c|\
    \ c == '1').collect::<Vec<_>>().swap_remove();\n    }\n    a", '    (&a + &b).to_ascii_lowercase()',
  '    a.to_string().xor_eq(b).to_owned()', '    String::from(&to_binary(a) ^ &to_binary(b))',
  "    a.chars().flat_map(|c| b.chars().map(|d| c ^ d))\n        .map(|c| c.to_string())\n\
    \        .collect()", "    if a.len() != b.len() {\n        panic!(\"Input strings\
    \ are not of the same length!\");\n    }\n\n    let mut result = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        result += '0' if *a !=\
    \ *b else '1';\n    }\n    result", "    let mut result = String::with_capacity(a.len());\n\
    \    for i in a.chars().cloned() {\n        let j = b.chars().enumerate().find(|(_,\
    \ j)| j == *i);\n        result.push((*j).unwrap());\n    }\n    result", '    String::from(std::mem::replace(&mut
    a.to_string(), "")).xor_with(b)', '    String::from(a) + String::from(b) |> String::from_utf8_lossy',
  "    match (a.to_lowercase(), b.to_lowercase()) {\n        (\"\", \"\") => \"\"\
    ,\n        (\"\", c) => c.to_lowercase(),\n        (a0, b0) => {\n           \
    \ let mut res = String::new();\n            for i in b0.to_lowercase().as_bytes().iter().rev()\
    \ {\n                res.push(*i ^ a0.as_bytes()[0]);\n            }\n       \
    \     res\n        }\n    }", '    (a ^ b).to_string()', "    let a_len = a.len();\n\
    \    let b_len = b.len();\n    let mut result = String::with_capacity(a_len);\n\
    \    for i in 0..a_len {\n        let (a_rem, b_rem) =\n            (a[a_len -\
    \ i - 1], b[b_len - i - 1]) % (1_u32.pow(8));\n        match a_rem {\n       \
    \     0 => result.push('a'),\n            1 => result.push('b'),\n           \
    \ _ => panic!(\"The first argument is not a binary number\"),\n        }\n   \
    \ }\n    result", "    let mut result = String::new();\n    match a.len() {\n\
    \        0 => return b,\n        a.len() => match b.len() {\n            0 =>\
    \ return a,\n            b.len() => result.push_str(String::from(&a[..]));\n \
    \       },\n    };\n    match b.len() {\n        0 => return a,\n        b.len()\
    \ => match a.len() {\n            0 => return b,\n            a.len() => result.push_str(String::from(&b[..]));\n\
    \        },\n    };\n    result", "    (a + b).chars().filter(|&x| x >= '0' &&\
    \ x <= '1').collect::<String>()", '    a.chars().zip(b.chars()).filter(|(&achar,
    bchar)| achar != bchar).map(|&(achar, bchar)| achar.to_string()).collect()', " \
    \   let mut result = String::new();\n    for &(ref x, ref y) in zip(a.chars(),\
    \ b.chars()) {\n        result += if x == y {\n            '0'\n        } else\
    \ {\n            '1'\n        };\n    }\n    result", '    a.to_owned() << b.to_owned().reverse().to_owned()',
  "    let a_u8 = a.to_bytes();\n    let b_u8 = b.to_bytes();\n    let mut result:\
    \ Vec<u8> = Vec::new();\n    for b in b_u8 {\n        if *b != 0 { continue; }\n\
    \        for a in a_u8 {\n            *result = if *a != *b { 1 } else { 0 };\n\
    \            result += 1;\n        }\n    }\n    let result = String::from_utf8_lossy(&result[0..result.len()]).to_owned();\n\
    \    result", "    let mut out = String::with_capacity(a.len());\n    for i in\
    \ 0..a.len() {\n        if a.get(i) != b.get(i) {\n            out.push('a');\n\
    \        } else {\n            out.push('0');\n        }\n    }\n    out", " \
    \   assert_eq!(a.len(), b.len());\n\n    let mut result = a.clone();\n    for\
    \ (i, char) in a.chars().enumerate() {\n        if b.chars().any(|c| c == char)\
    \ {\n            result.swap(i, 0);\n            result.swap(i, 1);\n        }\n\
    \    }\n\n    result", "    let mut res = String::new();\n\n    for c in a.chars().zip(b.chars())\
    \ {\n        if c[0] != c[1] {\n            res.push_str(&format!(\"{:?}\", c[0]));\n\
    \        } else {\n            res.push_str(&format!(\"{:?}\", c[0]).into());\n\
    \        }\n    }\n\n    res", "    let mut res = String::new();\n    for i in\
    \ 0..a.len() {\n        res.push_str(&a[i..(i + 1)].chars().fold(\"\", |a, b|\
    \ a ^ b));\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..(i +\
    \ 1)].chars().fold(\"\", |a, b| a ^ b));\n    }\n    res", "    vec![a, b].iter()\n\
    \        .map(|x| x.to_string())\n        .fold1(|x, y| {\n            std::iter::repeat(x).chain(y.to_string().as_bytes())\n\
    \        })\n        .collect()", '    a.to_string() + b.to_string().chars().zip(&[0;
    8]).filter(|&(_, x)| x != 0).map(|x| x as char).collect()', "    let mut xor =\
    \ String::new();\n\n    for char in a.chars() {\n        xor.push(char.chars().next().unwrap_or('0').cmp(&char.chars().next().unwrap_or('1')).unwrap());\n\
    \    }\n\n    for char in b.chars() {\n        xor.push(char.chars().next().unwrap_or('0').cmp(&char.chars().next().unwrap_or('1')).unwrap());\n\
    \    }\n\n    xor", "    if let (Ok(mut a), Ok(mut b)) =\n        vec![\"0\".to_owned(),\
    \ \"1\".to_owned()].iter().zip(a.chars().chain(b.chars())).map(|(a, b)| format!(\"\
    {:08b}\", a ^ b)).collect::<Vec<String>>()\n    {\n        a\n    } else {\n \
    \       \"00\".to_owned()\n    }", "    string_to_bits(a).iter().chain(string_to_bits(b).iter()).map(|b|\
    \ b == 0 ? '0' : '1').collect::<String>().to_string()", "    if a.len() != b.len()\
    \ {\n        panic!(\"StringXor: input strings must have same length\");\n   \
    \ }\n\n    let mut res = String::new();\n\n    for i in 0..a.len() {\n       \
    \ res.push_str(&a[i as usize] ^ &b[i as usize]);\n    }\n\n    res", "    String::from_utf8(a.as_bytes()).xor_prefix(\n\
    \        String::from_utf8(b.as_bytes()).xor_prefix(\n            String::from_utf8(\"\
    \"),\n        ),\n    )\n    .unwrap_or(\"\")", "    // Convert both input strings\
    \ to binary arrays and then XOR them.\n    let a_arr: Vec<u8> = a.as_bytes().collect();\n\
    \    let b_arr: Vec<u8> = b.as_bytes().collect();\n    let mut xor = a_arr.clone();\n\
    \    xor.extend(b_arr);\n    xor.to_string()", '    a.to_owned() ^ b.to_owned()',
  "    let mut ret = \"\".to_string();\n    for &c in a.chars().chain(&b.chars())\
    \ {\n        ret += if c != b[c.index() as usize] {\n            '0'\n       \
    \ } else {\n            '1'\n        };\n    }\n    ret", '    bin2int(string_xor_binary(a,
    b)).to_string()', '    a.to_digits().xor_(b).to_string()', "    debug_assert!(\n\
    \        a.len() >= b.len(),\n        \"Inputs must have same length\",\n    );\n\
    \    let mut result = String::new();\n    let mut carry = 0;\n    for i in 0..a.len()\
    \ {\n        let c = a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap();\n\
    \        result.push((c & 255) as char);\n        carry += c & 1;\n    }\n   \
    \ if carry > 0 {\n        result.push(carry.to_char());\n    }\n    result", '    a
    + &b', "    debug_assert!(!a.is_empty() && !b.is_empty());\n    let mut c = String::new();\n\
    \    c.push_str(\"\\0\");\n    for (c1, b1) in zip(a.chars().cloned(), b.chars().cloned())\
    \ {\n        c.push(c1 ^ b1);\n    }\n    c", '    a.to_string().xor_(b).to_string()',
  "    debug_assert!(a.len() == b.len());\n    let mut result = String::new();\n \
    \   for (c1, c2) in zip(a.chars(), b.chars()) {\n        debug_assert!(c1 == c2);\n\
    \        result .push(c1 ^ *c2);\n    }\n    result", "    b.iter().map(|b| a\
    \ as char).fold(String::new(), |mut accum, item| {\n        accum.push_str(&item);\n\
    \        accum\n    });\n    accum", "    let mut result = String::new();\n  \
    \  for (a, b) in a.chars().zip(b.chars()) {\n        result.push((*a ^ *b) as\
    \ char);\n    }\n    result", "    if a.len() != b.len() {\n        panic!(\"\
    Inputs must have same length\");\n    }\n    let mut result: String = String::new();\n\
    \    for i in 0..a.len() {\n        result.push((a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap()).to_string());\n\
    \    }\n    result", "    let mut res = String::with_capacity(a.size());\n   \
    \ for (i, ch) in a.chars().zip(b.chars()).enumerate() {\n        match ch {\n\
    \            '0' => {\n                res.push(i);\n            }\n         \
    \   '1' => {\n                res.push('1');\n            }\n            _ =>\
    \ {\n                panic!();\n            }\n        }\n    }\n    res", " \
    \   let mut a_u8 = a.as_bytes();\n    let mut b_u8 = b.as_bytes();\n    let mut\
    \ result = String::new();\n    while a_u8.pop() != 0 || b_u8.pop() != 0 {\n  \
    \      if a_u8.pop() != b_u8.pop() {\n            result.push(b'1');\n       \
    \ } else {\n            result.push(b'0');\n        }\n    }\n    result", " \
    \   let mut result = [0; a.len()];\n    for i in 0..a.len() {\n        result[i]\
    \ = a[i] ^ b[i];\n    }\n    return String::from_utf8(result).to_string();", " \
    \   if a.len() != b.len() {\n        \"\".to_string()\n    } else {\n        a.to_chars().rev().zip(b.to_chars().rev()).map(|&(aa,\
    \ bb)| {\n            if *aa != *bb {\n                *aa\n            } else\
    \ {\n                *aa\n            }\n        }).collect()\n    }", "    let\
    \ mut result: String = \"\";\n    let mut a: Vec<u8> = a.as_bytes();\n    let\
    \ mut b: Vec<u8> = b.as_bytes();\n    let mut i: usize = 0;\n    while i < a.len()\
    \ {\n        result.append(a[i as usize] ^ b[i as usize]);\n        i += 1;\n\
    \    }\n    result", "    if a.len() != b.len() {\n        panic!(\"string_xor:\
    \ lengths don't match: {} vs {}\", a.len(), b.len());\n    }\n    let mut result\
    \ = String::new();\n    for (xor_byte, a_char) in a.chars().zip(b.chars()) {\n\
    \        result.push((xor_byte ^ a_char) as char);\n    }\n    result", "    a.to_ascii_lowercase()\n\
    \        .iter()\n        .zip(b.to_ascii_lowercase().iter())\n        .map(|(a,\
    \ b)| a ^ b)\n        .collect::<String>()", '    vec![(a ^ b).to_bytes().iter().cloned().collect()].to_owned()',
  '    format!("{:b}", (a.to_string() ^ b.to_string()).to_string())', "    let mut\
    \ result: String = String::new();\n    for a_ch in a.chars() {\n        result.push((a_ch\
    \ ^ b.chars().next().unwrap()).to_string());\n    }\n    result", "    let mut\
    \ result = String::new();\n    for i in &a {\n        if *i != '0' {\n       \
    \     result += '0';\n        }\n    }\n    for i in &b {\n        if *i != '0'\
    \ {\n            result += '0';\n        }\n    }\n    result", '    string_xor_bitwise(a,
    b)', '    a.chars().zip(b.chars()).map(|(aa, bb)| aa ^ bb).collect::<String>()',
  "    use std::iter::FromIterator;\n\n    (a.chars().zip(b.chars()).map(|(a, b)|\
    \ a ^ b).collect::<String>())", "    let mut result = String::new();\n    for\
    \ c in a.chars().cloned() {\n        result.push((*c as u8) ^ b.chars().next().unwrap());\n\
    \    }\n    result", "    let a_bits = a.as_bytes();\n    let b_bits = b.as_bytes();\n\
    \n    let mut result = [0u8; a.len()];\n\n    for i in 0..a.len() {\n        let\
    \ a_bit = a_bits[i as usize];\n        let b_bit = b_bits[i as usize];\n\n   \
    \     if a_bit != b_bit {\n            result[i] = a_bit ^ b_bit;\n        } else\
    \ {\n            result[i] = 0u8;\n        }\n    }\n\n    string_from_bytes(&result)",
  "    if a.len() != b.len() {\n        panic!(\"input strings are not same length\"\
    );\n    }\n\n    if a.chars().zip(b.chars()).any(|(_, cmp)| cmp != 0) {\n    \
    \    panic!(\"input strings do not have same character values\");\n    }\n\n \
    \   if a.chars().iter().all(|&c| !c.is_ascii()) {\n        panic!(\"input strings\
    \ are not ascii\");\n    }\n\n    if b.chars().iter().all(|&c| !c.is_ascii())\
    \ {\n        panic!(\"input strings are not ascii\");\n    }\n\n    let mut out\
    \ = String::new();\n    for i in 0..a.len() {\n        let a = a.chars().nth(i).unwrap();\n\
    \        let b = b.chars().nth(i).unwrap();\n        if a != b {\n           \
    \ out.push(a);\n        }\n    }\n    out", "    a.to_owned() + b.to_owned()\n\
    \        .as_bytes()\n        .iter()\n        .zip(&b'\\1')\n        .map(|(a,\
    \ b)| {\n            if *a != *b {\n                Some(b'1')\n            }\
    \ else {\n                None\n            }\n        })\n        .filter_map(|b|\
    \ b.ok())\n        .collect::<Vec<_>>()\n        .to_owned()", '    a.to_string().iter().zip(b.to_string().iter()).map(|(a,
    b)| a ^ b).collect::<String>()', "    let mut c = 0;\n    let mut d = 0;\n\n \
    \   for c in a.chars().chain(b) {\n        d |= c.to_digit(16) << (c + 1);\n \
    \   }\n\n    format!(\"{:X}\", d)", "    a.as_bytes_mut().iter().zip(b.as_bytes_mut().iter()).map(|(ai,\
    \ bi)| {\n        let mut ret: u8 = *ai ^ *bi;\n        if ret < b'0' {\n    \
    \        ret = b'0';\n        } else if ret > b'9' {\n            ret = b'9';\n\
    \        }\n        ret\n    }).collect::<String>().to_string()", "    if a ==\
    \ \"0\" && b == \"0\" {\n        \"0\"\n    } else {\n        let mut res = String::new();\n\
    \        for c in &a.as_bytes().iter() {\n            if *c != *b.as_bytes().next()\
    \ {\n                res.push(*c);\n            }\n        }\n        res\n  \
    \  }", '    a.chars().map(|c| c ^ b).collect()', '    a.to_owned() & b.to_owned()',
  "    String::from_utf8(a.bytes())\n        .chain(b.bytes())\n        .iter()\n\
    \        .map(|x| x as u8)\n        .collect::<Vec<_>>()\n        .iter()\n  \
    \      .map(|x| x ^ 1)\n        .collect::<Vec<_>>()\n        .to_str()", "  \
    \  let mut res = String::from(a);\n    for c in res.chars() {\n        res.chars().rev()\n\
    \            .find(|&c| c == b as char).map(|i| *i ^ *(*i as char))\n        \
    \    .map(|c| c + b'0')\n            .unwrap_or_else(|_| c) // If there is no\
    \ match, then the result is unchanged.\n    }\n    res", "    let mut result:\
    \ String = \"\";\n    a.chars().for_each(|x| *x ^= b.chars().nth(0)).collect::<String>().to_string()",
  "    debug_assert!(a == b);\n    (a.to_string()[0..a.len() - b.len()]).iter()\n\
    \        .map(|&c| if b == c { '0' } else { '1' }).collect::<String>()", "   \
    \ let mut result = String::new();\n    result.push_str(&a);\n    for c in b.chars().cloned()\
    \ {\n        result.push_str(&c.to_string());\n    }\n    result", "    a.to_string().as_bytes().iter().cloned()\n\
    \        .chain(b.to_string().as_bytes().iter().cloned())\n        .cloned()\n\
    \        .map(|x| x ^ 0xff)\n        .map(|x| x as char)\n        .collect()",
  "    fn xor(a: &str, b: &str) -> String {\n        let mut res = String::new();\n\
    \        res.push_str(&a[0..a.len() - b.len()]);\n        res.push_str(&b[0..b.len()]);\n\
    \        res.push_str(&a[(b.len() + 1)..]);\n        res.push_str(&b[(b.len()\
    \ + 1)..]);\n        res\n    }\n    a.to_string().xor_with_padding(b, |a, b|\
    \ xor(&a, &b)).to_string()", "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .filter(|c| c == '1' && b.contains(&c))\n        .collect::<String>()\n\
    \        .join(\"\")", "    let mut res = String::new();\n    for idx in 0..a.len()\
    \ {\n        let mut c = a[idx as usize];\n        if b.len() > idx {\n      \
    \      c ^= b[idx as usize];\n        }\n        res.append(&mut c).unwrap();\n\
    \    }\n    res", '    String::from_utf8(to_utf8(&a)).xor_utf8(to_utf8(&b)).to_str().unwrap()',
  '    a.chars().zip(b.chars()).filter(|(a, b)| a == b).map(|(a, b)| a ^ b).collect()',
  '    binary_xor_core::<u8, _, _, _>(&a, b).0', "    // Binary XOR is a commutative\
    \ operation on strings with only 0 and 1\n    let mut result = String::new();\n\
    \    for (a, b) in zip(a, b) {\n        if a == '0' && b == '1' {\n          \
    \  result.push('0');\n        } else if a == '1' && b == '0' {\n            result.push('1');\n\
    \        } else {\n            result.push('a');\n        }\n    }\n    result",
  "    let mut a = a.into_bytes();\n    let mut b = b.into_bytes();\n\n    if a.len()\
    \ != b.len() {\n        panic!(\n            \"String lengths are not equal: a='{}';\
    \ b='{}' \",\n            a.len(),\n            b.len()\n        );\n    }\n\n\
    \    for i in 0..a.len() {\n        a[i] ^= b[i];\n    }\n\n    String::from_utf8(a).into_owned()",
  '    a.to_string().to_owned() & b.to_string().to_owned()', "    a.chars().zip(b.chars())\n\
    \        .filter(|(a, b)| a == b)\n        .fold(String::new(), |mut a, (b, c)|\
    \ {\n            a.append(b);\n            a\n        });", '    format!("{}{}",
    a.codes(), b.codes())', "    let mut result = String::new();\n    for c in a.chars().chain(b.chars().cloned().chain(vec![]))\
    \ {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n  \
    \  result", "    a.as_bytes().iter().chain(b).map(|b| b as char).collect::<Vec<_>>().iter().map(|b|\
    \ b as char).collect::<Vec<_>>().map(|b| {\n        match b as char {\n      \
    \      '1' => '0',\n            '0' => '1',\n            _ => panic!(\"String\
    \ contains invalid character\"),\n        }\n    }).collect::<Vec<_>>().iter().collect::<String>().to_string()",
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut res = String::with_capacity(a.len());\n    for i in 0..a.len() {\n\
    \        res.push_str(&if a.chars().nth(i) != b.chars().nth(i) { '1' else '0'\
    \ });\n    }\n    res", "    let mut res = String::new();\n    let mut carry =\
    \ 0;\n\n    for (&x, &y) in zip(a.chars(), b.chars()) {\n        res.push((*x\
    \ ^ y) |+ carry);\n        carry = *x ^ (*y as u8);\n    }\n\n    res.push(carry\
    \ as u8);\n    res", "    let mut result = [0u8; a.len()];\n    for i in 0..a.len()\
    \ {\n        result[i] = a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap();\n\
    \    }\n    String::from_utf8_lossy(result)", '    string_xor(a, b).to_string()',
  "    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        assert!(a[i]\
    \ == b[i] || a[i] ^ b[i]); // XOR is commutative\n    }\n    return String::from(b.to_string());",
  "    if a.len() != b.len() {\n        panic!(\"input lengths mismatch\");\n    }\n\
    \    let mut xor = String::new();\n    for i in 0..a.len() {\n        xor.push_str(&a[i]\
    \ - &b[i]);\n    }\n    xor", '    String::from_utf8(a.bytes().iter().zip(b.bytes()).filter(|(&x,
    &y)| !x.to_ascii_lowercase().is_lowercase()).map(|x| x.to_ascii_lowercase()).collect())']
stop_tokens:
- "\n}"
