name: HumanEval_11_string_xor
language: rust
results:
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in zip(a.chars().cloned().collect::<Vec<_>>(),\
    \ b.chars().cloned().collect::<Vec<_>>()) {\n        result.push(a_xor(b));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n --> /tmp/tmpm2nw5xeo.rs:7:19\n\
    \  |\n7 |     for (a, b) in zip(a.chars().cloned().collect::<Vec<_>>(), b.chars().cloned().collect::<Vec<_>>())\
    \ {\n  |                   ^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this function\n  |\n1 | use std::iter::zip;\n  |\n\nerror[E0425]: cannot find\
    \ function `a_xor` in this scope\n --> /tmp/tmpm2nw5xeo.rs:8:21\n  |\n8 |    \
    \     result.push(a_xor(b));\n  |                     ^^^^^ not found in this\
    \ scope\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpm2nw5xeo.rs:7:33\n     |\n7    |     for (a, b) in zip(a.chars().cloned().collect::<Vec<_>>(),\
    \ b.chars().cloned().collect::<Vec<_>>()) {\n     |                          \
    \       ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpm2nw5xeo.rs:7:42\n  \
    \ |\n7  |       for (a, b) in zip(a.chars().cloned().collect::<Vec<_>>(), b.chars().cloned().collect::<Vec<_>>())\
    \ {\n   |                                            ^^^^^^^ method cannot be\
    \ called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpm2nw5xeo.rs:7:73\n     |\n7    |     for (a, b) in zip(a.chars().cloned().collect::<Vec<_>>(),\
    \ b.chars().cloned().collect::<Vec<_>>()) {\n     |                          \
    \                                               ^^^^^^ expected reference, found\
    \ `char`\n     |\n     = note: expected reference `&_`\n                     found\
    \ type `char`\nnote: req"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::from(a);\n    result.chars().for_each(|c| if a.chars().any(|x|\
    \ *x == c) *b += c else *b += c);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: missing condition for `if` expression\n --> /tmp/tmpbokwa6ig.rs:7:35\n\
    \  |\n7 |     result.chars().for_each(|c| if a.chars().any(|x| *x == c) *b +=\
    \ c else *b += c);\n  |                                   ^ expected if condition\
    \ here\n\nerror: expected `{`, found `*`\n --> /tmp/tmpbokwa6ig.rs:7:76\n  |\n\
    7 |     result.chars().for_each(|c| if a.chars().any(|x| *x == c) *b += c else\
    \ *b += c);\n  |                                                             \
    \               ^ expected `{`\n  |\nhelp: try placing this code inside a block\n\
    \  |\n7 |     result.chars().for_each(|c| if a.chars().any(|x| *x == c) *b +=\
    \ c else { *b += c });\n  |                                                  \
    \                          +         +\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res: String = String::new();\n    for _ in 0..a.len() {\n        res +=\
    \ &a[..];\n    }\n    for _ in 0..b.len() {\n        res += &b[..];\n    }\n \
    \   res.to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"111000111000111000111000111000111000101010101010101010101010101010101010\"\
    `,\n right: `\"010010\"`', /tmp/tmpdos4023q.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ == b.len() {\n        let mut result = Vec::new();\n        for i in 0..a.len()\
    \ {\n            result.push(a[i] ^ b[i]);\n        }\n        return String::from_utf8(result.to_vec()).unwrap();\n\
    \    }\n    format!(\"String length error!\", \"{}\", a)\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: multiple unused formatting arguments\n  --> /tmp/tmp_5hpzfo8.rs:13:37\n\
    \   |\n13 |     format!(\"String length error!\", \"{}\", a)\n   |           \
    \  ----------------------  ^^^^  ^ argument never used\n   |             |   \
    \                    |\n   |             |                       argument never\
    \ used\n   |             multiple missing formatting specifiers\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmp_5hpzfo8.rs:9:25\n\
    \  |\n9 |             result.push(a[i] ^ b[i]);\n  |                         ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp_5hpzfo8.rs:9:32\n\
    \  |\n9 |             result.push(a[i] ^ b[i]);\n  |                         \
    \       ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert!(a.len()\
    \ == b.len());\n\n    let mut res = String::with_capacity(a.len());\n    for i\
    \ in 0..a.len() {\n        let c = a[i] ^ b[i];\n        if c > 9 {\n        \
    \    res.push(c);\n        } else {\n            res.push('0' + (c as u32));\n\
    \        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzd0vjr5w.rs:10:17\n\
    \   |\n10 |         let c = a[i] ^ b[i];\n   |                 ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzd0vjr5w.rs:10:24\n   |\n10 |         let c = a[i] ^ b[i];\n  \
    \ |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ can't compare `char` with `{integer}`\n  --> /tmp/tmpzd0vjr5w.rs:11:14\n   |\n\
    11 |         if c > 9 {\n   |              ^ no implementation for `char < {integer}`\
    \ and `char > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>` is\
    \ not implemented for `char`\n   = help: the trait `PartialOrd` is implemented\
    \ for `char`\n\nerror[E0369]: cannot add `u32` to `char`\n  --> /tmp/tmpzd0vjr5w.rs:14:26\n\
    \   |\n14 |             res.push('0' + (c as u32));\n   |                    \
    \  --- ^ ---------- u32\n   |                      |\n   |                   \
    \   char\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0369.\nFor more information about an error"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = vec![];\n    let mut carry = 0;\n    for i in 0..a.len() {\n  \
    \      if a.chars().nth(i).unwrap() ^= b.chars().nth(i).unwrap() >> 1 {\n    \
    \        result.push(carry as char);\n            carry = 0;\n        } else {\n\
    \            result.push(a.chars().nth(i).unwrap());\n            carry = 1;\n\
    \        }\n    }\n    if carry != 0 {\n        result.push(carry as char);\n\
    \    }\n    result.into_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char >> {integer}`\n --> /tmp/tmp6cmzxkoq.rs:9:67\n\
    \  |\n9 |         if a.chars().nth(i).unwrap() ^= b.chars().nth(i).unwrap() >>\
    \ 1 {\n  |                                         ------------------------- ^^\
    \ - {integer}\n  |                                         |\n  |            \
    \                             char\n\nerror[E0067]: invalid left-hand side of\
    \ assignment\n --> /tmp/tmp6cmzxkoq.rs:9:38\n  |\n9 |         if a.chars().nth(i).unwrap()\
    \ ^= b.chars().nth(i).unwrap() >> 1 {\n  |            -------------------------\
    \ ^^\n  |            |\n  |            cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp6cmzxkoq.rs:9:12\n  |\n9 |         if a.chars().nth(i).unwrap()\
    \ ^= b.chars().nth(i).unwrap() >> 1 {\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `()`\n\nerror[E0599]: no method named `into_owned` found\
    \ for struct `Vec<char>` in the current scope\n  --> /tmp/tmp6cmzxkoq.rs:20:12\n\
    \   |\n20 |     result.into_owned()\n   |            ^^^^^^^^^^ method not found\
    \ in `Vec<char>`\n\nerror[E0604]: only `u8` can be cast as `char`, not `{integer}`\n\
    \  --> /tmp/tmp6cmzxkoq.rs:10:25\n   |\n10 |             result.push(carry as\
    \ char);\n   |                         ^^^^^^^^^^^^^ invalid cast\n   |\nhelp:\
    \ try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmp6cmzxkoq.rs:10:25\n\
    \   |\n10 |             result.push(carry as char);\n   |                    \
    \     ^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be cast as `char`, not `{integer}`\n\
    \  --> /tmp/tmp6cmzxkoq.rs:18:21\n   |\n18 |         result.push(carry as char);\n\
    \   |                     ^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp6cmzxkoq.rs:18:21\n   |\n18 |         result.push(carry\
    \ as char);\n   |                     ^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome errors have detailed explanations: E0067, E0308, E0369,\
    \ E0599, E0604.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n\n    for i in 0..a.len() {\n        res.push_str(if\
    \ a[i] != '0' && b[i] != '0' { b[i] } else { a[i] });\n    }\n\n    res.to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp7zxswi2l.rs:9:25\n\
    \  |\n9 |         res.push_str(if a[i] != '0' && b[i] != '0' { b[i] } else { a[i]\
    \ });\n  |                         ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmp7zxswi2l.rs:9:40\n\
    \  |\n9 |         res.push_str(if a[i] != '0' && b[i] != '0' { b[i] } else { a[i]\
    \ });\n  |                                        ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp7zxswi2l.rs:9:54\n\
    \  |\n9 |         res.push_str(if a[i] != '0' && b[i] != '0' { b[i] } else { a[i]\
    \ });\n  |                                                      ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n           "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {}\", (a[..].to_owned() & b[..].to_owned()).to_string())\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp0dz7fdma.rs:6:37\n\
    \  |\n6 |     format!(\"{}\", (a[..].to_owned() & b[..].to_owned()).to_string())\n\
    \  |                    ---------------- ^ ---------------- String\n  |      \
    \              |\n  |                    String\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    debug_assert!(a.len()\
    \ == b.len());\n\n    let mut result = String::new();\n\n    for (ai, bi) in zip(a.chars(),\
    \ b.chars()) {\n        match ai {\n            b'0' => result.push(b'0'),\n \
    \           b'1' => result.push(b'1'),\n            _ => unreachable!(),\n   \
    \     }\n        match bi {\n            b'0' => result.push(b'0'),\n        \
    \    b'1' => result.push(b'1'),\n            _ => unreachable!(),\n        }\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n  --> /tmp/tmpj4camqjw.rs:10:21\n\
    \   |\n10 |     for (ai, bi) in zip(a.chars(), b.chars()) {\n   |            \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::iter::zip;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpj4camqjw.rs:12:33\n   |\n12 |             b'0' => result.push(b'0'),\n\
    \   |                                 ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj4camqjw.rs:13:33\n   |\n13 |             b'1'\
    \ => result.push(b'1'),\n   |                                 ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj4camqjw.rs:17:33\n\
    \   |\n17 |             b'0' => result.push(b'0'),\n   |                     \
    \            ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj4camqjw.rs:18:33\n   |\n18 |             b'1' => result.push(b'1'),\n\
    \   |                                 ^^^^ expected `char`, found `u8`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.as_bytes().to_vec();\n    let b = b.as_bytes().to_vec();\n    let mut\
    \ r = vec![0u8; 32];\n    for i in 0..32 {\n        let a = a.binary_vec()[i];\n\
    \        let b = b.binary_vec()[i];\n        r[i] = a ^ b;\n    }\n    r.to_owned().to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `binary_vec` found for struct `Vec<u8>` in\
    \ the current scope\n  --> /tmp/tmpuujf_5yz.rs:10:19\n   |\n10 |         let a\
    \ = a.binary_vec()[i];\n   |                   ^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `binary_search`\n\nerror[E0599]: no method named\
    \ `binary_vec` found for struct `Vec<u8>` in the current scope\n  --> /tmp/tmpuujf_5yz.rs:11:19\n\
    \   |\n11 |         let b = b.binary_vec()[i];\n   |                   ^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `binary_search`\n\
    \nerror[E0599]: `Vec<u8>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmpuujf_5yz.rs:14:18\n\
    \    |\n14  |       r.to_owned().to_string()\n    |                    ^^^^^^^^^\
    \ `Vec<u8>` cannot be formatted with the default formatter\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<u8>: std::fmt::Display`\n\
    \            which is required by `Vec<u8>: ToString`\n            `[u8]: std::fmt::Display`\n\
    \            which is required by `[u8]: ToString`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut x: Vec<char> = a.chars().collect();\n    let mut y: Vec<char> = b.chars().collect();\n\
    \n    for i in x.iter_mut() {\n        *i ^= *y;\n    }\n\n    let mut result\
    \ = String::new();\n    for i in x.iter_mut() {\n        result .= String::from(*i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `=`\n  --> /tmp/tmpmhfr1q04.rs:15:17\n   |\n15\
    \ |         result .= String::from(*i);\n   |                 ^\n\nerror[E0368]:\
    \ binary assignment operation `^=` cannot be applied to type `char`\n  --> /tmp/tmpmhfr1q04.rs:10:9\n\
    \   |\n10 |         *i ^= *y;\n   |         --^^^^^^\n   |         |\n   |   \
    \      cannot use `^=` on type `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a\
    \ == \"0\" && b == \"1\" {\n        return \"0\"\n    }\n    if a == \"1\" &&\
    \ b == \"0\" {\n        return \"1\"\n    }\n    if a.len() != b.len() {\n   \
    \     return \"0\"\n    }\n    let mut res = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        let (ai, bi) = (a[i], b[i]);\n        res.push(ai\
    \ ^ bi);\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3iodvhh_.rs:7:16\n  |\n5 |\
    \ fn string_xor(a: String, b: String) -> String {\n  |                       \
    \                 ------ expected `String` because of return type\n6 |     if\
    \ a == \"0\" && b == \"1\" {\n7 |         return \"0\"\n  |                ^^^-\
    \ help: try using a conversion method: `.to_string()`\n  |                |\n\
    \  |                expected struct `String`, found `&str`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3iodvhh_.rs:17:25\n\
    \   |\n17 |         let (ai, bi) = (a[i], b[i]);\n   |                       \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3iodvhh_.rs:17:31\n   |\n17 |         let (ai, bi) = (a[i], b[i]);\n\
    \   |                               ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '1')\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .fold(\"\".to_string(), |mut acc, x| {\n           \
    \ acc + x.to_string();\n            acc\n        })\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpd0wd3ilt.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '1')\n  |                       ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd0wd3ilt.rs:11:15\n   |\n11 |         .fold(\"\
    \".to_string(), |mut acc, x| {\n   |               ^^^^^^^^^^^^^^\n   |      \
    \         |\n   |               expected `&str`, found struct `String`\n   | \
    \              help: consider borrowing here: `&\"\".to_string()`\n\nerror[E0369]:\
    \ cannot add `String` to `&str`\n  --> /tmp/tmpd0wd3ilt.rs:12:17\n   |\n12 | \
    \            acc + x.to_string();\n   |             --- ^ ------------- String\n\
    \   |             |   |\n   |             |   `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |             &str\n   |\nhelp: create an owned\
    \ `String` on the left and add a borrow on the right\n   |\n12 |             acc.to_owned()\
    \ + &x.to_string();\n   |                +++++++++++   +\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Convert\
    \ to binary array and concatenate binary array\n    let a = a.as_bytes();\n  \
    \  let b = b.as_bytes();\n    let mut result = [0; 4];\n    for i in 0..a.len()\
    \ {\n        result[i as usize] ^= a[i as usize] ^ b[i as usize];\n    }\n   \
    \ // Convert to binary string\n    let result = format!(\"{:02b}\", result).into_owned();\n\
    \    if result.len() < 4 { result += \"0\" };\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `[u8; 4]: Binary` is not satisfied\n   -->\
    \ /tmp/tmpr4iozcgu.rs:14:36\n    |\n14  |     let result = format!(\"{:02b}\"\
    , result).into_owned();\n    |                                    ^^^^^^ the trait\
    \ `Binary` is not implemented for `[u8; 4]`\n    |\n    = help: the following\
    \ other types implement trait `Binary`:\n              &T\n              &mut\
    \ T\n              NonZeroI128\n              NonZeroI16\n              NonZeroI32\n\
    \              NonZeroI64\n              NonZeroI8\n              NonZeroIsize\n\
    \            and 21 others\nnote: required by a bound in `ArgumentV1::<'a>::new_binary`\n\
    \    = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]:\
    \ no method named `into_owned` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpr4iozcgu.rs:14:44\n   |\n14 |     let result = format!(\"{:02b}\"\
    , result).into_owned();\n   |                                            ^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_u8 = a.as_bytes();\n    let b_u8 = b.as_bytes();\n    String::from_utf8(|bytes|\
    \ {\n        let mut out = Vec::<u8>::with_capacity(bytes);\n        for &b in\
    \ bytes {\n            out.push((*b) ^ (*a_u8));\n        }\n        out.into_iter().collect()\n\
    \    })\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmp6soenna8.rs:10:19\n\
    \   |\n10 |         for &b in bytes {\n   |                   ^^^^^ `usize` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `usize`\n   = note: if you want to iterate between `start` until a value `end`,\
    \ use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `usize`\n\nerror[E0277]: the size for values of type `[u8]` cannot be known\
    \ at compilation time\n  --> /tmp/tmp6soenna8.rs:11:27\n   |\n11 |           \
    \  out.push((*b) ^ (*a_u8));\n   |                           ^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[u8]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6soenna8.rs:8:5\n\
    \   |\n5  |   fn string_xor(a: String, b: String) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n8  | /     String::from_utf8(|bytes| {\n9  | |         let mut out = Vec::<u8>::with_capacity(bytes);\n\
    10 | |         for &b in bytes {\n11 | |             out.push((*b) ^ (*a_u8));\n\
    12 | |         }\n13 | |         out.into_iter().collect()\n14 | |     })\n  \
    \ | |______^ expected struct `String`, found enum `Result`\n   |\n   = note: expected\
    \ struct `String`\n                found enum `Result<String, FromUtf8Error>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    (a ^\
    \ b).to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpdl47s0jw.rs:6:8\n\
    \  |\n6 |     (a ^ b).to_string()\n  |      - ^ - String\n  |      |\n  |    \
    \  String\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for c in a.chars() {\n        if b[c.0 as usize]\
    \ != c.1 {\n            result.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0610]: `char` is a primitive type and therefore doesn't have fields\n\
    \ --> /tmp/tmpwmu_pu22.rs:8:16\n  |\n8 |         if b[c.0 as usize] != c.1 {\n\
    \  |                ^\n\nerror[E0610]: `char` is a primitive type and therefore\
    \ doesn't have fields\n --> /tmp/tmpwmu_pu22.rs:8:33\n  |\n8 |         if b[c.0\
    \ as usize] != c.1 {\n  |                                 ^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0610`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    (a.as_bytes()\
    \ ^ b.as_bytes()).to_string_lossy().to_string()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `&[u8] ^ &[u8]`\n --> /tmp/tmp5nj_mvlr.rs:6:19\n\
    \  |\n6 |     (a.as_bytes() ^ b.as_bytes()).to_string_lossy().to_string()\n  |\
    \      ------------ ^ ------------ &[u8]\n  |      |\n  |      &[u8]\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut output: String = \"\";\n    for c in a.chars().chain(b.chars()) {\n    \
    \    if *c != *c {\n            output += '0'\n        } else {\n            output\
    \ += '1'\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnc2al9me.rs:6:30\n  |\n6 |\
    \     let mut output: String = \"\";\n  |                     ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                     |   \
    \     |\n  |                     |        expected struct `String`, found `&str`\n\
    \  |                     expected due to this\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n --> /tmp/tmpnc2al9me.rs:8:12\n  |\n8 |         if *c != *c\
    \ {\n  |            ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n -->\
    \ /tmp/tmpnc2al9me.rs:8:18\n  |\n8 |         if *c != *c {\n  |              \
    \    ^^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnc2al9me.rs:9:23\n  |\n\
    9 |             output += '0'\n  |                       ^^^ expected `&str`,\
    \ found `char`\n  |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \  |\n9 |             output += \"0\"\n  |                       ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnc2al9me.rs:11:23\n   |\n11 |             output\
    \ += '1'\n   |                       ^^^ expected `&str`, found `char`\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n11 |   \
    \          output += \"1\"\n   |                       ~~~\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).filter_map(|(a,\
    \ b)| {\n        if *a == *b {\n            Ok((*a, *a))\n        } else {\n \
    \           Ok((*a, *b))\n        }\n    }).map(|(a, b)| String::from_utf8(a).unwrap().to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmps35_ligs.rs:7:12\n\
    \  |\n7 |         if *a == *b {\n  |            ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n --> /tmp/tmps35_ligs.rs:7:18\n  |\n7 |         if *a\
    \ == *b {\n  |                  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \ --> /tmp/tmps35_ligs.rs:8:17\n  |\n8 |             Ok((*a, *a))\n  |       \
    \          ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmps35_ligs.rs:8:21\n\
    \  |\n8 |             Ok((*a, *a))\n  |                     ^^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmps35_ligs.rs:8:13\n  |\n8 |             Ok((*a,\
    \ *a))\n  |             ^^^^^^^^^^^^ expected enum `Option`, found enum `Result`\n\
    \  |\n  = note: expected enum `Option<_>`\n             found enum `Result<_,\
    \ _>`\nhelp: try wrapping the expression in `Some`\n  |\n8 |             Some(Ok((*a,\
    \ *a)))\n  |             +++++            +\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmps35_ligs.rs:10:17\n   |\n10 |             Ok((*a,\
    \ *b))\n   |                 ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmps35_ligs.rs:10:21\n   |\n10 |             Ok((*a, *b))\n   |  \
    \                   ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps35_ligs.rs:10:13\n\
    \   |\n10 |             Ok((*a, *b))\n   |             ^^^^^^^^^^^^ expected enum\
    \ `Option`, found enum `Result`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found enum `Result<_, _>`\nhelp: try wrapping the expression in\
    \ `Some`\n   |\n10 |             Some(Ok((*a, *b)))\n   |             +++++  \
    \          +\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n\n    for i in 0..a.len() {\n        result .push_str(&if\
    \ a.chars().nth(i) == b.chars().nth(i) {\n            '1'\n        } else {\n\
    \            '0'\n        });\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjq11a8pu.rs:9:26\n   |\n\
    9  |           result .push_str(&if a.chars().nth(i) == b.chars().nth(i) {\n \
    \  |  __________________________^\n10 | |             '1'\n11 | |         } else\
    \ {\n12 | |             '0'\n13 | |         });\n   | |_________^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::with_capacity(a.len());\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        if *a != *b {\n            res.push_str(&*a);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpvo78yxrj.rs:8:12\n\
    \  |\n8 |         if *a != *b {\n  |            ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n --> /tmp/tmpvo78yxrj.rs:8:18\n  |\n8 |         if *a\
    \ != *b {\n  |                  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \ --> /tmp/tmpvo78yxrj.rs:9:27\n  |\n9 |             res.push_str(&*a);\n  | \
    \                          ^^\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {}{}\", a, b)\n        .chars()\n        .map(|c| if c != b'\\x00' { c ^ b'\\\
    x00' } else { b'\\x00' })\n        .collect::<Vec<Char>>()\n        .iter()\n\
    \        .map(String::from)\n        .collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n --> /tmp/tmpnb6pjbp1.rs:9:24\n\
    \  |\n9 |         .collect::<Vec<Char>>()\n  |                        ^^^^\n \
    \ |\nhelp: a builtin type with a similar name exists\n  |\n9 |         .collect::<Vec<char>>()\n\
    \  |                        ~~~~\nhelp: you might be missing a type parameter\n\
    \  |\n5 | fn string_xor<Char>(a: String, b: String) -> String {\n  |         \
    \     ++++++\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnb6pjbp1.rs:8:26\n\
    \  |\n8 |         .map(|c| if c != b'\\x00' { c ^ b'\\x00' } else { b'\\x00' })\n\
    \  |                          ^^^^^^^ expected `char`, found `u8`\n\nerror[E0369]:\
    \ no implementation for `char ^ u8`\n --> /tmp/tmpnb6pjbp1.rs:8:38\n  |\n8 | \
    \        .map(|c| if c != b'\\x00' { c ^ b'\\x00' } else { b'\\x00' })\n  |  \
    \                                  - ^ ------- u8\n  |                       \
    \             |\n  |                                    char\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0412.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.to_string();\n    let mut b = b.to_string();\n    while a.len() >=\
    \ b.len() {\n        a.pop();\n        b.pop();\n    }\n    while a.len() < b.len()\
    \ {\n        a.push('0');\n        b.push('0');\n    }\n    a.chars().zip(b.chars()).filter(|(&xa,\
    \ &xb)| xa != xb).map(|(&xa, &xb)| xa ^ xb).collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwz6hkej5.rs:16:39\n   |\n\
    16 |     a.chars().zip(b.chars()).filter(|(&xa, &xb)| xa != xb).map(|(&xa, &xb)|\
    \ xa ^ xb).collect()\n   |                                       ^^^     - expected\
    \ due to this\n   |                                       |\n   |            \
    \                           expected `char`, found reference\n   |           \
    \                            help: you can probably remove the explicit borrow:\
    \ `xa`\n   |\n   = note:   expected type `char`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwz6hkej5.rs:16:44\n   |\n16 |\
    \     a.chars().zip(b.chars()).filter(|(&xa, &xb)| xa != xb).map(|(&xa, &xb)|\
    \ xa ^ xb).collect()\n   |                                            ^^^- expected\
    \ due to this\n   |                                            |\n   |       \
    \                                     expected `char`, found reference\n   | \
    \                                           help: you can probably remove the\
    \ explicit borrow: `xb`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwz6hkej5.rs:16:66\n\
    \   |\n16 |     a.chars().zip(b.chars()).filter(|(&xa, &xb)| xa != xb).map(|(&xa,\
    \ &xb)| xa ^ xb).collect()\n   |                                             \
    \                     ^^^     - expected due to this\n   |                   \
    \                                               |\n   |                      \
    \                                            expected `char`, found reference\n\
    \   |                                                                  help: you\
    \ can probably remove the explicit borrow: `xa`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwz6hkej5.rs:16:71\n   |\n16 |     a.chars().zip(b.chars()).filter(|(&xa,\
    \ &xb)| xa != xb).map(|(&xa, &xb)| xa ^ xb).collect()\n   |                  \
    \                                                     ^^^- expected due to this\n\
    \   |                                                  "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(string_a_b(a)\
    \ ^ string_a_b(b))\n        .expect(\"failed to convert a_b result to String\"\
    )\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `string_a_b` in this scope\n --> /tmp/tmpjczf88ao.rs:6:23\n\
    \  |\n6 |     String::from_utf8(string_a_b(a) ^ string_a_b(b))\n  |          \
    \             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `string_a_b` in this scope\n --> /tmp/tmpjczf88ao.rs:6:39\n  |\n6 |\
    \     String::from_utf8(string_a_b(a) ^ string_a_b(b))\n  |                  \
    \                     ^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert!(b.len()\
    \ == a.len(), \"input strings must have equal length\");\n    let mut result =\
    \ String::with_capacity(a.len());\n    for (a, b) in zip(a.chars(), b.chars())\
    \ {\n        if a != b {\n            result.push(a);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n --> /tmp/tmpc6wbgdj2.rs:8:19\n\
    \  |\n8 |     for (a, b) in zip(a.chars(), b.chars()) {\n  |                 \
    \  ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::iter::zip;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.to_owned();\n    let mut b = b.to_owned();\n    for (ix, elt) in a.iter().enumerate()\
    \ {\n        *elt ^= *b[ix];\n    }\n    String::from(a)\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpef95u279.rs:8:24\n  |\n8 |     for (ix, elt) in a.iter().enumerate()\
    \ {\n  |                        ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n8 |     for (ix, elt) in a.chars().enumerate()\
    \ {\n  |                        ~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut x: String = \"\".to_string();\n    let mut y: String = \"\".to_string();\n\
    \    let mut r: String = \"\".to_string();\n\n    for i in 0..a.len() {\n    \
    \    match a.chars().nth(i) {\n            '1' => x += '0',\n            '0' =>\
    \ y += '0',\n            _ => panic!(),\n        }\n    }\n\n    for i in 0..b.len()\
    \ {\n        match b.chars().nth(i) {\n            '1' => x += '0',\n        \
    \    '0' => y += '0',\n            _ => panic!(),\n        }\n    }\n\n    x +=\
    \ y;\n\n    for c in x.chars() {\n        match c {\n            '0' => r += '1',\n\
    \            '1' => r += '0',\n            _ => panic!(),\n        }\n    }\n\n\
    \    r\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzjoc3b0z.rs:12:13\n   |\n\
    11 |         match a.chars().nth(i) {\n   |               ---------------- this\
    \ expression has type `Option<char>`\n12 |             '1' => x += '0',\n   |\
    \             ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ pattern in `Some`\n   |\n12 |             Some('1') => x += '0',\n   |     \
    \        +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzjoc3b0z.rs:13:13\n\
    \   |\n11 |         match a.chars().nth(i) {\n   |               ----------------\
    \ this expression has type `Option<char>`\n12 |             '1' => x += '0',\n\
    13 |             '0' => y += '0',\n   |             ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the pattern in `Some`\n   |\n13 |          \
    \   Some('0') => y += '0',\n   |             +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzjoc3b0z.rs:12:25\n   |\n12 |             '1' => x += '0',\n\
    \   |                         ^^^ expected `&str`, found `char`\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n12 |          \
    \   '1' => x += \"0\",\n   |                         ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzjoc3b0z.rs:13:25\n   |\n13 |             '0' => y += '0',\n\
    \   |                         ^^^ expected `&str`, found `char`\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n13 |          \
    \   '0' => y += \"0\",\n   |                         ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzjoc3b0z.rs:20:13\n   |\n19 |         match b.chars().nth(i)\
    \ {\n   |               ---------------- this expression has type `Option<char>`\n\
    20 |             '1' => x += '0',\n   |             ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the pattern in `Some`\n   |\n20 |          \
    \   Some('1') => x += '0',\n   |             +++++   +\n\nerror[E"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a: Vec<u8> = a.as_bytes().to_vec();\n    let mut b: Vec<u8> = b.as_bytes().to_vec();\n\
    \    while a.len() > 0 || b.len() > 0 {\n        if a.len() == 0 {\n         \
    \   b.push(0);\n            a.push(0);\n        } else if b.len() == 0 {\n   \
    \         a.push(0);\n            b.push(0);\n        }\n        if a.last() ^\
    \ b.last() != 0 {\n            a.push(0);\n            b.push(0);\n        }\n\
    \    }\n    String::from_utf8_lossy(&a).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `Option<&u8> ^ Option<&u8>`\n  -->\
    \ /tmp/tmp87nsm5u3.rs:16:21\n   |\n16 |         if a.last() ^ b.last() != 0 {\n\
    \   |            -------- ^ -------- Option<&u8>\n   |            |\n   |    \
    \        Option<&u8>\n\nerror[E0599]: no method named `unwrap` found for enum\
    \ `Cow<'_, str>` in the current scope\n  --> /tmp/tmp87nsm5u3.rs:21:33\n   |\n\
    21 |     String::from_utf8_lossy(&a).unwrap()\n   |                          \
    \       ^^^^^^ method not found in `Cow<'_, str>`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for _ in 0..a.len() {\n        res.push_str(&b[a\
    \ as usize] ^ b[(b as usize) + 1]);\n        (b as usize) += 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpugm6i_tn.rs:8:23\n\
    \  |\n8 |         res.push_str(&b[a as usize] ^ b[(b as usize) + 1]);\n  |   \
    \                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n\
    \  = help: the trait `Index<usize>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmpugm6i_tn.rs:8:39\n\
    \  |\n8 |         res.push_str(&b[a as usize] ^ b[(b as usize) + 1]);\n  |   \
    \                                    ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0067]: invalid left-hand side of assignment\n --> /tmp/tmpugm6i_tn.rs:9:22\n\
    \  |\n9 |         (b as usize) += 2;\n  |         ------------ ^^\n  |       \
    \  |\n  |         cannot assign to this expression\n\nerror[E0605]: non-primitive\
    \ cast: `String` as `usize`\n --> /tmp/tmpugm6i_tn.rs:8:25\n  |\n8 |         res.push_str(&b[a\
    \ as usize] ^ b[(b as usize) + 1]);\n  |                         ^^^^^^^^^^ an\
    \ `as` expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror[E0605]: non-primitive cast: `String` as\
    \ `usize`\n --> /tmp/tmpugm6i_tn.rs:8:41\n  |\n8 |         res.push_str(&b"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut r = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n     \
    \   if a == b {\n            r.push('a');\n        } else {\n            r.push('0');\n\
    \        }\n    }\n    r\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a0aa0a\"`,\n right: `\"010010\"`', /tmp/tmpgownkx8o.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbih32755.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |       ^^^^ method not found in `String`\n\
    \  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |       ~~~~~\n\nerror[E0599]: no method named\
    \ `iter` found for struct `String` in the current scope\n --> /tmp/tmpbih32755.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                    ^^^^ method not found in `String`\n  |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                    ~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"Cannot xor string with non-matching lengths.\
    \ {} != {}\", a.len(), b.len());\n    }\n    let mut res = String::new();\n  \
    \  for (x, y) in a.chars().zip(b.chars()) {\n        *res += if x == y { x } else\
    \ { x ^ y };\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n  --> /tmp/tmperko14dz.rs:11:42\n\
    \   |\n11 |         *res += if x == y { x } else { x ^ y };\n   |            \
    \                            - ^ - char\n   |                                \
    \        |\n   |                                        char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.iter().zip(b.iter()).map(|(x,\
    \ y)| {\n        let mut c = 0u8;\n        for x in x {\n            c ^= 1u8\
    \ & y;\n        }\n        c\n    }).collect::<String>(\"\")\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp1te8rqmq.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(x,\
    \ y)| {\n  |       ^^^^ method not found in `String`\n  |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(x,\
    \ y)| {\n  |       ~~~~~\n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n --> /tmp/tmp1te8rqmq.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(x,\
    \ y)| {\n  |                    ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(x,\
    \ y)| {\n  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result: String = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        *result |= c1 ^ *c2;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpxlu8mzvf.rs:8:25\n\
    \  |\n8 |         *result |= c1 ^ *c2;\n  |                         ^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in a.chars() {\n        res.push_str(&b[i\
    \ % b.len()]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `usize`\n --> /tmp/tmp773l8i2u.rs:8:27\n\
    \  |\n8 |         res.push_str(&b[i % b.len()]);\n  |                        \
    \ - ^ ------- usize\n  |                         |\n  |                      \
    \   char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(format!(\"\
    {:b}\", a ^ b).to_string())\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpewmlyk2d.rs:6:36\n\
    \  |\n6 |     String::from(format!(\"{:b}\", a ^ b).to_string())\n  |        \
    \                          - ^ - String\n  |                                 \
    \ |\n  |                                  String\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(binary_xor_of_string(&a.chars(),\
    \ &b.chars()).collect::<String>())\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_xor_of_string` in this scope\n\
    \ --> /tmp/tmpldp5q7i6.rs:6:18\n  |\n6 |     String::from(binary_xor_of_string(&a.chars(),\
    \ &b.chars()).collect::<String>())\n  |                  ^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(\"\
    \").into_iter().zip(b.into_iter()).filter(|(a, b)| a != b).map(|(a, b)| a.to_string()).collect::<Vec<_>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmpkgvt8ctm.rs:6:22\n    |\n6 \
    \  |       String::from(\"\").into_iter().zip(b.into_iter()).filter(|(a, b)| a\
    \ != b).map(|(a, b)| a.to_string()).col...\n    |                        ^^^^^^^^^\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `String: IntoIterator`\n\
    \            `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror[E0599]: the method `into_iter`\
    \ exists for struct `String`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmpkgvt8ctm.rs:6:40\n    |\n6   |       String::from(\"\").into_iter().zip(b.into_iter()).filter(|(a,\
    \ b)| a != b).map(|(a, b)| a.to_string()).col...\n    |                      \
    \                    ^^^^^^^^^\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `String: IntoIterator`\n            `&String: Iterator`\n            which\
    \ is required by `&String: IntoIterator`\n            `&mut String: Iterator`\n\
    \            which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut xor = String::new();\n    for &(ref ai, ref bi) in a.chars().zip(b.chars())\
    \ {\n        xor.push(*ai ^ *bi);\n    }\n    xor\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpur25d42x.rs:7:9\n  |\n7 |\
    \     for &(ref ai, ref bi) in a.chars().zip(b.chars()) {\n  |         ^^^^^^^^^^^^^^^^^\
    \    ------------------------ this expression has type `Option<(char, char)>`\n\
    \  |         |\n  |         expected tuple, found reference\n  |\n  = note:  expected\
    \ tuple `(char, char)`\n          found reference `&_`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpzb977ml5.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"length of input strings must be equal\");\n \
    \   }\n    let mut result = vec![];\n    for i in 0..a.len() {\n        result.append(a[i]\
    \ ^ b[i]);\n    }\n    result.into()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2cg0cyaa.rs:11:23\n\
    \   |\n11 |         result.append(a[i] ^ b[i]);\n   |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2cg0cyaa.rs:11:30\n   |\n11 |         result.append(a[i] ^ b[i]);\n\
    \   |                              ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `String: From<Vec<_>>` is not satisfied\n\
    \  --> /tmp/tmp2cg0cyaa.rs:13:12\n   |\n13 |     result.into()\n   |         \
    \   ^^^^ the trait `From<Vec<_>>` is not implemented for `String`\n   |\n   =\
    \ help: the following other types implement trait `From<T>`:\n             <String\
    \ as From<&String>>\n             <String as From<&mut str>>\n             <String\
    \ as From<&str>>\n             <String as From<Box<str>>>\n             <String\
    \ as From<Cow<'a, str>>>\n             <String as From<char>>\n   = note: required\
    \ because of the requirements on the impl of `Into<String>` for `Vec<_>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut s = String::new();\n    for i in 0..a.len() {\n        s.push_str(a.chars().nth(i).unwrap().to_string());\n\
    \    }\n    for i in 0..b.len() {\n        s.push_str(b.chars().nth(i).unwrap().to_string());\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpo54afbjs.rs:8:20\n  |\n8 |\
    \         s.push_str(a.chars().nth(i).unwrap().to_string());\n  |            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                    |\n  |\
    \                    expected `&str`, found struct `String`\n  |             \
    \       help: consider borrowing here: `&a.chars().nth(i).unwrap().to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo54afbjs.rs:11:20\n   |\n11 |\
    \         s.push_str(b.chars().nth(i).unwrap().to_string());\n   |           \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                    |\n \
    \  |                    expected `&str`, found struct `String`\n   |         \
    \           help: consider borrowing here: `&b.chars().nth(i).unwrap().to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n\n    for c in a.chars() {\n        if b.get(c) !=\
    \ '0' {\n            res.push_str(&format!(\"{:02}\", c));\n        } else {\n\
    \            res.push(c);\n        }\n    }\n\n    for c in b.chars() {\n    \
    \    if a.get(c) != '0' {\n            res.push_str(&format!(\"{:02}\", c));\n\
    \        } else {\n            res.push(c);\n        }\n    }\n\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `char`\n   --> /tmp/tmp7gf9s4wx.rs:9:18\n\
    \    |\n9   |         if b.get(c) != '0' {\n    |              --- ^ string indices\
    \ are ranges of `usize`\n    |              |\n    |              required by\
    \ a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>`\
    \ is not implemented for `char`\nnote: required by a bound in `core::str::<impl\
    \ str>::get`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7gf9s4wx.rs:9:24\n\
    \  |\n9 |         if b.get(c) != '0' {\n  |                        ^^^ expected\
    \ enum `Option`, found `char`\n  |\n  = note: expected enum `Option<&_>`\n   \
    \          found type `char`\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `char`\n   --> /tmp/tmp7gf9s4wx.rs:17:18\n    |\n17  |         if a.get(c)\
    \ != '0' {\n    |              --- ^ string indices are ranges of `usize`\n  \
    \  |              |\n    |              required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for\
    \ `char`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7gf9s4wx.rs:17:24\n   |\n17 |         if a.get(c)\
    \ != '0' {\n   |                        ^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<&_>`\n              found type `char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    bincode::bin_xor_i64(a.as_bytes(),\
    \ b.as_bytes()).to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n\
    \ --> /tmp/tmpmdksuo63.rs:6:5\n  |\n6 |     bincode::bin_xor_i64(a.as_bytes(),\
    \ b.as_bytes()).to_string()\n  |     ^^^^^^^ use of undeclared crate or module\
    \ `bincode`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.encode_utf8()\
    \ ^ b.encode_utf8()).unwrap()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `encode_utf8` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpl48q5h06.rs:6:25\n  |\n6 |     String::from_utf8(a.encode_utf8()\
    \ ^ b.encode_utf8()).unwrap()\n  |                         ^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `encode_utf16`\n\nerror[E0599]:\
    \ no method named `encode_utf8` found for struct `String` in the current scope\n\
    \ --> /tmp/tmpl48q5h06.rs:6:43\n  |\n6 |     String::from_utf8(a.encode_utf8()\
    \ ^ b.encode_utf8()).unwrap()\n  |                                           ^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `encode_utf16`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a +\
    \ &b[..std::cmp::min(a.len(), b.len())].iter().map(|&c| c.to_ne_byte()).sum::<u8>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmppdzamouv.rs:6:47\n  |\n6 |     a + &b[..std::cmp::min(a.len(),\
    \ b.len())].iter().map(|&c| c.to_ne_byte()).sum::<u8>()\n  |                 \
    \                              ^^^^ method not found in `str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut sum: u32 = 0;\n    for i in a.chars().take(32).chain(b.chars().take(32))\
    \ {\n        sum += i;\n    }\n    String::from_be_bytes(sum).to_string()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `char` to `u32`\n --> /tmp/tmptw8aw8wu.rs:8:13\n\
    \  |\n8 |         sum += i;\n  |             ^^ no implementation for `u32 +=\
    \ char`\n  |\n  = help: the trait `AddAssign<char>` is not implemented for `u32`\n\
    \  = help: the following other types implement trait `AddAssign<Rhs>`:\n     \
    \       <f32 as AddAssign<&f32>>\n            <f32 as AddAssign>\n           \
    \ <f64 as AddAssign<&f64>>\n            <f64 as AddAssign>\n            <i128\
    \ as AddAssign<&i128>>\n            <i128 as AddAssign>\n            <i16 as AddAssign<&i16>>\n\
    \            <i16 as AddAssign>\n          and 20 others\n\nerror[E0599]: no function\
    \ or associated item named `from_be_bytes` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmptw8aw8wu.rs:10:13\n   |\n10 |     String::from_be_bytes(sum).to_string()\n\
    \   |             ^^^^^^^^^^^^^ function or associated item not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {}{}\", a, b).to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"111000101010\"`,\n right: `\"010010\"`', /tmp/tmp539qxruy.rs:11:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\n            \"Input strings a and b must have\
    \ equal length. a: {}, b: {}\",\n            a,\n            b\n        );\n \
    \   }\n\n    let mut res = String::with_capacity(a.len());\n    for i in 0..a.len()\
    \ {\n        match a.get(i) {\n            None => res.push_str(\"0\"),\n    \
    \        Some('0' | '1' | 'x') => {\n                match b.get(i) {\n      \
    \              None => res.push_str(\"0\"),\n                    Some('0' | '1'\
    \ | 'x') => {\n                        let c = b'.get(i);\n                  \
    \      let x = a.chars().nth(i).unwrap();\n                        let y = b.chars().nth(i).unwrap();\n\
    \                        if c == '0' && x == '0' && y == '0' {\n             \
    \               res.push_str(\"0\");\n                        }\n            \
    \            else if c == '0' && x == '0' && y != '0' {\n                    \
    \        res.push_str(\"1\");\n                        }\n                   \
    \     else if c != '0' && x == '0' && y == '0' {\n                           \
    \ res.push_str(&String::from(\"1\"));\n                        }\n           \
    \             else if c != '0' && x == '0' && y != '0' {\n                   \
    \         res.push_str(&String::from(\"0\"));\n                        }\n   \
    \                     else if c != '0' && x != '0' && y == '0' {\n           \
    \                 res.push_str(&String::from(\"1\"));\n                      \
    \  }\n                        else if c != '0' && x != '0' && y != '0' {\n   \
    \                         res.push_str(&String::from(\"0\"));\n              \
    \          }\n                        else if c == '0' && x != '0' && y == '0'\
    \ {\n                            res.push_str(&String::from(\"1\"));\n       \
    \                 }\n                        else if c == '0' && x != '0' && y\
    \ != '0' {\n                            res.push_str(&String::from(\"0\"));\n\
    \                        }\n                        else if c != '0' && x != '0'\
    \ && y == '0' {\n                            res.push_str(&String::from(\"1\"\
    ));\n                        }\n                        else if c != '0' && x\
    \ != '0' && y != '0' {\n                            res.push_str(&String::from(\"\
    0\"));\n                        }\n                        else if c != '0' &&\
    \ x == '0' && y != '0' {\n                            res.push_str(&String::from(\"\
    1\"));\n                        }\n                        else if c != '0' &&\
    \ x == '0' && y == '0' {\n                            res.push_str(&String::from(\"\
    0\"));\n                        }\n                        else if c != '0' &&\
    \ x != '0' && y != '0' {\n                            \n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0763]: unterminated byte constant\n  --> /tmp/tmpb7buhj8n.rs:22:34\n\
    \   |\n22 |                         let c = b'.get(i);\n   |                 \
    \                 ^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0763`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    string_to_int(a)\
    \ ^ string_to_int(b)\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `string_to_int` in this scope\n -->\
    \ /tmp/tmpoxt3ojih.rs:6:5\n  |\n6 |     string_to_int(a) ^ string_to_int(b)\n\
    \  |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `string_to_int` in this scope\n --> /tmp/tmpoxt3ojih.rs:6:24\n  |\n6 |     string_to_int(a)\
    \ ^ string_to_int(b)\n  |                        ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a\
    \ == \"0000\" && b == \"0000\" {\n        return a;\n    }\n    let mut res =\
    \ String::new();\n    for i in (0..a.len() - 1) {\n        if a[i] != b[i] {\n\
    \            res.push_str(&format!(\"{}1\", a[i]));\n        }\n    }\n    res.push_str(&format!(\"\
    {}1\", a[i]));\n    res.trim_end_matches('1');\n    res\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpk3yx7yvc.rs:15:36\n\
    \   |\n15 |     res.push_str(&format!(\"{}1\", a[i]));\n   |                 \
    \                   ^ help: a local variable with a similar name exists: `a`\n\
    \nwarning: unnecessary parentheses around `for` iterator expression\n  --> /tmp/tmpk3yx7yvc.rs:10:14\n\
    \   |\n10 |     for i in (0..a.len() - 1) {\n   |              ^             \
    \ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n10 -     for i in (0..a.len() - 1) {\n10 +     for i in 0..a.len()\
    \ - 1 {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3yx7yvc.rs:11:12\n   |\n11 |         if a[i] != b[i] {\n   | \
    \           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3yx7yvc.rs:11:20\n   |\n11 |         if a[i] != b[i] {\n   | \
    \                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3yx7yvc.rs:12:42\n   |\n12 |             res.push_str(&format!(\""
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    binary_xor_iter(a,\
    \ b, |&(a, b), &(b, rest)| {\n        if a != '0' || b != '0' {\n            a\
    \ ^ b\n        } else {\n            rest\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `b` is bound more than once in this parameter\
    \ list\n --> /tmp/tmpm2lh17k9.rs:6:39\n  |\n6 |     binary_xor_iter(a, b, |&(a,\
    \ b), &(b, rest)| {\n  |                                       ^ used as parameter\
    \ more than once\n\nerror[E0425]: cannot find function `binary_xor_iter` in this\
    \ scope\n --> /tmp/tmpm2lh17k9.rs:6:5\n  |\n6 |     binary_xor_iter(a, b, |&(a,\
    \ b), &(b, rest)| {\n  |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0415, E0425.\nFor more information about an error, try `rustc --explain E0415`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    binary_xor_string::binary_xor_string(a,\
    \ b)\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `binary_xor_string`\n\
    \ --> /tmp/tmpjbcrb2yz.rs:6:5\n  |\n6 |     binary_xor_string::binary_xor_string(a,\
    \ b)\n  |     ^^^^^^^^^^^^^^^^^ use of undeclared crate or module `binary_xor_string`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    assert!(a.is_ascii());\n    assert!(b == '0' || b == '1');\n\
    \    let mut res = Vec::new();\n    for i in a.chars().iter().rev().take(b.len()).cloned()\
    \ {\n        res.insert(0, *i ^ *b);\n    }\n    String::from_utf8(res)\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `char`\n --> /tmp/tmpw_3ubbtp.rs:8:15\n\
    \  |\n8 |     assert!(b == '0' || b == '1');\n  |               ^^ no implementation\
    \ for `String == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            <&'a str as PartialEq<OsString>>\n            <&'a str as PartialEq<String>>\n\
    \            <&'b str as PartialEq<Cow<'a, str>>>\n            <String as PartialEq<&'a\
    \ str>>\n            <String as PartialEq<Cow<'a, str>>>\n            <String\
    \ as PartialEq<str>>\n            <String as PartialEq>\n            <str as PartialEq<Cow<'a,\
    \ str>>>\n          and 4 others\n\nerror[E0277]: can't compare `String` with\
    \ `char`\n --> /tmp/tmpw_3ubbtp.rs:8:27\n  |\n8 |     assert!(b == '0' || b ==\
    \ '1');\n  |                           ^^ no implementation for `String == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \       <&'a str as PartialEq<OsString>>\n            <&'a str as PartialEq<String>>\n\
    \            <&'b str as PartialEq<Cow<'a, str>>>\n            <String as PartialEq<&'a\
    \ str>>\n            <String as PartialEq<Cow<'a, str>>>\n            <String\
    \ as PartialEq<str>>\n            <String as PartialEq>\n            <str as PartialEq<Cow<'a,\
    \ str>>>\n          and 4 others\n\nerror[E0599]: no method named `iter` found\
    \ for struct `Chars` in the current scope\n  --> /tmp/tmpw_3ubbtp.rs:10:24\n \
    \  |\n10 |     for i in a.chars().iter().rev().take(b.len()).cloned() {\n   |\
    \                        ^^^^ private field, not a method\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n  --> /tmp/tmpw_3ubbtp.rs:11:26\n\
    \   |\n11 |         res.insert(0, *i ^ *b);\n   |                          ^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3ubbtp.rs:13:5\n\
    \   |\n5  | fn string_xor(a: String, b: "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &b in b.chars().skip(1) {\n        if a.chars().any(|c|\
    \ c == b) {\n            res.push_str(&b);\n        } else {\n            res.push_str(&a);\n\
    \        }\n    }\n    res.push_str(&a)\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpobcod9z7.rs:7:9\n  |\n7 |\
    \     for &b in b.chars().skip(1) {\n  |         ^^    ----------------- this\
    \ expression has type `Option<char>`\n  |         |\n  |         expected `char`,\
    \ found reference\n  |         help: you can probably remove the explicit borrow:\
    \ `b`\n  |\n  = note:   expected type `char`\n          found reference `&_`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpobcod9z7.rs:9:26\n  |\n9 |    \
    \         res.push_str(&b);\n  |                          ^^ expected `str`, found\
    \ `char`\n  |\n  = note: expected reference `&str`\n             found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpobcod9z7.rs:14:5\n\
    \   |\n5  | fn string_xor(a: String, b: String) -> String {\n   |            \
    \                            ------ expected `String` because of return type\n\
    ...\n14 |     res.push_str(&a)\n   |     ^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpobcod9z7.rs:14:9\n   |\n14 |     res.push_str(&a)\n   |     ---\
    \ ^^^^^^^^ this call modifies `res` in-place\n   |     |\n   |     you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).fold(String::new(),\
    \ |mut acc, (a, b)| {\n        let c = a + b;\n        acc.push_str(c.to_digit(10).to_string());\n\
    \        acc\n    })\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n --> /tmp/tmpqjpsq49z.rs:7:19\n\
    \  |\n7 |         let c = a + b;\n  |                 - ^ - char\n  |        \
    \         |\n  |                 char\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = vec![];\n    for i in 0..a.len() {\n        match a[i] {\n       \
    \     '0' => {\n                match b[i] {\n                    '1' => {\n \
    \                       res.push('a');\n                    },\n             \
    \       '0' => {\n                        res.push('b');\n                   \
    \ }\n                }\n            },\n            '1' => {\n               \
    \ match b[i] {\n                    '1' => {\n                        res.push('b');\n\
    \                    },\n                    '0' => {\n                      \
    \  res.push('a');\n                    }\n                }\n            },\n\
    \            _ => {}\n        }\n    }\n    res.collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpnjc9h5ub.rs:8:15\n\
    \  |\n8 |         match a[i] {\n  |               ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnjc9h5ub.rs:10:23\n\
    \   |\n10 |                 match b[i] {\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnjc9h5ub.rs:20:23\n   |\n20 |                 match b[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ `Vec<char>` is not an iterator\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // TODO:\
    \ Check if string inputs are valid\n    let a = a.to_string();\n    let b = b.to_string();\n\
    \    let mut result = \"\";\n    for &b in &b[..] {\n        result += '0' if\
    \ *b == '1' else '1';\n    }\n    for &a in &a[..] {\n        result += '0' if\
    \ *a == '1' else '1';\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpa0prl51w.rs:11:23\n   |\n11 |         result += '0' if *b\
    \ == '1' else '1';\n   |                       ^^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpa0prl51w.rs:14:23\n   |\n14 |         result\
    \ += '0' if *a == '1' else '1';\n   |                       ^^ expected one of\
    \ `.`, `;`, `?`, `}`, or an operator\n\nerror[E0277]: `&str` is not an iterator\n\
    \  --> /tmp/tmpa0prl51w.rs:10:15\n   |\n10 |     for &b in &b[..] {\n   |    \
    \           ^^^^^^ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&str`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&str`\n\
    \nerror[E0277]: `&str` is not an iterator\n  --> /tmp/tmpa0prl51w.rs:13:15\n \
    \  |\n13 |     for &a in &a[..] {\n   |               ^^^^^^ `&str` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa0prl51w.rs:16:5\n   |\n5  | fn string_xor(a: String, b: String)\
    \ -> String {\n   |                                        ------ expected `String`\
    \ because of return type\n...\n16 |     result\n   |     ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut ret = String::new();\n    for (i, c) in a.chars().enumerate() {\n      \
    \  if b[i as usize] != c {\n            ret += c;\n        }\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp3x1z2100.rs:8:12\n\
    \  |\n8 |         if b[i as usize] != c {\n  |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp3x1z2100.rs:9:20\n  |\n9 |    \
    \         ret += c;\n  |                    ^ expected `&str`, found `char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a { result.push((c ^ &b[0]) as char);\
    \ }\n    for &c in &b { result.push((c ^ &a[0]) as char); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp0p703cpk.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push((c ^ &b[0]) as char); }\n  |        \
    \       ^^ `&String` is not an iterator\n  |\n  = help: the trait `Iterator` is\
    \ not implemented for `&String`\n  = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n --> /tmp/tmp0p703cpk.rs:7:38\n  |\n7 |  \
    \   for &c in &a { result.push((c ^ &b[0]) as char); }\n  |                  \
    \                    ^^^^ `String` cannot be indexed by `{integer}`\n  |\n  =\
    \ help: the trait `Index<{integer}>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ `&String` is not an iterator\n --> /tmp/tmp0p703cpk.rs:8:15\n  |\n8 |     for\
    \ &c in &b { result.push((c ^ &a[0]) as char); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \ --> /tmp/tmp0p703cpk.rs:8:38\n  |\n8 |     for &c in &b { result.push((c ^ &a[0])\
    \ as char); }\n  |                                      ^^^^ `String` cannot be\
    \ indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert!(\n\
    \        a.len() == b.len(),\n        \"Input strings must be same length\",\n\
    \    );\n    let mut res = String::new();\n    for ch in a.chars() {\n       \
    \ res.push_str(&ch.to_string() ^ b.chars().next().unwrap().to_string());\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `&String ^ String`\n  --> /tmp/tmpjgbm12af.rs:12:38\n\
    \   |\n12 |         res.push_str(&ch.to_string() ^ b.chars().next().unwrap().to_string());\n\
    \   |                      --------------- ^ -------------------------------------\
    \ String\n   |                      |\n   |                      &String\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ == 0 || b.len() == 0 {\n        \"\".to_string()\n    } else {\n        a.to_string()\
    \ + b.to_string()\n    }\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpronljfm9.rs:9:25\n  |\n9 |\
    \         a.to_string() + b.to_string()\n  |                         ^^^^^^^^^^^^^\n\
    \  |                         |\n  |                         expected `&str`, found\
    \ struct `String`\n  |                         help: consider borrowing here:\
    \ `&b.to_string()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // If\
    \ any one is empty return empty string.\n    if a.is_empty() || b.is_empty() {\n\
    \        return \"\";\n    }\n    if a.len() != b.len() {\n        return \"\"\
    ;\n    }\n    let mut res: String = \"\";\n    let mut a_iter = a.chars();\n \
    \   let mut b_iter = b.chars();\n\n    for a_val in a_iter {\n        if b_iter.any(|b_val|\
    \ a_val != b_val) {\n            break;\n        }\n        res.insert(0, a_val);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvxhafimt.rs:8:16\n  |\n5 |\
    \ fn string_xor(a: String, b: String) -> String {\n  |                       \
    \                 ------ expected `String` because of return type\n...\n8 |  \
    \       return \"\";\n  |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n  |                |\n  |                expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvxhafimt.rs:13:27\n\
    \   |\n13 |     let mut res: String = \"\";\n   |                  ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  |\
    \        |\n   |                  |        expected struct `String`, found `&str`\n\
    \   |                  expected due to this\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        let mut j = i;\n\
    \        while j < b.len() && b.starts_with(&a[j..]) {\n            res.push_str(&a[j..]);\n\
    \            j += 1; // Move on to the end of the next letter\n        }\n   \
    \     res.push_str(&b[j..]); // Only add chars missing from a\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"101010010101010010100\"`,\n right: `\"010010\"`', /tmp/tmpgb8x5qh_.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = vec![];\n    let mut len = a.len();\n    let mut carry = 0;\n \
    \   let mut a_len = a.chars().count();\n    let mut b_len = b.chars().count();\n\
    \n    if a_len == 0 || b_len == 0 {\n        result.append(0);\n        return\
    \ String::from_utf8(result.as_slice()).unwrap();\n    }\n\n    // First check\
    \ for overflow\n    if b_len > a_len {\n        let mut b_len = b_len;\n     \
    \   let mut a_len = a_len;\n        let mut carry = 0;\n    }\n\n    // Process\
    \ the two strings in parallel\n    for i in a_len..(len + 1) {\n        let mut\
    \ a_char = a.chars().nth(i);\n        let mut b_char = b.chars().nth(i);\n   \
    \     // Do the actual XOR\n        let res = a_char.wrapping_xor(&b_char);\n\
    \        // Append result to result\n        result.append(res);\n        // Remember\
    \ the carry for the next iteration\n        carry = ((*res) + carry) & 0xff;\n\
    \    }\n\n    // If carry is > 0 add it to the result, if not, just move the result\
    \ to the end\n    if carry > 0 {\n        result.append(carry);\n    }\n\n   \
    \ // Reverse result\n    result.reverse();\n\n    return String::from_utf8(result.as_slice()).unwrap();\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvy008dyy.rs:13:23\n   |\n\
    13 |         result.append(0);\n   |                       ^ expected `&mut Vec<_>`,\
    \ found integer\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n \
    \                          found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvy008dyy.rs:14:34\n   |\n14 |         return String::from_utf8(result.as_slice()).unwrap();\n\
    \   |                                  ^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |                                  |\n   |         \
    \                         expected struct `Vec`, found `&[_]`\n   |\n   = note:\
    \ expected struct `Vec<u8>`\n           found reference `&[_]`\n\nerror[E0599]:\
    \ no method named `wrapping_xor` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpvy008dyy.rs:29:26\n   |\n29 |         let res = a_char.wrapping_xor(&b_char);\n\
    \   |                          ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `map_or`\n\nerror[E0369]: cannot add `{integer}` to `Vec<_>`\n\
    \  --> /tmp/tmpvy008dyy.rs:33:25\n   |\n33 |         carry = ((*res) + carry)\
    \ & 0xff;\n   |                  ------ ^ ----- {integer}\n   |              \
    \    |\n   |                  Vec<_>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvy008dyy.rs:38:23\n   |\n38 |         result.append(carry);\n   |  \
    \                     ^^^^^ expected `&mut Vec<_>`, found integer\n   |\n   =\
    \ note: expected mutable reference `&mut Vec<_>`\n                           found\
    \ type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvy008dyy.rs:44:30\n\
    \   |\n44 |     return String::from_utf8(result.as_slice()).unwrap();\n   |  \
    \                            ^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_vec()`\n   |                              |\n   |                     \
    \         expected struct `Vec`, found `&[_]`\n   |\n   = note: expected struct\
    \ `Vec<u8>`\n           found reference `&[_]`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more informa"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut carry = 0;\n\n    for (ix, &ch) in\
    \ a.chars().enumerate() {\n        let (q, r) = if let Some((x, _)) = b[ix].chars().next()\
    \ {\n            (carry + x * b, 0)\n        } else {\n            ((carry, 1),\
    \ 0)\n        };\n        if q != 0 {\n            result.push_str(&format!(\"\
    {}{}\", ch - '0', q % 10));\n        }\n        carry = r;\n    }\n\n    if carry\
    \ != 0 {\n        result.push_str(&format!(\"{}{}\", ch - '0', carry % 10));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ch` in this scope\n  --> /tmp/tmpo5ym4r6m.rs:22:42\n\
    \   |\n22 |         result.push_str(&format!(\"{}{}\", ch - '0', carry % 10));\n\
    \   |                                          ^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpo5ym4r6m.rs:9:14\n  |\n9 |     for\
    \ (ix, &ch) in a.chars().enumerate() {\n  |              ^^^     ---------------------\
    \ this expression has type `Option<(usize, char)>`\n  |              |\n  |  \
    \            expected `char`, found reference\n  |              help: you can\
    \ probably remove the explicit borrow: `ch`\n  |\n  = note:   expected type `char`\n\
    \          found reference `&_`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpo5ym4r6m.rs:10:44\n   |\n10 |         let (q, r) =\
    \ if let Some((x, _)) = b[ix].chars().next() {\n   |                         \
    \                   ^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo5ym4r6m.rs:15:17\n\
    \   |\n15 |         if q != 0 {\n   |                 ^ expected tuple, found\
    \ integer\n   |\n   = note: expected tuple `({integer}, {integer})`\n        \
    \       found type `{integer}`\n\nerror[E0369]: cannot mod `({integer}, {integer})`\
    \ by `{integer}`\n  --> /tmp/tmpo5ym4r6m.rs:16:58\n   |\n16 |             result.push_str(&format!(\"\
    {}{}\", ch - '0', q % 10));\n   |                                            \
    \            - ^ -- {integer}\n   |                                          \
    \              |\n   |                                                       \
    \ ({integer}, {integer})\n\nerror: aborting due to "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::with_capacity(a.size());\n\n    for i in 0..a.len() {\n  \
    \      if a[i] != b[i] {\n            res.push_str(&a[..i]);\n            break;\n\
    \        }\n        res.push_str(&b[..i]);\n    }\n\n    res.push_str(&a[a.len()..]);\n\
    \    res.to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp66_j6eg4.rs:6:43\n  |\n6 |     let mut res = String::with_capacity(a.size());\n\
    \  |                                           ^^^^ method not found in `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp66_j6eg4.rs:9:12\n\
    \  |\n9 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp66_j6eg4.rs:9:20\n\
    \  |\n9 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in &a as &str {\n        let j = i as\
    \ char;\n        if &b == &j {\n            result.push(j);\n        } else {\n\
    \            result.push('-');\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&str` is not an iterator\n --> /tmp/tmp0znmlypu.rs:7:14\n\
    \  |\n7 |     for i in &a as &str {\n  |              ^^^^^^^^^^ `&str` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait\
    \ `Iterator` is not implemented for `&str`\n  = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0277]: can't\
    \ compare `String` with `char`\n --> /tmp/tmp0znmlypu.rs:9:15\n  |\n9 |      \
    \   if &b == &j {\n  |               ^^ no implementation for `String == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \       <&'a str as PartialEq<OsString>>\n            <&'a str as PartialEq<String>>\n\
    \            <&'b str as PartialEq<Cow<'a, str>>>\n            <String as PartialEq<&'a\
    \ str>>\n            <String as PartialEq<Cow<'a, str>>>\n            <String\
    \ as PartialEq<str>>\n            <String as PartialEq>\n            <str as PartialEq<Cow<'a,\
    \ str>>>\n          and 4 others\n  = note: required because of the requirements\
    \ on the impl of `PartialEq<&char>` for `&String`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().chain(b.to_string().chars()).filter(|c|\
    \ c != '1').collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpmoapwvme.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().chain(b.to_string().chars()).filter(|c| c\
    \ != '1').collect::<String>()\n  |                                           \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result: String = \"\".to_string();\n    for i in (0..a.len() - b.len()).rev()\
    \ {\n        result.push(*a ^ *b + &mut result[i..]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&mut str` to `str`\n --> /tmp/tmpvak_8bp1.rs:8:29\n\
    \  |\n8 |         result.push(*a ^ *b + &mut result[i..]);\n  |              \
    \            -- ^ ---------------- &mut str\n  |                          |\n\
    \  |                          str\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push_str(&(a[i]\
    \ ^ b[i]));\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp1pbbf7cp.rs:8:27\n\
    \  |\n8 |         result.push_str(&(a[i] ^ b[i]));\n  |                      \
    \     ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp1pbbf7cp.rs:8:34\n\
    \  |\n8 |         result.push_str(&(a[i] ^ b[i]));\n  |                      \
    \            ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n  = help: the following other\
    \ types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(\n\
    \        a.to_owned()\n            .iter()\n            .chain(b.to_owned().iter())\n\
    \            .map(|c| c ^ 1)\n            .collect()\n            .collect::<String>()\
    \ + b.to_owned().to_owned()\n    )\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp4av6krkd.rs:8:14\n  |\n8 |             .iter()\n  |    \
    \          ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n8 |             .chars()\n  |              ~~~~~\n\n\
    error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp4av6krkd.rs:9:33\n  |\n9 |             .chain(b.to_owned().iter())\n\
    \  |                                 ^^^^ method not found in `String`\n  |\n\
    help: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n  |\n9 |             .chain(b.to_owned().chars())\n\
    \  |                                 ~~~~~\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in a.chars().filter(|c| b[c.as_byte()].is_some())\
    \ {\n        result += if b[i as usize].is_some() {\n            i as char\n \
    \       } else {\n            ' ' as char\n        };\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_byte` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmpqjctctb0.rs:7:39\n  |\n7 |     for i in a.chars().filter(|c|\
    \ b[c.as_byte()].is_some()) {\n  |                                       ^^^^^^^\
    \ method not found in `&char`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmpqjctctb0.rs:8:22\n  |\n8 |         result += if b[i\
    \ as usize].is_some() {\n  |                      ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpqjctctb0.rs:9:13\n  |\n9 |    \
    \         i as char\n  |             ^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqjctctb0.rs:11:13\n   |\n11 |\
    \             ' ' as char\n   |             ^^^^^^^^^^^ expected `&str`, found\
    \ `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.as_bytes().iter().zip(b.as_bytes()).map(|&(a0,\
    \ a1), &(b0, b1)| {\n        assert!(a0 < b0);\n        assert!(a1 > b1);\n  \
    \      (a0 ^ b0).to_string()\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0593]: closure is expected to take a single 2-tuple as argument,\
    \ but it takes 2 distinct arguments\n --> /tmp/tmpt5n98xmv.rs:6:43\n  |\n6 | \
    \    a.as_bytes().iter().zip(b.as_bytes()).map(|&(a0, a1), &(b0, b1)| {\n  | \
    \                                          ^^^ ---------------------- takes 2\
    \ distinct arguments\n  |                                           |\n  |   \
    \                                        expected closure that takes a single\
    \ 2-tuple as argument\n  |\nhelp: change the closure to accept a tuple instead\
    \ of individual arguments\n  |\n6 |     a.as_bytes().iter().zip(b.as_bytes()).map(|(&(a0,\
    \ a1), &(b0, b1))| {\n  |                                               ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0593`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {}{}\", a, b)\n        .bytes()\n        .iter()\n        .map(|&b| b as u8)\n\
    \        .fold(String::new(), |result, byte| {\n            let byte = byte ^\
    \ 0xff;\n            result.push((byte >> 8) as u8);\n            result.push((byte\
    \ & 0xff) as u8);\n            format!(\"{:02}\", byte)\n        })\n        .expect(\"\
    Invalid byte encoding encountered\")\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Bytes`\
    \ in the current scope\n --> /tmp/tmp56llb0qc.rs:8:10\n  |\n8 |         .iter()\n\
    \  |          ^^^^ method not found in `std::str::Bytes<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result: Vec<u8> = vec![0; a.len()];\n    let mut carry = 0;\n    let mut\
    \ a_index = 0;\n    let mut b_index = 0;\n    while a_index < a.len() && b_index\
    \ < b.len() {\n        let c_val = a.chars().nth(a_index).unwrap() ^ (b.chars().nth(b_index).unwrap()\
    \ << 8);\n        result.push((c_val + carry).wrapping_add(1).unwrap());\n   \
    \     a_index += 1;\n        b_index += 1;\n        carry = c_val > 255;\n   \
    \ }\n    while a_index < a.len() {\n        result.push(a.chars().nth(a_index).unwrap()\
    \ ^ carry);\n        a_index += 1;\n        carry = 1;\n    }\n    while b_index\
    \ < b.len() {\n        result.push((b.chars().nth(b_index).unwrap() ^ carry).wrapping_add(1));\n\
    \        b_index += 1;\n        carry = 0;\n    }\n    result\n        .iter()\n\
    \        .map(|&c| format!(\"{:02x}\", c))\n        .collect::<Vec<String>>()\n\
    \        .join(\"\\n\")\n}\n\nfn main() {\n    let candidate = string_xor;\n \
    \   assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char << {integer}`\n  --> /tmp/tmpbp1dqz5b.rs:11:88\n\
    \   |\n11 |         let c_val = a.chars().nth(a_index).unwrap() ^ (b.chars().nth(b_index).unwrap()\
    \ << 8);\n   |                                                        -------------------------------\
    \ ^^ - {integer}\n   |                                                       \
    \ |\n   |                                                        char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbp1dqz5b.rs:15:17\n   |\n7  |     let mut carry\
    \ = 0;\n   |                     - expected due to this value\n...\n15 |     \
    \    carry = c_val > 255;\n   |                 ^^^^^^^^^^^ expected integer,\
    \ found `bool`\n\nerror[E0369]: no implementation for `char ^ {integer}`\n  -->\
    \ /tmp/tmpbp1dqz5b.rs:18:53\n   |\n18 |         result.push(a.chars().nth(a_index).unwrap()\
    \ ^ carry);\n   |                     ------------------------------- ^ -----\
    \ {integer}\n   |                     |\n   |                     char\n\nerror[E0369]:\
    \ no implementation for `char ^ {integer}`\n  --> /tmp/tmpbp1dqz5b.rs:23:54\n\
    \   |\n23 |         result.push((b.chars().nth(b_index).unwrap() ^ carry).wrapping_add(1));\n\
    \   |                      ------------------------------- ^ ----- {integer}\n\
    \   |                      |\n   |                      char\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert!(b.len()\
    \ == a.len(), \"Strings should have same length\");\n    let mut result = String::new();\n\
    \    b.chars().for_each(|c| {\n        result.push((a as u8).wrapping_xor(c as\
    \ u8) as char);\n    });\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_xor` found for type `u8` in the\
    \ current scope\n --> /tmp/tmplla69qys.rs:9:31\n  |\n9 |         result.push((a\
    \ as u8).wrapping_xor(c as u8) as char);\n  |                               ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `wrapping_pow`\n\n\
    error[E0605]: non-primitive cast: `String` as `u8`\n --> /tmp/tmplla69qys.rs:9:21\n\
    \  |\n9 |         result.push((a as u8).wrapping_xor(c as u8) as char);\n  | \
    \                    ^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0605.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert!(a.len()\
    \ >= b.len());\n    let mut res = String::with_capacity(a.len());\n    for i in\
    \ 0..a.len() {\n        if a.chars().nth(i).unwrap() != b.chars().nth(i).unwrap()\
    \ {\n            res.push('a');\n        } else {\n            res.push('0');\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0a00a0\"`,\n right: `\"010010\"`', /tmp/tmp_cv5q2u2.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = [0; (a.len() + b.len()) / 2];\n\n    for i in 0..(a.len() + b.len()\
    \ - 1) {\n        result[i] = a[i] ^ b[i];\n    }\n\n    let mut result = String::new();\n\
    \    for i in 0..result.len() {\n        let mut c = result[i];\n        match\
    \ c {\n            0 => result.push('0'),\n            1 => result.push('1'),\n\
    \            _ => result.push(format!(\"{:02}\", c)),\n        };\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n --> /tmp/tmp_8ykv4ap.rs:6:27\n\
    \  |\n5 | fn string_xor(a: String, b: String) -> String {\n  |               -\
    \ this would need to be a `const`\n6 |     let mut result = [0; (a.len() + b.len())\
    \ / 2];\n  |                           ^\n\nerror[E0435]: attempt to use a non-constant\
    \ value in a constant\n --> /tmp/tmp_8ykv4ap.rs:6:37\n  |\n5 | fn string_xor(a:\
    \ String, b: String) -> String {\n  |                          - this would need\
    \ to be a `const`\n6 |     let mut result = [0; (a.len() + b.len()) / 2];\n  |\
    \                                     ^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n --> /tmp/tmp_8ykv4ap.rs:9:21\n  |\n9 |         result[i]\
    \ = a[i] ^ b[i];\n  |                     ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmp_8ykv4ap.rs:9:28\n\
    \  |\n9 |         result[i] = a[i] ^ b[i];\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_8ykv4ap.rs:14:21\n\
    \   |\n14 |         l"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::with_capacity(a.len());\n    for (a, b) in a.chars().zip(b.chars()).zip(result.chars())\
    \ {\n        *a = *a ^ &*b;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `(char, char)` cannot be dereferenced\n --> /tmp/tmprq8wjlbl.rs:8:9\n\
    \  |\n8 |         *a = *a ^ &*b;\n  |         ^^\n\nerror[E0614]: type `(char,\
    \ char)` cannot be dereferenced\n --> /tmp/tmprq8wjlbl.rs:8:14\n  |\n8 |     \
    \    *a = *a ^ &*b;\n  |              ^^\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n --> /tmp/tmprq8wjlbl.rs:8:20\n  |\n8 |         *a = *a ^ &*b;\n\
    \  |                    ^^\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    match\
    \ a.len() {\n        0 => b,\n        _ => a,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"111000\"`,\n right: `\"010010\"`', /tmp/tmpx0ouow8o.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n\n    let mut res = String::new();\n\n    for i in 0..a.len() {\n\
    \        let c = a.chars().nth(i).unwrap();\n        if b[i] == '0' {\n      \
    \      res.push(c);\n        } else {\n            res.push('1');\n        }\n\
    \    }\n\n    return res;\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu00t8qk9.rs:12:12\n\
    \   |\n12 |         if b[i] == '0' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Iterate\
    \ over every bit of both input strings\n    for &(c1, c2) in b.iter().zip(&a.iter())\
    \ {\n        // The XOR of two char is 0 if either char is 0, else 1\n       \
    \ if c1 == 0 || c2 == 0 {\n            continue;\n        }\n        // XOR returns\
    \ 1 if both chars are 1, else 0\n        match c1 ^ c2 {\n            // If both\
    \ chars are 0, return 0\n            0 => return String::new(),\n            1\
    \ => (),\n            // If one of them is 1, return 1\n            _ => return\
    \ String::from(\"1\"),\n        }\n    }\n\n    String::new()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpv2d5qnmk.rs:7:24\n  |\n7 |     for &(c1, c2) in b.iter().zip(&a.iter())\
    \ {\n  |                        ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n7 |     for &(c1, c2) in b.chars().zip(&a.iter())\
    \ {\n  |                        ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpv2d5qnmk.rs:7:38\n\
    \  |\n7 |     for &(c1, c2) in b.iter().zip(&a.iter()) {\n  |                \
    \                      ^^^^ method not found in `String`\n  |\nhelp: because of\
    \ the in-memory representation of `&str`, to obtain an `Iterator` over each of\
    \ its codepoint use method `chars`\n  |\n7 |     for &(c1, c2) in b.iter().zip(&a.chars())\
    \ {\n  |                                      ~~~~~\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).filter(|(a,\
    \ b)| a).fold(String::new(), |s, (a, _)| {\n        s.append(char::to_string(a\
    \ ^ b));\n        s\n    })\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpndp90dzr.rs:6:46\n  |\n6 |\
    \     a.chars().zip(b.chars()).filter(|(a, b)| a).fold(String::new(), |s, (a,\
    \ _)| {\n  |                                              ^ expected `bool`, found\
    \ `&char`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n --> /tmp/tmpndp90dzr.rs:7:11\n  |\n7 |         s.append(char::to_string(a\
    \ ^ b));\n  |           ^^^^^^ method not found in `String`\n\nerror[E0369]: no\
    \ implementation for `char ^ String`\n --> /tmp/tmpndp90dzr.rs:7:36\n  |\n7 |\
    \         s.append(char::to_string(a ^ b));\n  |                             \
    \     - ^ - String\n  |                                  |\n  |              \
    \                    char\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = vec![];\n    for (a, b) in a.chars().zip(b.chars()) {\n       \
    \ if *a != *b {\n            result.push(*b);\n        } else {\n            result.push(*a);\n\
    \        }\n    }\n    String::from_utf8_lossy(&result).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmp3hlhhmhc.rs:8:12\n\
    \  |\n8 |         if *a != *b {\n  |            ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n --> /tmp/tmp3hlhhmhc.rs:8:18\n  |\n8 |         if *a\
    \ != *b {\n  |                  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \ --> /tmp/tmp3hlhhmhc.rs:9:25\n  |\n9 |             result.push(*b);\n  |   \
    \                      ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp3hlhhmhc.rs:11:25\n   |\n11 |             result.push(*a);\n  \
    \ |                         ^^\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    binops::ops::binxor_str(&a,\
    \ &b).unwrap()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `binops`\n\
    \ --> /tmp/tmphnt7meqp.rs:6:5\n  |\n6 |     binops::ops::binxor_str(&a, &b).unwrap()\n\
    \  |     ^^^^^^ use of undeclared crate or module `binops`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &c in &a.chars() {\n        match &b.chars().next()\
    \ {\n            Some(bc) => result.push(*c ^ *bc),\n            None => result.push(c),\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n --> /tmp/tmp2tiuois8.rs:7:15\n\
    \  |\n7 |     for &c in &a.chars() {\n  |               -^^^^^^^^^\n  |      \
    \         |\n  |               `&Chars<'_>` is not an iterator\n  |          \
    \     help: consider removing the leading `&`-reference\n  |\n  = help: the trait\
    \ `Iterator` is not implemented for `&Chars<'_>`\n  = note: `Iterator` is implemented\
    \ for `&mut std::str::Chars<'_>`, but not for `&std::str::Chars<'_>`\n  = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&Chars<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| (*a ^ *b)).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmp0sy1t25e.rs:6:44\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| (*a ^ *b)).collect::<String>()\n\
    \  |                                            ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n --> /tmp/tmp0sy1t25e.rs:6:49\n  |\n6 |     a.chars().zip(b.chars()).map(|(a,\
    \ b)| (*a ^ *b)).collect::<String>()\n  |                                    \
    \             ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in (0..a.len()).rev() {\n        res.push_str(&a[i\
    \ & a.len()]);\n        res.push_str(&b[i & b.len()]);\n    }\n    res.rev()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmptny1jme9.rs:8:23\n\
    \  |\n8 |         res.push_str(&a[i & a.len()]);\n  |                       ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmptny1jme9.rs:9:23\n\
    \  |\n9 |         res.push_str(&b[i & b.len()]);\n  |                       ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmptny1jme9.rs:11:9\n\
    \    |\n11  |       res.rev()\n    |           ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for &b in &b {\n        if a == b {\n        \
    \    res.push('a');\n        } else {\n            res.push('0');\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsrkrfsg4.rs:7:15\n\
    \  |\n7 |     for &b in &b {\n  |               ^^ `&String` is not an iterator\n\
    \  |\n  = help: the trait `Iterator` is not implemented for `&String`\n  = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in (0..a.len()).map(|i| {\n        res[i\
    \ as usize] = a[i] ^ b[i];\n    });\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `;`\n --> /tmp/tmpwvnuwy2y.rs:9:7\n  |\n9 |\
    \     });\n  |       ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpygy04v72.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {}{}\", a, b).to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"111000101010\"`,\n right: `\"010010\"`', /tmp/tmpiue520on.rs:11:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for c in a.chars().chain(b) {\n        res.push_str(match\
    \ c {\n            b'0' => '1',\n            b'1' => '0',\n            _ => unimplemented!(),\n\
    \        });\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n --> /tmp/tmp2k459ae8.rs:7:30\n\
    \  |\n7 |     for c in a.chars().chain(b) {\n  |                        -----\
    \ ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |   \
    \                     |\n  |                        required by a bound introduced\
    \ by this call\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n\
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0277]: `String` is not an iterator\n --> /tmp/tmp2k459ae8.rs:7:14\n\
    \  |\n7 |     for c in a.chars().chain(b) {\n  |              ^^^^^^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  =\
    \ help: the trait `Iterator` is not implemented for `String`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `std::iter::Chain<Chars<'_>,\
    \ String>`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `std::iter::Chain<Chars<'_>, String>`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp2k459ae8.rs:9:13\n  |\n8 |         res.push_str(match c {\n  | \
    \                           - this expression has type `char`\n9 |           \
    \  b'0' => '1',\n  |             ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2k459ae8.rs:10:13\n   |\n8  |         res.push_str(match\
    \ c {\n   |                            - this expression has type `char`\n9  |\
    \             b'0' => '1',\n10 |             b'1' => '0',\n   |             ^^^^\
    \ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2k459ae8.rs:9:21\n\
    \  |\n9 |             b'0' => '1',\n  |                     ^^^ expected `&str`,\
    \ found `char`\n  |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \  |\n9 |             b'0' => \"1\",\n  |                     ~~~\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(helper::xor(String::from(a),\
    \ String::from(b)))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `helper`\n\
    \ --> /tmp/tmpcxrpgxs4.rs:6:18\n  |\n6 |     String::from(helper::xor(String::from(a),\
    \ String::from(b)))\n  |                  ^^^^^^ use of undeclared crate or module\
    \ `helper`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpwjsmpgmi.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                           - ^ - char\n  |               \
    \                            |\n  |                                          \
    \ char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    binary_xor_str(&a,\
    \ &b)\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_xor_str` in this scope\n -->\
    \ /tmp/tmpmcbka60x.rs:6:5\n  |\n6 |     binary_xor_str(&a, &b)\n  |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"Lengths of strings do not match\")\n    }\n \
    \   let mut res = String::with_capacity(a.len());\n    for i in 0..a.len() {\n\
    \        if a[i] != b[i] {\n            res.push_str(&format!(\"{:?}\", a[i] ^\
    \ b[i]));\n        } else {\n            res.push(a[i]);\n        }\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo5ut0su6.rs:11:12\n\
    \   |\n11 |         if a[i] != b[i] {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo5ut0su6.rs:11:20\n   |\n11 |         if a[i] != b[i] {\n   | \
    \                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo5ut0su6.rs:12:43\n   |\n12 |             res.push_str(&format!(\"\
    {:?}\", a[i] ^ b[i]));\n   |                                           ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in a.chars().zip(b.chars()).cloned() {\n\
    \        let (a, b) = i;\n        if *a != *b {\n            res.push_str(&*a);\n\
    \        } else {\n            res.push('0');\n        }\n    }\n    res.into_owned()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Zip<Chars<'_>, Chars<'_>> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp82kea0l7.rs:7:39\n     |\n7    |     for i in a.chars().zip(b.chars()).cloned()\
    \ {\n     |                                       ^^^^^^ expected reference, found\
    \ tuple\n     |\n     = note: expected reference `&_`\n                    found\
    \ tuple `(char, char)`\nnote: required by a bound in `cloned`\n\nerror[E0271]:\
    \ type mismatch resolving `<Zip<Chars<'_>, Chars<'_>> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmp82kea0l7.rs:7:14\n  |\n7 |     for i in a.chars().zip(b.chars()).cloned()\
    \ {\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found\
    \ reference\n  |\n  = note:  expected tuple `(char, char)`\n          found reference\
    \ `&_`\n  = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Zip<Chars<'_>, Chars<'_>>>`\n  = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Cloned<Zip<Chars<'_>, Chars<'_>>>`\n\nerror[E0271]:\
    \ type mismatch resolving `<Zip<Chars<'_>, Chars<'_>> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmp82kea0l7.rs:7:14\n  |\n7 |     for i in a.chars().zip(b.chars()).cloned()\
    \ {\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found\
    \ reference\n  |\n  = note:  expected tuple `(char, char)`\n          found reference\
    \ `&_`\n  = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Zip<Chars<'_>, Chars<'_>>>`\n\nerror[E0599]: no method named `into_owned`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp82kea0l7.rs:15:9\n\
    \   |\n15 |     res.into_owned()\n   |         ^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().enumerate().filter(|(i,\
    \ x)| {\n        b.chars().any(|(_, b)| x == b)\n    }).map(|(i, _)| a[i..]).collect::<Vec<_>>().join(\"\
    \").to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5k3dcj8_.rs:7:24\n  |\n7 |\
    \         b.chars().any(|(_, b)| x == b)\n  |                        ^^^^^-\n\
    \  |                        |    |\n  |                        |    expected due\
    \ to this\n  |                        expected `char`, found tuple\n  |\n  = note:\
    \ expected type `char`\n            found tuple `(_, _)`\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmp5k3dcj8_.rs:8:12\n\
    \    |\n8   |     }).map(|(i, _)| a[i..]).collect::<Vec<_>>().join(\"\").to_string()\n\
    \    |        --- ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |        |\n    |        required by a bound introduced by this call\n  \
    \  |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `map`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Map<Filter<Enumerate<Chars<'_>>, [closure@/tmp/tmp5k3dcj8_.rs:6:46: 8:6]>,\
    \ [closure@/tmp/tmp5k3dcj8_.rs:8:12: 8:27]>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp5k3dcj8_.rs:8:29\n   |\n8  |       }).map(|(i, _)| a[i..]).collect::<Vec<_>>().join(\"\
    \").to_string()\n   |                               ^^^^^^^ method cannot be called\
    \ on `Map<Filter<Enumerate<Chars<'_>>, [closure@/tmp/tmp5k3dcj8_.rs:6:46: 8:6]>,\
    \ [closure@/tmp/tmp5k3dcj8_.rs:8:12: 8:27]>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `Map<Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmp5k3dcj8_.rs:6:46: 8:6]>, [closure@/tmp/tmp5k3dcj8_.rs:8:12:\
    \ 8:27]>: Iterator`\n           which is required by `&mut Map<Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmp5k3dcj8_.rs:6:46: 8:6]>, [closure@/tmp/tmp5k3dcj8_.rs:8:12:\
    \ 8:27]>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(binary_xor_encode(a.as_bytes(),\
    \ b))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_xor_encode` in this scope\n\
    \ --> /tmp/tmpdel0x2nd.rs:6:18\n  |\n6 |     String::from(binary_xor_encode(a.as_bytes(),\
    \ b))\n  |                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ == 0 || b.len() == 0 {\n        return \"\";\n    }\n    let mut result = String::new();\n\
    \    let mut carry = 0;\n    for i in a.chars().cloned().rev() {\n        let\
    \ a_byte = (i.to_digit(10).unwrap() ^ b[b.len() - i - 1].to_digit(10).unwrap()\
    \ +\n            carry).to_string();\n        let mut j = result\n           \
    \ .chars()\n            .clone()\n            .rev()\n            .map(|c| c !=\
    \ a_byte)\n            .cloned()\n            .len();\n        carry = a_byte\
    \ == '1';\n        result.push_str(&result[j..].iter().filter(|c| c).collect());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpft2zilk_.rs:7:16\n  |\n5 |\
    \ fn string_xor(a: String, b: String) -> String {\n  |                       \
    \                 ------ expected `String` because of return type\n6 |     if\
    \ a.len() == 0 || b.len() == 0 {\n7 |         return \"\";\n  |              \
    \  ^^- help: try using a conversion method: `.to_string()`\n  |              \
    \  |\n  |                expected struct `String`, found `&str`\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpft2zilk_.rs:11:24\n\
    \     |\n11   |     for i in a.chars().cloned().rev() {\n     |              \
    \          ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `rev` exists for struct `Cloned<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpft2zilk_.rs:11:33\n \
    \  |\n11 |       for i in a.chars().cloned().rev() {\n   |                   \
    \                ^^^ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Chars<'_> as Iterator>::Item = &_`\n           which is required\
    \ by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n\
    \           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpft2zilk_.rs:12:49\n\
    \   |\n12 |         let a_byte = (i.to_digit(10).unwrap() ^ b[b.len() - i - 1].to_digit(10).unwrap()\
    \ +\n   |                                                 ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(vec![3..4].iter()\n\
    \                       .enumerate()\n                       .map(|(i, c)| if\
    \ *c == 1 { 1 } else { 0 })\n                       .collect::<Vec<_>>())\n  \
    \      .iter()\n        .fold(String::new(), |mut acc, x| acc ^ x)\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptqqr5ryb.rs:8:47\n  |\n8 |\
    \                        .map(|(i, c)| if *c == 1 { 1 } else { 0 })\n  |     \
    \                                          ^ expected struct `std::ops::Range`,\
    \ found integer\n  |\n  = note: expected struct `std::ops::Range<{integer}>`\n\
    \               found type `{integer}`\n\nerror[E0369]: no implementation for\
    \ `String ^ &String`\n  --> /tmp/tmptqqr5ryb.rs:11:47\n   |\n11 |         .fold(String::new(),\
    \ |mut acc, x| acc ^ x)\n   |                                           --- ^\
    \ - &String\n   |                                           |\n   |          \
    \                                 String\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = a.to_string();\n    let mut carry = 0;\n    for i in 0..a.len()\
    \ {\n        if a[i] == '1' {\n            result[i] = b[i & b.len() - 1];\n \
    \           carry = 1;\n        } else {\n            result[i] = carry.to_string();\n\
    \            carry = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpvrwdyz_u.rs:9:12\n\
    \  |\n9 |         if a[i] == '1' {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvrwdyz_u.rs:10:13\n\
    \   |\n10 |             result[i] = b[i & b.len() - 1];\n   |             ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvrwdyz_u.rs:10:25\n   |\n10 |             result[i] = b[i & b.len()\
    \ - 1];\n   |                         ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror["
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        throw StringFormatError::invalid_length {\n          \
    \  expected: a.len(),\n            actual: b.len(),\n        };\n    }\n    let\
    \ mut c: [u8; 4] = [0; 4];\n    for i in 0..a.len() {\n        c[0] = (a[i] as\
    \ u8) ^ b[i] as u8;\n        c[1] = (c[0] >> 4);\n        c[2] = (c[1] >> 2);\n\
    \        c[3] = (c[2] >> 0);\n    }\n    c.to_owned()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `StringFormatError`\n --> /tmp/tmpck6sryw3.rs:7:15\n  |\n7 |         throw\
    \ StringFormatError::invalid_length {\n  |               ^^^^^^^^^^^^^^^^^ expected\
    \ one of 8 possible tokens\n\nwarning: unnecessary parentheses around assigned\
    \ value\n  --> /tmp/tmpck6sryw3.rs:15:16\n   |\n15 |         c[1] = (c[0] >> 4);\n\
    \   |                ^         ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n15 -         c[1] = (c[0]\
    \ >> 4);\n15 +         c[1] = c[0] >> 4;\n   | \n\nwarning: unnecessary parentheses\
    \ around assigned value\n  --> /tmp/tmpck6sryw3.rs:16:16\n   |\n16 |         c[2]\
    \ = (c[1] >> 2);\n   |                ^         ^\n   |\nhelp: remove these parentheses\n\
    \   |\n16 -         c[2] = (c[1] >> 2);\n16 +         c[2] = c[1] >> 2;\n   |\
    \ \n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmpck6sryw3.rs:17:16\n\
    \   |\n17 |         c[3] = (c[2] >> 0);\n   |                ^         ^\n   |\n\
    help: remove these parentheses\n   |\n17 -         c[3] = (c[2] >> 0);\n17 + \
    \        c[3] = c[2] >> 0;\n   | \n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpck6sryw3.rs:14:17\n   |\n14 |         c[0]\
    \ = (a[i] as u8) ^ b[i] as u8;\n   |                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpck6sryw3.rs:14:31\n   |\n14 |         c[0] = (a[i] as u8) ^ b[i]\
    \ as u8;\n   |                               ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    string_to_int(a)\
    \ ^ string_to_int(b)\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `string_to_int` in this scope\n -->\
    \ /tmp/tmp24z65zr4.rs:6:5\n  |\n6 |     string_to_int(a) ^ string_to_int(b)\n\
    \  |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `string_to_int` in this scope\n --> /tmp/tmp24z65zr4.rs:6:24\n  |\n6 |     string_to_int(a)\
    \ ^ string_to_int(b)\n  |                        ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"Input lengths do not match. a: {} b: {}\", a.len(),\
    \ b.len());\n    }\n\n    for &b in b.chars() {\n        a.chars().filter(|c|\
    \ c == '1').collect::<Vec<_>>().swap_remove();\n    }\n    a\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwd2jhqoy.rs:10:9\n   |\n\
    10 |     for &b in b.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `b`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpwd2jhqoy.rs:11:32\n   |\n11\
    \ |         a.chars().filter(|c| c == '1').collect::<Vec<_>>().swap_remove();\n\
    \   |                                ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpwd2jhqoy.rs:11:60\n\
    \     |\n11   |         a.chars().filter(|c| c == '1').collect::<Vec<_>>().swap_remove();\n\
    \     |                                                            ^^^^^^^^^^^-\
    \ supplied 0 arguments\n     |                                               \
    \             |\n     |                                                      \
    \      expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    (&a\
    \ + &b).to_ascii_lowercase()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&String` to `&String`\n --> /tmp/tmpvh2ig5ry.rs:6:9\n\
    \  |\n6 |     (&a + &b).to_ascii_lowercase()\n  |      -- ^ -- &String\n  |  \
    \    |  |\n  |      |  `+` cannot be used to concatenate two `&str` strings\n\
    \  |      &String\n  |\n  = note: string concatenation requires an owned `String`\
    \ on the left\nhelp: remove the borrow to obtain an owned `String`\n  |\n6 - \
    \    (&a + &b).to_ascii_lowercase()\n6 +     (a + &b).to_ascii_lowercase()\n \
    \ | \n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().xor_eq(b).to_owned()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmplq0ff7f3.rs:6:19\n  |\n6 |     a.to_string().xor_eq(b).to_owned()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(&to_binary(a)\
    \ ^ &to_binary(b))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_binary` in this scope\n --> /tmp/tmp55hz8a2m.rs:6:19\n\
    \  |\n6 |     String::from(&to_binary(a) ^ &to_binary(b))\n  |               \
    \    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_binary`\
    \ in this scope\n --> /tmp/tmp55hz8a2m.rs:6:35\n  |\n6 |     String::from(&to_binary(a)\
    \ ^ &to_binary(b))\n  |                                   ^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().flat_map(|c|\
    \ b.chars().map(|d| c ^ d))\n        .map(|c| c.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp11hu48b4.rs:6:48\n\
    \  |\n6 |     a.chars().flat_map(|c| b.chars().map(|d| c ^ d))\n  |          \
    \                                    - ^ - char\n  |                         \
    \                     |\n  |                                              char\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"Input strings are not of the same length!\");\n\
    \    }\n\n    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result += '0' if *a != *b else '1';\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp5_zi6l1g.rs:12:23\n   |\n12 |         result += '0' if *a\
    \ != *b else '1';\n   |                       ^^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::with_capacity(a.len());\n    for i in a.chars().cloned()\
    \ {\n        let j = b.chars().enumerate().find(|(_, j)| j == *i);\n        result.push((*j).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp9ep6cmx2.rs:7:24\n     |\n7    |     for i in a.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmp9ep6cmx2.rs:7:14\n\
    \  |\n7 |     for i in a.chars().cloned() {\n  |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmp9ep6cmx2.rs:7:14\n  |\n7 |     for i in a.chars().cloned() {\n \
    \ |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0614]: type `Option<(usize, char)>` cannot be dereferenced\n --> /tmp/tmp9ep6cmx2.rs:9:21\n\
    \  |\n9 |         result.push((*j).unwrap());\n  |                     ^^^^\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0614.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(std::mem::replace(&mut\
    \ a.to_string(), \"\")).xor_with(b)\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnl9x4g96.rs:6:56\n  |\n6 |\
    \     String::from(std::mem::replace(&mut a.to_string(), \"\")).xor_with(b)\n\
    \  |                                                        ^^- help: try using\
    \ a conversion method: `.to_string()`\n  |                                   \
    \                     |\n  |                                                 \
    \       expected struct `String`, found `&str`\n\nerror[E0599]: no method named\
    \ `xor_with` found for struct `String` in the current scope\n --> /tmp/tmpnl9x4g96.rs:6:61\n\
    \  |\n6 |     String::from(std::mem::replace(&mut a.to_string(), \"\")).xor_with(b)\n\
    \  |                                                             ^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from(a)\
    \ + String::from(b) |> String::from_utf8_lossy\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `>`\n --> /tmp/tmpn6val6b6.rs:6:40\n\
    \  |\n6 |     String::from(a) + String::from(b) |> String::from_utf8_lossy\n \
    \ |                                        ^ expected expression\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    match\
    \ (a.to_lowercase(), b.to_lowercase()) {\n        (\"\", \"\") => \"\",\n    \
    \    (\"\", c) => c.to_lowercase(),\n        (a0, b0) => {\n            let mut\
    \ res = String::new();\n            for i in b0.to_lowercase().as_bytes().iter().rev()\
    \ {\n                res.push(*i ^ a0.as_bytes()[0]);\n            }\n       \
    \     res\n        }\n    }\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpal66drom.rs:7:10\n  |\n6 |\
    \     match (a.to_lowercase(), b.to_lowercase()) {\n  |           ------------------------------------\
    \ this expression has type `(String, String)`\n7 |         (\"\", \"\") => \"\"\
    ,\n  |          ^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpal66drom.rs:7:14\n  |\n6 |     match (a.to_lowercase(),\
    \ b.to_lowercase()) {\n  |           ------------------------------------ this\
    \ expression has type `(String, String)`\n7 |         (\"\", \"\") => \"\",\n\
    \  |              ^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpal66drom.rs:8:10\n  |\n6 |     match (a.to_lowercase(),\
    \ b.to_lowercase()) {\n  |           ------------------------------------ this\
    \ expression has type `(String, String)`\n7 |         (\"\", \"\") => \"\",\n\
    8 |         (\"\", c) => c.to_lowercase(),\n  |          ^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpal66drom.rs:7:21\n\
    \  |\n5 | fn string_xor(a: String, b: String) -> String {\n  |               \
    \                         ------ expected `String` because of return type\n6 |\
    \     match (a.to_lowercase(), b.to_lowercase()) {\n7 |         (\"\", \"\") =>\
    \ \"\",\n  |                     ^^- help: try using a conversion method: `.to_string()`\n\
    \  |                     |\n  |                     expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpal66drom.rs:12:26\n\
    \   |\n12 |                 res.push(*i ^ a0.as_bytes()[0]);\n   |           \
    \               ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `u8`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    (a ^\
    \ b).to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpxbxcku24.rs:6:8\n\
    \  |\n6 |     (a ^ b).to_string()\n  |      - ^ - String\n  |      |\n  |    \
    \  String\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_len = a.len();\n    let b_len = b.len();\n    let mut result = String::with_capacity(a_len);\n\
    \    for i in 0..a_len {\n        let (a_rem, b_rem) =\n            (a[a_len -\
    \ i - 1], b[b_len - i - 1]) % (1_u32.pow(8));\n        match a_rem {\n       \
    \     0 => result.push('a'),\n            1 => result.push('b'),\n           \
    \ _ => panic!(\"The first argument is not a binary number\"),\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvpvrlsdy.rs:11:14\n\
    \   |\n11 |             (a[a_len - i - 1], b[b_len - i - 1]) % (1_u32.pow(8));\n\
    \   |              ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvpvrlsdy.rs:11:32\n   |\n11 |             (a[a_len - i - 1], b[b_len\
    \ - i - 1]) % (1_u32.pow(8));\n   |                                ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot mod `(_, _)` by `u32`\n  --> /tmp/tmpvpvrlsdy.rs:11:50\n\
    \   |\n11 |             (a[a_len - i - 1], b[b_len - i - 1]) % (1_u32.pow(8));\n\
    \   |             ------------------------------------ ^ -------------- u32\n\
    \   |             |\n   |             (_, _)\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    match a.len() {\n        0 => return b,\n \
    \       a.len() => match b.len() {\n            0 => return a,\n            b.len()\
    \ => result.push_str(String::from(&a[..]));\n        },\n    };\n    match b.len()\
    \ {\n        0 => return a,\n        b.len() => match a.len() {\n            0\
    \ => return b,\n            a.len() => result.push_str(String::from(&b[..]));\n\
    \        },\n    };\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `.`\n --> /tmp/tmp91qt8024.rs:9:10\n\
    \  |\n9 |         a.len() => match b.len() {\n  |          ^ expected one of `=>`,\
    \ `@`, `if`, or `|`\n\nerror: expected one of `=>`, `@`, `if`, or `|`, found `.`\n\
    \  --> /tmp/tmp91qt8024.rs:16:10\n   |\n16 |         b.len() => match a.len()\
    \ {\n   |          ^ expected one of `=>`, `@`, `if`, or `|`\n\nwarning: unreachable\
    \ statement\n  --> /tmp/tmp91qt8024.rs:14:5\n   |\n7  | /     match a.len() {\n\
    8  | |         0 => return b,\n9  | |         a.len() => match b.len() {\n10 |\
    \ |             0 => return a,\n11 | |             b.len() => result.push_str(String::from(&a[..]));\n\
    12 | |         },\n13 | |     };\n   | |_____- any code following this `match`\
    \ expression is unreachable, as all arms diverge\n14 | /     match b.len() {\n\
    15 | |         0 => return a,\n16 | |         b.len() => match a.len() {\n17 |\
    \ |             0 => return b,\n18 | |             a.len() => result.push_str(String::from(&b[..]));\n\
    19 | |         },\n20 | |     };\n   | |______^ unreachable statement\n   |\n\
    \   = note: `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to\
    \ 2 previous errors; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    (a +\
    \ b).chars().filter(|&x| x >= '0' && x <= '1').collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkly03z79.rs:6:10\n  |\n6 |\
    \     (a + b).chars().filter(|&x| x >= '0' && x <= '1').collect::<String>()\n\
    \  |          ^\n  |          |\n  |          expected `&str`, found struct `String`\n\
    \  |          help: consider borrowing here: `&b`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).filter(|(&achar,\
    \ bchar)| achar != bchar).map(|&(achar, bchar)| achar.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5c7zo5xl.rs:6:39\n  |\n6 |\
    \     a.chars().zip(b.chars()).filter(|(&achar, bchar)| achar != bchar).map(|&(achar,\
    \ bchar)| achar.to_string())....\n  |                                       ^^^^^^\
    \       - expected due to this\n  |                                       |\n\
    \  |                                       expected `char`, found reference\n\
    \  |                                       help: you can probably remove the explicit\
    \ borrow: `achar`\n  |\n  = note:   expected type `char`\n          found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5c7zo5xl.rs:6:76\n  |\n\
    6 | ... bchar)| achar != bchar).map(|&(achar, bchar)| achar.to_string()).collect()\n\
    \  |                                  ^^^^^^^^^^^^^^-\n  |                   \
    \               |             |\n  |                                  |      \
    \       expected due to this\n  |                                  expected tuple,\
    \ found reference\n  |\n  = note:  expected tuple `(char, char)`\n          found\
    \ reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for &(ref x, ref y) in zip(a.chars(), b.chars())\
    \ {\n        result += if x == y {\n            '0'\n        } else {\n      \
    \      '1'\n        };\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n --> /tmp/tmp_f760gl6.rs:7:28\n\
    \  |\n7 |     for &(ref x, ref y) in zip(a.chars(), b.chars()) {\n  |        \
    \                    ^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this function\n  |\n1 | use std::iter::zip;\n  |\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp_f760gl6.rs:9:13\n  |\n9 |             '0'\n  |        \
    \     ^^^ expected `&str`, found `char`\n  |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n  |\n9 |             \"0\"\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_f760gl6.rs:11:13\n   |\n11 |             '1'\n\
    \   |             ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n11 |             \"1\"\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ << b.to_owned().reverse().to_owned()\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpde9lek8f.rs:6:34\n  |\n6 |     a.to_owned() << b.to_owned().reverse().to_owned()\n\
    \  |                                  ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_u8 = a.to_bytes();\n    let b_u8 = b.to_bytes();\n    let mut result: Vec<u8>\
    \ = Vec::new();\n    for b in b_u8 {\n        if *b != 0 { continue; }\n     \
    \   for a in a_u8 {\n            *result = if *a != *b { 1 } else { 0 };\n   \
    \         result += 1;\n        }\n    }\n    let result = String::from_utf8_lossy(&result[0..result.len()]).to_owned();\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bytes` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpbyhd8vrt.rs:6:18\n  |\n6 |     let a_u8 = a.to_bytes();\n\
    \  |                  ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `bytes`\n\nerror[E0599]: no method named `to_bytes` found for struct `String`\
    \ in the current scope\n --> /tmp/tmpbyhd8vrt.rs:7:18\n  |\n7 |     let b_u8 =\
    \ b.to_bytes();\n  |                  ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `bytes`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbyhd8vrt.rs:12:37\n\
    \   |\n12 |             *result = if *a != *b { 1 } else { 0 };\n   |        \
    \                             ^ expected slice `[u8]`, found integer\n   |\nhelp:\
    \ to create an array, use square brackets instead of curly braces\n   |\n12 |\
    \             *result = if *a != *b [ 1 ] else { 0 };\n   |                  \
    \                 ~   ~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbyhd8vrt.rs:12:48\n\
    \   |\n12 |             *result = if *a != *b { 1 } else { 0 };\n   |        \
    \                                        ^ expected slice `[u8]`, found integer\n\
    \   |\nhelp: to create an array, use square brackets instead of curly braces\n\
    \   |\n12 |             *result = if *a != *b { 1 } else [ 0 ];\n   |        \
    \                                      ~   ~\n\nerror[E0277]: the size for values\
    \ of type `[u8]` cannot be known at compilation time\n  --> /tmp/tmpbyhd8vrt.rs:12:13\n\
    \   |\n12 |             *result = if *a != *b { 1 } else { 0 };\n   |        \
    \     ^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the\
    \ trait `Sized` is not implemented for `[u8]`\n   = note: the left-hand-side of\
    \ an assignment must have a statically known size\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Vec<u8>`\n  --> /tmp/tmpbyhd8vrt.rs:13:13\n\
    \   |\n13 |             result += 1;\n   |             ------^^^^^\n   |     \
    \        |\n   |             cannot use `+=` on type `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbyhd8vrt.rs:17:5\n   |\n5  | fn string_xor(a:\
    \ String, b: St"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut out = String::with_capacity(a.len());\n    for i in 0..a.len() {\n     \
    \   if a.get(i) != b.get(i) {\n            out.push('a');\n        } else {\n\
    \            out.push('0');\n        }\n    }\n    out\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n   --> /tmp/tmpyuptk9z2.rs:8:18\n\
    \    |\n8   |         if a.get(i) != b.get(i) {\n    |              --- ^ string\
    \ indices are ranges of `usize`\n    |              |\n    |              required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n   --> /tmp/tmpyuptk9z2.rs:8:30\n\
    \    |\n8   |         if a.get(i) != b.get(i) {\n    |                       \
    \   --- ^ string indices are ranges of `usize`\n    |                        \
    \  |\n    |                          required by a bound introduced by this call\n\
    \    |\n    = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n\n    let mut result = a.clone();\n    for (i, char) in a.chars().enumerate()\
    \ {\n        if b.chars().any(|c| c == char) {\n            result.swap(i, 0);\n\
    \            result.swap(i, 1);\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmps_l9ec5n.rs:11:20\n   |\n11 |             result.swap(i,\
    \ 0);\n   |                    ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmps_l9ec5n.rs:12:20\n   |\n12 |             result.swap(i, 1);\n   | \
    \                   ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n\n    for c in a.chars().zip(b.chars()) {\n      \
    \  if c[0] != c[1] {\n            res.push_str(&format!(\"{:?}\", c[0]));\n  \
    \      } else {\n            res.push_str(&format!(\"{:?}\", c[0]).into());\n\
    \        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `(char, char)`\n --> /tmp/tmpy6do97f5.rs:9:12\n\
    \  |\n9 |         if c[0] != c[1] {\n  |            ^^^^ help: to access tuple\
    \ elements, use: `c.0`\n\nerror[E0608]: cannot index into a value of type `(char,\
    \ char)`\n --> /tmp/tmpy6do97f5.rs:9:20\n  |\n9 |         if c[0] != c[1] {\n\
    \  |                    ^^^^ help: to access tuple elements, use: `c.1`\n\nerror[E0608]:\
    \ cannot index into a value of type `(char, char)`\n  --> /tmp/tmpy6do97f5.rs:10:43\n\
    \   |\n10 |             res.push_str(&format!(\"{:?}\", c[0]));\n   |        \
    \                                   ^^^^ help: to access tuple elements, use:\
    \ `c.0`\n\nerror[E0608]: cannot index into a value of type `(char, char)`\n  -->\
    \ /tmp/tmpy6do97f5.rs:12:43\n   |\n12 |             res.push_str(&format!(\"{:?}\"\
    , c[0]).into());\n   |                                           ^^^^ help: to\
    \ access tuple elements, use: `c.0`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..(i\
    \ + 1)].chars().fold(\"\", |a, b| a ^ b));\n    }\n    for i in 0..b.len() {\n\
    \        res.push_str(&b[i..(i + 1)].chars().fold(\"\", |a, b| a ^ b));\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `&str ^ char`\n --> /tmp/tmpfkcdlcqo.rs:8:63\n\
    \  |\n8 |         res.push_str(&a[i..(i + 1)].chars().fold(\"\", |a, b| a ^ b));\n\
    \  |                                                             - ^ - char\n\
    \  |                                                             |\n  |      \
    \                                                       &str\n\nerror[E0369]:\
    \ no implementation for `&str ^ char`\n  --> /tmp/tmpfkcdlcqo.rs:11:63\n   |\n\
    11 |         res.push_str(&b[i..(i + 1)].chars().fold(\"\", |a, b| a ^ b));\n\
    \   |                                                             - ^ - char\n\
    \   |                                                             |\n   |    \
    \                                                         &str\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    vec![a,\
    \ b].iter()\n        .map(|x| x.to_string())\n        .fold1(|x, y| {\n      \
    \      std::iter::repeat(x).chain(y.to_string().as_bytes())\n        })\n    \
    \    .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `fold1` found for struct `Map` in the current\
    \ scope\n --> /tmp/tmptq8ep6qx.rs:8:10\n  |\n8 |         .fold1(|x, y| {\n  |\
    \          ^^^^^ method not found in `Map<std::slice::Iter<'_, String>, [closure@/tmp/tmptq8ep6qx.rs:7:14:\
    \ 7:31]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string().chars().zip(&[0; 8]).filter(|&(_, x)| x != 0).map(|x| x as char).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&{integer}` with `{integer}`\n --> /tmp/tmpafycpxae.rs:6:75\n\
    \  |\n6 |     a.to_string() + b.to_string().chars().zip(&[0; 8]).filter(|&(_,\
    \ x)| x != 0).map(|x| x as char).collect()\n  |                              \
    \                                             ^^ no implementation for `&{integer}\
    \ == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&{integer}`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n\nerror[E0277]: a value of type `&str` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpafycpxae.rs:6:100\n     |\n6 \
    \   |     a.to_string() + b.to_string().chars().zip(&[0; 8]).filter(|&(_, x)|\
    \ x != 0).map(|x| x as char).collect()\n     |                               \
    \                                                                     ^^^^^^^\
    \ value of type `&str` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `&str`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0605]: non-primitive cast: `(char, &{integer})` as `char`\n --> /tmp/tmpafycpxae.rs:6:89\n\
    \  |\n6 |     a.to_string() + b.to_string().chars().zip(&[0; 8]).filter(|&(_,\
    \ x)| x != 0).map(|x| x as char).collect()\n  |                              \
    \                                                           ^^^^^^^^^ an `as`\
    \ expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror: aborting due to 3 previous errors\n\nSo"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut xor = String::new();\n\n    for char in a.chars() {\n        xor.push(char.chars().next().unwrap_or('0').cmp(&char.chars().next().unwrap_or('1')).unwrap());\n\
    \    }\n\n    for char in b.chars() {\n        xor.push(char.chars().next().unwrap_or('0').cmp(&char.chars().next().unwrap_or('1')).unwrap());\n\
    \    }\n\n    xor\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n --> /tmp/tmpo0y2jci9.rs:9:23\n  |\n9 |         xor.push(char.chars().next().unwrap_or('0').cmp(&char.chars().next().unwrap_or('1')).unwrap());\n\
    \  |                       ^^^^^ method not found in `char`\n\nerror[E0599]: no\
    \ method named `chars` found for type `char` in the current scope\n --> /tmp/tmpo0y2jci9.rs:9:63\n\
    \  |\n9 |         xor.push(char.chars().next().unwrap_or('0').cmp(&char.chars().next().unwrap_or('1')).unwrap());\n\
    \  |                                                               ^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `chars` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpo0y2jci9.rs:13:23\n   |\n13 |   \
    \      xor.push(char.chars().next().unwrap_or('0').cmp(&char.chars().next().unwrap_or('1')).unwrap());\n\
    \   |                       ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpo0y2jci9.rs:13:63\n\
    \   |\n13 |         xor.push(char.chars().next().unwrap_or('0').cmp(&char.chars().next().unwrap_or('1')).unwrap());\n\
    \   |                                                               ^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if let\
    \ (Ok(mut a), Ok(mut b)) =\n        vec![\"0\".to_owned(), \"1\".to_owned()].iter().zip(a.chars().chain(b.chars())).map(|(a,\
    \ b)| format!(\"{:08b}\", a ^ b)).collect::<Vec<String>>()\n    {\n        a\n\
    \    } else {\n        \"00\".to_owned()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `&String ^ char`\n --> /tmp/tmpr5sxk5vw.rs:7:118\n\
    \  |\n7 | ...chain(b.chars())).map(|(a, b)| format!(\"{:08b}\", a ^ b)).collect::<Vec<String>>()\n\
    \  |                                                     - ^ - char\n  |     \
    \                                                |\n  |                      \
    \                               &String\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr5sxk5vw.rs:6:12\n  |\n6 | ...f let (Ok(mut a), Ok(mut b)) =\n  |  \
    \        ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found tuple\n7 | ...  \
    \ vec![\"0\".to_owned(), \"1\".to_owned()].iter().zip(a.chars().chain(b.chars())).map(|(a,\
    \ b)| format!(\"{:08b}\", a ^ b)).collect::<Vec<String>>()\n  |       -------------------------------------------------------------------------------------------------------------------------------------------\
    \ this expression has type `Vec<String>`\n  |\n  = note: expected struct `Vec<String>`\n\
    \              found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    string_to_bits(a).iter().chain(string_to_bits(b).iter()).map(|b|\
    \ b == 0 ? '0' : '1').collect::<String>().to_string()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `'0'`\n\
    \ --> /tmp/tmpyczvlu14.rs:6:79\n  |\n6 | ...).iter()).map(|b| b == 0 ? '0' : '1').collect::<String>().to_string()\n\
    \  |                               ^^^ expected one of `)`, `,`, `.`, `?`, or\
    \ an operator\n\nerror: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `...`,\
    \ `.`, `;`, `<`, `?`, `[`, `_`, `async`, `const`, `dyn`, `extern`, `fn`, `for`,\
    \ `impl`, `unsafe`, `}`, `~`, an operator, lifetime, or path, found `'1'`\n -->\
    \ /tmp/tmpyczvlu14.rs:6:85\n  |\n6 | ...(b).iter()).map(|b| b == 0 ? '0' : '1').collect::<String>().to_string()\n\
    \  |                                       ^^^ expected one of 26 possible tokens\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"StringXor: input strings must have same length\"\
    );\n    }\n\n    let mut res = String::new();\n\n    for i in 0..a.len() {\n \
    \       res.push_str(&a[i as usize] ^ &b[i as usize]);\n    }\n\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6zcseuvj.rs:13:23\n\
    \   |\n13 |         res.push_str(&a[i as usize] ^ &b[i as usize]);\n   |     \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6zcseuvj.rs:13:40\n\
    \   |\n13 |         res.push_str(&a[i as usize] ^ &b[i as usize]);\n   |     \
    \                                   ^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_prefix(\n\
    \        String::from_utf8(b.as_bytes()).xor_prefix(\n            String::from_utf8(\"\
    \"),\n        ),\n    )\n    .unwrap_or(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmrpdoow4.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_prefix(\n  |                       ^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n  |                      \
    \ |\n  |                       expected struct `Vec`, found `&[u8]`\n  |\n  =\
    \ note: expected struct `Vec<u8>`\n          found reference `&[u8]`\n\nerror[E0599]:\
    \ no method named `xor_prefix` found for enum `Result` in the current scope\n\
    \ --> /tmp/tmpmrpdoow4.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_prefix(\n\
    \  |                                     ^^^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmrpdoow4.rs:7:27\n\
    \  |\n7 |         String::from_utf8(b.as_bytes()).xor_prefix(\n  |           \
    \                ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                           |\n  |                           expected struct\
    \ `Vec`, found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found\
    \ reference `&[u8]`\n\nerror[E0599]: no method named `xor_prefix` found for enum\
    \ `Result` in the current scope\n --> /tmp/tmpmrpdoow4.rs:7:41\n  |\n7 |     \
    \    String::from_utf8(b.as_bytes()).xor_prefix(\n  |                        \
    \                 ^^^^^^^^^^ method not found in `Result<String, FromUtf8Error>`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpmrpdoow4.rs:8:31\n  |\n8 |    \
    \         String::from_utf8(\"\"),\n  |                               ^^ expected\
    \ struct `Vec`, found `&str`\n  |\n  = note: expected struct `Vec<u8>`\n     \
    \     found reference `&'static str`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Convert\
    \ both input strings to binary arrays and then XOR them.\n    let a_arr: Vec<u8>\
    \ = a.as_bytes().collect();\n    let b_arr: Vec<u8> = b.as_bytes().collect();\n\
    \    let mut xor = a_arr.clone();\n    xor.extend(b_arr);\n    xor.to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `&[u8]` is not an iterator\n --> /tmp/tmpuxrpeqns.rs:7:39\n\
    \  |\n7 |     let a_arr: Vec<u8> = a.as_bytes().collect();\n  |              \
    \                         ^^^^^^^ `&[u8]` is not an iterator; try calling `.iter()`\n\
    \  |\n  = note: the following trait bounds were not satisfied:\n          `&[u8]:\
    \ Iterator`\n          which is required by `&mut &[u8]: Iterator`\n         \
    \ `[u8]: Iterator`\n          which is required by `&mut [u8]: Iterator`\n\nerror[E0599]:\
    \ `&[u8]` is not an iterator\n --> /tmp/tmpuxrpeqns.rs:8:39\n  |\n8 |     let\
    \ b_arr: Vec<u8> = b.as_bytes().collect();\n  |                              \
    \         ^^^^^^^ `&[u8]` is not an iterator; try calling `.iter()`\n  |\n  =\
    \ note: the following trait bounds were not satisfied:\n          `&[u8]: Iterator`\n\
    \          which is required by `&mut &[u8]: Iterator`\n          `[u8]: Iterator`\n\
    \          which is required by `&mut [u8]: Iterator`\n\nerror[E0599]: `Vec<u8>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpuxrpeqns.rs:11:9\n   \
    \ |\n11  |       xor.to_string()\n    |           ^^^^^^^^^ `Vec<u8>` cannot be\
    \ formatted with the default formatter\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<u8>: std::fmt::Display`\n     \
    \       which is required by `Vec<u8>: ToString`\n            `[u8]: std::fmt::Display`\n\
    \            which is required by `[u8]: ToString`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ ^ b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpfcswo2uw.rs:6:18\n\
    \  |\n6 |     a.to_owned() ^ b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut ret = \"\".to_string();\n    for &c in a.chars().chain(&b.chars()) {\n \
    \       ret += if c != b[c.index() as usize] {\n            '0'\n        } else\
    \ {\n            '1'\n        };\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n --> /tmp/tmpeekskesd.rs:7:31\n\
    \  |\n7 |     for &c in a.chars().chain(&b.chars()) {\n  |                   \
    \      ----- ^^^^^^^^^^ `&Chars<'_>` is not an iterator\n  |                 \
    \        |\n  |                         required by a bound introduced by this\
    \ call\n  |\n  = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n\
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Chars<'_>`\nhelp: consider dereferencing here\n  |\n7 |     for &c in\
    \ a.chars().chain(*&b.chars()) {\n  |                               +\nhelp: consider\
    \ removing the leading `&`-reference\n  |\n7 -     for &c in a.chars().chain(&b.chars())\
    \ {\n7 +     for &c in a.chars().chain(b.chars()) {\n  | \nhelp: consider changing\
    \ this borrow's mutability\n  |\n7 |     for &c in a.chars().chain(&mut b.chars())\
    \ {\n  |                               ~~~~\n\nerror[E0277]: `&Chars<'_>` is not\
    \ an iterator\n --> /tmp/tmpeekskesd.rs:7:15\n  |\n7 |     for &c in a.chars().chain(&b.chars())\
    \ {\n  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `&Chars<'_>` is not an iterator\n\
    \  |\n  = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n  =\
    \ help: the trait `Iterator` is implemented for `Chars<'a>`\n  = note: `Iterator`\
    \ is implemented for `&mut std::str::Chars<'_>`, but not for `&std::str::Chars<'_>`\n\
    \  = note: required because of the requirements on the impl of `Iterator` for\
    \ `std::iter::Chain<Chars<'_>, &Chars<'_>>`\n  = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `std::iter::Chain<Chars<'_>,\
    \ &Chars<'_>>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpeekskesd.rs:7:9\n\
    \  |\n7 |     for &c in a.chars().chain(&b.chars()) {\n  |         ^^    ---------------------------\
    \ this expression has type `Option<char>`\n  |         |\n  |         expected\
    \ `char`, found reference\n  |         help: you can probably remove the explicit\
    \ borrow: `c`\n  |\n  = note:   expected type `char`\n          found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpeekskesd.rs:9:13\n  |\n\
    9 |        "
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    bin2int(string_xor_binary(a,\
    \ b)).to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `bin2int` in this scope\n --> /tmp/tmpaau6ng9r.rs:6:5\n\
    \  |\n6 |     bin2int(string_xor_binary(a, b)).to_string()\n  |     ^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `string_xor_binary`\
    \ in this scope\n --> /tmp/tmpaau6ng9r.rs:6:13\n  |\n6 |     bin2int(string_xor_binary(a,\
    \ b)).to_string()\n  |             ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_digits().xor_(b).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for struct `String` in\
    \ the current scope\n --> /tmp/tmp3fb3tt8l.rs:6:7\n  |\n6 |     a.to_digits().xor_(b).to_string()\n\
    \  |       ^^^^^^^^^ method not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    debug_assert!(\n\
    \        a.len() >= b.len(),\n        \"Inputs must have same length\",\n    );\n\
    \    let mut result = String::new();\n    let mut carry = 0;\n    for i in 0..a.len()\
    \ {\n        let c = a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap();\n\
    \        result.push((c & 255) as char);\n        carry += c & 1;\n    }\n   \
    \ if carry > 0 {\n        result.push(carry.to_char());\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n  --> /tmp/tmpu3272vkp.rs:13:43\n\
    \   |\n13 |         let c = a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap();\n\
    \   |                 ------------------------- ^ ------------------------- char\n\
    \   |                 |\n   |                 char\n\nerror[E0599]: no method\
    \ named `to_char` found for type `{integer}` in the current scope\n  --> /tmp/tmpu3272vkp.rs:18:27\n\
    \   |\n18 |         result.push(carry.to_char());\n   |                      \
    \     ^^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a +\
    \ &b\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"111000101010\"`,\n right: `\"010010\"`', /tmp/tmpk1ql5h9b.rs:11:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    debug_assert!(!a.is_empty()\
    \ && !b.is_empty());\n    let mut c = String::new();\n    c.push_str(\"\\0\");\n\
    \    for (c1, b1) in zip(a.chars().cloned(), b.chars().cloned()) {\n        c.push(c1\
    \ ^ b1);\n    }\n    c\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n --> /tmp/tmp7viajdkj.rs:9:21\n\
    \  |\n9 |     for (c1, b1) in zip(a.chars().cloned(), b.chars().cloned()) {\n\
    \  |                     ^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this function\n  |\n1 | use std::iter::zip;\n  |\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp7viajdkj.rs:9:35\n\
    \     |\n9    |     for (c1, b1) in zip(a.chars().cloned(), b.chars().cloned())\
    \ {\n     |                                   ^^^^^^ expected reference, found\
    \ `char`\n     |\n     = note: expected reference `&_`\n                     found\
    \ type `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp7viajdkj.rs:9:55\n\
    \     |\n9    |     for (c1, b1) in zip(a.chars().cloned(), b.chars().cloned())\
    \ {\n     |                                                       ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0425.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().xor_(b).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpfstrj_e7.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    debug_assert!(a.len()\
    \ == b.len());\n    let mut result = String::new();\n    for (c1, c2) in zip(a.chars(),\
    \ b.chars()) {\n        debug_assert!(c1 == c2);\n        result .push(c1 ^ *c2);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n --> /tmp/tmp3fqmtwkw.rs:8:21\n\
    \  |\n8 |     for (c1, c2) in zip(a.chars(), b.chars()) {\n  |               \
    \      ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::iter::zip;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    b.iter().map(|b|\
    \ a as char).fold(String::new(), |mut accum, item| {\n        accum.push_str(&item);\n\
    \        accum\n    });\n    accum\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `accum` in this scope\n  --> /tmp/tmpc_edhfsq.rs:10:5\n\
    \   |\n10 |     accum\n   |     ^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpc_edhfsq.rs:6:7\n  |\n6 |     b.iter().map(|b| a as char).fold(String::new(),\
    \ |mut accum, item| {\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     b.chars().map(|b| a as\
    \ char).fold(String::new(), |mut accum, item| {\n  |       ~~~~~\n\nerror[E0605]:\
    \ non-primitive cast: `String` as `char`\n --> /tmp/tmpc_edhfsq.rs:6:22\n  |\n\
    6 |     b.iter().map(|b| a as char).fold(String::new(), |mut accum, item| {\n\
    \  |                      ^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599,\
    \ E0605.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push((*a ^ *b) as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpbvp4y8a7.rs:8:22\n\
    \  |\n8 |         result.push((*a ^ *b) as char);\n  |                      ^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpbvp4y8a7.rs:8:27\n\
    \  |\n8 |         result.push((*a ^ *b) as char);\n  |                       \
    \    ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"Inputs must have same length\");\n    }\n   \
    \ let mut result: String = String::new();\n    for i in 0..a.len() {\n       \
    \ result.push((a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap()).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n  --> /tmp/tmp_0ntnzo1.rs:11:48\n\
    \   |\n11 |         result.push((a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap()).to_string());\n\
    \   |                      ------------------------- ^ -------------------------\
    \ char\n   |                      |\n   |                      char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::with_capacity(a.size());\n    for (i, ch) in a.chars().zip(b.chars()).enumerate()\
    \ {\n        match ch {\n            '0' => {\n                res.push(i);\n\
    \            }\n            '1' => {\n                res.push('1');\n       \
    \     }\n            _ => {\n                panic!();\n            }\n      \
    \  }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpy9665aix.rs:6:43\n  |\n6 |     let mut res = String::with_capacity(a.size());\n\
    \  |                                           ^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpy9665aix.rs:9:13\n  |\n8 |    \
    \     match ch {\n  |               -- this expression has type `(char, char)`\n\
    9 |             '0' => {\n  |             ^^^ expected tuple, found `char`\n \
    \ |\n  = note: expected tuple `(char, char)`\n              found type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy9665aix.rs:12:13\n   |\n8  |\
    \         match ch {\n   |               -- this expression has type `(char, char)`\n\
    ...\n12 |             '1' => {\n   |             ^^^ expected tuple, found `char`\n\
    \   |\n   = note: expected tuple `(char, char)`\n               found type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy9665aix.rs:10:26\n   |\n10 |\
    \                 res.push(i);\n   |                          ^ expected `char`,\
    \ found `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a_u8 = a.as_bytes();\n    let mut b_u8 = b.as_bytes();\n    let mut result\
    \ = String::new();\n    while a_u8.pop() != 0 || b_u8.pop() != 0 {\n        if\
    \ a_u8.pop() != b_u8.pop() {\n            result.push(b'1');\n        } else {\n\
    \            result.push(b'0');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pop` found for reference `&[u8]` in the\
    \ current scope\n --> /tmp/tmp51uhud11.rs:9:16\n  |\n9 |     while a_u8.pop()\
    \ != 0 || b_u8.pop() != 0 {\n  |                ^^^ method not found in `&[u8]`\n\
    \nerror[E0599]: no method named `pop` found for reference `&[u8]` in the current\
    \ scope\n --> /tmp/tmp51uhud11.rs:9:35\n  |\n9 |     while a_u8.pop() != 0 ||\
    \ b_u8.pop() != 0 {\n  |                                   ^^^ method not found\
    \ in `&[u8]`\n\nerror[E0599]: no method named `pop` found for reference `&[u8]`\
    \ in the current scope\n  --> /tmp/tmp51uhud11.rs:10:17\n   |\n10 |         if\
    \ a_u8.pop() != b_u8.pop() {\n   |                 ^^^ method not found in `&[u8]`\n\
    \nerror[E0599]: no method named `pop` found for reference `&[u8]` in the current\
    \ scope\n  --> /tmp/tmp51uhud11.rs:10:31\n   |\n10 |         if a_u8.pop() !=\
    \ b_u8.pop() {\n   |                               ^^^ method not found in `&[u8]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp51uhud11.rs:11:25\n   |\n11 |\
    \             result.push(b'1');\n   |                         ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp51uhud11.rs:13:25\n\
    \   |\n13 |             result.push(b'0');\n   |                         ^^^^\
    \ expected `char`, found `u8`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = [0; a.len()];\n    for i in 0..a.len() {\n        result[i] = a[i]\
    \ ^ b[i];\n    }\n    return String::from_utf8(result).to_string();\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n --> /tmp/tmp0quiafei.rs:6:26\n\
    \  |\n5 | fn string_xor(a: String, b: String) -> String {\n  |               -\
    \ this would need to be a `const`\n6 |     let mut result = [0; a.len()];\n  |\
    \                          ^\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp0quiafei.rs:8:21\n  |\n8 |         result[i] = a[i]\
    \ ^ b[i];\n  |                     ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmp0quiafei.rs:8:28\n\
    \  |\n8 |         result[i] = a[i] ^ b[i];\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0599]: `Result<String, FromUtf8Error>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmp0quiafei.rs:10:38\n    |\n10  |       return String::from_utf8(result).to_string();\n\
    \    |                                        ^^^^^^^^^ `Result<String, FromUtf8Error>`\
    \ cannot be formatted with the default formatter\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Result<String, FromUtf8Error>:\
    \ std::fmt::Displa"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        \"\".to_string()\n    } else {\n        a.to_chars().rev().zip(b.to_chars().rev()).map(|&(aa,\
    \ bb)| {\n            if *aa != *bb {\n                *aa\n            } else\
    \ {\n                *aa\n            }\n        }).collect()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_chars` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp0i_mr96m.rs:9:11\n  |\n9 |         a.to_chars().rev().zip(b.to_chars().rev()).map(|&(aa,\
    \ bb)| {\n  |           ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `chars`\n\nerror[E0599]: no method named `to_chars` found for\
    \ struct `String` in the current scope\n --> /tmp/tmp0i_mr96m.rs:9:34\n  |\n9\
    \ |         a.to_chars().rev().zip(b.to_chars().rev()).map(|&(aa, bb)| {\n  |\
    \                                  ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `chars`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result: String = \"\";\n    let mut a: Vec<u8> = a.as_bytes();\n    let\
    \ mut b: Vec<u8> = b.as_bytes();\n    let mut i: usize = 0;\n    while i < a.len()\
    \ {\n        result.append(a[i as usize] ^ b[i as usize]);\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp19w5ritk.rs:6:30\n  |\n6 |\
    \     let mut result: String = \"\";\n  |                     ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                     |   \
    \     |\n  |                     |        expected struct `String`, found `&str`\n\
    \  |                     expected due to this\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp19w5ritk.rs:7:26\n  |\n7 |     let mut a: Vec<u8> = a.as_bytes();\n\
    \  |                -------   ^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_vec()`\n  |                |         |\n  |                |         expected\
    \ struct `Vec`, found `&[u8]`\n  |                expected due to this\n  |\n\
    \  = note: expected struct `Vec<u8>`\n          found reference `&[u8]`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp19w5ritk.rs:8:26\n  |\n8 |     let mut b: Vec<u8>\
    \ = b.as_bytes();\n  |                -------   ^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_vec()`\n  |                |         |\n  |      \
    \          |         expected struct `Vec`, found `&[u8]`\n  |               \
    \ expected due to this\n  |\n  = note: expected struct `Vec<u8>`\n          found\
    \ reference `&[u8]`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp19w5ritk.rs:11:16\n   |\n11 | \
    \        result.append(a[i as usize] ^ b[i as usize]);\n   |                ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"string_xor: lengths don't match: {} vs {}\",\
    \ a.len(), b.len());\n    }\n    let mut result = String::new();\n    for (xor_byte,\
    \ a_char) in a.chars().zip(b.chars()) {\n        result.push((xor_byte ^ a_char)\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n  --> /tmp/tmppufw2mty.rs:11:31\n\
    \   |\n11 |         result.push((xor_byte ^ a_char) as char);\n   |          \
    \            -------- ^ ------ char\n   |                      |\n   |       \
    \               char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_ascii_lowercase()\n\
    \        .iter()\n        .zip(b.to_ascii_lowercase().iter())\n        .map(|(a,\
    \ b)| a ^ b)\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmphrb6t2j4.rs:7:10\n  |\n7 |         .iter()\n  |        \
    \  ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory representation\
    \ of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \  |\n7 |         .chars()\n  |          ~~~~~\n\nerror[E0599]: no method named\
    \ `iter` found for struct `String` in the current scope\n --> /tmp/tmphrb6t2j4.rs:8:37\n\
    \  |\n8 |         .zip(b.to_ascii_lowercase().iter())\n  |                   \
    \                  ^^^^ method not found in `String`\n  |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n  |\n8 |         .zip(b.to_ascii_lowercase().chars())\n\
    \  |                                     ~~~~~\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    vec![(a\
    \ ^ b).to_bytes().iter().cloned().collect()].to_owned()\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpa1a51n4j.rs:6:13\n\
    \  |\n6 |     vec![(a ^ b).to_bytes().iter().cloned().collect()].to_owned()\n\
    \  |           - ^ - String\n  |           |\n  |           String\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpa1a51n4j.rs:6:5\n  |\n5 | fn string_xor(a: String,\
    \ b: String) -> String {\n  |                                        ------ expected\
    \ `String` because of return type\n6 |     vec![(a ^ b).to_bytes().iter().cloned().collect()].to_owned()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n  |\n  = note: expected struct `String`\n\
    \             found struct `Vec<_, _>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {:b}\", (a.to_string() ^ b.to_string()).to_string())\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmp7o5g6xlb.rs:6:36\n\
    \  |\n6 |     format!(\"{:b}\", (a.to_string() ^ b.to_string()).to_string())\n\
    \  |                      ------------- ^ ------------- String\n  |          \
    \            |\n  |                      String\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result: String = String::new();\n    for a_ch in a.chars() {\n        result.push((a_ch\
    \ ^ b.chars().next().unwrap()).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp9mqjz6ma.rs:8:27\n\
    \  |\n8 |         result.push((a_ch ^ b.chars().next().unwrap()).to_string());\n\
    \  |                      ---- ^ ------------------------- char\n  |         \
    \             |\n  |                      char\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in &a {\n        if *i != '0' {\n   \
    \         result += '0';\n        }\n    }\n    for i in &b {\n        if *i !=\
    \ '0' {\n            result += '0';\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpcwuxosg4.rs:7:14\n\
    \  |\n7 |     for i in &a {\n  |              ^^ `&String` is not an iterator\n\
    \  |\n  = help: the trait `Iterator` is not implemented for `&String`\n  = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpcwuxosg4.rs:9:23\n  |\n9 |    \
    \         result += '0';\n  |                       ^^^ expected `&str`, found\
    \ `char`\n  |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \  |\n9 |             result += \"0\";\n  |                       ~~~\n\nerror[E0277]:\
    \ `&String` is not an iterator\n  --> /tmp/tmpcwuxosg4.rs:12:14\n   |\n12 |  \
    \   for i in &b {\n   |              ^^ `&String` is not an iterator\n   |\n \
    \  = help: the trait `Iterator` is not implemented for `&String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcwuxosg4.rs:14:23\n   |\n14 |  \
    \           result += '0';\n   |                       ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n14 |             result += \"0\";\n   |                       ~~~\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    string_xor_bitwise(a,\
    \ b)\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `string_xor_bitwise` in this scope\n\
    \ --> /tmp/tmpn4dqayr4.rs:6:5\n  |\n6 |     string_xor_bitwise(a, b)\n  |    \
    \ ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(aa,\
    \ bb)| aa ^ bb).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpp4c5aimi.rs:6:48\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(aa, bb)| aa ^ bb).collect::<String>()\n\
    \  |                                             -- ^ -- char\n  |           \
    \                                  |\n  |                                    \
    \         char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    use\
    \ std::iter::FromIterator;\n\n    (a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::iter::FromIterator`\n --> /tmp/tmpx18m2yf7.rs:6:9\n\
    \  |\n6 |     use std::iter::FromIterator;\n  |         ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary\
    \ parentheses around block return value\n --> /tmp/tmpx18m2yf7.rs:8:5\n  |\n8\
    \ |     (a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>())\n \
    \ |     ^                                                                ^\n \
    \ |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \  |\n8 -     (a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>())\n\
    8 +     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()\n  |\
    \ \n\nerror[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpx18m2yf7.rs:8:46\n\
    \  |\n8 |     (a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>())\n\
    \  |                                            - ^ - char\n  |              \
    \                              |\n  |                                        \
    \    char\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for c in a.chars().cloned() {\n        result.push((*c\
    \ as u8) ^ b.chars().next().unwrap());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp5dffa2i8.rs:7:24\n     |\n7    |     for c in a.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmp5dffa2i8.rs:7:14\n\
    \  |\n7 |     for c in a.chars().cloned() {\n  |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmp5dffa2i8.rs:7:14\n  |\n7 |     for c in a.chars().cloned() {\n \
    \ |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bits = a.as_bytes();\n    let b_bits = b.as_bytes();\n\n    let mut result\
    \ = [0u8; a.len()];\n\n    for i in 0..a.len() {\n        let a_bit = a_bits[i\
    \ as usize];\n        let b_bit = b_bits[i as usize];\n\n        if a_bit != b_bit\
    \ {\n            result[i] = a_bit ^ b_bit;\n        } else {\n            result[i]\
    \ = 0u8;\n        }\n    }\n\n    string_from_bytes(&result)\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n --> /tmp/tmphnhjujns.rs:9:28\n\
    \  |\n5 | fn string_xor(a: String, b: String) -> String {\n  |               -\
    \ this would need to be a `const`\n...\n9 |     let mut result = [0u8; a.len()];\n\
    \  |                            ^\n\nerror[E0425]: cannot find function `string_from_bytes`\
    \ in this scope\n  --> /tmp/tmphnhjujns.rs:22:5\n   |\n22 |     string_from_bytes(&result)\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0435.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"input strings are not same length\");\n    }\n\
    \n    if a.chars().zip(b.chars()).any(|(_, cmp)| cmp != 0) {\n        panic!(\"\
    input strings do not have same character values\");\n    }\n\n    if a.chars().iter().all(|&c|\
    \ !c.is_ascii()) {\n        panic!(\"input strings are not ascii\");\n    }\n\n\
    \    if b.chars().iter().all(|&c| !c.is_ascii()) {\n        panic!(\"input strings\
    \ are not ascii\");\n    }\n\n    let mut out = String::new();\n    for i in 0..a.len()\
    \ {\n        let a = a.chars().nth(i).unwrap();\n        let b = b.chars().nth(i).unwrap();\n\
    \        if a != b {\n            out.push(a);\n        }\n    }\n    out\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnb9vcnz1.rs:10:55\n   |\n\
    10 |     if a.chars().zip(b.chars()).any(|(_, cmp)| cmp != 0) {\n   |        \
    \                                               ^ expected `char`, found `u8`\n\
    \nerror[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpnb9vcnz1.rs:14:18\n   |\n14 |     if a.chars().iter().all(|&c|\
    \ !c.is_ascii()) {\n   |                  ^^^^ private field, not a method\n\n\
    error[E0599]: no method named `iter` found for struct `Chars` in the current scope\n\
    \  --> /tmp/tmpnb9vcnz1.rs:18:18\n   |\n18 |     if b.chars().iter().all(|&c|\
    \ !c.is_ascii()) {\n   |                  ^^^^ private field, not a method\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ + b.to_owned()\n        .as_bytes()\n        .iter()\n        .zip(&b'\\1')\n\
    \        .map(|(a, b)| {\n            if *a != *b {\n                Some(b'1')\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .filter_map(|b| b.ok())\n        .collect::<Vec<_>>()\n        .to_owned()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: unknown byte escape: `1`\n --> /tmp/tmpfxrlooce.rs:9:18\n  |\n9\
    \ |         .zip(&b'\\1')\n  |                  ^ unknown byte escape\n  |\n \
    \ = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfxrlooce.rs:6:20\n   |\n6  | \
    \      a.to_owned() + b.to_owned()\n   |  ____________________^\n7  | |      \
    \   .as_bytes()\n8  | |         .iter()\n9  | |         .zip(&b'\\1')\n...  |\n\
    18 | |         .collect::<Vec<_>>()\n19 | |         .to_owned()\n   | |___________________^\
    \ expected `&str`, found struct `Vec`\n   |\n   = note: expected reference `&str`\n\
    \                 found struct `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpksnass_o.rs:6:19\n  |\n6 |     a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                   ^^^^ method not found\
    \ in `String`\n  |\nhelp: because of the in-memory representation of `&str`, to\
    \ obtain an `Iterator` over each of its codepoint use method `chars`\n  |\n6 |\
    \     a.to_string().chars().zip(b.to_string().iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                   ~~~~~\n\nerror[E0599]: no method named `iter` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpksnass_o.rs:6:44\n  |\n6\
    \ |     a.to_string().iter().zip(b.to_string().iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                            ^^^^ method not found in `String`\n\
    \  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n  |\n6 |     a.to_string().iter().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                                        \
    \    ~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut c = 0;\n    let mut d = 0;\n\n    for c in a.chars().chain(b) {\n      \
    \  d |= c.to_digit(16) << (c + 1);\n    }\n\n    format!(\"{:X}\", d)\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n --> /tmp/tmpf2x1_crz.rs:9:30\n\
    \  |\n9 |     for c in a.chars().chain(b) {\n  |                        -----\
    \ ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |   \
    \                     |\n  |                        required by a bound introduced\
    \ by this call\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n\
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0277]: `String` is not an iterator\n --> /tmp/tmpf2x1_crz.rs:9:14\n\
    \  |\n9 |     for c in a.chars().chain(b) {\n  |              ^^^^^^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  =\
    \ help: the trait `Iterator` is not implemented for `String`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `std::iter::Chain<Chars<'_>,\
    \ String>`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `std::iter::Chain<Chars<'_>, String>`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmpf2x1_crz.rs:10:35\n   |\n10 |         d |= c.to_digit(16)\
    \ << (c + 1);\n   |                                 - ^ - {integer}\n   |    \
    \                             |\n   |                                 char\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.as_bytes_mut().iter().zip(b.as_bytes_mut().iter()).map(|(ai,\
    \ bi)| {\n        let mut ret: u8 = *ai ^ *bi;\n        if ret < b'0' {\n    \
    \        ret = b'0';\n        } else if ret > b'9' {\n            ret = b'9';\n\
    \        }\n        ret\n    }).collect::<String>().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `u8`\n    --> /tmp/tmp34bzeww1.rs:14:8\n     |\n14   |\
    \     }).collect::<String>().to_string()\n     |        ^^^^^^^ value of type\
    \ `String` cannot be built from `std::iter::Iterator<Item=u8>`\n     |\n     =\
    \ help: the trait `FromIterator<u8>` is not implemented for `String`\n     = help:\
    \ the following other types implement trait `FromIterator<A>`:\n             \
    \  <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a\
    \ == \"0\" && b == \"0\" {\n        \"0\"\n    } else {\n        let mut res =\
    \ String::new();\n        for c in &a.as_bytes().iter() {\n            if *c !=\
    \ *b.as_bytes().next() {\n                res.push(*c);\n            }\n     \
    \   }\n        res\n    }\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1kqgsubd.rs:7:9\n  |\n5 |\
    \ fn string_xor(a: String, b: String) -> String {\n  |                       \
    \                 ------ expected `String` because of return type\n6 |     if\
    \ a == \"0\" && b == \"0\" {\n7 |         \"0\"\n  |         ^^^- help: try using\
    \ a conversion method: `.to_string()`\n  |         |\n  |         expected struct\
    \ `String`, found `&str`\n\nerror[E0277]: `&std::slice::Iter<'_, u8>` is not an\
    \ iterator\n  --> /tmp/tmp1kqgsubd.rs:10:18\n   |\n10 |         for c in &a.as_bytes().iter()\
    \ {\n   |                  -^^^^^^^^^^^^^^^^^^^\n   |                  |\n   |\
    \                  `&std::slice::Iter<'_, u8>` is not an iterator\n   |      \
    \            help: consider removing the leading `&`-reference\n   |\n   = help:\
    \ the trait `Iterator` is not implemented for `&std::slice::Iter<'_, u8>`\n  \
    \ = note: `Iterator` is implemented for `&mut std::slice::Iter<'_, u8>`, but not\
    \ for `&std::slice::Iter<'_, u8>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&std::slice::Iter<'_, u8>`\n\nerror[E0599]:\
    \ no method named `next` found for reference `&[u8]` in the current scope\n  -->\
    \ /tmp/tmp1kqgsubd.rs:11:36\n   |\n11 |             if *c != *b.as_bytes().next()\
    \ {\n   |                                    ^^^^ method not found in `&[u8]`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().map(|c|\
    \ c ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ String`\n --> /tmp/tmpe_fxyull.rs:6:25\n\
    \  |\n6 |     a.chars().map(|c| c ^ b).collect()\n  |                       -\
    \ ^ - String\n  |                       |\n  |                       char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_owned()\
    \ & b.to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7ye80ywe.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.bytes())\n\
    \        .chain(b.bytes())\n        .iter()\n        .map(|x| x as u8)\n     \
    \   .collect::<Vec<_>>()\n        .iter()\n        .map(|x| x ^ 1)\n        .collect::<Vec<_>>()\n\
    \        .to_str()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_028n398.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.bytes())\n  |                       ^^^^^^^^^ expected\
    \ struct `Vec`, found struct `std::str::Bytes`\n  |\n  = note: expected struct\
    \ `Vec<u8>`\n             found struct `std::str::Bytes<'_>`\n\nerror[E0599]:\
    \ `Result<String, FromUtf8Error>` is not an iterator\n   --> /tmp/tmp_028n398.rs:7:10\n\
    \    |\n7   |           .chain(b.bytes())\n    |            ^^^^^ `Result<String,\
    \ FromUtf8Error>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Result<String, FromUtf8Error>: Iterator`\n\
    \            which is required by `&mut Result<String, FromUtf8Error>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::from(a);\n    for c in res.chars() {\n        res.chars().rev()\n\
    \            .find(|&c| c == b as char).map(|i| *i ^ *(*i as char))\n        \
    \    .map(|c| c + b'0')\n            .unwrap_or_else(|_| c) // If there is no\
    \ match, then the result is unchanged.\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmp6g_kc6j9.rs:9:48\n\
    \  |\n9 |             .find(|&c| c == b as char).map(|i| *i ^ *(*i as char))\n\
    \  |                                                ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n --> /tmp/tmp6g_kc6j9.rs:9:55\n  |\n9 |            \
    \ .find(|&c| c == b as char).map(|i| *i ^ *(*i as char))\n  |                \
    \                                       ^^\n\nerror[E0605]: non-primitive cast:\
    \ `String` as `char`\n --> /tmp/tmp6g_kc6j9.rs:9:29\n  |\n9 |             .find(|&c|\
    \ c == b as char).map(|i| *i ^ *(*i as char))\n  |                           \
    \  ^^^^^^^^^ an `as` expression can only be used to convert between primitive\
    \ types or to coerce to a specific trait object\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0605, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0605`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result: String = \"\";\n    a.chars().for_each(|x| *x ^= b.chars().nth(0)).collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp05w_zr0x.rs:6:30\n  |\n6 |\
    \     let mut result: String = \"\";\n  |                     ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                     |   \
    \     |\n  |                     |        expected struct `String`, found `&str`\n\
    \  |                     expected due to this\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n --> /tmp/tmp05w_zr0x.rs:7:28\n  |\n7 |     a.chars().for_each(|x|\
    \ *x ^= b.chars().nth(0)).collect::<String>().to_string()\n  |               \
    \             ^^\n\nerror[E0599]: `()` is not an iterator\n --> /tmp/tmp05w_zr0x.rs:7:52\n\
    \  |\n7 |     a.chars().for_each(|x| *x ^= b.chars().nth(0)).collect::<String>().to_string()\n\
    \  |                                                    ^^^^^^^ `()` is not an\
    \ iterator\n  |\n  = note: the following trait bounds were not satisfied:\n  \
    \        `(): Iterator`\n          which is required by `&mut (): Iterator`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    debug_assert!(a\
    \ == b);\n    (a.to_string()[0..a.len() - b.len()]).iter()\n        .map(|&c|\
    \ if b == c { '0' } else { '1' }).collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpctmylmhk.rs:7:43\n  |\n7 |     (a.to_string()[0..a.len()\
    \ - b.len()]).iter()\n  |                                           ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    result.push_str(&a);\n    for c in b.chars().cloned()\
    \ {\n        result.push_str(&c.to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp5e9dbgsu.rs:8:24\n     |\n8    |     for c in b.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmp5e9dbgsu.rs:8:14\n\
    \  |\n8 |     for c in b.chars().cloned() {\n  |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmp5e9dbgsu.rs:8:14\n  |\n8 |     for c in b.chars().cloned() {\n \
    \ |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().as_bytes().iter().cloned()\n\
    \        .chain(b.to_string().as_bytes().iter().cloned())\n        .cloned()\n\
    \        .map(|x| x ^ 0xff)\n        .map(|x| x as char)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, u8> as Iterator>::Item\
    \ == &&_`\n --> /tmp/tmpdrhf_9qt.rs:8:10\n  |\n8 |         .cloned()\n  |    \
    \      ^^^^^^ expected reference, found `u8`\n  |\n  = note: expected reference\
    \ `&&_`\n             found reference `&u8`\n  = note: required because of the\
    \ requirements on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, u8>>`\n\
    \  = note: 1 redundant requirement hidden\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ u8>>, Cloned<std::slice::Iter<'_, u8>>>`\n\nerror[E0599]: the method `map` exists\
    \ for struct `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_, u8>>, Cloned<std::slice::Iter<'_,\
    \ u8>>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpdrhf_9qt.rs:9:10\n\
    \   |\n9  |           .map(|x| x ^ 0xff)\n   |            ^^^ method cannot be\
    \ called on `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_, u8>>, Cloned<std::slice::Iter<'_,\
    \ u8>>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ u8>>, Cloned<std::slice::Iter<'_, u8>>> as Iterator>::Item = &_`\n         \
    \  which is required by `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_, u8>>,\
    \ Cloned<std::slice::Iter<'_, u8>>>>: Iterator`\n           `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ u8>>, Cloned<std::slice::Iter<'_, u8>>>>: Iterator`\n           which is required\
    \ by `&mut Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_, u8>>, Cloned<std::slice::Iter<'_,\
    \ u8>>>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    fn xor(a:\
    \ &str, b: &str) -> String {\n        let mut res = String::new();\n        res.push_str(&a[0..a.len()\
    \ - b.len()]);\n        res.push_str(&b[0..b.len()]);\n        res.push_str(&a[(b.len()\
    \ + 1)..]);\n        res.push_str(&b[(b.len() + 1)..]);\n        res\n    }\n\
    \    a.to_string().xor_with_padding(b, |a, b| xor(&a, &b)).to_string()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `xor_with_padding` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp30gu6g2r.rs:14:19\n   |\n14 |     a.to_string().xor_with_padding(b,\
    \ |a, b| xor(&a, &b)).to_string()\n   |                   ^^^^^^^^^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmp30gu6g2r.rs:14:40\n   |\n14 |  \
    \   a.to_string().xor_with_padding(b, |a, b| xor(&a, &b)).to_string()\n   |  \
    \                                      ^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\nhelp: function\
    \ arguments must have a statically known size, borrowed types always have a known\
    \ size\n   |\n14 |     a.to_string().xor_with_padding(b, |&a, b| xor(&a, &b)).to_string()\n\
    \   |                                        +\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmp30gu6g2r.rs:14:43\n\
    \   |\n14 |     a.to_string().xor_with_padding(b, |a, b| xor(&a, &b)).to_string()\n\
    \   |                                           ^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    help: function arguments must have a statically known size, borrowed types always\
    \ have a known size\n   |\n14 |     a.to_string().xor_with_padding(b, |a, &b|\
    \ xor(&a, &b)).to_string()\n   |                                           +\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '1' && b.contains(&c))\n\
    \        .collect::<String>()\n        .join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp5r_pvnpz.rs:8:23\n\
    \  |\n8 |         .filter(|c| c == '1' && b.contains(&c))\n  |               \
    \        ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n\
    \    --> /tmp/tmp5r_pvnpz.rs:8:44\n     |\n8    |         .filter(|c| c == '1'\
    \ && b.contains(&c))\n     |                                   -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                             \
    \      |\n     |                                   required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0599]: no method named `join` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp5r_pvnpz.rs:10:10\n   |\n10 |         .join(\"\")\n   |\
    \          ^^^^ method not found in `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for idx in 0..a.len() {\n        let mut c = a[idx\
    \ as usize];\n        if b.len() > idx {\n            c ^= b[idx as usize];\n\
    \        }\n        res.append(&mut c).unwrap();\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp0c0w7tbk.rs:8:21\n\
    \  |\n8 |         let mut c = a[idx as usize];\n  |                     ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0c0w7tbk.rs:10:18\n\
    \   |\n10 |             c ^= b[idx as usize];\n   |                  ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp0c0w7tbk.rs:12:13\n   |\n12 |         res.append(&mut\
    \ c).unwrap();\n   |             ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(to_utf8(&a)).xor_utf8(to_utf8(&b)).to_str().unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_utf8` in this scope\n --> /tmp/tmpxkgc4row.rs:6:23\n\
    \  |\n6 |     String::from_utf8(to_utf8(&a)).xor_utf8(to_utf8(&b)).to_str().unwrap()\n\
    \  |                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `to_utf8` in this scope\n --> /tmp/tmpxkgc4row.rs:6:45\n  |\n\
    6 |     String::from_utf8(to_utf8(&a)).xor_utf8(to_utf8(&b)).to_str().unwrap()\n\
    \  |                                             ^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `xor_utf8` found for enum `Result` in the current\
    \ scope\n --> /tmp/tmpxkgc4row.rs:6:36\n  |\n6 |     String::from_utf8(to_utf8(&a)).xor_utf8(to_utf8(&b)).to_str().unwrap()\n\
    \  |                                    ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars()).filter(|(a,\
    \ b)| a == b).map(|(a, b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp4s2nxneq.rs:6:69\n\
    \  |\n6 |     a.chars().zip(b.chars()).filter(|(a, b)| a == b).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    binary_xor_core::<u8,\
    \ _, _, _>(&a, b).0\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_xor_core` in this scope\n -->\
    \ /tmp/tmpgrrr0mw_.rs:6:5\n  |\n6 |     binary_xor_core::<u8, _, _, _>(&a, b).0\n\
    \  |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Binary\
    \ XOR is a commutative operation on strings with only 0 and 1\n    let mut result\
    \ = String::new();\n    for (a, b) in zip(a, b) {\n        if a == '0' && b ==\
    \ '1' {\n            result.push('0');\n        } else if a == '1' && b == '0'\
    \ {\n            result.push('1');\n        } else {\n            result.push('a');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n --> /tmp/tmp0yfrxtl7.rs:8:19\n\
    \  |\n8 |     for (a, b) in zip(a, b) {\n  |                   ^^^ not found in\
    \ this scope\n  |\nhelp: consider importing this function\n  |\n1 | use std::iter::zip;\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.into_bytes();\n    let mut b = b.into_bytes();\n\n    if a.len() !=\
    \ b.len() {\n        panic!(\n            \"String lengths are not equal: a='{}';\
    \ b='{}' \",\n            a.len(),\n            b.len()\n        );\n    }\n\n\
    \    for i in 0..a.len() {\n        a[i] ^= b[i];\n    }\n\n    String::from_utf8(a).into_owned()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `into_owned` found for enum `Result` in the\
    \ current scope\n  --> /tmp/tmpn_fgqeve.rs:21:26\n   |\n21 |     String::from_utf8(a).into_owned()\n\
    \   |                          ^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `into_ok`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().to_owned()\
    \ & b.to_string().to_owned()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp3vov5oqx.rs:6:30\n\
    \  |\n6 |     a.to_string().to_owned() & b.to_string().to_owned()\n  |     ------------------------\
    \ ^ ------------------------ String\n  |     |\n  |     String\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars().zip(b.chars())\n\
    \        .filter(|(a, b)| a == b)\n        .fold(String::new(), |mut a, (b, c)|\
    \ {\n            a.append(b);\n            a\n        });\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpqsyev27_.rs:9:15\n  |\n9 |             a.append(b);\n\
    \  |               ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqsyev27_.rs:5:40\n   |\n5  | fn string_xor(a: String, b:\
    \ String) -> String {\n   |    ----------                          ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n...\n11 |         });\n   |       \
    \    - help: remove this semicolon\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {}{}\", a.codes(), b.codes())\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `codes` found for struct `String` in the\
    \ current scope\n --> /tmp/tmppqdzvumu.rs:6:23\n  |\n6 |     format!(\"{}{}\"\
    , a.codes(), b.codes())\n  |                       ^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `codes` found for struct `String` in the current\
    \ scope\n --> /tmp/tmppqdzvumu.rs:6:34\n  |\n6 |     format!(\"{}{}\", a.codes(),\
    \ b.codes())\n  |                                  ^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for c in a.chars().chain(b.chars().cloned().chain(vec![]))\
    \ {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp5mo1b_55.rs:7:40\n     |\n7    |     for c in a.chars().chain(b.chars().cloned().chain(vec![]))\
    \ {\n     |                                        ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `chain` exists for struct `Cloned<Chars<'_>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp5mo1b_55.rs:7:49\n   |\n7  |       for c in\
    \ a.chars().chain(b.chars().cloned().chain(vec![])) {\n   |                  \
    \                                 ^^^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmp5mo1b_55.rs:8:12\n\
    \  |\n8 |         if *c != 0 {\n  |            ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n --> /tmp/tmp5mo1b_55.rs:9:25\n  |\n9 |            \
    \ result.push(*c);\n  |                         ^^\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0271, E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.as_bytes().iter().chain(b).map(|b|\
    \ b as char).collect::<Vec<_>>().iter().map(|b| b as char).collect::<Vec<_>>().map(|b|\
    \ {\n        match b as char {\n            '1' => '0',\n            '0' => '1',\n\
    \            _ => panic!(\"String contains invalid character\"),\n        }\n\
    \    }).collect::<Vec<_>>().iter().collect::<String>().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n --> /tmp/tmp34l6x173.rs:6:31\n\
    \  |\n6 |     a.as_bytes().iter().chain(b).map(|b| b as char).collect::<Vec<_>>().iter().map(|b|\
    \ b as char).collect::<Vec...\n  |                         ----- ^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n  |                 \
    \        |\n  |                         required by a bound introduced by this\
    \ call\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n\
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0599]: the method `map` exists for struct `std::iter::Chain<std::slice::Iter<'_,\
    \ u8>, String>`, but its trait bounds were not satisfied\n   --> /tmp/tmp34l6x173.rs:6:34\n\
    \    |\n6   |       a.as_bytes().iter().chain(b).map(|b| b as char).collect::<Vec<_>>().iter().map(|b|\
    \ b as char).collect::...\n    |                                    ^^^ method\
    \ cannot be called on `std::iter::Chain<std::slice::Iter<'_, u8>, String>` due\
    \ to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `<String as Iterator>::Item = &u8`\n           \
    \ which is required by `std::iter::Chain<std::slice::Iter<'_, u8>, String>: Iterator`\n\
    \            `String: Iterator`\n            which is required by `std::iter::Chain<std::slice::Iter<'_,\
    \ u8>, String>: Iterator`\n            `std::iter::Chain<std::slice::Iter<'_,\
    \ u8>, String>: Iterator`\n            which is required by `&mut std::iter::Chain<std::slice::Iter<'_,\
    \ u8>, String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp59opfllx.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::with_capacity(a.len());\n    for i in 0..a.len() {\n     \
    \   res.push_str(&if a.chars().nth(i) != b.chars().nth(i) { '1' else '0' });\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `else`\n --> /tmp/tmpr2702bvc.rs:8:69\n  |\n8 |         res.push_str(&if a.chars().nth(i)\
    \ != b.chars().nth(i) { '1' else '0' });\n  |                                \
    \                                     ^^^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    let mut carry = 0;\n\n    for (&x, &y) in zip(a.chars(),\
    \ b.chars()) {\n        res.push((*x ^ y) |+ carry);\n        carry = *x ^ (*y\
    \ as u8);\n    }\n\n    res.push(carry as u8);\n    res\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpyhl0v9me.rs:10:28\n\
    \   |\n10 |         res.push((*x ^ y) |+ carry);\n   |                       \
    \     ^ expected expression\n\nerror[E0425]: cannot find function `zip` in this\
    \ scope\n --> /tmp/tmpyhl0v9me.rs:9:21\n  |\n9 |     for (&x, &y) in zip(a.chars(),\
    \ b.chars()) {\n  |                     ^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this function\n  |\n1 | use std::iter::zip;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyhl0v9me.rs:14:14\n   |\n14 |     res.push(carry\
    \ as u8);\n   |              ^^^^^^^^^^^ expected `char`, found `u8`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = [0u8; a.len()];\n    for i in 0..a.len() {\n        result[i] =\
    \ a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap();\n    }\n    String::from_utf8_lossy(result)\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n --> /tmp/tmpf2r17x52.rs:6:28\n\
    \  |\n5 | fn string_xor(a: String, b: String) -> String {\n  |               -\
    \ this would need to be a `const`\n6 |     let mut result = [0u8; a.len()];\n\
    \  |                            ^\n\nerror[E0369]: no implementation for `char\
    \ ^ char`\n --> /tmp/tmpf2r17x52.rs:8:47\n  |\n8 |         result[i] = a.chars().nth(i).unwrap()\
    \ ^ b.chars().nth(i).unwrap();\n  |                     -------------------------\
    \ ^ ------------------------- char\n  |                     |\n  |           \
    \          char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf2r17x52.rs:10:5\n\
    \   |\n5  | fn string_xor(a: String, b: String) -> String {\n   |            \
    \                            ------ expected `String` because of return type\n\
    ...\n10 |     String::from_utf8_lossy(result)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found enum `Cow`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Cow<'_, str>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0435.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    string_xor(a,\
    \ b).to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "\nthread 'main' has overflowed its stack\nfatal runtime error: stack overflow\n"
  exit_code: -6
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    for i in 0..a.len() {\n        assert!(a[i] == b[i] || a[i] ^\
    \ b[i]); // XOR is commutative\n    }\n    return String::from(b.to_string());\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpa9c9kd8b.rs:8:17\n\
    \  |\n8 |         assert!(a[i] == b[i] || a[i] ^ b[i]); // XOR is commutative\n\
    \  |                 ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpa9c9kd8b.rs:8:25\n\
    \  |\n8 |         assert!(a[i] == b[i] || a[i] ^ b[i]); // XOR is commutative\n\
    \  |                         ^^^^ `String` cannot be indexed by `usize`\n  |\n\
    \  = help: the trait `Index<usize>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmpa9c9kd8b.rs:8:33\n\
    \  |\n8 |         assert!(a[i] == b[i] || a[i] ^ b[i]); // XOR is commutative\n\
    \  |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ I"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"input lengths mismatch\");\n    }\n    let mut\
    \ xor = String::new();\n    for i in 0..a.len() {\n        xor.push_str(&a[i]\
    \ - &b[i]);\n    }\n    xor\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_k3fvs3v.rs:11:23\n\
    \   |\n11 |         xor.push_str(&a[i] - &b[i]);\n   |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_k3fvs3v.rs:11:31\n   |\n11 |         xor.push_str(&a[i] - &b[i]);\n\
    \   |                               ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.bytes().iter().zip(b.bytes()).filter(|(&x,\
    \ &y)| !x.to_ascii_lowercase().is_lowercase()).map(|x| x.to_ascii_lowercase()).collect())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Bytes`\
    \ in the current scope\n --> /tmp/tmpa001sayv.rs:6:33\n  |\n6 |     String::from_utf8(a.bytes().iter().zip(b.bytes()).filter(|(&x,\
    \ &y)| !x.to_ascii_lowercase().is_lowercase())...\n  |                       \
    \          ^^^^ method not found in `std::str::Bytes<'_>`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpa001sayv.rs:6:5\n  |\n5 | fn string_xor(a: String, b: String)\
    \ -> String {\n  |                                        ------ expected `String`\
    \ because of return type\n6 |     String::from_utf8(a.bytes().iter().zip(b.bytes()).filter(|(&x,\
    \ &y)| !x.to_ascii_lowercase().is_lowercase()).map(|x| x.to_ascii_lowercase()).collect())\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Result`\n  |\n  = note: expected struct\
    \ `String`\n               found enum `Result<String, FromUtf8Error>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
