name: HumanEval_28_concatenate
language: rust
results:
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut acc, s|\
    \ acc + s).to_string()\n}\n\nfn main() {\n    let candidate = concatenate;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return \"\";\n\
    \    }\n\n    if strings.len() == 1 {\n        return strings[0].clone();\n  \
    \  }\n\n    let mut s = String::new();\n    for s in strings {\n        s.append(&s);\n\
    \    }\n\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpt0uv2z2m.rs:8:16\n  |\n6 |\
    \ fn concatenate(strings: Vec<String>) -> String {\n  |                      \
    \                   ------ expected `String` because of return type\n7 |     if\
    \ strings.is_empty() {\n8 |         return \"\";\n  |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                |\n  |   \
    \             expected struct `String`, found `&str`\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmpt0uv2z2m.rs:17:11\n\
    \   |\n17 |         s.append(&s);\n   |           ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut buffer = String::new();\n    strings.iter().for_each(|s|\
    \ buffer.push_str(s));\n    buffer\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    strings.iter().for_each(|string|\
    \ result.push_str(string));\n    result\n}\n\nfn main() {\n    let candidate =\
    \ concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut buffer = String::new();\n    for s in\
    \ strings {\n        buffer.push_str(&s);\n    }\n    buffer\n}\n\nfn main() {\n\
    \    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut result,\
    \ string| {\n        result.push_str(string);\n        result\n    })\n}\n\nfn\
    \ main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2xcb7nnn.rs:8:25\n  |\n8 |\
    \         result.push_str(string);\n  |                         ^^^^^^\n  |  \
    \                       |\n  |                         expected `&str`, found\
    \ struct `String`\n  |                         help: consider borrowing here:\
    \ `&string`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut acc,\
    \ s| acc + &s).to_string()\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        \"\".to_string()\n\
    \    } else {\n        let mut iter = strings.iter();\n        iter.next().unwrap().to_string()\n\
    \            + &mut iter.collect::<Vec<_>>()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpswjb_myt.rs:12:15\n   |\n\
    12 |             + &mut iter.collect::<Vec<_>>()\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `Vec`\n   |\n   = note:      expected reference\
    \ `&str`\n           found mutable reference `&mut Vec<&String>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter()\n        .map(|s| s.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(String::from).collect::<String>().into()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    // Empty string concatenated with anything\n \
    \   if strings.is_empty() {\n        return String::new();\n    }\n\n    // First\
    \ item is the empty string\n    let first = strings.remove(0);\n    if strings.is_empty()\
    \ {\n        return first;\n    }\n\n    // Construct the rest of the string by\
    \ concatenating the remaining strings\n    // and returning the final string\n\
    \    let mut result = first;\n    for (i, s) in strings.iter().enumerate() {\n\
    \        result = format!(\"{}{}\", result, s);\n        if i == strings.len()\
    \ - 1 {\n            return result;\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptev356zt.rs:21:5\n   |\n\
    6  |   fn concatenate(strings: Vec<String>) -> String {\n   |                \
    \                           ------ expected `String` because of return type\n\
    ...\n21 | /     for (i, s) in strings.iter().enumerate() {\n22 | |         result\
    \ = format!(\"{}{}\", result, s);\n23 | |         if i == strings.len() - 1 {\n\
    24 | |             return result;\n25 | |         }\n26 | |     }\n   | |_____^\
    \ expected struct `String`, found `()`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    strings.iter().for_each(|s|\
    \ result.push_str(s).unwrap());\n    result\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for unit type `()` in the\
    \ current scope\n --> /tmp/tmp42wjat2k.rs:8:52\n  |\n8 |     strings.iter().for_each(|s|\
    \ result.push_str(s).unwrap());\n  |                                         \
    \           ^^^^^^ method not found in `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings\n        .into_iter()\n        .map(|s|\
    \ s.to_string())\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut string = \"\";\n    for s in strings {\n\
    \        string += s;\n    }\n    string\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n --> /tmp/tmpd7z1v6o7.rs:9:9\n  |\n9 |         string += s;\n  |   \
    \      ------^--^^\n  |         |      |\n  |         |      `+` cannot be used\
    \ to concatenate a `&str` with a `String`\n  |         cannot use `+=` on type\
    \ `&str`\n  |\n  = note: string concatenation requires an owned `String` on the\
    \ left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd7z1v6o7.rs:11:5\n   |\n\
    6  | fn concatenate(strings: Vec<String>) -> String {\n   |                  \
    \                       ------ expected `String` because of return type\n...\n\
    11 |     string\n   |     ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"x y z\"`,\n right: `\"xyz\"`', /tmp/tmpg08qgba4.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut s,\
    \ s| {\n        s.push_str(&s);\n        s.push_str(&*s);\n        s\n    })\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n --> /tmp/tmppo6_apkl.rs:7:53\n  |\n7 |     strings.into_iter().fold(String::new(),\
    \ |mut s, s| {\n  |                                                     ^ used\
    \ as parameter more than once\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0415`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut str, s|\
    \ str.append(s));\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpbsv31a68.rs:7:57\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut str, s| str.append(s));\n  |                                          \
    \               ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpbsv31a68.rs:6:41\n  |\n6 | fn concatenate(strings: Vec<String>)\
    \ -> String {\n  |    -----------                          ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n7 |     strings.iter().fold(String::new(), |mut\
    \ str, s| str.append(s));\n  |                                               \
    \                    - help: remove this semicolon\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings\n        .iter()\n        .map(|s| s.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for s in strings\
    \ {\n        s += s.to_string();\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8nmhwe2u.rs:9:14\n  |\n9 |\
    \         s += s.to_string();\n  |              ^^^^^^^^^^^^^\n  |           \
    \   |\n  |              expected `&str`, found struct `String`\n  |          \
    \    help: consider borrowing here: `&s.to_string()`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        String::new()\n\
    \    } else {\n        strings.into_iter().fold(String::new(), |mut s, string|\
    \ s.push_str(string)).collect()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkmx7t79u.rs:10:76\n   |\n\
    10 |         strings.into_iter().fold(String::new(), |mut s, string| s.push_str(string)).collect()\n\
    \   |                                                                        \
    \    ^^^^^^\n   |                                                            \
    \                |\n   |                                                     \
    \                       expected `&str`, found struct `String`\n   |         \
    \                                                                   help: consider\
    \ borrowing here: `&string`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkmx7t79u.rs:10:65\n\
    \   |\n6  | fn concatenate(strings: Vec<String>) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n10 |         strings.into_iter().fold(String::new(), |mut s, string| s.push_str(string)).collect()\n\
    \   |                                                                 ^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpkmx7t79u.rs:10:67\n   |\n10 |         strings.into_iter().fold(String::new(),\
    \ |mut s, string| s.push_str(string)).collect()\n   |                        \
    \                                         - ^^^^^^^^ this call modifies `s` in-place\n\
    \   |                                                                 |\n   |\
    \                                                                 you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror[E0599]: `String` is not an iterator\n\
    \   --> /tmp/tmpkmx7t79u.rs:10:85\n    |\n10  |           strings.into_iter().fold(String::new(),\
    \ |mut s, string| s.push_str(string)).collect()\n    |                       \
    \                                                                ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \        "
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut acc, s|\
    \ {\n        acc.push_str(&s);\n        acc\n    })\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(|s| s.to_string()).collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::with_capacity(strings.len());\n\
    \    for string in strings {\n        result += string;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgbz780xr.rs:9:19\n  |\n9 |\
    \         result += string;\n  |                   ^^^^^^\n  |               \
    \    |\n  |                   expected `&str`, found struct `String`\n  |    \
    \               help: consider borrowing here: `&string`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().reduce(|s0, s1| s0.concat(s1)).collect()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpcvv35pyr.rs:7:44\n  |\n7 |     strings.into_iter().reduce(|s0,\
    \ s1| s0.concat(s1)).collect()\n  |                                          \
    \  ^^^^^^ method not found in `String`\n\nerror[E0599]: `Option<String>` is not\
    \ an iterator\n   --> /tmp/tmpcvv35pyr.rs:7:56\n    |\n7   |       strings.into_iter().reduce(|s0,\
    \ s1| s0.concat(s1)).collect()\n    |                                        \
    \                  ^^^^^^^ `Option<String>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<String>:\
    \ Iterator`\n            which is required by `&mut Option<String>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter()\n        .map(|s| s.to_string())\n\
    \        .collect::<Vec<_>>()\n        .join(\",\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"x,y,z\"`,\n right: `\"xyz\"`', /tmp/tmpo9x1lhgn.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut s,\
    \ s| s + s)\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n --> /tmp/tmpoofhu989.rs:7:53\n  |\n7 |     strings.into_iter().fold(String::new(),\
    \ |mut s, s| s + s)\n  |                                                     ^\
    \ used as parameter more than once\n\nerror[E0308]: mismatched types\n --> /tmp/tmpoofhu989.rs:7:60\n\
    \  |\n7 |     strings.into_iter().fold(String::new(), |mut s, s| s + s)\n  | \
    \                                                           ^\n  |           \
    \                                                 |\n  |                     \
    \                                       expected `&str`, found struct `String`\n\
    \  |                                                            help: consider\
    \ borrowing here: `&s`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0415.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for s in\
    \ strings.iter() {\n        result = result.push_str(s);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnr29h9qm.rs:9:18\n  |\n7 |\
    \     let mut result = String::new();\n  |                      -------------\
    \ expected due to this value\n8 |     for s in strings.iter() {\n9 |         result\
    \ = result.push_str(s);\n  |                  ^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n  |\nnote: method `push_str` modifies its receiver in-place\n\
    \ --> /tmp/tmpnr29h9qm.rs:9:25\n  |\n9 |         result = result.push_str(s);\n\
    \  |                  ------ ^^^^^^^^ this call modifies `result` in-place\n \
    \ |                  |\n  |                  you probably want to use this value\
    \ after calling the method...\n  = note: ...instead of the `()` output of method\
    \ `push_str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut s = String::new();\n    for s in strings {\n        s +=\
    \ s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0u47ldpz.rs:13:14\n   |\n\
    13 |         s += s;\n   |              ^\n   |              |\n   |         \
    \     expected `&str`, found struct `String`\n   |              help: consider\
    \ borrowing here: `&s`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut acc, x|\
    \ acc + &x.to_string()).to_string()\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for s in strings.iter()\
    \ {\n        s += &*s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&String`\n --> /tmp/tmp0qtrctvq.rs:9:9\n  |\n9 |         s += &*s;\n  |   \
    \      -^^^^^^^\n  |         |\n  |         cannot use `+=` on type `&String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    return strings.join(\"\");\n}\n\nfn main() {\n\
    \    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut acc,\
    \ s| {\n        acc.push_str(s);\n        acc\n    })\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptrp53phx.rs:8:22\n  |\n8 |\
    \         acc.push_str(s);\n  |                      ^\n  |                  \
    \    |\n  |                      expected `&str`, found struct `String`\n  | \
    \                     help: consider borrowing here: `&s`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n    strings.iter().fold(String::new(), |mut s, x| s.push_str(&*x).unwrap());\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpwea0cw5g.rs:10:67\n   |\n10 |     strings.iter().fold(String::new(),\
    \ |mut s, x| s.push_str(&*x).unwrap());\n   |                                \
    \                                   ^^^^^^ method not found in `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwea0cw5g.rs:6:41\n   |\n6  | fn concatenate(strings:\
    \ Vec<String>) -> String {\n   |    -----------                          ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n10 |     strings.iter().fold(String::new(),\
    \ |mut s, x| s.push_str(&*x).unwrap());\n   |                                \
    \                                            - help: remove this semicolon\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut res = String::with_capacity(strings.len()\
    \ * 5);\n    for s in strings.iter() {\n        res.extend(&s);\n        res.extend(&'\
    \ ');\n    }\n    res.trim_end().to_string()\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&String` is not an iterator\n   --> /tmp/tmp2syh68d0.rs:9:20\n\
    \    |\n9   |         res.extend(&s);\n    |             ------ ^^ `&&String`\
    \ is not an iterator\n    |             |\n    |             required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&&String`\nnote: required by a bound in `extend`\n\n\
    error[E0277]: `&char` is not an iterator\n   --> /tmp/tmp2syh68d0.rs:10:20\n \
    \   |\n10  |         res.extend(&' ');\n    |             ------ ^^^^ `&char`\
    \ is not an iterator\n    |             |\n    |             required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&char`\n    = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&char`\nnote: required by a bound in `extend`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut acc,\
    \ s| acc + s)\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm55x15vj.rs:7:64\n  |\n7 |\
    \     strings.into_iter().fold(String::new(), |mut acc, s| acc + s)\n  |     \
    \                                                           ^\n  |           \
    \                                                     |\n  |                 \
    \                                               expected `&str`, found struct\
    \ `String`\n  |                                                              \
    \  help: consider borrowing here: `&s`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        \"\".to_string()\n\
    \    } else {\n        strings.join(\"\").to_string()\n    }\n}\n\nfn main() {\n\
    \    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut res = String::new();\n    for &s in strings\
    \ {\n        res.push_str(s);\n    }\n    res.into_boxed_str()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbk5ki1cz.rs:8:9\n  |\n8 |\
    \     for &s in strings {\n  |         ^^    ------- this expression has type\
    \ `Option<String>`\n  |         |\n  |         expected struct `String`, found\
    \ reference\n  |         help: you can probably remove the explicit borrow: `s`\n\
    \  |\n  = note: expected struct `String`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbk5ki1cz.rs:11:5\n   |\n6  | fn concatenate(strings:\
    \ Vec<String>) -> String {\n   |                                         ------\
    \ expected `String` because of return type\n...\n11 |     res.into_boxed_str()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found struct `Box`\n   |\n   =\
    \ note: expected struct `String`\n              found struct `Box<str>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::with_capacity(strings.len());\n\
    \    for s in strings {\n        s += s;\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptbsez0in.rs:9:14\n  |\n9 |\
    \         s += s;\n  |              ^\n  |              |\n  |              expected\
    \ `&str`, found struct `String`\n  |              help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |result,\
    \ string| {\n        result + string;\n    })\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbk8obrq0.rs:8:18\n  |\n8 |\
    \         result + string;\n  |                  ^^^^^^\n  |                 \
    \ |\n  |                  expected `&str`, found struct `String`\n  |        \
    \          help: consider borrowing here: `&string`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpbk8obrq0.rs:7:62\n  |\n7 |       strings.into_iter().fold(String::new(),\
    \ |result, string| {\n  |  ______________________________________________________________^\n\
    8 | |         result + string;\n  | |                        - help: remove this\
    \ semicolon\n9 | |     })\n  | |_____^ expected struct `String`, found `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(|s| s.to_string()).collect::<String>().into()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut s, s|\
    \ s.push_str(s));\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n --> /tmp/tmp4x0att5o.rs:7:48\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s.push_str(s));\n  |                                            \
    \    ^ used as parameter more than once\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp4x0att5o.rs:7:51\n  |\n7 |     strings.iter().fold(String::new(), |mut\
    \ s, s| s.push_str(s));\n  |                                                 \
    \  ^^^^^^^^^^^^^ expected struct `String`, found `()`\n  |\nnote: method `push_str`\
    \ modifies its receiver in-place\n --> /tmp/tmp4x0att5o.rs:7:53\n  |\n7 |    \
    \ strings.iter().fold(String::new(), |mut s, s| s.push_str(s));\n  |         \
    \                                          - ^^^^^^^^ this call modifies `s` in-place\n\
    \  |                                                   |\n  |                \
    \                                   you probably want to use this value after\
    \ calling the method...\n  = note: ...instead of the `()` output of method `push_str`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp4x0att5o.rs:6:41\n  |\n6 | fn concatenate(strings:\
    \ Vec<String>) -> String {\n  |    -----------                          ^^^^^^\
    \ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s.push_str(s));\n  |                                            \
    \                     - help: remove this semicolon\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0415.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut buffer = String::new();\n    for string\
    \ in strings.iter() {\n        buffer.push_str(string);\n    }\n    buffer\n}\n\
    \nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for (i, str) in\
    \ strings.into_iter().enumerate() {\n        if i != 0 {\n            s.push('\
    \ ');\n        }\n        s.push(*str);\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjiyfq8c8.rs:12:16\n   |\n\
    12 |         s.push(*str);\n   |                ^^^^ expected `char`, found `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for string\
    \ in strings {\n        result += string;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq04_by2p.rs:9:19\n  |\n9 |\
    \         result += string;\n  |                   ^^^^^^\n  |               \
    \    |\n  |                   expected `&str`, found struct `String`\n  |    \
    \               help: consider borrowing here: `&string`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for s in strings\
    \ {\n        s += s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0co1hbg2.rs:9:14\n  |\n9 |\
    \         s += s;\n  |              ^\n  |              |\n  |              expected\
    \ `&str`, found struct `String`\n  |              help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut res, s|\
    \ res.push_str(s));\n    return res;\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `res` in this scope\n --> /tmp/tmp7pohd2hg.rs:8:12\n\
    \  |\n8 |     return res;\n  |            ^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp7pohd2hg.rs:7:53\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut res, s| res.push_str(s));\n  |                                        \
    \             ^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n  |\nnote:\
    \ method `push_str` modifies its receiver in-place\n --> /tmp/tmp7pohd2hg.rs:7:57\n\
    \  |\n7 |     strings.iter().fold(String::new(), |mut res, s| res.push_str(s));\n\
    \  |                                                     --- ^^^^^^^^ this call\
    \ modifies `res` in-place\n  |                                               \
    \      |\n  |                                                     you probably\
    \ want to use this value after calling the method...\n  = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(String::from).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n\n    for s in\
    \ strings.into_iter() {\n        result += s;\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppctx8tg3.rs:10:19\n   |\n\
    10 |         result += s;\n   |                   ^\n   |                   |\n\
    \   |                   expected `&str`, found struct `String`\n   |         \
    \          help: consider borrowing here: `&s`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut s,\
    \ s| s + s)\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n --> /tmp/tmplkbvhlxx.rs:7:53\n  |\n7 |     strings.into_iter().fold(String::new(),\
    \ |mut s, s| s + s)\n  |                                                     ^\
    \ used as parameter more than once\n\nerror[E0308]: mismatched types\n --> /tmp/tmplkbvhlxx.rs:7:60\n\
    \  |\n7 |     strings.into_iter().fold(String::new(), |mut s, s| s + s)\n  | \
    \                                                           ^\n  |           \
    \                                                 |\n  |                     \
    \                                       expected `&str`, found struct `String`\n\
    \  |                                                            help: consider\
    \ borrowing here: `&s`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0415.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut res = String::new();\n    for (i, s) in\
    \ strings.into_iter().enumerate() {\n        if i != 0 {\n            res.push_str(&mut\
    \ \" | \"?);\n        }\n        res.push_str(&s);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the `?` operator can only be applied to values that implement\
    \ `Try`\n  --> /tmp/tmpzssa3f13.rs:10:31\n   |\n10 |             res.push_str(&mut\
    \ \" | \"?);\n   |                               ^^^^^^ the `?` operator cannot\
    \ be applied to type `&str`\n   |\n   = help: the trait `Try` is not implemented\
    \ for `&str`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpzssa3f13.rs:10:36\n   |\n6  | / fn concatenate(strings: Vec<String>)\
    \ -> String {\n7  | |     let mut res = String::new();\n8  | |     for (i, s)\
    \ in strings.into_iter().enumerate() {\n9  | |         if i != 0 {\n10 | |   \
    \          res.push_str(&mut \" | \"?);\n   | |                              \
    \      ^ cannot use the `?` operator in a function that returns `String`\n...\
    \  |\n14 | |     res\n15 | | }\n   | |_- this function should return `Result`\
    \ or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>` is not\
    \ implemented for `String`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpzssa3f13.rs:10:31\n   |\n\
    10 |             res.push_str(&mut \" | \"?);\n   |                          \
    \     ^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `str`\n   = note: all local variables must have\
    \ a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmpzssa3f13.rs:10:36\n   |\n10 |             res.push_str(&mut\
    \ \" | \"?);\n   |                                    ^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Break`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for s in strings\
    \ {\n        s += s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_qayj5qd.rs:9:14\n  |\n9 |\
    \         s += s;\n  |              ^\n  |              |\n  |              expected\
    \ `&str`, found struct `String`\n  |              help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings\n        .iter()\n        .map(|s| s.to_string())\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().collect()\n}\n\nfn main() {\n \
    \   let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmp_bapx28l.rs:7:20\n     |\n\
    7    |     strings.iter().collect()\n     |                    ^^^^^^^ value of\
    \ type `String` cannot be built from `std::iter::Iterator<Item=&String>`\n   \
    \  |\n     = help: the trait `FromIterator<&String>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        \"\".to_string()\n\
    \    } else {\n        strings.iter().reduce(|mut acc, x| acc + x)\n    }\n}\n\
    \nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&String` to `&String`\n  --> /tmp/tmpqtwokit8.rs:10:48\n\
    \   |\n10 |         strings.iter().reduce(|mut acc, x| acc + x)\n   |        \
    \                                    --- ^ - &String\n   |                   \
    \                         |   |\n   |                                        \
    \    |   `+` cannot be used to concatenate two `&str` strings\n   |          \
    \                                  &String\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: create an owned `String` from\
    \ a string reference\n   |\n10 |         strings.iter().reduce(|mut acc, x| acc.to_owned()\
    \ + x)\n   |                                               +++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqtwokit8.rs:10:9\n   |\n6  | fn concatenate(strings:\
    \ Vec<String>) -> String {\n   |                                         ------\
    \ expected `String` because of return type\n...\n10 |         strings.iter().reduce(|mut\
    \ acc, x| acc + x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut buffer = String::new();\n\n    for s in\
    \ strings {\n        buffer.push_str(s);\n    }\n\n    buffer\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp584y4c67.rs:10:25\n   |\n\
    10 |         buffer.push_str(s);\n   |                         ^\n   |       \
    \                  |\n   |                         expected `&str`, found struct\
    \ `String`\n   |                         help: consider borrowing here: `&s`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut result = String::new();\n    for s in strings {\n      \
    \  result = result.push_str(s);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphcipw5x9.rs:13:34\n   |\n\
    13 |         result = result.push_str(s);\n   |                              \
    \    ^\n   |                                  |\n   |                        \
    \          expected `&str`, found struct `String`\n   |                      \
    \            help: consider borrowing here: `&s`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphcipw5x9.rs:13:18\n   |\n11 |     let mut result = String::new();\n\
    \   |                      ------------- expected due to this value\n12 |    \
    \ for s in strings {\n13 |         result = result.push_str(s);\n   |        \
    \          ^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n   |\nnote:\
    \ method `push_str` modifies its receiver in-place\n  --> /tmp/tmphcipw5x9.rs:13:25\n\
    \   |\n13 |         result = result.push_str(s);\n   |                  ------\
    \ ^^^^^^^^ this call modifies `result` in-place\n   |                  |\n   |\
    \                  you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::with_capacity(strings.len()\
    \ * 2);\n    for s in strings.iter() {\n        result += s;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(|s| s.to_string()).collect::<String>().into()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut s, s|\
    \ s + s)\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n --> /tmp/tmp1kq7hn6i.rs:7:48\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s + s)\n  |                                                ^ used\
    \ as parameter more than once\n\nerror[E0369]: cannot add `&String` to `&String`\n\
    \ --> /tmp/tmp1kq7hn6i.rs:7:53\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s + s)\n  |                                                   - ^\
    \ - &String\n  |                                                   | |\n  |  \
    \                                                 | `+` cannot be used to concatenate\
    \ two `&str` strings\n  |                                                   &String\n\
    \  |\n  = note: string concatenation requires an owned `String` on the left\n\
    help: create an owned `String` from a string reference\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s.to_owned() + s)\n  |                                          \
    \          +++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0415.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for s in\
    \ strings.iter() {\n        result.push_str(s);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().map(String::join).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `join` found for struct\
    \ `String` in the current scope\n --> /tmp/tmpwftfm6p6.rs:7:37\n  |\n7 |     strings.into_iter().map(String::join).collect::<String>()\n\
    \  |                                     ^^^^ function or associated item not\
    \ found in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut res = String::new();\n    for s in strings\
    \ {\n        res.push_str(&s);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"x y z\"`,\n right: `\"xyz\"`', /tmp/tmpiwikshr5.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut string = String::new();\n    for s in\
    \ strings {\n        string.push_str(&s);\n    }\n    string\n}\n\nfn main() {\n\
    \    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut a,\
    \ s| {\n        a.push_str(s);\n        a\n    })\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy0sh8fj5.rs:8:20\n  |\n8 |\
    \         a.push_str(s);\n  |                    ^\n  |                    |\n\
    \  |                    expected `&str`, found struct `String`\n  |          \
    \          help: consider borrowing here: `&s`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    strings.iter().for_each(|s|\
    \ result.push_str(s));\n    result\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut buffer = String::new();\n    buffer.push_str(strings.pop().unwrap());\n\
    \    for string in strings {\n        buffer.push_str(&*string);\n    }\n\n  \
    \  buffer\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyivde48m.rs:12:21\n   |\n\
    12 |     buffer.push_str(strings.pop().unwrap());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&strings.pop().unwrap()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut acc, s|\
    \ {\n        acc + s.to_string();\n    })\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyem264_g.rs:8:15\n  |\n8 |\
    \         acc + s.to_string();\n  |               ^^^^^^^^^^^^^\n  |         \
    \      |\n  |               expected `&str`, found struct `String`\n  |      \
    \         help: consider borrowing here: `&s.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpyem264_g.rs:7:53\n  |\n7 |       strings.iter().fold(String::new(),\
    \ |mut acc, s| {\n  |  _____________________________________________________^\n\
    8 | |         acc + s.to_string();\n  | |                            - help: remove\
    \ this semicolon\n9 | |     })\n  | |_____^ expected struct `String`, found `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n    strings.iter()\n        .map(|s| s.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings\n        .iter()\n        .fold(String::new(),\
    \ |mut ss, s| ss.push_str(s));\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprlyfk9db.rs:9:42\n  |\n9 |\
    \         .fold(String::new(), |mut ss, s| ss.push_str(s));\n  |             \
    \                             ^^^^^^^^^^^^^^ expected struct `String`, found `()`\n\
    \  |\nnote: method `push_str` modifies its receiver in-place\n --> /tmp/tmprlyfk9db.rs:9:45\n\
    \  |\n9 |         .fold(String::new(), |mut ss, s| ss.push_str(s));\n  |     \
    \                                     -- ^^^^^^^^ this call modifies `ss` in-place\n\
    \  |                                          |\n  |                         \
    \                 you probably want to use this value after calling the method...\n\
    \  = note: ...instead of the `()` output of method `push_str`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmprlyfk9db.rs:6:41\n  |\n6 | fn concatenate(strings:\
    \ Vec<String>) -> String {\n  |    -----------                          ^^^^^^\
    \ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n...\n9 |         .fold(String::new(),\
    \ |mut ss, s| ss.push_str(s));\n  |                                          \
    \               - help: remove this semicolon\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return \"\";\n\
    \    }\n    strings.iter()\n        .fold(String::new(), |mut acc, s| {\n    \
    \        acc + &s + &s;\n        })\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfhh2jc26.rs:8:16\n  |\n6 |\
    \ fn concatenate(strings: Vec<String>) -> String {\n  |                      \
    \                   ------ expected `String` because of return type\n7 |     if\
    \ strings.is_empty() {\n8 |         return \"\";\n  |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                |\n  |   \
    \             expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfhh2jc26.rs:11:43\n   |\n11 |           .fold(String::new(),\
    \ |mut acc, s| {\n   |  ___________________________________________^\n12 | | \
    \            acc + &s + &s;\n   | |                          - help: remove this\
    \ semicolon\n13 | |         })\n   | |_________^ expected struct `String`, found\
    \ `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpnetlw46g.rs:7:20\n     |\n\
    7    |     strings.iter().collect::<String>().to_string()\n     |            \
    \        ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter()\n        .map(|s| s.to_string())\n\
    \        .collect::<Vec<_>>()\n        .join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for s in strings\
    \ {\n        s += s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmph9q8f8y9.rs:9:14\n  |\n9 |\
    \         s += s;\n  |              ^\n  |              |\n  |              expected\
    \ `&str`, found struct `String`\n  |              help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n    let mut s = String::new();\n    for s in strings.iter() {\n      \
    \  s += s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&String`\n  --> /tmp/tmpjuw1ew7p.rs:12:9\n   |\n12 |         s += s;\n   |\
    \         -^^^^^\n   |         |\n   |         cannot use `+=` on type `&String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    return strings.iter().collect::<String>(String::new()).to_string();\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpn6zwvhwj.rs:7:27\n     |\n\
    7    |     return strings.iter().collect::<String>(String::new()).to_string();\n\
    \     |                           ^^^^^^^ value of type `String` cannot be built\
    \ from `std::iter::Iterator<Item=&String>`\n     |\n     = help: the trait `FromIterator<&String>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpn6zwvhwj.rs:7:27\n     |\n7   \
    \ |     return strings.iter().collect::<String>(String::new()).to_string();\n\
    \     |                           ^^^^^^^           ------------- supplied 1 argument\n\
    \     |                           |\n     |                           expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().collect::<Vec<_>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings\n        .iter()\n        .fold(String::new(),\
    \ |mut builder, mut string| {\n            builder.push_str(string);\n       \
    \     builder\n        })\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n    strings.iter()\n        .fold(String::new(), |mut acc, s| acc.push_str(s));\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxm6k496o.rs:11:43\n   |\n\
    11 |         .fold(String::new(), |mut acc, s| acc.push_str(s));\n   |       \
    \                                    ^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpxm6k496o.rs:11:47\n   |\n11 |         .fold(String::new(), |mut\
    \ acc, s| acc.push_str(s));\n   |                                           ---\
    \ ^^^^^^^^ this call modifies `acc` in-place\n   |                           \
    \                |\n   |                                           you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxm6k496o.rs:6:41\n   |\n6  | fn concatenate(strings: Vec<String>) ->\
    \ String {\n   |    -----------                          ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n...\n11 |         .fold(String::new(), |mut\
    \ acc, s| acc.push_str(s));\n   |                                            \
    \               - help: remove this semicolon\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n\n    strings.into_iter().fold(String::new(), |mut s, s| s + &s)\n}\n\n\
    fn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmpsnk8vzep.rs:11:53\n   |\n11 |     strings.into_iter().fold(String::new(),\
    \ |mut s, s| s + &s)\n   |                                                   \
    \  ^ used as parameter more than once\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0415`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for s in strings\
    \ {\n        s += s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplqt8m8at.rs:9:14\n  |\n9 |\
    \         s += s;\n  |              ^\n  |              |\n  |              expected\
    \ `&str`, found struct `String`\n  |              help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings\n        .iter()\n        .cloned()\n\
    \        .map(|s| s.to_string())\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for s in strings\
    \ {\n        s += s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0j2imng5.rs:9:14\n  |\n9 |\
    \         s += s;\n  |              ^\n  |              |\n  |              expected\
    \ `&str`, found struct `String`\n  |              help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter()\n        .fold(String::new(), |mut\
    \ acc, s| acc + s.to_string())\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpryyiwj2v.rs:8:49\n  |\n8 |\
    \         .fold(String::new(), |mut acc, s| acc + s.to_string())\n  |        \
    \                                         ^^^^^^^^^^^^^\n  |                 \
    \                                |\n  |                                      \
    \           expected `&str`, found struct `String`\n  |                      \
    \                           help: consider borrowing here: `&s.to_string()`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut buffer = String::with_capacity(strings.len());\n\
    \    for s in strings {\n        buffer.push_str(&s);\n    }\n    buffer\n}\n\n\
    fn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut string = String::new();\n    for s in\
    \ strings.iter() {\n        string.push_str(s);\n    }\n    string\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut accum,\
    \ s| accum += s).to_string()\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoxg303t_.rs:7:55\n  |\n6 |\
    \ fn concatenate(strings: Vec<String>) -> String {\n  |                      \
    \                   ------ expected `String` because of return type\n7 |     strings.iter().fold(String::new(),\
    \ |mut accum, s| accum += s).to_string()\n  |                                \
    \                       ^^^^^^^^^^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n    let mut buffer = String::new();\n    for s in strings {\n        buffer.push_str(s);\n\
    \    }\n    buffer\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ihsv44i.rs:12:25\n   |\n\
    12 |         buffer.push_str(s);\n   |                         ^\n   |       \
    \                  |\n   |                         expected `&str`, found struct\
    \ `String`\n   |                         help: consider borrowing here: `&s`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return \"\".to_owned();\n\
    \    }\n    strings.iter().fold(\"\".to_owned(), |mut s1, s2| s1 + s2.to_owned())\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl_b6sscf.rs:10:58\n   |\n\
    10 |     strings.iter().fold(\"\".to_owned(), |mut s1, s2| s1 + s2.to_owned())\n\
    \   |                                                          ^^^^^^^^^^^^^\n\
    \   |                                                          |\n   |       \
    \                                                   expected `&str`, found struct\
    \ `String`\n   |                                                          help:\
    \ consider borrowing here: `&s2.to_owned()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        \"\".to_string()\n\
    \    } else {\n        strings[0] + strings[1..].join(\"\").to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl2yre79w.rs:10:22\n   |\n\
    10 |         strings[0] + strings[1..].join(\"\").to_string()\n   |          \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                      |\n\
    \   |                      expected `&str`, found struct `String`\n   |      \
    \                help: consider borrowing here: `&strings[1..].join(\"\").to_string()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut buffer = String::new();\n    strings.iter().for_each(|string|\
    \ buffer.push_str(&string));\n    buffer\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut s, s|\
    \ s + s)\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n --> /tmp/tmps9hs289i.rs:7:48\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s + s)\n  |                                                ^ used\
    \ as parameter more than once\n\nerror[E0369]: cannot add `&String` to `&String`\n\
    \ --> /tmp/tmps9hs289i.rs:7:53\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s + s)\n  |                                                   - ^\
    \ - &String\n  |                                                   | |\n  |  \
    \                                                 | `+` cannot be used to concatenate\
    \ two `&str` strings\n  |                                                   &String\n\
    \  |\n  = note: string concatenation requires an owned `String` on the left\n\
    help: create an owned `String` from a string reference\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s.to_owned() + s)\n  |                                          \
    \          +++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0415.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        String::new()\n\
    \    } else {\n        strings.iter().map(|s| s.to_string()).collect::<String>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(\"\".to_string(), |mut s,\
    \ str| s + &str)\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut string,\
    \ ref str| {\n        string.push_str(str);\n        string\n    });\n}\n\nfn\
    \ main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb98r8vkx.rs:6:41\n   |\n\
    6  | fn concatenate(strings: Vec<String>) -> String {\n   |    -----------   \
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n10 |     });\n   |       - help: remove this semicolon\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::with_capacity(strings.len());\n\
    \    for s in strings {\n        result.push_str(s);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxgsz2vyx.rs:9:25\n  |\n9 |\
    \         result.push_str(s);\n  |                         ^\n  |            \
    \             |\n  |                         expected `&str`, found struct `String`\n\
    \  |                         help: consider borrowing here: `&s`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for &s in\
    \ strings {\n        result = result.push_str(s);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpywoee8ad.rs:8:9\n  |\n8 |\
    \     for &s in strings {\n  |         ^^    ------- this expression has type\
    \ `Option<String>`\n  |         |\n  |         expected struct `String`, found\
    \ reference\n  |         help: you can probably remove the explicit borrow: `s`\n\
    \  |\n  = note: expected struct `String`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpywoee8ad.rs:9:18\n  |\n7 |     let mut result\
    \ = String::new();\n  |                      ------------- expected due to this\
    \ value\n8 |     for &s in strings {\n9 |         result = result.push_str(s);\n\
    \  |                  ^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n\
    \  |\nnote: method `push_str` modifies its receiver in-place\n --> /tmp/tmpywoee8ad.rs:9:25\n\
    \  |\n9 |         result = result.push_str(s);\n  |                  ------ ^^^^^^^^\
    \ this call modifies `result` in-place\n  |                  |\n  |          \
    \        you probably want to use this value after calling the method...\n  =\
    \ note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().cloned().collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(String::from).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut acc, str|\
    \ {\n        acc.push_str(str);\n        acc\n    })\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        \"\".to_string()\n\
    \    } else {\n        strings.into_iter().fold(\"\".to_string(), |mut acc, s|\
    \ acc + s)\n    }\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp00ug5bk0.rs:10:69\n   |\n\
    10 |         strings.into_iter().fold(\"\".to_string(), |mut acc, s| acc + s)\n\
    \   |                                                                     ^\n\
    \   |                                                                     |\n\
    \   |                                                                     expected\
    \ `&str`, found struct `String`\n   |                                        \
    \                             help: consider borrowing here: `&s`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(|s| s.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().collect()\n        .unwrap_or_else(||\
    \ String::new())\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpyaxewhk9.rs:7:20\n\
    \  |\n7 |     strings.iter().collect()\n  |                    ^^^^^^^ cannot\
    \ infer type for type parameter `B` declared on the associated function `collect`\n\
    \  |\n  = note: type must be known at this point\nhelp: consider specifying the\
    \ type argument in the method call\n  |\n7 |     strings.iter().collect::<B>()\n\
    \  |                           +++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut string = String::new();\n    for s in\
    \ strings {\n        string.push_str(&s);\n    }\n    string.to_string()\n}\n\n\
    fn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().map(String::from).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        \"\".to_owned()\n\
    \    } else {\n        strings.join(\"\").to_owned()\n    }\n}\n\nfn main() {\n\
    \    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n    let mut builder = String::new();\n    for mut s in strings {\n   \
    \     builder.push_str(s);\n    }\n    builder.into()\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq0og8ci7.rs:12:26\n   |\n\
    12 |         builder.push_str(s);\n   |                          ^\n   |     \
    \                     |\n   |                          expected `&str`, found\
    \ struct `String`\n   |                          help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut acc, str|\
    \ {\n        acc.push_str(str);\n        acc\n    });\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwjizy3mj.rs:6:41\n   |\n\
    6  | fn concatenate(strings: Vec<String>) -> String {\n   |    -----------   \
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n10 |     });\n   |       - help: remove this semicolon\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold('', |mut s, s| s + s)\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n --> /tmp/tmpc2fg8coe.rs:7:31\n  |\n7 |\
    \     strings.into_iter().fold('', |mut s, s| s + s)\n  |                    \
    \           ^ empty character literal\n\nerror[E0415]: identifier `s` is bound\
    \ more than once in this parameter list\n --> /tmp/tmpc2fg8coe.rs:7:42\n  |\n\
    7 |     strings.into_iter().fold('', |mut s, s| s + s)\n  |                  \
    \                        ^ used as parameter more than once\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpc2fg8coe.rs:7:49\n  |\n7 |     strings.into_iter().fold('',\
    \ |mut s, s| s + s)\n  |                                                 ^\n \
    \ |                                                 |\n  |                   \
    \                              expected `&str`, found struct `String`\n  |   \
    \                                              help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0415.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        \"\".to_string()\n\
    \    } else {\n        strings.iter().fold(\"\".to_string(), |mut acc, s| acc\
    \ + s)\n    }\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut acc,\
    \ s| {\n        acc.push_str(s);\n        acc\n    })\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3szqd8gp.rs:8:22\n  |\n8 |\
    \         acc.push_str(s);\n  |                      ^\n  |                  \
    \    |\n  |                      expected `&str`, found struct `String`\n  | \
    \                     help: consider borrowing here: `&s`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut result = String::new();\n    for s in strings {\n      \
    \  result.push_str(&s);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut res = String::new();\n    for string in\
    \ strings {\n        res += string;\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpja834dlp.rs:9:16\n  |\n9 |\
    \         res += string;\n  |                ^^^^^^\n  |                |\n  |\
    \                expected `&str`, found struct `String`\n  |                help:\
    \ consider borrowing here: `&string`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return \"\".to_owned();\n\
    \    }\n    return strings\n        .iter()\n        .fold(String::new(), |mut\
    \ acc, s| acc + &*s.as_str())\n        .to_string();\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\",\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"x,y,z\"`,\n right: `\"xyz\"`', /tmp/tmpz7b14u9f.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut s, s|\
    \ s.push_str(&s))\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n --> /tmp/tmp27wduy_s.rs:7:48\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s.push_str(&s))\n  |                                            \
    \    ^ used as parameter more than once\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp27wduy_s.rs:7:51\n  |\n6 | fn concatenate(strings: Vec<String>) -> String\
    \ {\n  |                                         ------ expected `String` because\
    \ of return type\n7 |     strings.iter().fold(String::new(), |mut s, s| s.push_str(&s))\n\
    \  |                                                   ^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n  |\nnote: method `push_str` modifies its receiver\
    \ in-place\n --> /tmp/tmp27wduy_s.rs:7:53\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s.push_str(&s))\n  |                                            \
    \       - ^^^^^^^^ this call modifies `s` in-place\n  |                      \
    \                             |\n  |                                         \
    \          you probably want to use this value after calling the method...\n \
    \ = note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0415.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for s in\
    \ strings.iter() {\n        result.append(&mut s);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpi3ygo038.rs:9:16\n  |\n9 |         result.append(&mut\
    \ s);\n  |                ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\",\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"x,y,z\"`,\n right: `\"xyz\"`', /tmp/tmpdehk0kys.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n\n    for s in\
    \ strings.into_iter() {\n        result.push_str(s);\n    }\n\n    result\n}\n\
    \nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi_7qox5o.rs:10:25\n   |\n\
    10 |         result.push_str(s);\n   |                         ^\n   |       \
    \                  |\n   |                         expected `&str`, found struct\
    \ `String`\n   |                         help: consider borrowing here: `&s`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for s in\
    \ strings {\n        result.push_str(s);\n        result.push(' ');\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbz8aj_av.rs:9:25\n  |\n9 |\
    \         result.push_str(s);\n  |                         ^\n  |            \
    \             |\n  |                         expected `&str`, found struct `String`\n\
    \  |                         help: consider borrowing here: `&s`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings\n        .iter()\n        .map(String::from)\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(String::new(), |mut acc,\
    \ s| {\n        acc.push_str(&s);\n        acc\n    })\n}\n\nfn main() {\n   \
    \ let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return \"\";\n\
    \    }\n    let mut result = strings.iter().fold(String::new(), |mut acc, s| {\n\
    \        acc + s;\n        acc\n    });\n    if strings.len() == 1 {\n       \
    \ result\n    } else {\n        result + &strings[1..]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpas7ko9dk.rs:8:16\n  |\n6 |\
    \ fn concatenate(strings: Vec<String>) -> String {\n  |                      \
    \                   ------ expected `String` because of return type\n7 |     if\
    \ strings.is_empty() {\n8 |         return \"\";\n  |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                |\n  |   \
    \             expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpas7ko9dk.rs:17:18\n   |\n17 |         result + &strings[1..]\n\
    \   |                  ^^^^^^^^^^^^^ expected `str`, found slice\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&[String]`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter()\n        .map(|s| s.to_string())\n\
    \        .collect::<Vec<_>>()\n        .join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::with_capacity(strings.len());\n\
    \    strings.for_each(|s| s.push_str(&mut s));\n    s\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<String>` is not an iterator\n   --> /tmp/tmpzhktjorb.rs:8:13\n\
    \    |\n8   |       strings.for_each(|s| s.push_str(&mut s));\n    |         \
    \      ^^^^^^^^ `Vec<String>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<String>: Iterator`\n    \
    \        which is required by `&mut Vec<String>: Iterator`\n            `[String]:\
    \ Iterator`\n            which is required by `&mut [String]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut s, s|\
    \ s.push_str(&s));\n    s.into()\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0415]: identifier `s` is bound more than once in this parameter\
    \ list\n --> /tmp/tmpfw_no7s0.rs:7:48\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s.push_str(&s));\n  |                                           \
    \     ^ used as parameter more than once\n\nerror[E0425]: cannot find value `s`\
    \ in this scope\n --> /tmp/tmpfw_no7s0.rs:8:5\n  |\n8 |     s.into()\n  |    \
    \ ^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfw_no7s0.rs:7:51\n\
    \  |\n7 |     strings.iter().fold(String::new(), |mut s, s| s.push_str(&s));\n\
    \  |                                                   ^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n  |\nnote: method `push_str` modifies its receiver\
    \ in-place\n --> /tmp/tmpfw_no7s0.rs:7:53\n  |\n7 |     strings.iter().fold(String::new(),\
    \ |mut s, s| s.push_str(&s));\n  |                                           \
    \        - ^^^^^^^^ this call modifies `s` in-place\n  |                     \
    \                              |\n  |                                        \
    \           you probably want to use this value after calling the method...\n\
    \  = note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0415,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\",\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"x,y,z\"`,\n right: `\"xyz\"`', /tmp/tmpre5041x6.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold('', |mut s, s| s + s)\n}\n\
    \nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n --> /tmp/tmpyff152_u.rs:7:26\n  |\n7 |\
    \     strings.iter().fold('', |mut s, s| s + s)\n  |                         \
    \ ^ empty character literal\n\nerror[E0415]: identifier `s` is bound more than\
    \ once in this parameter list\n --> /tmp/tmpyff152_u.rs:7:37\n  |\n7 |     strings.iter().fold('',\
    \ |mut s, s| s + s)\n  |                                     ^ used as parameter\
    \ more than once\n\nerror[E0369]: cannot add `&String` to `&String`\n --> /tmp/tmpyff152_u.rs:7:42\n\
    \  |\n7 |     strings.iter().fold('', |mut s, s| s + s)\n  |                 \
    \                       - ^ - &String\n  |                                   \
    \     | |\n  |                                        | `+` cannot be used to\
    \ concatenate two `&str` strings\n  |                                        &String\n\
    \  |\n  = note: string concatenation requires an owned `String` on the left\n\
    help: create an owned `String` from a string reference\n  |\n7 |     strings.iter().fold('',\
    \ |mut s, s| s.to_owned() + s)\n  |                                         +++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0415.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut builder = String::new();\n    for (i,\
    \ s) in strings.into_iter().enumerate() {\n        if i > 0 {\n            builder.push(\"\
    , \");\n        }\n        builder.push(s);\n    }\n    builder.to_string()\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfi2bubq.rs:10:26\n   |\n\
    10 |             builder.push(\", \");\n   |                          ^^^^ expected\
    \ `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzfi2bubq.rs:12:22\n\
    \   |\n12 |         builder.push(s);\n   |                      ^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(|s| s.to_string()).collect::<Vec<_>>().join('')\n\
    }\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n --> /tmp/tmp2hoyr_9x.rs:7:69\n  |\n7 |\
    \     strings.iter().map(|s| s.to_string()).collect::<Vec<_>>().join('')\n  |\
    \                                                                     ^ empty\
    \ character literal\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut res = String::with_capacity(strings.len());\n\
    \    for s in strings {\n        res.push_str(s);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxznracw2.rs:9:22\n  |\n9 |\
    \         res.push_str(s);\n  |                      ^\n  |                  \
    \    |\n  |                      expected `&str`, found struct `String`\n  | \
    \                     help: consider borrowing here: `&s`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.into_iter().fold(\"\".to_string(), |mut\
    \ acc, s| acc + s)\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk03575u_.rs:7:65\n  |\n7 |\
    \     strings.into_iter().fold(\"\".to_string(), |mut acc, s| acc + s)\n  |  \
    \                                                               ^\n  |       \
    \                                                          |\n  |            \
    \                                                     expected `&str`, found struct\
    \ `String`\n  |                                                              \
    \   help: consider borrowing here: `&s`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut s = String::new();\n    for s in strings\
    \ {\n        s += s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfo7gcubh.rs:9:14\n  |\n9 |\
    \         s += s;\n  |              ^\n  |              |\n  |              expected\
    \ `&str`, found struct `String`\n  |              help: consider borrowing here:\
    \ `&s`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(String::from).collect::<Vec<_>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().map(String::join).collect()\n}\n\
    \nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `join` found for struct\
    \ `String` in the current scope\n --> /tmp/tmpzwwl9386.rs:7:32\n  |\n7 |     strings.iter().map(String::join).collect()\n\
    \  |                                ^^^^ function or associated item not found\
    \ in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut acc, x|\
    \ {\n        acc.push_str(x);\n        acc\n    });\n}\n\nfn main() {\n    let\
    \ candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_opxdf5b.rs:6:41\n   |\n\
    6  | fn concatenate(strings: Vec<String>) -> String {\n   |    -----------   \
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n10 |     });\n   |       - help: remove this semicolon\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    // Concatenate strings separated by newlines\n\
    \    // See https://docs.python.org/2/library/stdtypes.html#str.join\n    // See\
    \ https://docs.python.org/2/library/stdtypes.html#str.splitlines\n    strings\n\
    \        .iter()\n        .map(|s| s.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\\n\")\n}\n\nfn main() {\n    let candidate = concatenate;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n  \
    \  assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"x\\ny\\nz\"`,\n right: `\"xyz\"`', /tmp/tmpyvqva_8u.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for s in\
    \ strings {\n        result = result.push_str(s);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyhian9od.rs:9:34\n  |\n9 |\
    \         result = result.push_str(s);\n  |                                  ^\n\
    \  |                                  |\n  |                                 \
    \ expected `&str`, found struct `String`\n  |                                \
    \  help: consider borrowing here: `&s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpyhian9od.rs:9:18\n  |\n7 |     let mut result = String::new();\n  |\
    \                      ------------- expected due to this value\n8 |     for s\
    \ in strings {\n9 |         result = result.push_str(s);\n  |                \
    \  ^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n  |\nnote: method\
    \ `push_str` modifies its receiver in-place\n --> /tmp/tmpyhian9od.rs:9:25\n \
    \ |\n9 |         result = result.push_str(s);\n  |                  ------ ^^^^^^^^\
    \ this call modifies `result` in-place\n  |                  |\n  |          \
    \        you probably want to use this value after calling the method...\n  =\
    \ note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for string\
    \ in strings {\n        if !result.is_empty() {\n            result.push_str(\"\
    ,\");\n        }\n        result.push_str(string);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgb4jrlsg.rs:12:25\n   |\n\
    12 |         result.push_str(string);\n   |                         ^^^^^^\n \
    \  |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&string`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    strings.iter().fold(String::new(), |mut str, s|\
    \ str + s)\n}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return \"\";\n\
    \    }\n    strings.iter().fold(String::from(\"xyz\"), |mut current, str| {\n\
    \        current + str + &\"xyz\";\n    });\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_8a97xzt.rs:8:16\n  |\n6 |\
    \ fn concatenate(strings: Vec<String>) -> String {\n  |                      \
    \                   ------ expected `String` because of return type\n7 |     if\
    \ strings.is_empty() {\n8 |         return \"\";\n  |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                |\n  |   \
    \             expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_8a97xzt.rs:10:65\n   |\n10 |       strings.iter().fold(String::from(\"\
    xyz\"), |mut current, str| {\n   |  _________________________________________________________________^\n\
    11 | |         current + str + &\"xyz\";\n   | |                             \
    \  - help: remove this semicolon\n12 | |     });\n   | |_____^ expected struct\
    \ `String`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_8a97xzt.rs:6:41\n\
    \   |\n6  | fn concatenate(strings: Vec<String>) -> String {\n   |    -----------\
    \                          ^^^^^^ expected struct `String`, found `()`\n   | \
    \   |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n12 |     });\n   |       - help: remove this semicolon\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    let mut result = String::new();\n    for s in\
    \ strings.into_iter() {\n        result.push_str(s);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"\
    y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbyyhjtz3.rs:9:25\n  |\n9 |\
    \         result.push_str(s);\n  |                         ^\n  |            \
    \             |\n  |                         expected `&str`, found struct `String`\n\
    \  |                         help: consider borrowing here: `&s`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Concatenate list of strings into a single string\n/// >>> concatenate([])\n\
    /// ''\n/// >>> concatenate(['a', 'b', 'c'])\n/// 'abc'\nfn concatenate(strings:\
    \ Vec<String>) -> String {\n    if strings.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut result = String::new();\n    for s in strings {\n      \
    \  result.push_str(s);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\
    \"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"),\
    \ String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"\
    k\")]), String::from(\"xyzwk\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxr9serjh.rs:13:25\n   |\n\
    13 |         result.push_str(s);\n   |                         ^\n   |       \
    \                  |\n   |                         expected `&str`, found struct\
    \ `String`\n   |                         help: consider borrowing here: `&s`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
