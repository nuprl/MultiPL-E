name: HumanEval_21_rescale_to_unit
language: rust
results:
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0] as f64;\n    let mut max_value = numbers[0]\
    \ as f64;\n    for i in numbers.iter().rev() {\n        if i == 0.0 {\n      \
    \      continue;\n        }\n        let m = i as f64 - min_value;\n        min_value\
    \ = max_value;\n        max_value = i;\n    }\n    let mut new_numbers = vec![];\n\
    \    for i in numbers.iter() {\n        new_numbers.push(i as f64 - (max_value\
    \ - min_value) * (i as f64 / max_value));\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&f64` with `{float}`\n --> /tmp/tmpvo060fnb.rs:9:14\n\
    \  |\n9 |         if i == 0.0 {\n  |              ^^ no implementation for `&f64\
    \ == {float}`\n  |\n  = help: the trait `PartialEq<{float}>` is not implemented\
    \ for `&f64`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvo060fnb.rs:14:21\n\
    \   |\n7  |     let mut max_value = numbers[0] as f64;\n   |                 \
    \        ----------------- expected due to this value\n...\n14 |         max_value\
    \ = i;\n   |                     ^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |         max_value = *i;\n   |         \
    \            +\n\nerror[E0606]: casting `&f64` as `f64` is invalid\n  --> /tmp/tmpvo060fnb.rs:12:17\n\
    \   |\n12 |         let m = i as f64 - min_value;\n   |                 -^^^^^^^\n\
    \   |                 |\n   |                 cannot cast `&f64` as `f64`\n  \
    \ |                 help: dereference the expression: `*i`\n\nerror[E0606]: casting\
    \ `&f64` as `f64` is invalid\n  --> /tmp/tmpvo060fnb.rs:18:26\n   |\n18 |    \
    \     new_numbers.push(i as f64 - (max_value - min_value) * (i as f64 / max_value));\n\
    \   |                          -^^^^^^^\n   |                          |\n   |\
    \                          cannot cast `&f64` as `f64`\n   |                 \
    \         help: dereference the expression: `*i`\n\nerror[E0606]: casting `&f64`\
    \ as `f64` is invalid\n  --> /tmp/tmpvo060fnb.rs:18:64\n   |\n18 |         new_numbers.push(i\
    \ as f64 - (max_value - min_value) * (i as f64 / max_value));\n   |          \
    \                                                      -^^^^^^^\n   |        \
    \                                                        |\n   |             \
    \                                                   cannot cast `&f64` as `f64`\n\
    \   |                                                                help: dereference\
    \ the expression: `*"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut range: Vec<_> = numbers.iter().cloned().collect();\n\n    // find\
    \ the minimum and maximum values\n    let max_num: f64 = range.iter().max().unwrap();\n\
    \    let min_num: f64 = range.iter().min().unwrap();\n\n    // rescale all the\
    \ numbers so that they fall between 0 and 1\n    for num in range {\n        let\
    \ rescaled = num / max_num;\n        range.push(rescaled);\n    }\n\n    // multiply\
    \ by the length of the range to get the new range\n    range\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4d2ggcpe.rs:9:37\n\
    \     |\n9    |     let max_num: f64 = range.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp4d2ggcpe.rs:9:24\n  |\n9 |    \
    \ let max_num: f64 = range.iter().max().unwrap();\n  |                  ---  \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  |              \
    \    |\n  |                  expected due to this\n  |\nhelp: consider dereferencing\
    \ the borrow\n  |\n9 |     let max_num: f64 = *range.iter().max().unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmp4d2ggcpe.rs:10:37\n     |\n10   |     let min_num:\
    \ f64 = range.iter().min().unwrap();\n     |                                 \
    \    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the\
    \ following other types implement trait `Ord`:\n               i128\n        \
    \       i16\n               i32\n               i64\n               i8\n     \
    \          isize\n               u128\n               u16\n             and 4\
    \ others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4d2ggcpe.rs:10:24\n   |\n10 |     let min_num:\
    \ f64 = range.iter().min().unwrap();\n   |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n   |                  |\n   |                \
    \  expected due to this\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    10 |     let min_num: f64 = *range.iter"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0].clone();\n    let mut max = numbers[0].clone();\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let range\
    \ = (max - min).abs();\n    let mut ratio = 0.0;\n    for &n in numbers {\n  \
    \      ratio += n.clone().powi(2);\n    }\n    ratio = (range / ratio).sqrt();\n\
    \    let mut multiplier = 0.0;\n    for &n in numbers {\n        *n -= min;\n\
    \        *n = *n.powi(2) * ratio;\n        *n /= ratio;\n        multiplier +=\
    \ *n;\n    }\n    return numbers;\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyxcnseen.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyxcnseen.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpyxcnseen.rs:23:9\n   |\n23 |     for &n in numbers {\n   |     \
    \    ^^    ------- this expression has type `Option<f64>`\n   |         |\n  \
    \ |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() <= 1 {\n        return numbers;\n    }\n\n    let mut min_num\
    \ = numbers.iter().min().unwrap();\n    let mut max_num = numbers.iter().max().unwrap();\n\
    \n    for n in numbers {\n        min_num = std::cmp::min(min_num, n);\n     \
    \   max_num = std::cmp::max(max_num, n);\n    }\n\n    let mut scaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let scaled_number = (n - min_num)\
    \ / (max_num - min_num);\n        scaled_numbers.push(scaled_number);\n    }\n\
    \    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpu3r_9q2h.rs:10:38\n\
    \     |\n10   |     let mut min_num = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpu3r_9q2h.rs:11:38\n\
    \     |\n11   |     let mut max_num = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu3r_9q2h.rs:14:42\n   |\n14 |\
    \         min_num = std::cmp::min(min_num, n);\n   |                         \
    \                 ^\n   |                                          |\n   |   \
    \                                       expected `&f64`, found `f64`\n   |   \
    \                                       help: consider borrowing here: `&n`\n\n\
    error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpu3r_9q2h.rs:14:19\n\
    \     |\n14   |         min_num = std::cmp::min(min_num, n);\n     |         \
    \          ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_number = numbers[0];\n    let max_number = numbers[0];\n    for i\
    \ in numbers.iter().rev() {\n        if *i < min_number {\n            min_number\
    \ = *i;\n        }\n        if *i > max_number {\n            max_number = *i;\n\
    \        }\n    }\n    let mut min_number = min_number / 2.0 * 2.0;\n    let mut\
    \ max_number = max_number / 2.0 * 2.0;\n    for i in numbers.iter().rev() {\n\
    \        let mut v = i / 2.0 * 2.0 - min_number - max_number;\n        if v <\
    \ 0.0 {\n            v = 0.0;\n        }\n        if v > 1.0 {\n            v\
    \ = 1.0;\n        }\n        min_number = v * 2.0 * 2.0 - min_number - max_number;\n\
    \        max_number = v * 2.0 * 2.0 - min_number - max_number;\n    }\n    numbers.push(min_number);\n\
    \    numbers.push(max_number);\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `min_number`\n\
    \  --> /tmp/tmpouaxr6nj.rs:10:13\n   |\n6  |     let min_number = numbers[0];\n\
    \   |         ----------\n   |         |\n   |         first assignment to `min_number`\n\
    \   |         help: consider making this binding mutable: `mut min_number`\n...\n\
    10 |             min_number = *i;\n   |             ^^^^^^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `max_number`\n  --> /tmp/tmpouaxr6nj.rs:13:13\n   |\n7  |     let max_number\
    \ = numbers[0];\n   |         ----------\n   |         |\n   |         first assignment\
    \ to `max_number`\n   |         help: consider making this binding mutable: `mut\
    \ max_number`\n...\n13 |             max_number = *i;\n   |             ^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `numbers`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpouaxr6nj.rs:29:5\n\
    \   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |        \
    \            ------- help: consider changing this to be mutable: `mut numbers`\n\
    ...\n29 |     numbers.push(min_number);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `numbers` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpouaxr6nj.rs:30:5\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n30 |     numbers.push(max_number);\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\n\
    For more information about an error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_n = numbers[0];\n    let mut max_n = numbers[0];\n    for n in\
    \ numbers {\n        if n < min_n {\n            min_n = n;\n        }\n     \
    \   if n > max_n {\n            max_n = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        new_numbers.push(n - min_n /\
    \ (max_n - min_n));\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp2vb4_11h.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().cloned().map(|n| {\n        n * 1.0 / numbers.len()\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n --> /tmp/tmpcqb3hcwy.rs:7:17\n\
    \  |\n7 |         n * 1.0 / numbers.len()\n  |                 ^ no implementation\
    \ for `f64 / usize`\n  |\n  = help: the trait `Div<usize>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Div<Rhs>`:\n\
    \            <&'a f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n      \
    \      <&'a i128 as Div<i128>>\n            <&'a i16 as Div<i16>>\n          \
    \  <&'a i32 as Div<i32>>\n            <&'a i64 as Div<i64>>\n            <&'a\
    \ i8 as Div<i8>>\n            <&'a isize as Div<isize>>\n          and 54 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers.min(|a, b| a.partial_cmp(b).unwrap());\n   \
    \ let mut max_number = numbers.max(|a, b| a.partial_cmp(b).unwrap());\n    let\
    \ mut min_number = max_number - min_number;\n    numbers.push(min_number);\n \
    \   numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp4e_qq_fd.rs:6:34\n    |\n6   |   \
    \    let mut min_number = numbers.min(|a, b| a.partial_cmp(b).unwrap());\n   \
    \ |                                    ^^^ method cannot be called on `Vec<f64>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `f64: Ord`\n            which is required by\
    \ `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&mut Vec<f64>: Ord`\n            `Vec<f64>: Iterator`\n            which\
    \ is required by `&mut Vec<f64>: Iterator`\n            `f64: Ord`\n         \
    \   which is required by `[f64]: Ord`\n            `[f64]: Ord`\n            which\
    \ is required by `&[f64]: Ord`\n            `[f64]: Ord`\n            which is\
    \ required by `&mut [f64]: Ord`\n            `[f64]: Iterator`\n            which\
    \ is required by `&mut [f64]: Iterator`\n\nerror[E0599]: the method `max` exists\
    \ for struct `Vec<f64>`, but its trait bounds were not satisfied\n   --> /tmp/tmp4e_qq_fd.rs:7:34\n\
    \    |\n7   |       let mut max_number = numbers.max(|a, b| a.partial_cmp(b).unwrap());\n\
    \    |                                    ^^^ method cannot be called on `Vec<f64>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `f64: Ord`\n            which is required by\
    \ `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&mut Vec<f64>: Ord`\n            `Vec<f64>: Iterator`\n            which\
    \ is required by `&mut Vec<f64>: Iterator`\n            `f64: Ord`\n         \
    \   which is required by `[f64]: Ord`\n            `[f64]: Ord`\n            which\
    \ is required by `&[f64]: Ord`\n            `[f64]: Ord`\n            which is\
    \ required by `&mut [f64]: Ord`\n            `[f64]: Iterator`\n            which\
    \ is required by `&mut [f64]: Itera"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0] as f64;\n    let mut max = numbers[0] as f64;\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ result = Vec::new();\n    let mut scale = (max - min) as f64;\n    for &n in\
    \ numbers {\n        result.push((n - min) / scale);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk7lh26ej.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk7lh26ej.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return vec![0.0; numbers.len()];\n    }\n\
    \    let mut result = numbers[0..numbers.len() - 1];\n    let mut min_value =\
    \ numbers.iter().min().unwrap();\n    let mut max_value = numbers.iter().max().unwrap();\n\
    \n    if min_value == 0.0 {\n        // min_value was 0, so make sure it is equal\
    \ to 0.5\n        min_value = 0.5;\n    }\n\n    if max_value == 1.0 {\n     \
    \   // max_value was 1, so make sure it is equal to 0.5\n        max_value = 0.5;\n\
    \    }\n\n    for &x in &result {\n        if x == 0.0 {\n            x = min_value;\n\
    \        } else {\n            x = x * max_value / min_value;\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n --> /tmp/tmpup3q1s4o.rs:9:9\n  |\n9 |     let mut result = numbers[0..numbers.len()\
    \ - 1];\n  |         ^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n\
    \  = help: the trait `Sized` is not implemented for `[f64]`\n  = note: all local\
    \ variables must have a statically known size\n  = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n  |\n9 |     let mut\
    \ result = &numbers[0..numbers.len() - 1];\n  |                      +\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpup3q1s4o.rs:10:40\n\
    \     |\n10   |     let mut min_value = numbers.iter().min().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpup3q1s4o.rs:11:40\n\
    \     |\n11   |     let mut max_value = numbers.iter().max().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: can't compare `&f64` with `{float}`\n  --> /tmp/tmpup3q1s4o.rs:13:18\n\
    \   |\n13 |     if min_value == 0.0 {\n   |                  ^^ no implementation\
    \ for `&f64 == {float}`\n   |\n   = help: the trait `Part"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut n = numbers[0];\n    for n in numbers.iter().rev() {\n        if\
    \ n > 1.0 {\n            break;\n        }\n    }\n    let mut c = 0.0;\n    for\
    \ n in numbers.iter().rev() {\n        if n < 0.0 {\n            break;\n    \
    \    }\n        c += n * n;\n    }\n    let res = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        res.push(c / numbers[i]);\n    }\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxcnojwrv.rs:8:16\n  |\n8 |\
    \         if n > 1.0 {\n  |                ^^^\n  |                |\n  |    \
    \            expected `&f64`, found floating-point number\n  |               \
    \ help: consider borrowing here: `&1.0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxcnojwrv.rs:14:16\n   |\n14 |         if n < 0.0 {\n   |           \
    \     ^^^\n   |                |\n   |                expected `&f64`, found floating-point\
    \ number\n   |                help: consider borrowing here: `&0.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        numbers\n    } else {\n        numbers\n\
    \            .iter()\n            .map(|n| n / numbers.last().unwrap())\n    \
    \        .collect()\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04008016032064128, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpsb0d0rpw.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled_numbers = Vec::new();\n    let mut previous_value = numbers[0];\n\
    \    for value in numbers {\n        let rescaled = previous_value / value;\n\
    \        rescaled_numbers.push(rescaled);\n        previous_value = value;\n \
    \   }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 0.04008016032064128]`,\n right: `[0.0, 1.0]`', /tmp/tmpnm95o8id.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min: f64 = numbers.iter().min(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n\
    \    let mut max: f64 = numbers.iter().max(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n\
    \    if max < min {\n        // Handle cases where min is 0\n        // Use epsilon\
    \ to avoid division by 0\n        min = min - f64::EPSILON;\n        max = max\
    \ + f64::EPSILON;\n    }\n    let mut scale = max - min;\n    // If scale is 0,\
    \ just use 1.0\n    if scale == 0 {\n        scale = 1.0;\n    }\n    let mut\
    \ new_numbers = Vec::new();\n    new_numbers.push(0.0);\n    new_numbers.push(scale);\n\
    \    for i in numbers.iter().rev() {\n        let val = i - min;\n        new_numbers.push(val\
    \ / scale);\n    }\n    new_numbers.reverse();\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp81t8r_iq.rs:6:39\n\
    \     |\n6    |     let mut min: f64 = numbers.iter().min(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n\
    \     |                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp81t8r_iq.rs:6:39\n     |\n6    |     let mut min: f64 = numbers.iter().min(|a,\
    \ b| a.partial_cmp(b).unwrap()).unwrap();\n     |                            \
    \           ^^^ -------------------------------- supplied 1 argument\n     | \
    \                                      |\n     |                             \
    \          expected 0 arguments\n     |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp81t8r_iq.rs:6:24\n  |\n6 |    \
    \ let mut min: f64 = numbers.iter().min(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n\
    \  |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |                  |\n  |                  expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n6 |     let\
    \ mut min: f64 = *numbers.iter().min(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmp81t8r_iq.rs:7:39\n     |\n7    |     let mut max:\
    \ f64 = numbers.iter().max(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let mut min: f64 = numbers[0];\n    let\
    \ mut max: f64 = numbers[0];\n    for n in numbers {\n        min = std::min(n,\
    \ min);\n        max = std::max(n, max);\n    }\n    let mut min_index = 0;\n\
    \    let mut max_index = 0;\n    for n in numbers {\n        let nn = n * n /\
    \ min + 1;\n        if nn < 1 {\n            min_index += 1;\n        } else {\n\
    \            max_index += 1;\n        }\n    }\n    if min_index > max_index {\n\
    \        // min_index > max_index\n        // Find new min and max if new min\
    \ > new max\n        // min_index is now the old max index\n        // max_index\
    \ is the new min index\n        // min and max should be reversed in the new list\
    \ to be the same\n        min = numbers[max_index];\n        max = numbers[min_index];\n\
    \    } else {\n        // min_index < max_index\n        // Find new min and max\
    \ if new min < new max\n        // min_index is now the new min index\n      \
    \  // max_index is the old max index\n        // min and max should be reversed\
    \ in the new list to be the same\n        min = numbers[min_index];\n        max\
    \ = numbers[max_index];\n    }\n\n    let mut output: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        let nn = n * n / min + 1;\n        if nn < 1\
    \ {\n            output.push(n);\n        } else {\n            output.push((nn\
    \ - 1) / n);\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n  --> /tmp/tmpws20z7m6.rs:10:20\n\
    \   |\n10 |         min = std::min(n, min);\n   |                    ^^^ not found\
    \ in `std`\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\nhelp: if you import `min`, refer to it directly\n   |\n10 -         min\
    \ = std::min(n, min);\n10 +         min = min(n, min);\n   | \n\nerror[E0425]:\
    \ cannot find function `max` in crate `std`\n  --> /tmp/tmpws20z7m6.rs:11:20\n\
    \   |\n11 |         max = std::max(n, max);\n   |                    ^^^ not found\
    \ in `std`\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\nhelp: if you import `max`, refer to it directly\n   |\n11 -         max\
    \ = std::max(n, max);\n11 +         max = max(n, max);\n   | \n\nerror[E0277]:\
    \ cannot add `{integer}` to `f64`\n  --> /tmp/tmpws20z7m6.rs:16:30\n   |\n16 |\
    \         let nn = n * n / min + 1;\n   |                              ^ no implementation\
    \ for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n16 |         let nn = n * n / min + 1.0;\n   |                 \
    \                ++\n\nerror[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmpws20z7m6.rs:43:30\n\
    \   |\n43 |         let nn = n * n / min + 1;\n   |                          \
    \    ^ no implementation for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0].clone();\n    let mut max = numbers[0].clone();\n\
    \    for &n in numbers {\n        if n < min {\n            min = n.clone();\n\
    \        }\n        if n > max {\n            max = n.clone();\n        }\n  \
    \  }\n    for &n in numbers {\n        *n -= min;\n        *n /= (max - min);\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp52yr54ou.rs:18:15\n\
    \   |\n18 |         *n /= (max - min);\n   |               ^         ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n18 -         *n /= (max - min);\n18 +         *n /= max - min;\n   | \n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp52yr54ou.rs:8:9\n  |\n8 |     for\
    \ &n in numbers {\n  |         ^^    ------- this expression has type `Option<f64>`\n\
    \  |         |\n  |         expected `f64`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `n`\n  |\n  = note:   expected\
    \ type `f64`\n          found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp52yr54ou.rs:16:9\n   |\n16 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    if min < 0.0 {\n        min =\
    \ std::f64::MAX;\n    }\n    if max > 1.0 {\n        max = std::f64::MIN;\n  \
    \  }\n    let mut scale = std::f64::MIN;\n    if max < min {\n        // The minimum\
    \ and maximum are equal, so we don't need to scale\n        // to zero.\n    \
    \    return numbers;\n    }\n    let num_elements = numbers.len();\n    if num_elements\
    \ == 1 {\n        // Just a number\n        scale = max - min;\n        if scale\
    \ == 0.0 {\n            return numbers;\n        }\n        return vec![min /\
    \ scale];\n    }\n    // Find the minimum and maximum element values\n    let\
    \ min_val = numbers.iter().fold(\n        0,\n        |min_val, n| {\n       \
    \     if n == min {\n                min_val\n            } else {\n         \
    \       n.abs().min(min_val)\n            }\n        },\n    );\n    let max_val\
    \ = numbers.iter().fold(\n        0,\n        |max_val, n| {\n            if n\
    \ == max {\n                max_val\n            } else {\n                n.abs().max(max_val)\n\
    \            }\n        },\n    );\n    if min_val == max_val {\n        // The\
    \ minimum and maximum are equal, so we don't need to scale\n        // to zero.\n\
    \        return numbers;\n    }\n    // Find the scale factor such that the difference\
    \ between min and max is 1\n    // If the difference is greater than 1, we will\
    \ need to scale to a larger value.\n    let scale: f64 = (max - min).reciprocal();\n\
    \    // Scale the elements\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        if n > 1.0 {\n            n /= scale;\n        }\n      \
    \  if n < -1.0 {\n            n = -(n * scale);\n        }\n        new_numbers.push((n));\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpg0q0fnws.rs:75:26\n\
    \   |\n75 |         new_numbers.push((n));\n   |                          ^ ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n75 -         new_numbers.push((n));\n75 +         new_numbers.push(n);\n\
    \   | \n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpg0q0fnws.rs:41:18\n\
    \   |\n41 |             if n == min {\n   |                  ^^ no implementation\
    \ for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented\
    \ for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg0q0fnws.rs:44:29\n\
    \   |\n44 |                 n.abs().min(min_val)\n   |                       \
    \      ^^^^^^^ expected `f64`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg0q0fnws.rs:44:17\n   |\n44 |                 n.abs().min(min_val)\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^ expected integer, found `f64`\n\nerror[E0277]:\
    \ can't compare `&f64` with `f64`\n  --> /tmp/tmpg0q0fnws.rs:51:18\n   |\n51 |\
    \             if n == max {\n   |                  ^^ no implementation for `&f64\
    \ == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for\
    \ `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg0q0fnws.rs:54:29\n\
    \   |\n54 |                 n.abs().max(max_val)\n   |                       \
    \      ^^^^^^^ expected `f64`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg0q0fnws.rs:54:17\n   |\n54 |                 n.abs().max(max_val)\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^ expected integer, found `f64`\n\nerror[E0599]:\
    \ no method"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result: Vec<_> = numbers.iter().cloned().collect();\n    let mut\
    \ smallest: f64 = numbers[0].clone();\n    let mut largest: f64 = numbers[0].clone();\n\
    \    let mut smallest_idx: usize = 0;\n    let mut largest_idx: usize = 0;\n \
    \   let mut total_weight: f64 = numbers[0].clone();\n    let mut last_weight:\
    \ f64 = numbers[0].clone();\n    for number in &numbers {\n        if smallest.abs()\
    \ < number.abs() {\n            smallest = number;\n            smallest_idx =\
    \ result.len();\n        }\n        if number.abs() > largest.abs() {\n      \
    \      largest = number;\n            largest_idx = result.len();\n        }\n\
    \        total_weight += number;\n        last_weight = total_weight;\n      \
    \  result.push(number / last_weight as f64);\n    }\n    result[smallest_idx]\
    \ = 0.0;\n    result[largest_idx] = 1.0;\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxpeykw2y.rs:15:24\n   |\n\
    7  |     let mut smallest: f64 = numbers[0].clone();\n   |                   \
    \    --- expected due to this type\n...\n15 |             smallest = number;\n\
    \   |                        ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n15 |             smallest = *number;\n\
    \   |                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpeykw2y.rs:19:23\n\
    \   |\n8  |     let mut largest: f64 = numbers[0].clone();\n   |             \
    \         --- expected due to this type\n...\n19 |             largest = number;\n\
    \   |                       ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |             largest = *number;\n   |  \
    \                     +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers[0];\n    let max = numbers[0];\n\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n\n    numbers.iter().map(|n| (n -\
    \ min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp14ja20vv.rs:9:9\n  |\n9 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return vec![];\n    }\n    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    let min_num = *numbers.iter().min();\n\
    \    let max_num = *numbers.iter().max();\n    let mut scale = 1;\n    for n in\
    \ numbers {\n        let mut new_value = n * scale + min_num;\n        if new_value\
    \ > max_num {\n            new_value -= 1;\n        }\n        scale = (new_value\
    \ - min_num) / (max_num - min_num);\n        result.push(new_value);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkkm2ks1n.rs:10:35\n\
    \     |\n10   |     let min_num = *numbers.iter().min();\n     |             \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n    \
    \ |\n     = help: the following other types implement trait `Ord`:\n         \
    \      i128\n               i16\n               i32\n               i64\n    \
    \           i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0614]: type `Option<&f64>` cannot be dereferenced\n  --> /tmp/tmpkkm2ks1n.rs:10:19\n\
    \   |\n10 |     let min_num = *numbers.iter().min();\n   |                   ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkkm2ks1n.rs:11:35\n\
    \     |\n11   |     let max_num = *numbers.iter().max();\n     |             \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n    \
    \ |\n     = help: the following other types implement trait `Ord`:\n         \
    \      i128\n               i16\n               i32\n               i64\n    \
    \           i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0614]: type `Option<&f64>` cannot be dereferenced\n  --> /tmp/tmpkkm2ks1n.rs:11:19\n\
    \   |\n11 |     let max_num = *numbers.iter().max();\n   |                   ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: cannot multiply `f64` by `{integer}`\n  --> /tmp/tmpkkm2ks1n.rs:14:31\n\
    \   |\n14 |         let mut new_value = n * scale + min_num;\n   |           \
    \                    ^ no implementation for `f64 * {integer}`\n   |\n   = help:\
    \ the trait `Mul<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().cloned().collect::<Vec<f64>>()\n        .iter_mut()\n    \
    \    .zip(\n            numbers.iter().cloned().collect::<Vec<f64>>(),\n     \
    \   )\n        .map(|(v1, v2)| v1 * std::f64::from(v2) / (v1 - std::f64::from(0.0)))\n\
    \        .collect::<Vec<f64>>()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `from` in module `std::f64`\n  --> /tmp/tmpbnjxbk8l.rs:11:40\n\
    \   |\n11 |         .map(|(v1, v2)| v1 * std::f64::from(v2) / (v1 - std::f64::from(0.0)))\n\
    \   |                                        ^^^^ not found in `std::f64`\n\n\
    error[E0425]: cannot find function `from` in module `std::f64`\n  --> /tmp/tmpbnjxbk8l.rs:11:67\n\
    \   |\n11 |         .map(|(v1, v2)| v1 * std::f64::from(v2) / (v1 - std::f64::from(0.0)))\n\
    \   |                                                                   ^^^^ not\
    \ found in `std::f64`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_value = numbers.iter().min();\n    let max_value = numbers.iter().max();\n\
    \    let mut new_numbers = Vec::new();\n    new_numbers.reserve(numbers.len());\n\
    \    for number in numbers {\n        let number = number - min_value;\n     \
    \   new_numbers.push(number);\n    }\n    new_numbers.sort();\n    new_numbers.reverse();\n\
    \    new_numbers.append(0.0 as f64);\n    new_numbers.append(1.0 as f64);\n  \
    \  new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpduspmk0i.rs:6:36\n\
    \     |\n6    |     let min_value = numbers.iter().min();\n     |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpduspmk0i.rs:7:36\n\
    \     |\n7    |     let max_value = numbers.iter().max();\n     |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: cannot subtract `Option<&f64>` from `f64`\n  --> /tmp/tmpduspmk0i.rs:11:29\n\
    \   |\n11 |         let number = number - min_value;\n   |                   \
    \          ^ no implementation for `f64 - Option<&f64>`\n   |\n   = help: the\
    \ trait `Sub<Option<&f64>>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpduspmk0i.rs:16:24\n   |\n16 |     new_numbers.append(0.0\
    \ as f64);\n   |              "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_element = numbers.iter().min().unwrap();\n    let mut max_element\
    \ = numbers.iter().max().unwrap();\n    let mut result = Vec::new();\n    while\
    \ min_element > 0.0 && max_element < 1.0 {\n        if min_element > max_element\
    \ {\n            result.push(min_element as f64 / max_element);\n        } else\
    \ {\n            result.push(min_element);\n        }\n        min_element -=\
    \ max_element as f64;\n        max_element += min_element as f64;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp11gg5n7e.rs:6:42\n\
    \     |\n6    |     let mut min_element = numbers.iter().min().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp11gg5n7e.rs:7:42\n\
    \     |\n7    |     let mut max_element = numbers.iter().max().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp11gg5n7e.rs:9:25\n  |\n9 |    \
    \ while min_element > 0.0 && max_element < 1.0 {\n  |                        \
    \ ^^^\n  |                         |\n  |                         expected `&f64`,\
    \ found floating-point number\n  |                         help: consider borrowing\
    \ here: `&0.0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp11gg5n7e.rs:9:46\n\
    \  |\n9 |     while min_element > 0.0 && max_element < 1.0 {\n  |            \
    \                                  ^^^\n  |                                  \
    \            |\n  |                                              expected `&f64`,\
    \ found floating-point number\n  |                                           \
    \   help: consider borrowing here: `&1.0`\n\nerror[E0308]: mismatched"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0].clone();\n    let mut max_value = numbers[0].clone();\n\
    \    let mut scale = numbers[0].clone();\n\n    for i in 1..numbers.len() {\n\
    \        let mut curr_min = min_value.clone();\n        let mut curr_max = max_value.clone();\n\
    \        let mut curr_scale = scale.clone();\n        curr_max = numbers[i].max();\n\
    \        curr_min = numbers[i].min();\n        curr_scale = numbers[i].abs();\n\
    \        if curr_scale < min_scale {\n            min_value = curr_min;\n    \
    \        min_scale = curr_scale;\n        }\n        if curr_scale > max_scale\
    \ {\n            max_value = curr_max;\n            max_scale = curr_scale;\n\
    \        }\n        scale = max(curr_scale, scale);\n    }\n\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for i in 0..numbers.len() {\n        rescaled_numbers.push((numbers[i]\
    \ - min_value) * scale + min_value);\n    }\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `min_scale` in this scope\n  --> /tmp/tmp25okez9m.rs:17:25\n\
    \   |\n17 |         if curr_scale < min_scale {\n   |                        \
    \ ^^^^^^^^^ help: a local variable with a similar name exists: `min_value`\n\n\
    error[E0425]: cannot find value `min_scale` in this scope\n  --> /tmp/tmp25okez9m.rs:19:13\n\
    \   |\n19 |             min_scale = curr_scale;\n   |             ^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `min_value`\n\nerror[E0425]: cannot\
    \ find value `max_scale` in this scope\n  --> /tmp/tmp25okez9m.rs:21:25\n   |\n\
    21 |         if curr_scale > max_scale {\n   |                         ^^^^^^^^^\
    \ help: a local variable with a similar name exists: `max_value`\n\nerror[E0425]:\
    \ cannot find value `max_scale` in this scope\n  --> /tmp/tmp25okez9m.rs:23:13\n\
    \   |\n23 |             max_scale = curr_scale;\n   |             ^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `max_value`\n\nerror[E0425]: cannot\
    \ find function `max` in this scope\n  --> /tmp/tmp25okez9m.rs:25:17\n   |\n25\
    \ |         scale = max(curr_scale, scale);\n   |                 ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::max;\n   |\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmp25okez9m.rs:14:31\n    |\n14  |         curr_max\
    \ = numbers[i].max();\n    |                               ^^^- supplied 0 arguments\n\
    \    |                               |\n    |                               expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp25okez9m.rs:15:31\n\
    \    |\n15  |         curr_min = numbers[i].min();\n    |                    \
    \           ^^^- supplied 0 arguments\n    |                               |\n\
    \    |                               expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 7 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0425.\nFor more information about an error, "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for num in\
    \ numbers {\n        if num < min {\n            min = num;\n        }\n     \
    \   if num > max {\n            max = num;\n        }\n    }\n    let mut result\
    \ = vec![];\n    for num in numbers {\n        result.push((num - min) / (max\
    \ - min));\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp70a3v7j3.rs:17:16\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for num in numbers {\n \
    \   |                ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for num in numbers {\n    |                ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for num in &numbers\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = Vec::new();\n\n    let mut min = numbers[0];\n    for\
    \ n in numbers {\n        if n < min {\n            min = n;\n        }\n    }\n\
    \    new_numbers.push(0.0);\n    new_numbers.push(1.0 + min / 2);\n\n    for n\
    \ in numbers {\n        let range = n - min;\n        new_numbers.push(n / range);\n\
    \    }\n\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n  --> /tmp/tmpy89_zzgm.rs:15:32\n\
    \   |\n15 |     new_numbers.push(1.0 + min / 2);\n   |                       \
    \         ^ no implementation for `f64 / {integer}`\n   |\n   = help: the trait\
    \ `Div<{integer}>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n15 |     new_numbers.push(1.0 + min /\
    \ 2.0);\n   |                                   ++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_list = numbers[..];\n    new_list.sort();\n\n    let mut current_min\
    \ = new_list[0];\n    let mut current_max = new_list[0];\n\n    for n in new_list.iter().rev()\
    \ {\n        if n > current_max {\n            current_max = n;\n        }\n \
    \       if n < current_min {\n            current_min = n;\n        }\n    }\n\
    \n    let current_range = current_max - current_min;\n    let scale: f64 = 2.0\
    \ * current_range as f64 / numbers.len();\n    new_list *= scale;\n\n    new_list\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n --> /tmp/tmphti7_x55.rs:6:9\n  |\n6 |     let mut new_list = numbers[..];\n\
    \  |         ^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n  =\
    \ help: the trait `Sized` is not implemented for `[f64]`\n  = note: all local\
    \ variables must have a statically known size\n  = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n  |\n6 |     let mut\
    \ new_list = &numbers[..];\n  |                        +\n\nerror[E0277]: the\
    \ trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmphti7_x55.rs:7:14\n \
    \   |\n7   |     new_list.sort();\n    |              ^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphti7_x55.rs:13:16\n\
    \   |\n13 |         if n > current_max {\n   |                ^^^^^^^^^^^\n  \
    \ |                |\n   |                expected `&f64`, found `f64`\n   | \
    \               help: consider borrowing here: `&current_max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphti7_x55.rs:14:27\n   |\n10 |     let mut current_max\
    \ = new_list[0];\n   |                           ----------- expected due to this\
    \ value\n...\n14 |             current_max = n;\n   |                        \
    \   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n14 |             current_max = *n;\n   |                           +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphti7_x55.rs:16:16\n   |\n16 |  \
    \       if n < current_min {\n   |                ^^^^^^^^^^^\n   |          \
    \      |\n   |                expected `&f64`, found `f64`\n   |             \
    \   help: consider borrowing here: `&current_min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphti7_x55.rs:17:27\n   |\n9  |     let mut current_min =\
    \ n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return vec![];\n    }\n    let mut rescaled\
    \ = Vec::with_capacity(numbers.len() as usize);\n    let mut new_min = numbers[0]\
    \ as f64;\n    let mut new_max = numbers[0] as f64;\n    for n in numbers.iter().skip(1)\
    \ {\n        new_min = *std::cmp::min(new_min, *n);\n        new_max = *std::cmp::max(new_max,\
    \ *n);\n    }\n    for i in 0..numbers.len() {\n        rescaled.push((numbers[i]\
    \ - new_min) / (new_max - new_min));\n    }\n    rescaled\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpukdk17ty.rs:13:20\n\
    \     |\n13   |         new_min = *std::cmp::min(new_min, *n);\n     |       \
    \             ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::cmp::min`\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpukdk17ty.rs:13:19\n   |\n13\
    \ |         new_min = *std::cmp::min(new_min, *n);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpukdk17ty.rs:14:20\n\
    \     |\n14   |         new_max = *std::cmp::max(new_max, *n);\n     |       \
    \             ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::cmp::max`\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpukdk17ty.rs:14:19\n   |\n14\
    \ |         new_max = *std::cmp::max(new_max, *n);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = numbers.clone();\n    new_numbers.sort();\n    let\
    \ n = new_numbers.len();\n    let mut min_x = new_numbers[0];\n    let mut max_x\
    \ = new_numbers[0];\n    let mut min_y = new_numbers[0];\n    let mut max_y =\
    \ new_numbers[0];\n    for i in 1..n {\n        if new_numbers[i] < new_numbers[i\
    \ - 1] {\n            max_y = new_numbers[i];\n        } else {\n            min_y\
    \ = new_numbers[i];\n        }\n        if new_numbers[i] > new_numbers[i-1] {\n\
    \            max_x = new_numbers[i];\n        } else {\n            min_x = new_numbers[i];\n\
    \        }\n    }\n    new_numbers[0] = min_x;\n    new_numbers[n - 1] = max_x;\n\
    \    new_numbers[1] = min_y;\n    new_numbers[n - 2] = max_y;\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpq5dzssmr.rs:7:17\n\
    \    |\n7   |     new_numbers.sort();\n    |                 ^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers\n        .iter()\n        .enumerate()\n        .map(|(i, x)| (*i)\
    \ * (1.0 / numbers[*i].max()))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n --> /tmp/tmpfsv987xm.rs:9:23\n\
    \  |\n9 |         .map(|(i, x)| (*i) * (1.0 / numbers[*i].max()))\n  |       \
    \                ^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n -->\
    \ /tmp/tmpfsv987xm.rs:9:45\n  |\n9 |         .map(|(i, x)| (*i) * (1.0 / numbers[*i].max()))\n\
    \  |                                             ^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        } else if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut range = max - min;\n    range\
    \ = if range < 0.0 {\n        0.0\n    } else {\n        range\n    };\n    let\
    \ mut offset = 0.0;\n    if min != 0.0 {\n        offset = min - range / 2.0;\n\
    \    }\n    numbers.push(0.0);\n    numbers.iter().for_each(|n| {\n        *n\
    \ = *n / range;\n        numbers.push(*n - offset);\n    });\n    numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpwvfb2nz4.rs:27:9\n   |\n26 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n27 |         *n = *n / range;\n   |         ^^^^^^^^^^^^^^^\
    \ `n` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0596]:\
    \ cannot borrow `numbers` as mutable, as it is not declared as mutable\n  -->\
    \ /tmp/tmpwvfb2nz4.rs:28:9\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) ->\
    \ Vec<f64> {\n   |                    ------- help: consider changing this to\
    \ be mutable: `mut numbers`\n...\n28 |         numbers.push(*n - offset);\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `numbers` as mutable, as it is not declared as mutable\n  -->\
    \ /tmp/tmpwvfb2nz4.rs:25:5\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) ->\
    \ Vec<f64> {\n   |                    ------- help: consider changing this to\
    \ be mutable: `mut numbers`\n...\n25 |     numbers.push(0.0);\n   |     ^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \   --> /tmp/tmpwvfb2nz4.rs:25:5\n    |\n5   | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n8   | \
    \    for n in numbers {\n    |              ------- `numbers` moved due to this\
    \ implicit call to `.into_iter()`\n...\n25  |     numbers.push(0.0);\n    |  \
    \   ^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider\
    \ iterating over a slice of the `Vec<f64>`'s content to avoid moving into the\
    \ `for` loop\n    |\n8   |     for n in &numbers {\n    |              +\n\nerror[E0500]:\
    \ closure requires unique access to `numbers` but it is already borrowed\n  -->\
    \ /tmp/tmpwvfb2nz4.rs:26:29\n   |\n26 |     numbers.iter().for_each(|n| {\n  \
    \ |     -------------- -------- ^^^ closure construction "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = Vec::with_capacity(numbers.len());\n    for n in numbers\
    \ {\n        if n == 0.0 {\n            new_numbers.push(n);\n        } else {\n\
    \            new_numbers.push(n / n::MAX);\n        }\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `n`\n\
    \  --> /tmp/tmpbp2y97ow.rs:11:34\n   |\n11 |             new_numbers.push(n /\
    \ n::MAX);\n   |                                  ^ use of undeclared crate or\
    \ module `n`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_inclusive = numbers.min().unwrap();\n    let mut max_exclusive\
    \ = numbers.max().unwrap();\n    if min_inclusive == max_exclusive {\n       \
    \ return numbers;\n    }\n    while min_inclusive < 0.0 && numbers.len() > 1 {\n\
    \        numbers.remove(0);\n    }\n    while numbers.len() > 1 && min_inclusive\
    \ > 0.0 {\n        numbers.remove(numbers.len() - 1);\n    }\n    numbers\n  \
    \      .into_iter()\n        .map(|num| num / std::f64::from(numbers.len()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `from` in module `std::f64`\n  --> /tmp/tmp39oqoog5.rs:19:36\n\
    \   |\n19 |         .map(|num| num / std::f64::from(numbers.len()))\n   |    \
    \                                ^^^^ not found in `std::f64`\n\nerror[E0599]:\
    \ the method `min` exists for struct `Vec<f64>`, but its trait bounds were not\
    \ satisfied\n   --> /tmp/tmp39oqoog5.rs:6:37\n    |\n6   |       let mut min_inclusive\
    \ = numbers.min().unwrap();\n    |                                       ^^^ method\
    \ cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `f64: Ord`\n\
    \            which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmp39oqoog5.rs:7:37\n    |\n7   |       let\
    \ mut max_exclusive = numbers.max().unwrap();\n    |                         \
    \              ^^^ method cannot be called on `Vec<f64>` due to unsatisfied trait\
    \ bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n  \
    \          `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n\
    \            `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>:\
    \ Ord`\n            `Vec<f64>: Iterator`\n            which is required by `&mut\
    \ Vec<f64>: Iterator`\n            `f64: Ord`\n            which is required by\
    \ `[f64]: Ord`\n            `[f64]: Ord`\n       "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        numbers\n    } else {\n        let mut min\
    \ = numbers[0];\n        let mut max = numbers[0];\n        for i in numbers.iter().rev()\
    \ {\n            if i < min {\n                min = i;\n            }\n     \
    \       if i > max {\n                max = i;\n            }\n        }\n   \
    \     let length = max - min;\n        let mut result = Vec::new();\n        for\
    \ i in 0..numbers.len() {\n            result.push((numbers[i] - min) / length);\n\
    \        }\n        result\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0uik3cnk.rs:12:20\n   |\n\
    12 |             if i < min {\n   |                    ^^^\n   |             \
    \       |\n   |                    expected `&f64`, found `f64`\n   |        \
    \            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0uik3cnk.rs:13:23\n   |\n9  |         let mut min = numbers[0];\n\
    \   |                       ---------- expected due to this value\n...\n13 | \
    \                min = i;\n   |                       ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |          \
    \       min = *i;\n   |                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0uik3cnk.rs:15:20\n   |\n15 |             if i > max {\n   |  \
    \                  ^^^\n   |                    |\n   |                    expected\
    \ `&f64`, found `f64`\n   |                    help: consider borrowing here:\
    \ `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0uik3cnk.rs:16:23\n\
    \   |\n10 |         let mut max = numbers[0];\n   |                       ----------\
    \ expected due to this value\n...\n16 |                 max = i;\n   |       \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |                 max = *i;\n   |                     \
    \  +\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut scale = 1f64;\n\n    // If the input vector is empty or only has\
    \ one element, we return the original vector\n    if numbers.len() == 0 || numbers.len()\
    \ == 1 {\n        return vec![0.0];\n    }\n\n    // If there is more than one\
    \ element in the input, we calculate the minimum scale\n    // so that the smallest\
    \ element in the vector will become 0\n    if numbers.len() > 1 {\n        scale\
    \ = std::f64::min(numbers.iter().map(|x| x as f64).collect::<Vec<_>>());\n   \
    \ }\n\n    let mut i = 0;\n    while i < numbers.len() {\n        numbers[i] =\
    \ numbers[i] * scale;\n        i += 1;\n    }\n\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in module `std::f64`\n   --> /tmp/tmpoc1fk8jj.rs:16:27\n\
    \    |\n16  |         scale = std::f64::min(numbers.iter().map(|x| x as f64).collect::<Vec<_>>());\n\
    \    |                           ^^^\n    |\nhelp: a constant with a similar name\
    \ exists\n    |\n16  |         scale = std::f64::MIN(numbers.iter().map(|x| x\
    \ as f64).collect::<Vec<_>>());\n    |                           ~~~\nhelp: consider\
    \ importing this function\n    |\n1   | use std::cmp::min;\n    |\nhelp: if you\
    \ import `min`, refer to it directly\n    |\n16  -         scale = std::f64::min(numbers.iter().map(|x|\
    \ x as f64).collect::<Vec<_>>());\n16  +         scale = min(numbers.iter().map(|x|\
    \ x as f64).collect::<Vec<_>>());\n    | \n\nerror[E0606]: casting `&f64` as `f64`\
    \ is invalid\n  --> /tmp/tmpoc1fk8jj.rs:16:54\n   |\n16 |         scale = std::f64::min(numbers.iter().map(|x|\
    \ x as f64).collect::<Vec<_>>());\n   |                                      \
    \                -^^^^^^^\n   |                                              \
    \        |\n   |                                                      cannot cast\
    \ `&f64` as `f64`\n   |                                                      help:\
    \ dereference the expression: `*x`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let mut min_num\
    \ = numbers[0];\n    let mut max_num = numbers[0];\n\n    for n in numbers {\n\
    \        if n < min_num {\n            min_num = n;\n        }\n        if n >\
    \ max_num {\n            max_num = n;\n        }\n    }\n\n    numbers.iter().map(|x|\
    \ x / max_num).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmprc0kui5l.rs:22:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n13  |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |     numbers.iter().map(|x| x / max_num).collect::<Vec<_>>()\n    |\
    \     ^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\n    = note: borrow\
    \ occurs due to deref coercion to `[f64]`\nhelp: consider iterating over a slice\
    \ of the `Vec<f64>`'s content to avoid moving into the `for` loop\n    |\n13 \
    \ |     for n in &numbers {\n    |              +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers\n        .iter()\n        .fold(0.0, |acc, n| acc + (n - n) / numbers.len())\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvmkpn0or.rs:8:15\n  |\n8 |\
    \         .fold(0.0, |acc, n| acc + (n - n) / numbers.len())\n  |            \
    \   ^^^ expected struct `Vec`, found floating-point number\n  |\n  = note: expected\
    \ struct `Vec<f64>`\n               found type `{float}`\n\nerror[E0277]: cannot\
    \ divide `f64` by `usize`\n --> /tmp/tmpvmkpn0or.rs:8:43\n  |\n8 |         .fold(0.0,\
    \ |acc, n| acc + (n - n) / numbers.len())\n  |                               \
    \            ^ no implementation for `f64 / usize`\n  |\n  = help: the trait `Div<usize>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `Div<Rhs>`:\n            <&'a f32 as Div<f32>>\n            <&'a f64 as\
    \ Div<f64>>\n            <&'a i128 as Div<i128>>\n            <&'a i16 as Div<i16>>\n\
    \            <&'a i32 as Div<i32>>\n            <&'a i64 as Div<i64>>\n      \
    \      <&'a i8 as Div<i8>>\n            <&'a isize as Div<isize>>\n          and\
    \ 54 others\n\nerror[E0369]: cannot add `_` to `Vec<f64>`\n --> /tmp/tmpvmkpn0or.rs:8:33\n\
    \  |\n8 |         .fold(0.0, |acc, n| acc + (n - n) / numbers.len())\n  |    \
    \                         --- ^ ----------------------- _\n  |               \
    \              |\n  |                             Vec<f64>\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min: f64 = numbers[0];\n    let max: f64 = numbers[0];\n    for &x in\
    \ numbers {\n        if x < min {\n            min = x;\n        }\n        if\
    \ x > max {\n            max = x;\n        }\n    }\n\n    let mut scale = max\
    \ - min;\n    if scale == 0 {\n        return vec![min];\n    }\n    for &x in\
    \ numbers {\n        *x = *x / scale + min;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvuh39qur.rs:8:9\n  |\n8 |\
    \     for &x in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `x`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvuh39qur.rs:18:17\n   |\n18 |     if scale ==\
    \ 0 {\n   |                 ^\n   |                 |\n   |                 expected\
    \ `f64`, found integer\n   |                 help: use a float literal: `0.0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvuh39qur.rs:21:9\n   |\n21 | \
    \    for &x in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = Vec::new();\n    let mut last_number = numbers[0];\n\
    \n    for i in numbers.iter() {\n        let diff = i - last_number;\n       \
    \ new_numbers.push(last_number + diff / numbers.len());\n        last_number =\
    \ i;\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n  --> /tmp/tmpadln7flp.rs:11:45\n\
    \   |\n11 |         new_numbers.push(last_number + diff / numbers.len());\n  \
    \ |                                             ^ no implementation for `f64 /\
    \ usize`\n   |\n   = help: the trait `Div<usize>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `Div<Rhs>`:\n          \
    \   <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpadln7flp.rs:12:23\n   |\n7  |     let mut last_number\
    \ = numbers[0];\n   |                           ---------- expected due to this\
    \ value\n...\n12 |         last_number = i;\n   |                       ^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12\
    \ |         last_number = *i;\n   |                       +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0].min(numbers.iter().min());\n    let mut max = numbers[0].max(numbers.iter().max());\n\
    \    for i in 1..numbers.len() {\n        min = numbers[i].min(min);\n       \
    \ max = numbers[i].max(max);\n    }\n\n    let mut scale = numbers[0].pow(1.0\
    \ / numbers.size());\n    for i in 1..numbers.len() {\n        let scale = numbers[i].pow(1.0\
    \ / numbers.size());\n        let min = min * (scale.clone());\n        let max\
    \ = max * (scale.clone());\n        let mut new_min = min - scale;\n        let\
    \ mut new_max = max + scale;\n        while new_min < 0.0 {\n            new_min\
    \ += 1.0;\n            new_max = new_max + (1.0);\n        }\n        while new_max\
    \ > 1.0 {\n            new_max -= 1.0;\n            new_min = new_min - (1.0);\n\
    \        }\n        min = new_min;\n        max = new_max;\n    }\n\n    let mut\
    \ new_numbers = Vec::with_capacity(numbers.len());\n    for i in 0..numbers.len()\
    \ {\n        let number: f64 = numbers[i] * ((max - min).clone() / scale.clone());\n\
    \        new_numbers.push(*number);\n    }\n\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp55mwz5_v.rs:6:49\n\
    \     |\n6    |     let mut min = numbers[0].min(numbers.iter().min());\n    \
    \ |                                                 ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp55mwz5_v.rs:6:34\n\
    \  |\n6 |     let mut min = numbers[0].min(numbers.iter().min());\n  |       \
    \                           ^^^^^^^^^^^^^^^^^^^^ expected `f64`, found enum `Option`\n\
    \  |\n  = note: expected type `f64`\n             found enum `Option<&f64>`\n\n\
    error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp55mwz5_v.rs:7:49\n\
    \     |\n7    |     let mut max = numbers[0].max(numbers.iter().max());\n    \
    \ |                                                 ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::max`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp55mwz5_v.rs:7:34\n\
    \  |\n7 |     let mut max = numbers[0].max(numbers.iter().max());\n  |       \
    \                           ^^^^^^^^^^^^^^^^^^^^ expected `f64`, found enum `Option`\n\
    \  |\n  = note: expected type `f64`\n             found enum `Option<&f64>`\n\n\
    error[E0599]: no method named `pow` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp55mwz5_v.rs:13:32\n   |\n13 |     let mut scale = numbers[0].pow"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Find the min and max of the input\n    let (min, max) = numbers.iter().minmax().unwrap();\n\
    \n    // Rescale the input\n    let mut output: Vec<f64> = vec![];\n    for number\
    \ in numbers {\n        let mut scaled = number - min;\n        if scaled < 0\
    \ {\n            scaled += 1;\n        }\n        output.append(scaled);\n   \
    \ }\n\n    // Make sure the minimum and maximum are 1\n    let len = output.len();\n\
    \    if min == 0.0 && max == 0.0 {\n        output = [1.0];\n    }\n\n    // Return\
    \ the output\n    output\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `minmax` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmpfwurxqqu.rs:7:37\n  |\n7 |     let (min,\
    \ max) = numbers.iter().minmax().unwrap();\n  |                              \
    \       ^^^^^^ method not found in `std::slice::Iter<'_, f64>`\n\nerror[E0277]:\
    \ can't compare `&mut Vec<f64>` with `{integer}`\n  --> /tmp/tmpfwurxqqu.rs:13:19\n\
    \   |\n13 |         if scaled < 0 {\n   |                   ^ no implementation\
    \ for `&mut Vec<f64> < {integer}` and `&mut Vec<f64> > {integer}`\n   |\n   =\
    \ help: the trait `PartialOrd<{integer}>` is not implemented for `&mut Vec<f64>`\n\
    \   = help: the trait `PartialOrd` is implemented for `Vec<T, A>`\n\nerror[E0277]:\
    \ cannot add-assign `{integer}` to `&mut Vec<f64>`\n  --> /tmp/tmpfwurxqqu.rs:14:20\n\
    \   |\n14 |             scaled += 1;\n   |                    ^^ no implementation\
    \ for `&mut Vec<f64> += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `&mut Vec<f64>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpfwurxqqu.rs:22:18\n   |\n10 |     let mut output: Vec<f64> = vec![];\n\
    \   |                     -------- expected due to this type\n...\n22 |      \
    \   output = [1.0];\n   |                  ^^^^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |                  |\n   |                  expected\
    \ struct `Vec`, found array `[{float}; 1]`\n   |\n   = note: expected struct `Vec<f64>`\n\
    \               found array `[{float}; 1]`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for n in numbers {\n        if n < min_value {\n            min_value = n;\n\
    \        }\n        if n > max_value {\n            max_value = n;\n        }\n\
    \    }\n    min_value /= max_value;\n    let mut scale: f64 = 1.0;\n    if min_value\
    \ == 0.0 {\n        scale = 0.0;\n    } else if min_value == 1.0 {\n        scale\
    \ = 1.0;\n    }\n    let mut ret: Vec<f64> = vec![];\n    for n in numbers {\n\
    \        let mut value = n * scale;\n        if value >= 1.0 {\n            value\
    \ -= 1.0;\n        }\n        push!(ret, n);\n    }\n    ret\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `push` in this scope\n  --> /tmp/tmp1f8hzh0m.rs:29:9\n\
    \   |\n29 |         push!(ret, n);\n   |         ^^^^\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = numbers;\n\n    // Compute the mean and standard deviation\
    \ of the numbers\n    let mut sum_of_numbers = 0.;\n    let mut std_of_numbers\
    \ = 0.;\n    for n in numbers {\n        sum_of_numbers += n;\n        std_of_numbers\
    \ += n * n;\n    }\n\n    // Compute the standard deviation by taking the square\
    \ root of the variance\n    let std_of_numbers = std::sqrt(std_of_numbers as f64);\n\
    \n    // Scale the numbers to the interval [0, 1]\n    let mut new_numbers_normalized\
    \ = new_numbers;\n    for n in new_numbers_normalized.iter_mut() {\n        *n\
    \ /= std_of_numbers;\n    }\n    new_numbers_normalized\n}\n\nfn main() {\n  \
    \  let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in crate `std`\n  --> /tmp/tmpykv_zfi5.rs:17:31\n\
    \   |\n17 |     let std_of_numbers = std::sqrt(std_of_numbers as f64);\n   | \
    \                              ^^^^ not found in `std`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut max_value = numbers[0];\n    let mut min_value = numbers[0];\n  \
    \  for value in numbers {\n        let delta = value - min_value;\n        let\
    \ scaled_value = delta * 1.0 / (max_value - min_value);\n        min_value = value;\n\
    \        max_value = value;\n    }\n    vec![min_value, max_value]\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[49.9, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmpvt43ml6o.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min: f64;\n    let mut max: f64;\n    let mut n: usize;\n\n    //\
    \ min and max are the \"span\" of each number (in terms of absolute value)\n \
    \   let mut min_abs = std::f64::MAX;\n    let mut max_abs = std::f64::MIN;\n\n\
    \    for n in numbers.iter() {\n        min_abs = std::cmp::min(min_abs, std::f64::abs(n));\n\
    \        max_abs = std::cmp::max(max_abs, std::f64::abs(n));\n    }\n    let min:\
    \ f64 = min_abs as f64;\n    let max: f64 = max_abs as f64;\n\n    // rescale\
    \ the numbers\n    let mut new_numbers = Vec::new();\n    for n in numbers.iter()\
    \ {\n        if n == 0.0 {\n            new_numbers.push(f64::consts::ONE);\n\
    \        } else {\n            new_numbers.push(n * std::f64::consts::ONE.powf((n\
    \ as f64).recip()));\n        }\n    }\n\n    // multiply the numbers by their\
    \ difference between min and max\n    let mut diff_min = max - min;\n    for n\
    \ in new_numbers.iter() {\n        *n /= diff_min as f64;\n    }\n\n    // shift\
    \ all numbers in the new list to the negative direction\n    let mut shift = max\
    \ as f64 - min;\n    for n in new_numbers.iter() {\n        *n -= shift;\n   \
    \ }\n\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpwpf6wq8c.rs:15:52\n\
    \   |\n15 |         min_abs = std::cmp::min(min_abs, std::f64::abs(n));\n   |\
    \                                                    ^^^ not found in `std::f64`\n\
    \nerror[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpwpf6wq8c.rs:16:52\n\
    \   |\n16 |         max_abs = std::cmp::max(max_abs, std::f64::abs(n));\n   |\
    \                                                    ^^^ not found in `std::f64`\n\
    \nerror[E0425]: cannot find value `ONE` in module `std::f64::consts`\n  --> /tmp/tmpwpf6wq8c.rs:27:52\n\
    \   |\n27 |             new_numbers.push(n * std::f64::consts::ONE.powf((n as\
    \ f64).recip()));\n   |                                                    ^^^\
    \ not found in `std::f64::consts`\n\nerror[E0277]: the trait bound `f64: Ord`\
    \ is not satisfied\n    --> /tmp/tmpwpf6wq8c.rs:15:19\n     |\n15   |        \
    \ min_abs = std::cmp::min(min_abs, std::f64::abs(n));\n     |                \
    \   ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n     =\
    \ help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\nnote: required by a bound in `std::cmp::min`\n\nerror[E0277]: the\
    \ trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpwpf6wq8c.rs:16:19\n\
    \     |\n16   |         max_abs = std::cmp::max(max_abs, std::f64::abs(n));\n\
    \     |                   ^^^^^^^^^^^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::max`\n\
    \nerror[E0277]: can't compare `&f64` with `{float}`\n  --> /tmp/tmpwpf6wq8c.rs:24:14\n\
    \   |\n24 |         if n == 0.0 {\n   |              ^^ no implementation for\
    \ `&f64 == {float}`"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Calculate the max and min\n    let mut max_value: f64 = numbers.iter().max().unwrap_or(numbers.first().unwrap_or(1.0)).unwrap_or(0.0);\n\
    \    let mut min_value: f64 = numbers.iter().min().unwrap_or(numbers.last().unwrap_or(0.0)).unwrap_or(1.0);\n\
    \    let mut scale: f64 = 1.0;\n    while min_value != 0.0 {\n        min_value\
    \ -= max_value * scale;\n        scale /= 2.0\n    }\n    // Scale the numbers\n\
    \    let mut scaled_numbers = Vec::with_capacity(numbers.len() * 2);\n    for\
    \ n in numbers {\n        scaled_numbers.push((n - min_value) / scale);\n    \
    \    scaled_numbers.push((n - min_value) / scale);\n    }\n    // Return the new\
    \ list\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpwumnybqj.rs:7:45\n\
    \     |\n7    |     let mut max_value: f64 = numbers.iter().max().unwrap_or(numbers.first().unwrap_or(1.0)).unwrap_or(0.0);\n\
    \     |                                             ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::max`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwumnybqj.rs:7:87\n\
    \  |\n7 |     let mut max_value: f64 = numbers.iter().max().unwrap_or(numbers.first().unwrap_or(1.0)).unwrap_or(0.0);\n\
    \  |                                                                         \
    \              ^^^\n  |                                                      \
    \                                 |\n  |                                     \
    \                                                  expected `&f64`, found floating-point\
    \ number\n  |                                                                \
    \                       help: consider borrowing here: `&1.0`\n\nerror[E0599]:\
    \ no method named `unwrap_or` found for reference `&f64` in the current scope\n\
    \ --> /tmp/tmpwumnybqj.rs:7:93\n  |\n7 |     let mut max_value: f64 = numbers.iter().max().unwrap_or(numbers.first().unwrap_or(1.0)).unwrap_or(0.0);\n\
    \  |                                                                         \
    \                    ^^^^^^^^^ method not found in `&f64`\n\nerror[E0277]: the\
    \ trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpwumnybqj.rs:8:45\n\
    \     |\n8    |     let mut min_value: f64 = numbers.iter().min().unwrap_or(numbers.last().unwrap_or(0.0)).unwrap_or(1.0);\n\
    \     |                                             ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following oth"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n    let mut min_number\
    \ = numbers[0];\n    let mut max_number = numbers[0];\n    for x in numbers {\n\
    \        if x < min_number {\n            min_number = x;\n        }\n       \
    \ if x > max_number {\n            max_number = x;\n        }\n    }\n    let\
    \ mut rescaled = Vec::new();\n    for x in numbers {\n        rescaled.push((x\
    \ - min_number) / (max_number - min_number));\n    }\n    rescaled\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp7xhlvsob.rs:20:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n11  |     for x in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for x in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for x in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled_numbers = Vec::new();\n    let mut sum: f64 = numbers.iter().sum();\n\
    \n    // Find smallest and largest numbers in the array\n    let mut min_value:\
    \ f64 = numbers.iter().min().unwrap();\n    let mut max_value: f64 = numbers.iter().max().unwrap();\n\
    \n    // Find scale factor that linearly rescales all numbers in the array\n \
    \   while sum < 1.0 {\n        min_value -= 0.01;\n        max_value += 0.01;\n\
    \        sum += 0.1;\n    }\n    while sum > 1.0 {\n        min_value += 0.01;\n\
    \        max_value -= 0.01;\n        sum -= 0.1;\n    }\n\n    // Rescale all\
    \ numbers in the array\n    for i in 0..numbers.len() {\n        rescaled_numbers.push(min_value\
    \ + (max_value - min_value) * numbers[i] / sum);\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1wghgsot.rs:10:45\n\
    \     |\n10   |     let mut min_value: f64 = numbers.iter().min().unwrap();\n\
    \     |                                             ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wghgsot.rs:10:30\n\
    \   |\n10 |     let mut min_value: f64 = numbers.iter().min().unwrap();\n   |\
    \                        ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found\
    \ `&f64`\n   |                        |\n   |                        expected\
    \ due to this\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |     let\
    \ mut min_value: f64 = *numbers.iter().min().unwrap();\n   |                 \
    \             +\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \    --> /tmp/tmp1wghgsot.rs:11:45\n     |\n11   |     let mut max_value: f64\
    \ = numbers.iter().max().unwrap();\n     |                                   \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1wghgsot.rs:11:30\n   |\n11 |     let mut max_value:\
    \ f64 = numbers.iter().max().unwrap();\n   |                        ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n   |                        |\n   |          \
    \          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().cloned().fold(0.0, |min, x| min + x).map(|x| x / numbers[numbers.len()\
    \ - 1])\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `f64` is not an iterator\n --> /tmp/tmpahjkgf1e.rs:6:57\n\
    \  |\n6 |     numbers.iter().cloned().fold(0.0, |min, x| min + x).map(|x| x /\
    \ numbers[numbers.len() - 1])\n  |                                           \
    \              ^^^ `f64` is not an iterator\n  |\n  = note: the following trait\
    \ bounds were not satisfied:\n          `f64: Iterator`\n          which is required\
    \ by `&mut f64: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0].clone().into();\n    let mut max = numbers[0].clone().into();\n\
    \    for i in numbers.iter().skip(1) {\n        if i.is_neg() {\n            max\
    \ = -max;\n        } else {\n            min = min.min(&i).unwrap();\n       \
    \     max = max.max(&i).unwrap();\n        }\n    }\n    let diff = max - min;\n\
    \    if diff < DBL_EPSILON {\n        return Vec::with_capacity(1);\n    }\n \
    \   let mut scale: f64 = diff / f64::from((max - min));\n    numbers.iter_mut().for_each(|f|\
    \ {\n        *f = *f / scale;\n    });\n    vec![numbers[0] + diff * scale]\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `DBL_EPSILON` in this scope\n  --> /tmp/tmpucytt9hv.rs:17:15\n\
    \   |\n17 |     if diff < DBL_EPSILON {\n   |               ^^^^^^^^^^^ not found\
    \ in this scope\n\nwarning: unnecessary parentheses around function argument\n\
    \  --> /tmp/tmpucytt9hv.rs:20:43\n   |\n20 |     let mut scale: f64 = diff / f64::from((max\
    \ - min));\n   |                                           ^         ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n20 -     let mut scale: f64 = diff / f64::from((max - min));\n20 +    \
    \ let mut scale: f64 = diff / f64::from(max - min);\n   | \n\nerror[E0599]: no\
    \ method named `is_neg` found for reference `&f64` in the current scope\n -->\
    \ /tmp/tmpucytt9hv.rs:9:14\n  |\n9 |         if i.is_neg() {\n  |            \
    \  ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers[0]\n    let max = numbers[0]\n    for number in numbers\
    \ {\n        if number < min {\n            min = number\n        }\n        if\
    \ number > max {\n            max = number\n        }\n    }\n\n    let mut number\
    \ = 0.0\n    for (i, &v) in numbers.iter().enumerate() {\n        number += v\
    \ * i / (numbers.len() - 1.0)\n    }\n\n    (0.0 - number) / (max - min)\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmppbk7xmhv.rs:6:25\n\
    \  |\n6 |     let min = numbers[0]\n  |                         ^ help: add `;`\
    \ here\n7 |     let max = numbers[0]\n  |     --- unexpected token\n\nerror: expected\
    \ `;`, found keyword `for`\n --> /tmp/tmppbk7xmhv.rs:7:25\n  |\n7 |     let max\
    \ = numbers[0]\n  |                         ^ help: add `;` here\n8 |     for\
    \ number in numbers {\n  |     --- unexpected token\n\nerror: expected `;`, found\
    \ keyword `for`\n  --> /tmp/tmppbk7xmhv.rs:17:25\n   |\n17 |     let mut number\
    \ = 0.0\n   |                         ^ help: add `;` here\n18 |     for (i, &v)\
    \ in numbers.iter().enumerate() {\n   |     --- unexpected token\n\nerror[E0277]:\
    \ cannot multiply `f64` by `usize`\n  --> /tmp/tmppbk7xmhv.rs:19:21\n   |\n19\
    \ |         number += v * i / (numbers.len() - 1.0)\n   |                    \
    \ ^ no implementation for `f64 * usize`\n   |\n   = help: the trait `Mul<usize>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0277]: cannot subtract `{float}` from `usize`\n\
    \  --> /tmp/tmppbk7xmhv.rs:19:42\n   |\n19 |         number += v * i / (numbers.len()\
    \ - 1.0)\n   |                                          ^ no implementation for\
    \ `usize - {float}`\n   |\n   = help: the trait `Sub<{float}>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppbk7xmhv.rs:2"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    Vec::from(\n        ((numbers[0]\
    \ - min) / (max - min)).min(1.0),\n        (max - min).max(1.0),\n    )\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyiz88tiv.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmpyiz88tiv.rs:16:5\n\
    \    |\n16  |     Vec::from(\n    |     ^^^^^^^^^ expected 1 argument\n17  | \
    \        ((numbers[0] - min) / (max - min)).min(1.0),\n    |         -------------------------------------------\n\
    18  |         (max - min).max(1.0),\n    |         -------------------- supplied\
    \ 2 arguments\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut scaled_numbers = Vec::new();\n    scaled_numbers.reserve(numbers.len()\
    \ + 1);\n    scaled_numbers.push((numbers[0] as f64) / (numbers[1] as f64));\n\
    \    scaled_numbers.push(1.0 - scaled_numbers[0]);\n    scaled_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04008016032064128, 0.9599198396793587]`,\n right: `[0.0, 1.0]`', /tmp/tmp4mefcp6v.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = Vec::new();\n    let mut max_value = numbers[0];\n\
    \    for &n in numbers {\n        if n > max_value {\n            max_value =\
    \ n;\n        }\n    }\n    for &n in numbers {\n        new_numbers.push((n -\
    \ max_value) / (max_value - 1.0) * 1.0);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgix2bidn.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgix2bidn.rs:13:9\n   |\n13 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // If the smallest number is 0, then we set the others to 1 as well\n   \
    \ if numbers.len() < 2 {\n        numbers.push(1.0f64);\n        numbers.push(-1.0f64);\n\
    \    }\n\n    // For the first two elements, set the largest and smallest to 0\
    \ and the rest\n    // to 1 (scaled to ensure they are in the range between 0\
    \ and 1)\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for\
    \ i in 1..numbers.len() {\n        min = numbers[i - 1];\n        max = numbers[i];\n\
    \    }\n\n    let mut ret: Vec<f64> = Vec::new();\n    let mut i = 0;\n    while\
    \ i < numbers.len() {\n        let x = numbers[i];\n        let y = min + (x -\
    \ min) * (max - min) / (max - min);\n        ret.push(y);\n        i += 1;\n \
    \   }\n\n    ret\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n --> /tmp/tmpm0n5xgue.rs:8:9\n  |\n5 | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n  |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n8 |         numbers.push(1.0f64);\n\
    \  |         ^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `numbers` as mutable, as it is not declared as mutable\n --> /tmp/tmpm0n5xgue.rs:9:9\n\
    \  |\n5 | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n  |           \
    \         ------- help: consider changing this to be mutable: `mut numbers`\n\
    ...\n9 |         numbers.push(-1.0f64);\n  |         ^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result: Vec<_> = numbers.iter().map(|x| x / numbers[0]).collect();\n\
    \    let mut max_value: f64 = result[0]; // first element should be 0\n    for\
    \ x in result.iter_mut() {\n        *x = max_value - (max_value - *x);\n     \
    \   if *x == 0.0 {\n            *x = 1.0;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 24.95]`,\n right: `[0.0, 1.0]`', /tmp/tmp0gnqenrl.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = numbers.iter().min().unwrap();\n    let mut max_number\
    \ = numbers.iter().max().unwrap();\n    min_number = (min_number - min_number\
    \ % 0.0).abs();\n    max_number = (max_number - max_number % 0.0).abs();\n   \
    \ let mut scaled_numbers = Vec::new();\n    scaled_numbers.extend_from_slice(&numbers);\n\
    \    for i in 0..numbers.len() {\n        let scaled_number = (scaled_numbers[i]\
    \ - min_number) / (max_number - min_number);\n        scaled_numbers.splice(i,\
    \ 1, scaled_number);\n    }\n    scaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpcrp4u5gv.rs:6:41\n\
    \     |\n6    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpcrp4u5gv.rs:7:41\n\
    \     |\n7    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpcrp4u5gv.rs:8:18\n  |\n6 |    \
    \ let mut min_number = numbers.iter().min().unwrap();\n  |                   \
    \       ----------------------------- expected due to this value\n7 |     let\
    \ mut max_number = numbers.iter().max().unwrap();\n8 |     min_number = (min_number\
    \ - min_number % 0.0).abs();\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |                  |\n  |                  expected `&f64`, found `f64`\n \
    \ |                  help: consider borrowing here: `&(min_number - min_number\
    \ % 0.0).abs()`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcrp4u5gv.rs:9:18\n\
    \  |\n7 |     let mut max_number = numbers.iter().max().unwrap();\n  |       \
    \                   ----------------------------- expected due to"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut smallest_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \n    for n in numbers {\n        if n < smallest_number {\n            smallest_number\
    \ = n;\n        }\n        if n > max_number {\n            max_number = n;\n\
    \        }\n    }\n\n    let mut range = (max_number - smallest_number).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        if n !=\
    \ 0.0 {\n            new_numbers.push(smallest_number + (n - smallest_number)\
    \ * range);\n        }\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpq4_znhpo.rs:18:9\n\
    \   |\n18 |     let mut range = (max_number - smallest_number).recip();\n   |\
    \         ----^^^^^\n   |         |\n   |         help: remove this `mut`\n  \
    \ |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved\
    \ value: `numbers`\n   --> /tmp/tmpq4_znhpo.rs:20:14\n    |\n5   | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n    |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    9   |     for n in numbers {\n    |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n20  |     for n in numbers {\n  \
    \  |              ^^^^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider\
    \ iterating over a slice of the `Vec<f64>`'s content to avoid moving into the\
    \ `for` loop\n    |\n9   |     for n in &numbers {\n    |              +\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n    for\
    \ num in numbers {\n        if num < min_num {\n            min_num = num;\n \
    \       }\n        if num > max_num {\n            max_num = num;\n        }\n\
    \    }\n\n    let mut factor = 1.0;\n    for num in numbers {\n        factor\
    \ *= num;\n    }\n\n    let scale = (max_num - min_num) / factor;\n    let mut\
    \ scaled_numbers = Vec::with_capacity(numbers.len());\n    for num in numbers\
    \ {\n        scaled_numbers.push(num * scale);\n    }\n\n    scaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp1u0cwi8q.rs:18:16\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for num in numbers {\n \
    \   |                ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for num in numbers {\n    |                ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for num in &numbers\
    \ {\n    |                +\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \  --> /tmp/tmp1u0cwi8q.rs:23:49\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n18 |  \
    \   for num in numbers {\n   |                ------- `numbers` moved due to this\
    \ implicit call to `.into_iter()`\n...\n23 |     let mut scaled_numbers = Vec::with_capacity(numbers.len());\n\
    \   |                                                 ^^^^^^^^^^^^^ value borrowed\
    \ here after move\n   |\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n   |\n18 |     for num in &numbers\
    \ {\n   |                +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().fold(0.0, |sum, num| sum + num / numbers.len()).div(1.0) *\
    \ numbers[0..numbers.len() - 1]\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `&f64` by `usize`\n --> /tmp/tmpf2drjs03.rs:6:51\n\
    \  |\n6 |     numbers.iter().fold(0.0, |sum, num| sum + num / numbers.len()).div(1.0)\
    \ * numbers[0..numbers.len() - 1]\n  |                                       \
    \            ^ no implementation for `&f64 / usize`\n  |\n  = help: the trait\
    \ `Div<usize>` is not implemented for `&f64`\n  = help: the following other types\
    \ implement trait `Div<Rhs>`:\n            <&'a f32 as Div<f32>>\n           \
    \ <&'a f64 as Div<f64>>\n            <&'a i128 as Div<i128>>\n            <&'a\
    \ i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n            <&'a i64 as\
    \ Div<i64>>\n            <&'a i8 as Div<i8>>\n            <&'a isize as Div<isize>>\n\
    \          and 54 others\n\nerror[E0689]: can't call method `div` on ambiguous\
    \ numeric type `{float}`\n --> /tmp/tmpf2drjs03.rs:6:68\n  |\n6 |     numbers.iter().fold(0.0,\
    \ |sum, num| sum + num / numbers.len()).div(1.0) * numbers[0..numbers.len() -\
    \ 1]\n  |                                                                    ^^^\n\
    \nerror[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n --> /tmp/tmpf2drjs03.rs:6:77\n  |\n6 |     numbers.iter().fold(0.0, |sum,\
    \ num| sum + num / numbers.len()).div(1.0) * numbers[0..numbers.len() - 1]\n \
    \ |                                                                          \
    \   ^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized`\
    \ is not implemented for `[f64]`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut sum = numbers.iter().fold(0., 0.);\n    for (i, &v) in numbers.iter().enumerate()\
    \ {\n        sum += v;\n        if i == 0 {\n            *v = (*v + 1.0) / 2.;\n\
    \        }\n        *v /= sum;\n    }\n    numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<({float}, &f64)>` closure, found `{float}`\n\
    \    --> /tmp/tmpydkap0di.rs:6:43\n     |\n6    |     let mut sum = numbers.iter().fold(0.,\
    \ 0.);\n     |                                  ----     ^^ expected an `FnMut<({float},\
    \ &f64)>` closure, found `{float}`\n     |                                  |\n\
    \     |                                  required by a bound introduced by this\
    \ call\n     |\n     = help: the trait `FnMut<({float}, &f64)>` is not implemented\
    \ for `{float}`\nnote: required by a bound in `fold`\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpydkap0di.rs:10:13\n   |\n10 |        \
    \     *v = (*v + 1.0) / 2.;\n   |             ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpydkap0di.rs:10:19\n   |\n10 |             *v\
    \ = (*v + 1.0) / 2.;\n   |                   ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpydkap0di.rs:12:9\n   |\n12 |         *v /= sum;\n\
    \   |         ^^\n   |\nhelp: parentheses are required to parse this as an expression\n\
    \   |\n9  ~         (if i == 0 {\n10 |             *v = (*v + 1.0) / 2.;\n11 ~\
    \         })\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // find the min and max numbers\n    let min = numbers[0];\n    let max =\
    \ numbers[0];\n    for num in numbers {\n        if num < min {\n            min\
    \ = num;\n        }\n        if num > max {\n            max = num;\n        }\n\
    \    }\n    // scale to the range [0, 1]\n    let mut scaled_numbers = Vec::with_capacity(numbers.len());\n\
    \    for num in numbers {\n        if num < min {\n            scaled_numbers.push((num\
    \ - min) / (max - min));\n        }\n        else {\n            scaled_numbers.push((num\
    \ - min) / (max - min));\n        }\n    }\n    scaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `min`\n  --> /tmp/tmp0hgvha7f.rs:11:13\n\
    \   |\n7  |     let min = numbers[0];\n   |         ---\n   |         |\n   |\
    \         first assignment to `min`\n   |         help: consider making this binding\
    \ mutable: `mut min`\n...\n11 |             min = num;\n   |             ^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `max`\n  --> /tmp/tmp0hgvha7f.rs:14:13\n   |\n8  |   \
    \  let max = numbers[0];\n   |         ---\n   |         |\n   |         first\
    \ assignment to `max`\n   |         help: consider making this binding mutable:\
    \ `mut max`\n...\n14 |             max = num;\n   |             ^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \   --> /tmp/tmp0hgvha7f.rs:18:49\n    |\n5   | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n9   | \
    \    for num in numbers {\n    |                ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n18  |     let mut scaled_numbers\
    \ = Vec::with_capacity(numbers.len());\n    |                                \
    \                 ^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `numbers`\nhelp:\
    \ consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n9   |     for num in &numbers {\n    |         \
    \       +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0382, E0384.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() > 2 {\n        numbers[2..] / (numbers[0..2].max() + numbers[0..2].min())\n\
    \    } else {\n        numbers\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `max` exists for slice `[f64]`, but its trait\
    \ bounds were not satisfied\n --> /tmp/tmpjz31_zf4.rs:7:39\n  |\n7 |         numbers[2..]\
    \ / (numbers[0..2].max() + numbers[0..2].min())\n  |                         \
    \              ^^^ method cannot be called on `[f64]` due to unsatisfied trait\
    \ bounds\n  |\n  = note: the following trait bounds were not satisfied:\n    \
    \      `f64: Ord`\n          which is required by `[f64]: Ord`\n          `[f64]:\
    \ Ord`\n          which is required by `&[f64]: Ord`\n          `[f64]: Ord`\n\
    \          which is required by `&mut [f64]: Ord`\n          `[f64]: Iterator`\n\
    \          which is required by `&mut [f64]: Iterator`\n\nerror[E0599]: the method\
    \ `min` exists for slice `[f64]`, but its trait bounds were not satisfied\n -->\
    \ /tmp/tmpjz31_zf4.rs:7:61\n  |\n7 |         numbers[2..] / (numbers[0..2].max()\
    \ + numbers[0..2].min())\n  |                                                \
    \             ^^^ method cannot be called on `[f64]` due to unsatisfied trait\
    \ bounds\n  |\n  = note: the following trait bounds were not satisfied:\n    \
    \      `f64: Ord`\n          which is required by `[f64]: Ord`\n          `[f64]:\
    \ Ord`\n          which is required by `&[f64]: Ord`\n          `[f64]: Ord`\n\
    \          which is required by `&mut [f64]: Ord`\n          `[f64]: Iterator`\n\
    \          which is required by `&mut [f64]: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n\n    for x in\
    \ numbers {\n        if x < min {\n            min = x;\n        }\n        if\
    \ x > max {\n            max = x;\n        }\n    }\n\n    let scale = 1.0 / (max\
    \ - min);\n    let mut result = Vec::with_capacity(numbers.len() * 2);\n    for\
    \ &x in numbers {\n        result.push((x - min) * scale);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2xnr2agz.rs:20:9\n   |\n\
    20 |     for &x in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n    let mut sum:\
    \ f64 = numbers[0] as f64;\n    for &n in &numbers {\n        sum += n;\n    }\n\
    \    let mut scale: f64 = 1.0 / (sum * 2.0);\n    let mut result: Vec<f64> = Vec::new();\n\
    \    for &n in &numbers {\n        result.push((n - sum) * scale);\n        scale\
    \ = 1.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-0.48144712430426717, -4.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpwr5b2w3w.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n\n  \
    \  for n in numbers {\n        let delta = n - min;\n        min = std::cmp::min(min,\
    \ n);\n        max = std::cmp::max(max, n);\n        if delta == 0.0 {\n     \
    \       break;\n        }\n    }\n    let mut scaled_numbers = Vec::new();\n \
    \   for n in numbers {\n        if n == min {\n            scaled_numbers.insert(0,\
    \ 0.);\n        } else {\n            scaled_numbers.push((n - min) / (max - min));\n\
    \        }\n    }\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp42lfloux.rs:11:15\n\
    \     |\n11   |         min = std::cmp::min(min, n);\n     |               ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::cmp::min`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmp42lfloux.rs:12:15\n     |\n12   |         max\
    \ = std::cmp::max(max, n);\n     |               ^^^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |\n     = help: the following other types\
    \ implement trait `Ord`:\n               i128\n               i16\n          \
    \     i32\n               i64\n               i8\n               isize\n     \
    \          u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::cmp::max`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut smallest: f64 = numbers[0];\n    let mut largest: f64 = numbers[0];\n\
    \    for i in numbers.iter() {\n        if i < smallest {\n            smallest\
    \ = i;\n        }\n        if i > largest {\n            largest = i;\n      \
    \  }\n    }\n    numbers.iter().map(|x| smallest).collect::<Vec<_>>().reverse().push(largest)\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8174t425.rs:9:16\n  |\n9 |\
    \         if i < smallest {\n  |                ^^^^^^^^\n  |                |\n\
    \  |                expected `&f64`, found `f64`\n  |                help: consider\
    \ borrowing here: `&smallest`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8174t425.rs:10:24\n\
    \   |\n6  |     let mut smallest: f64 = numbers[0];\n   |                    \
    \   --- expected due to this type\n...\n10 |             smallest = i;\n   | \
    \                       ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n10 |             smallest = *i;\n   |                    \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8174t425.rs:12:16\n  \
    \ |\n12 |         if i > largest {\n   |                ^^^^^^^\n   |        \
    \        |\n   |                expected `&f64`, found `f64`\n   |           \
    \     help: consider borrowing here: `&largest`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8174t425.rs:13:23\n   |\n7  |     let mut largest: f64 = numbers[0];\n\
    \   |                      --- expected due to this type\n...\n13 |          \
    \   largest = i;\n   |                       ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n13 |             largest\
    \ = *i;\n   |                       +\n\nerror[E0599]: no method named `push`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmp8174t425.rs:16:68\n\
    \   |\n16 |     numbers.iter().map(|x| smallest).collect::<Vec<_>>().reverse().push(largest)\n\
    \   |                                                                    ^^^^\
    \ method not found in `()`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = Vec::with_capacity(numbers.len());\n    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n    for &i in numbers {\n\
    \        if i < smallest {\n            smallest = i;\n        }\n        if i\
    \ > largest {\n            largest = i;\n        }\n        result.push((i - smallest)\
    \ / (largest - smallest));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8cj1r48k.rs:9:9\n  |\n9 |\
    \     for &i in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `i`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled_numbers = Vec::with_capacity(numbers.len());\n    for number\
    \ in numbers {\n        rescaled_numbers.push((number - numbers.min()) / (numbers.max()\
    \ - numbers.min()));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpuu3f5d3h.rs:8:49\n    |\n8   |   \
    \        rescaled_numbers.push((number - numbers.min()) / (numbers.max() - numbers.min()));\n\
    \    |                                                   ^^^ method cannot be\
    \ called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `f64: Ord`\n       \
    \     which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n    \
    \        which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmpuu3f5d3h.rs:8:67\n    |\n8   |          \
    \ rescaled_numbers.push((number - numbers.min()) / (numbers.max() - numbers.min()));\n\
    \    |                                                                     ^^^\
    \ method cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `f64:\
    \ Ord`\n            which is required by `Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Ord`\n            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Ord`\n            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0].abs();\n    let mut max = numbers[0].abs();\n  \
    \  for &n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let scale:\
    \ f64 = max - min;\n    let mut i = 0;\n    for &n in numbers {\n        *n /=\
    \ scale;\n        numbers[i] = *n;\n        i += 1;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp69z5l8_0.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp69z5l8_0.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut largest = numbers[0];\n    let mut smallest = numbers[0];\n    for\
    \ i in numbers.iter() {\n        if *i <= 0 {\n            *i *= -1.0;\n     \
    \   } else {\n            if *i > largest {\n                largest = *i;\n \
    \           }\n            if *i < smallest {\n                smallest = *i;\n\
    \            }\n        }\n    }\n\n    let mut scale = smallest as f64 / largest\
    \ as f64;\n    for i in numbers.iter() {\n        *i *= scale;\n    }\n\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp61waj633.rs:9:18\n  |\n9 |\
    \         if *i <= 0 {\n  |                  ^\n  |                  |\n  |  \
    \                expected `f64`, found integer\n  |                  help: use\
    \ a float literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n    let smallest\
    \ = numbers.iter().min_by_key(|x| x);\n    let largest = numbers.iter().max_by_key(|x|\
    \ x);\n    let min_range = largest - smallest;\n    let min_range_float = min_range\
    \ as f64;\n    let min_range_float_ceil = std::ceilf(min_range_float);\n    let\
    \ max_range_float = largest as f64;\n    let max_range_float_floor = std::floorf(max_range_float);\n\
    \    let mut new_numbers = Vec::new();\n    for i in 0..numbers.len() {\n    \
    \    if numbers[i] >= min_range_float_ceil {\n            new_numbers.push(numbers[i]\
    \ - min_range_float_ceil);\n        } else if numbers[i] <= max_range_float_floor\
    \ {\n            new_numbers.push(numbers[i] + min_range_float_ceil);\n      \
    \  } else {\n            new_numbers.push(numbers[i]);\n        }\n    }\n   \
    \ return new_numbers;\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ceilf` in crate `std`\n  --> /tmp/tmpwg50vba7.rs:13:37\n\
    \   |\n13 |     let min_range_float_ceil = std::ceilf(min_range_float);\n   |\
    \                                     ^^^^^ not found in `std`\n\nerror[E0425]:\
    \ cannot find function `floorf` in crate `std`\n  --> /tmp/tmpwg50vba7.rs:15:38\n\
    \   |\n15 |     let max_range_float_floor = std::floorf(max_range_float);\n  \
    \ |                                      ^^^^^^ not found in `std`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpwg50vba7.rs:9:46\n\
    \     |\n9    |     let smallest = numbers.iter().min_by_key(|x| x);\n     | \
    \                                  ---------- ^^^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |                                   |\n     |              \
    \                     required by a bound introduced by this call\n     |\n  \
    \   = help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n     = note: 1 redundant requirement hidden\n     = note: required\
    \ because of the requirements on the impl of `Ord` for `&&f64`\nnote: required\
    \ by a bound in `std::iter::Iterator::min_by_key`\n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmpwg50vba7.rs:10:45\n     |\n10 \
    \  |     let largest = numbers.iter().max_by_key(|x| x);\n     |             \
    \                     ---------- ^^^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |                                  |\n     |                   \
    \               required by a bound introduced by this call\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requ"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut scaled_numbers = numbers;\n\n    scaled_numbers.sort_unstable();\n\
    \n    for num in &mut scaled_numbers {\n        *num = num / scaled_numbers[scaled_numbers.len()\
    \ - 1];\n    }\n\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpeitk0vdv.rs:8:20\n\
    \     |\n8    |     scaled_numbers.sort_unstable();\n     |                  \
    \  ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n     =\
    \ help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\
    \nerror[E0369]: cannot divide `&mut f64` by `f64`\n  --> /tmp/tmpeitk0vdv.rs:11:20\n\
    \   |\n11 |         *num = num / scaled_numbers[scaled_numbers.len() - 1];\n \
    \  |                --- ^ ---------------------------------------- f64\n   | \
    \               |\n   |                &mut f64\n   |\nhelp: `/` can be used on\
    \ `f64`, you can dereference `num`\n   |\n11 |         *num = *num / scaled_numbers[scaled_numbers.len()\
    \ - 1];\n   |                +\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() == 0 {\n        return vec![1.0f64];\n    }\n\n    let mut\
    \ min_val = numbers[0];\n    let mut max_val = numbers[0];\n\n    for i in numbers.iter().rev()\
    \ {\n        if i < min_val {\n            min_val = i;\n        }\n        if\
    \ i > max_val {\n            max_val = i;\n        }\n    }\n\n    let mut scale\
    \ = 1.0f64;\n    while max_val - min_val >= 1.0f64 {\n        scale *= 1.0f64;\n\
    \    }\n\n    let mut offset = 0.0;\n\n    for i in numbers.iter().rev() {\n \
    \       offset += i;\n    }\n\n    let mut res = vec![0.0f64];\n\n    for i in\
    \ numbers.iter().rev() {\n        let f = (i - offset) * scale;\n        if f\
    \ < 0.0 {\n            res.push(-f);\n        } else {\n            res.push(f);\n\
    \        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmhs8nb1l.rs:14:16\n   |\n\
    14 |         if i < min_val {\n   |                ^^^^^^^\n   |             \
    \   |\n   |                expected `&f64`, found `f64`\n   |                help:\
    \ consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmhs8nb1l.rs:15:23\n   |\n10 |     let mut min_val = numbers[0];\n  \
    \ |                       ---------- expected due to this value\n...\n15 |   \
    \          min_val = i;\n   |                       ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |             min_val\
    \ = *i;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmhs8nb1l.rs:17:16\n   |\n17 |         if i > max_val {\n   |       \
    \         ^^^^^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&max_val`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmhs8nb1l.rs:18:23\n   |\n11 |\
    \     let mut max_val = numbers[0];\n   |                       ---------- expected\
    \ due to this value\n...\n18 |             max_val = i;\n   |                \
    \       ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n18 |             max_val = *i;\n   |                       +\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    numbers\n        .iter()\n        .map(|x| x\
    \ - (delta as f64) / (x as f64))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1_8256wq.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1_8256wq.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0606]: casting `&f64` as `f64` is invalid\n  --> /tmp/tmp1_8256wq.rs:11:39\n\
    \   |\n11 |         .map(|x| x - (delta as f64) / (x as f64))\n   |          \
    \                             ^-^^^^^^^^\n   |                               \
    \        ||\n   |                                       |help: dereference the\
    \ expression: `*x`\n   |                                       cannot cast `&f64`\
    \ as `f64`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0606.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().fold(0.0, |result, value| result * value / numbers.last().unwrap())\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfimg70bx.rs:6:25\n  |\n6 |\
    \     numbers.iter().fold(0.0, |result, value| result * value / numbers.last().unwrap())\n\
    \  |                         ^^^ expected struct `Vec`, found floating-point number\n\
    \  |\n  = note: expected struct `Vec<f64>`\n               found type `{float}`\n\
    \nerror[E0369]: cannot multiply `Vec<f64>` by `&f64`\n --> /tmp/tmpfimg70bx.rs:6:53\n\
    \  |\n6 |     numbers.iter().fold(0.0, |result, value| result * value / numbers.last().unwrap())\n\
    \  |                                              ------ ^ ----- &f64\n  |   \
    \                                           |\n  |                           \
    \                   Vec<f64>\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n\n    for\
    \ n in numbers.iter() {\n        let r = n - min;\n        min = std::f64::MAX;\n\
    \        max = std::f64::MIN;\n        if r > 0.0 {\n            min += r;\n \
    \       }\n        if r < 0.0 {\n            max -= r;\n        }\n    }\n\n \
    \   if min > std::f64::MIN {\n        numbers.iter_mut().cloned().for_each(|x|\
    \ {\n            if x < min {\n                *x = min as f64;\n            }\n\
    \        });\n    }\n\n    if max < std::f64::MAX {\n        numbers.iter_mut().cloned().for_each(|x|\
    \ {\n            if x > max {\n                *x = max as f64;\n            }\n\
    \        });\n    }\n\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::IterMut<'_, f64> as\
    \ Iterator>::Item == &_`\n    --> /tmp/tmpgjon5lqd.rs:22:28\n     |\n22   |  \
    \       numbers.iter_mut().cloned().for_each(|x| {\n     |                   \
    \         ^^^^^^ types differ in mutability\n     |\n     = note:      expected\
    \ reference `&_`\n             found mutable reference `&mut f64`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `for_each` exists for struct\
    \ `Cloned<std::slice::IterMut<'_, f64>>`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmpgjon5lqd.rs:22:37\n    |\n22  |           numbers.iter_mut().cloned().for_each(|x|\
    \ {\n    |                                       ^^^^^^^^ method cannot be called\
    \ on `Cloned<std::slice::IterMut<'_, f64>>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `<std::slice::IterMut<'_, f64> as Iterator>::Item = &_`\n            which\
    \ is required by `Cloned<std::slice::IterMut<'_, f64>>: Iterator`\n          \
    \  `Cloned<std::slice::IterMut<'_, f64>>: Iterator`\n            which is required\
    \ by `&mut Cloned<std::slice::IterMut<'_, f64>>: Iterator`\n\nerror[E0271]: type\
    \ mismatch resolving `<std::slice::IterMut<'_, f64> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpgjon5lqd.rs:30:28\n     |\n30   |         numbers.iter_mut().cloned().for_each(|x|\
    \ {\n     |                            ^^^^^^ types differ in mutability\n   \
    \  |\n     = note:      expected reference `&_`\n             found mutable reference\
    \ `&mut f64`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `for_each` exists for struct `Cloned<std::slice::IterMut<'_, f64>>`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmpgjon5lqd.rs:30:37\n    |\n30\
    \  |           numbers.iter_mut().cloned().for_each(|x| {\n    |             \
    \                          ^^^^^^^^ method cannot be called on `Cloned<std::slice::IterMut<'_,\
    \ f64>>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `<std::slice::IterMut<'_, f64> as Iterator>::"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers[0];\n    let max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n\n    let mut numbers: Vec<f64> = Vec::new();\n\
    \    let mut current: f64 = min;\n    for n in numbers {\n        if n == current\
    \ {\n            numbers.push((n - min) / (max - min));\n        } else {\n  \
    \          numbers.push(n);\n            current = n;\n        }\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `min`\n  --> /tmp/tmp_k085px7.rs:10:13\n\
    \   |\n6  |     let min = numbers[0];\n   |         ---\n   |         |\n   |\
    \         first assignment to `min`\n   |         help: consider making this binding\
    \ mutable: `mut min`\n...\n10 |             min = n;\n   |             ^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `max`\n  --> /tmp/tmp_k085px7.rs:13:13\n   |\n7  |   \
    \  let max = numbers[0];\n   |         ---\n   |         |\n   |         first\
    \ assignment to `max`\n   |         help: consider making this binding mutable:\
    \ `mut max`\n...\n13 |             max = n;\n   |             ^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \   --> /tmp/tmp_k085px7.rs:21:13\n    |\n17  |     let mut numbers: Vec<f64>\
    \ = Vec::new();\n    |         ----------- move occurs because `numbers` has type\
    \ `Vec<f64>`, which does not implement the `Copy` trait\n18  |     let mut current:\
    \ f64 = min;\n19  |     for n in numbers {\n    |              ------- `numbers`\
    \ moved due to this implicit call to `.into_iter()`\n20  |         if n == current\
    \ {\n21  |             numbers.push((n - min) / (max - min));\n    |         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n  \
    \  |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0384.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers\n        .iter()\n        .map(|x| x / numbers.len() as f64)\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 24.95]`,\n right: `[0.0, 1.0]`', /tmp/tmproamo4mo.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut out = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n        out.push((n - smallest) / (largest - smallest));\n\
    \    }\n    out\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[NaN, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpq7zyr8y_.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // If the numbers are all the same, we do no rescaling\n    if numbers.len()\
    \ == 1 {\n        return vec![numbers[0]];\n    }\n    // If the numbers are all\
    \ the same, rescale them such that they sum to one\n    // This assumes that if\
    \ they are the same, that they are evenly distributed in some way\n    let mut\
    \ sum = numbers[0];\n    for i in 1..numbers.len() {\n        sum += numbers[i];\n\
    \    }\n    if sum < 1.0f64 {\n        let factor = (1.0f64 / sum);\n        for\
    \ i in 0..numbers.len() {\n            numbers[i] *= factor;\n        }\n    }\n\
    \    return numbers;\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp8ebstr49.rs:17:22\n\
    \   |\n17 |         let factor = (1.0f64 / sum);\n   |                      ^\
    \            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n17 -         let factor = (1.0f64 / sum);\n\
    17 +         let factor = 1.0f64 / sum;\n   | \n\nerror[E0596]: cannot borrow\
    \ `numbers` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8ebstr49.rs:19:13\n\
    \   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |        \
    \            ------- help: consider changing this to be mutable: `mut numbers`\n\
    ...\n19 |             numbers[i] *= factor;\n   |             ^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter()\n        .map(|x| x / numbers[0])\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 24.95]`,\n right: `[0.0, 1.0]`', /tmp/tmp8g0in350.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &x in numbers\
    \ {\n        if x < min {\n            min = x;\n        }\n        if x > max\
    \ {\n            max = x;\n        }\n    }\n    let mut new_min = min * 0.5;\n\
    \    let mut new_max = max * 0.5;\n\n    if new_min < 0.0 && new_max < 0.0 {\n\
    \        new_min = min;\n        new_max = max;\n    }\n\n    let mut rescaled_numbers\
    \ = Vec::with_capacity(numbers.len());\n    for (i, &x) in numbers.iter().enumerate()\
    \ {\n        rescaled_numbers.push(\n            (x - min) / (max - min) * (new_max\
    \ - new_min) + new_min,\n        );\n    }\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpa4c1iupl.rs:8:9\n  |\n8 |\
    \     for &x in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `x`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // TODO: consider making `min` a parameter of the function, so that\n   \
    \ // `min` can be set arbitrarily.\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let mut scaled_numbers = Vec::new();\n\
    \    for (index, number) in numbers.iter().enumerate() {\n        let new_number\
    \ = (number - min) / (max - min);\n        scaled_numbers.push(new_number);\n\
    \    }\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp82w_rjg1.rs:8:30\n\
    \     |\n8    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp82w_rjg1.rs:9:30\n\
    \     |\n9    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let mut rescaled\
    \ = numbers;\n    let mut total = 0;\n    for i in rescaled {\n        total +=\
    \ i;\n    }\n\n    for i in rescaled {\n        rescaled.push((total - i) / total);\n\
    \    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpo5hij6ad.rs:13:15\n\
    \   |\n13 |         total += i;\n   |               ^^ no implementation for `{integer}\
    \ += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot subtract `f64` from `{integer}`\n  --> /tmp/tmpo5hij6ad.rs:17:30\n\
    \   |\n17 |         rescaled.push((total - i) / total);\n   |                \
    \              ^ no implementation for `{integer} - f64`\n   |\n   = help: the\
    \ trait `Sub<f64>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for x in numbers\
    \ {\n        if x < min {\n            min = x;\n        }\n        if x > max\
    \ {\n            max = x;\n        }\n    }\n\n    (0..numbers.len()).for_each(|i|\
    \ numbers[i] = numbers[i] - min) / (max - min);\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmpl8n34i5m.rs:17:68\n\
    \   |\n17 |     (0..numbers.len()).for_each(|i| numbers[i] = numbers[i] - min)\
    \ / (max - min);\n   |     --------------------------------------------------------------\
    \ ^ ----------- f64\n   |     |\n   |     ()\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut smallest = None;\n    let mut largest = None;\n    for n in numbers\
    \ {\n        if let Some(n) = smallest {\n            smallest = Some(n as f64\
    \ / n);\n        } else {\n            smallest = Some(n);\n        }\n      \
    \  if let Some(n) = largest {\n            largest = Some(n as f64 / n);\n   \
    \     } else {\n            largest = Some(n);\n        }\n    }\n    if let Some(smallest)\
    \ = smallest {\n        numbers.iter_mut().for_each(|x| x = x * smallest);\n \
    \   }\n    if let Some(largest) = largest {\n        numbers.iter_mut().for_each(|x|\
    \ x = x / largest);\n    }\n    numbers\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot multiply `&mut f64` by `f64`\n  --> /tmp/tmp0298kpxr.rs:21:47\n\
    \   |\n21 |         numbers.iter_mut().for_each(|x| x = x * smallest);\n   | \
    \                                            - ^ -------- f64\n   |          \
    \                                   |\n   |                                  \
    \           &mut f64\n   |\nhelp: `*` can be used on `f64`, you can dereference\
    \ `x`\n   |\n21 |         numbers.iter_mut().for_each(|x| x = *x * smallest);\n\
    \   |                                             +\n\nerror[E0369]: cannot divide\
    \ `&mut f64` by `f64`\n  --> /tmp/tmp0298kpxr.rs:24:47\n   |\n24 |         numbers.iter_mut().for_each(|x|\
    \ x = x / largest);\n   |                                             - ^ -------\
    \ f64\n   |                                             |\n   |              \
    \                               &mut f64\n   |\nhelp: `/` can be used on `f64`,\
    \ you can dereference `x`\n   |\n24 |         numbers.iter_mut().for_each(|x|\
    \ x = *x / largest);\n   |                                             +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled: Vec<f64> = vec![];\n    let smallest = numbers.iter().min();\n\
    \    let largest = numbers.iter().max();\n\n    for i in numbers.iter() {\n  \
    \      let ratio = i as f64 / largest as f64;\n        if ratio < 1.0 {\n    \
    \        rescaled.push(smallest);\n        } else {\n            rescaled.push(largest);\n\
    \        }\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmplqacmhio.rs:7:35\n\
    \     |\n7    |     let smallest = numbers.iter().min();\n     |             \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n    \
    \ |\n     = help: the following other types implement trait `Ord`:\n         \
    \      i128\n               i16\n               i32\n               i64\n    \
    \           i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmplqacmhio.rs:8:34\n\
    \     |\n8    |     let largest = numbers.iter().max();\n     |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplqacmhio.rs:13:27\n   |\n13 |\
    \             rescaled.push(smallest);\n   |                           ^^^^^^^^\
    \ expected `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n\
    \              found enum `Option<&f64>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmplqacmhio.rs:15:27\n   |\n15 |             rescaled.push(largest);\n\
    \   |                           ^^^^^^^ expected `f64`, found enum `Option`\n\
    \   |\n   = note: expected type `f64`\n              found enum `Option<&f64>`\n\
    \nerror[E0606]: casting `&f64` as `f64` is invalid\n  --> /tmp/tmplqacmhio.rs:11:21\n\
    \   |\n11 |         let ratio = i as f64 / largest as f64;\n   |             \
    \        -^^^^^^^\n   |                     |\n   |                     cannot\
    \ cast `&f64` as `f64`\n   |                    "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter()\n        .cloned()\n        .map(|number| number / number.min())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmps_irippc.rs:8:39\n    |\n8   |         .map(|number| number /\
    \ number.min())\n    |                                       ^^^- supplied 0 arguments\n\
    \    |                                       |\n    |                        \
    \               expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers\n        .iter()\n        .min(|a, b| a.abs() < b.abs())\n      \
    \  .unwrap()\n        .map(|n| n / numbers.len())\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2ivu7sau.rs:8:10\n\
    \     |\n8    |         .min(|a, b| a.abs() < b.abs())\n     |          ^^^ the\
    \ trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\nnote:\
    \ required by a bound in `std::iter::Iterator::min`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp2ivu7sau.rs:8:10\n\
    \     |\n8    |         .min(|a, b| a.abs() < b.abs())\n     |          ^^^ ------------------------\
    \ supplied 1 argument\n     |          |\n     |          expected 0 arguments\n\
    \     |\nnote: associated function defined here\n\nerror[E0599]: `&f64` is not\
    \ an iterator\n  --> /tmp/tmp2ivu7sau.rs:10:10\n   |\n10 |         .map(|n| n\
    \ / numbers.len())\n   |          ^^^ `&f64` is not an iterator\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `&f64: Iterator`\n\
    \           which is required by `&mut &f64: Iterator`\n           `f64: Iterator`\n\
    \           which is required by `&mut f64: Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0]; // the minimum is arbitrarily zero\n    let mut\
    \ max = numbers[0]; // the maximum is arbitrarily zero\n\n    for number in numbers\
    \ {\n        // if the new min is less than the current max,\n        // update\
    \ it\n        if min > number {\n            min = number;\n        }\n\n    \
    \    // otherwise, the new max is greater than the current max,\n        // so\
    \ just update the max with the current min\n        // so that we stay as close\
    \ to the original numbers as possible\n        // NOTE: this does not ensure that\
    \ the new min is always 0,\n        // it just ensures that the new min is close\
    \ to the original min\n        if max < number {\n            max = number;\n\
    \        }\n    }\n\n    // now the max and min are close to the original min,\
    \ max\n    // but we need to scale them so that the largest value becomes 1 and\
    \ the\n    // smallest value becomes 0\n    let mut scale = 1.0 / (max - min);\n\
    \    for number in numbers {\n        let new_number = number - min;\n       \
    \ new_number = new_number * scale;\n        new_number += min;\n        new_number\
    \ = new_number / scale;\n        numbers.push(new_number);\n    }\n\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpjjykc68x.rs:29:9\n\
    \   |\n29 |     let mut scale = 1.0 / (max - min);\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjjykc68x.rs:30:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n9   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n30  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n9   |     for number in &numbers {\n    |                   +\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `new_number`\n  --> /tmp/tmpjjykc68x.rs:32:9\n\
    \   |\n31 |         let new_number = number - min;\n   |             ----------\n\
    \   |             |\n   |             first assignment to `new_number`\n   | \
    \            help: consider making this binding mutable: `mut new_number`\n32\
    \ |         new_number = new_number * scale;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `new_number`\n  --> /tmp/tmpjjykc68x.rs:33:9\n   |\n31\
    \ |         let new_number = number - min;\n   |             ----------\n   |\
    \             |\n   |             first assignment to `new_number`\n   |     \
    \        help: consider making this binding mutable: `mut new_number`\n32 |  \
    \       new_number = new_number * scale;\n33 |         new_number += min;\n  \
    \ |         ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `new_number`\n  --> /tmp/tmpjjykc68x.rs:34:9\n\
    \   |\n31 "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() <= 1 {\n        numbers\n    } else {\n        let min_val\
    \ = numbers.iter().min().unwrap();\n        let max_val = numbers.iter().max().unwrap();\n\
    \        numbers.iter().map(|x| x / max_val * 2 - 1).collect()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpm5pzmafk.rs:9:38\n\
    \     |\n9    |         let min_val = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpm5pzmafk.rs:10:38\n\
    \     |\n10   |         let max_val = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: cannot multiply `f64` by `{integer}`\n  --> /tmp/tmpm5pzmafk.rs:11:44\n\
    \   |\n11 |         numbers.iter().map(|x| x / max_val * 2 - 1).collect()\n  \
    \ |                                            ^ no implementation for `f64 *\
    \ {integer}`\n   |\n   = help: the trait `Mul<{integer}>` is not implemented for\
    \ `f64`\n   = help: the following other types implement trait `Mul<Rhs>`:\n  \
    \           <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n      \
    \       <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n        \
    \     <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n            \
    \ <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n1"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        numbers\n    } else {\n        let mut min:\
    \ f64 = numbers[0] as f64;\n        let mut max: f64 = numbers[0] as f64;\n  \
    \      for i in numbers {\n            if i < min {\n                min = i;\n\
    \            }\n            if i > max {\n                max = i;\n         \
    \   }\n        }\n\n        let mut rescale = (max - min) as f64;\n        for\
    \ i in numbers {\n            i as f64 / rescale\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrr9dfm6.rs:22:13\n   |\n\
    22 |             i as f64 / rescale\n   |             ^^^^^^^^^^^^^^^^^^ expected\
    \ `()`, found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsrr9dfm6.rs:21:9\n\
    \   |\n5  |   fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |      \
    \                                      -------- expected `Vec<f64>` because of\
    \ return type\n...\n21 | /         for i in numbers {\n22 | |             i as\
    \ f64 / rescale\n23 | |         }\n   | |_________^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<f64>`\n           found unit type\
    \ `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers.iter().min().unwrap();\n    let mut max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter_mut().for_each(|n| {\n        *n\
    \ -= min;\n        *n /= range;\n    });\n    numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmprt5m5etc.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmprt5m5etc.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut range = [numbers[0], numbers[0]];\n    for number in numbers.iter().skip(1).rev()\
    \ {\n        range[1] = number;\n        if number < range[0] {\n            range[0]\
    \ = number;\n        }\n    }\n    let mid = range[0] + range[1] / 2;\n    let\
    \ scale = mid.abs() / range[1];\n    for number in numbers.iter() {\n        *number\
    \ /= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmxnt94ix.rs:8:20\n  |\n8 |\
    \         range[1] = number;\n  |         --------   ^^^^^^ expected `f64`, found\
    \ `&f64`\n  |         |\n  |         expected due to the type of this binding\n\
    \  |\nhelp: consider dereferencing the borrow\n  |\n8 |         range[1] = *number;\n\
    \  |                    +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmxnt94ix.rs:9:21\n\
    \  |\n9 |         if number < range[0] {\n  |                     ^^^^^^^^\n \
    \ |                     |\n  |                     expected `&f64`, found `f64`\n\
    \  |                     help: consider borrowing here: `&range[0]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmxnt94ix.rs:10:24\n   |\n10 |             range[0]\
    \ = number;\n   |             --------   ^^^^^^ expected `f64`, found `&f64`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n10 |             range[0]\
    \ = *number;\n   |                        +\n\nerror[E0277]: cannot divide `f64`\
    \ by `{integer}`\n  --> /tmp/tmpmxnt94ix.rs:13:35\n   |\n13 |     let mid = range[0]\
    \ + range[1] / 2;\n   |                                   ^ no implementation\
    \ for `f64 / {integer}`\n   |\n   = help: the trait `Div<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n13 |     let mid = range[0] + range[1] / 2.0;\n   |            \
    \                          ++\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut minimum: f64 = numbers[0];\n    let mut maximum: f64 = numbers[0];\n\
    \    for x in numbers.iter_mut() {\n        *x = f64::min(x.clone(), maximum);\n\
    \        *x = f64::max(x.clone(), minimum);\n        maximum = *x;\n        minimum\
    \ = *x;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n --> /tmp/tmp__lu3cdu.rs:8:14\n  |\n5 | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n  |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n8 |     for x in numbers.iter_mut()\
    \ {\n  |              ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers[0];\n    let max = numbers[0];\n\n    for n in numbers.iter_mut()\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    numbers\n        .iter()\n  \
    \      .map(|n| n - min) / (max - min)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgu21d2s1.rs:10:16\n   |\n\
    10 |         if n < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&mut f64`, found `f64`\n   |                help:\
    \ consider mutably borrowing here: `&mut min`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgu21d2s1.rs:11:19\n   |\n6  |     let min = numbers[0];\n   | \
    \              ---------- expected due to this value\n...\n11 |             min\
    \ = n;\n   |                   ^ expected `f64`, found `&mut f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n11 |             min = *n;\n   |  \
    \                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgu21d2s1.rs:13:16\n\
    \   |\n13 |         if n > max {\n   |                ^^^\n   |              \
    \  |\n   |                expected `&mut f64`, found `f64`\n   |             \
    \   help: consider mutably borrowing here: `&mut max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgu21d2s1.rs:14:19\n   |\n7  |     let max = numbers[0];\n\
    \   |               ---------- expected due to this value\n...\n14 |         \
    \    max = n;\n   |                   ^ expected `f64`, found `&mut f64`\n   |\n\
    help: consider dereferencing the borrow\n   |\n14 |             max = *n;\n  \
    \ |                   +\n\nerror[E0599]: `f64` is not an iterator\n  --> /tmp/tmpgu21d2s1.rs:20:10\n\
    \   |\n20 |         .collect()\n   |          ^^^^^^^ `f64` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `f64:\
    \ Iterator`\n           which is required by `&mut f64: Iterator`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() <= 1 {\n        return numbers;\n    }\n    let mut result\
    \ = Vec::new();\n    let min: f64 = numbers[0];\n    let max: f64 = numbers[0];\n\
    \    for n in numbers.iter() {\n        if n < min {\n            min = n;\n \
    \       }\n        if n > max {\n            max = n;\n        }\n    }\n    //\
    \ scale to unit interval first\n    for n in numbers.iter() {\n        *n /= max\
    \ - min;\n        (*n - min) /= max - min;\n        result.push(*n);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt35t6ujg.rs:13:16\n   |\n\
    13 |         if n < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&f64`, found `f64`\n   |                help: consider\
    \ borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt35t6ujg.rs:14:19\n\
    \   |\n10 |     let min: f64 = numbers[0];\n   |              --- expected due\
    \ to this type\n...\n14 |             min = n;\n   |                   ^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14\
    \ |             min = *n;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt35t6ujg.rs:16:16\n   |\n16 |         if n > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt35t6ujg.rs:17:19\n   |\n11 |     let max: f64\
    \ = numbers[0];\n   |              --- expected due to this type\n...\n17 |  \
    \           max = n;\n   |                   ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             max = *n;\n\
    \   |                   +\n\nerror[E0067]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpt35t6ujg.rs:23:20\n   |\n23 |         (*n - min) /= max - min;\n\
    \   |         ---------- ^^\n   |         |\n   |         cannot assign to this\
    \ expression\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0067, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.is_empty() {\n        return vec![];\n    }\n    let mut min_value\
    \ = numbers[0];\n    let mut max_value = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        let value = numbers[i] - min_value;\n        min_value = min_value.min(&value);\n\
    \        max_value = max_value.max(&value);\n    }\n    vec![min_value, max_value]\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo2hhowcj.rs:13:35\n   |\n\
    13 |         min_value = min_value.min(&value);\n   |                        \
    \           ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n13 -         min_value = min_value.min(&value);\n13 +    \
    \     min_value = min_value.min(value);\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo2hhowcj.rs:14:35\n   |\n14 |         max_value = max_value.max(&value);\n\
    \   |                                   ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider removing the borrow\n   |\n14 -         max_value = max_value.max(&value);\n\
    14 +         max_value = max_value.max(value);\n   | \n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() == 0 {\n        numbers\n    } else {\n        let mut min\
    \ = numbers[0];\n        let mut max = numbers[0];\n        for &x in &numbers\
    \ {\n            if x < min {\n                min = x;\n            }\n     \
    \       if x > max {\n                max = x;\n            }\n        }\n   \
    \     let mut new_numbers = Vec::new();\n        let mut offset = max - min;\n\
    \        for &x in numbers {\n            let y = ((x - min) / offset) as f64;\n\
    \            new_numbers.push(*y);\n        }\n        new_numbers\n    }\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprvrphee_.rs:21:13\n   |\n\
    21 |         for &x in numbers {\n   |             ^^    ------- this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmprvrphee_.rs:23:30\n\
    \   |\n23 |             new_numbers.push(*y);\n   |                          \
    \    ^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for i in numbers.iter_mut()\
    \ {\n        *i = i / (*i).sqrt();\n        if *i < min {\n            min = 0.;\n\
    \        }\n        if *i > max {\n            max = 1;\n        }\n    }\n  \
    \  numbers.iter_mut().map(|x| x / max).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot divide `&mut f64` by `f64`\n --> /tmp/tmp9p6mf74t.rs:9:16\n\
    \  |\n9 |         *i = i / (*i).sqrt();\n  |              - ^ ----------- f64\n\
    \  |              |\n  |              &mut f64\n  |\nhelp: `/` can be used on\
    \ `f64`, you can dereference `i`\n  |\n9 |         *i = *i / (*i).sqrt();\n  |\
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9p6mf74t.rs:14:19\n\
    \   |\n7  |     let mut max = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n14 |             max = 1;\n   |                   ^\n\
    \   |                   |\n   |                   expected `f64`, found integer\n\
    \   |                   help: use a float literal: `1.0`\n\nerror[E0369]: cannot\
    \ divide `&mut f64` by `f64`\n  --> /tmp/tmp9p6mf74t.rs:17:34\n   |\n17 |    \
    \ numbers.iter_mut().map(|x| x / max).collect()\n   |                        \
    \        - ^ --- f64\n   |                                |\n   |            \
    \                    &mut f64\n   |\nhelp: `/` can be used on `f64`, you can dereference\
    \ `x`\n   |\n17 |     numbers.iter_mut().map(|x| *x / max).collect()\n   |   \
    \                             +\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0].clone() as f64;\n    let mut max = numbers[0].clone()\
    \ as f64;\n    for &n in &numbers[1..] {\n        if n > max {\n            max\
    \ = n.clone() as f64;\n        }\n        if n < min {\n            min = n.clone()\
    \ as f64;\n        }\n    }\n    Vec::from(numbers.iter()\n        .map(|n| min\
    \ + (n - min) / (max - min) as f64 * max as f64)\n        .collect::<Vec<_>>())\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 51.9]`,\n right: `[0.0, 1.0]`', /tmp/tmprgt7ong9.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut i = 0;\n    while i < numbers.len() {\n        if numbers[i] >= numbers.last_mut().unwrap()\
    \ {\n            numbers[i].set(0.0);\n        } else {\n            numbers[i].set(1.0).unwrap();\n\
    \        }\n        i += 1;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3qa9q3mr.rs:8:26\n  |\n8 |\
    \         if numbers[i] >= numbers.last_mut().unwrap() {\n  |                \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&mut f64`\n  |\n\
    help: consider dereferencing the borrow\n  |\n8 |         if numbers[i] >= *numbers.last_mut().unwrap()\
    \ {\n  |                          +\n\nerror[E0599]: no method named `set` found\
    \ for type `f64` in the current scope\n   --> /tmp/tmp3qa9q3mr.rs:9:24\n    |\n\
    9   |             numbers[i].set(0.0);\n    |                        ^^^ method\
    \ not found in `f64`\n    |\nhelp: consider wrapping the receiver expression with\
    \ the appropriate type\n    |\n9   |             Pin::new(&mut numbers[i]).set(0.0);\n\
    \    |             +++++++++++++           +\n\nerror[E0599]: no method named\
    \ `set` found for type `f64` in the current scope\n   --> /tmp/tmp3qa9q3mr.rs:11:24\n\
    \    |\n11  |             numbers[i].set(1.0).unwrap();\n    |               \
    \         ^^^ method not found in `f64`\n    |\nhelp: consider wrapping the receiver\
    \ expression with the appropriate type\n    |\n11  |             Pin::new(&mut\
    \ numbers[i]).set(1.0).unwrap();\n    |             +++++++++++++           +\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_max = numbers.iter().fold((numbers[0], numbers[0]), |(min, max),\
    \ num| {\n        (max as f64, (min as f64 + num as f64) / (max as f64 as f64\
    \ + 1))\n    });\n\n    (0..numbers.len() as usize).map(|i| {\n        numbers[i]\
    \ / min_max\n    }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n --> /tmp/tmpjbdla_bt.rs:7:69\n\
    \  |\n7 |         (max as f64, (min as f64 + num as f64) / (max as f64 as f64\
    \ + 1))\n  |                                                                 \
    \    ^ no implementation for `f64 + {integer}`\n  |\n  = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `Add<Rhs>`:\n            <&'a f32 as Add<f32>>\n            <&'a f64 as\
    \ Add<f64>>\n            <&'a i128 as Add<i128>>\n            <&'a i16 as Add<i16>>\n\
    \            <&'a i32 as Add<i32>>\n            <&'a i64 as Add<i64>>\n      \
    \      <&'a i8 as Add<i8>>\n            <&'a isize as Add<isize>>\n          and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n  |\n7 |         (max as f64, (min as f64 + num as f64) / (max as f64\
    \ as f64 + 1.0))\n  |                                                        \
    \                ++\n\nerror[E0277]: cannot divide `f64` by `(f64, f64)`\n  -->\
    \ /tmp/tmpjbdla_bt.rs:11:20\n   |\n11 |         numbers[i] / min_max\n   |   \
    \                 ^ no implementation for `f64 / (f64, f64)`\n   |\n   = help:\
    \ the trait `Div<(f64, f64)>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n            \
    \ <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0606]: casting\
    \ `&f64` as `f64` is invalid\n --> /tmp/tmpjbdla_bt.rs:7:36\n  |\n7 |        \
    \ (max as f64, (min as f64 + num as f64) / (max as f64 as f64 + 1))\n  |     \
    \                               ---^^^^^^^\n  |                              \
    \      |\n  |                                    cannot cast `&f64` as `f64`\n\
    \  |                                    help: dereference the expression: `*num`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed expla"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    numbers.sort();\n    let mut lower = numbers[0];\n    let mut upper\
    \ = numbers[0];\n    let mut result = vec![0.0; numbers.len()];\n    for (i, &number)\
    \ in numbers.iter().enumerate() {\n        result[i] = number;\n        lower\
    \ = f64::min(lower, number);\n        upper = f64::max(upper, number);\n    }\n\
    \    let new_min = lower + ((upper * numbers.len() - lower) / (numbers.len() -\
    \ 1.0)).f64();\n    let new_max = upper;\n    result[0] = new_min;\n    result[result.len()\
    \ - 1] = new_max;\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpc71ta686.rs:10:13\n\
    \    |\n10  |     numbers.sort();\n    |             ^^^^ the trait `Ord` is not\
    \ implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0277]: cannot multiply `f64` by `usize`\n  --> /tmp/tmpc71ta686.rs:19:35\n\
    \   |\n19 |     let new_min = lower + ((upper * numbers.len() - lower) / (numbers.len()\
    \ - 1.0)).f64();\n   |                                   ^ no implementation for\
    \ `f64 * usize`\n   |\n   = help: the trait `Mul<usize>` is not implemented for\
    \ `f64`\n   = help: the following other types implement trait `Mul<Rhs>`:\n  \
    \           <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n      \
    \       <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n        \
    \     <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n            \
    \ <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0277]: cannot subtract `{float}` from `usize`\n  --> /tmp/tmpc71ta686.rs:19:77\n\
    \   |\n19 |     let new_min = lower + ((upper * numbers.len() - lower) / (numbers.len()\
    \ - 1.0)).f64();\n   |                                                       \
    \                      ^ no implementation for `usize - {float}`\n   |\n   = help:\
    \ the trait `Sub<{float}>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E027"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    numbers.iter().map(|n| n / max\
    \ - min).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpo1s19psn.rs:16:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n16  |     numbers.iter().map(|n| n / max - min).collect()\n    |     ^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `numbers`\n    = note: borrow occurs due to\
    \ deref coercion to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min: f64 = numbers[0].min();\n    let mut max: f64 = numbers[0].max();\n\
    \    for i in numbers.iter_mut() {\n        *i = i / (*i).norm() ;\n        *i\
    \ = f64::from(*i) * (*i).norm();\n        *i = f64::from(*i) * f64::from(*i).norm();\n\
    \        *i = f64::from(*i) / f64::from(*i).norm();\n        min = f64::from(*i)\
    \ < min ? f64::from(*i) : min;\n        max = f64::from(*i) > max ? f64::from(*i)\
    \ : max;\n    }\n    let mut numbers_new = Vec::new();\n    for i in numbers.iter_mut()\
    \ {\n        *i = i / (*i).norm() ;\n        *i = f64::from(*i) * (*i).norm();\n\
    \        *i = f64::from(*i) * f64::from(*i).norm();\n        *i = f64::from(*i)\
    \ / f64::from(*i).norm();\n        if f64::from(*i) > 1.0 {\n            *i =\
    \ f64::from(*i) / f64::from(*i).norm();\n            *i = *i;\n        }\n   \
    \     numbers_new.push(*i);\n    }\n    numbers_new\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `f64`\n\
    \  --> /tmp/tmp4ty09rl4.rs:13:37\n   |\n13 |         min = f64::from(*i) < min\
    \ ? f64::from(*i) : min;\n   |                                     ^^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmp4ty09rl4.rs:6:35\n\
    \    |\n6   |     let mut min: f64 = numbers[0].min();\n    |                \
    \                   ^^^- supplied 0 arguments\n    |                         \
    \          |\n    |                                   expected 1 argument\n  \
    \  |\nnote: associated function defined here\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmp4ty09rl4.rs:7:35\n\
    \    |\n7   |     let mut max: f64 = numbers[0].max();\n    |                \
    \                   ^^^- supplied 0 arguments\n    |                         \
    \          |\n    |                                   expected 1 argument\n  \
    \  |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `norm` found for type `f64` in the current scope\n --> /tmp/tmp4ty09rl4.rs:9:23\n\
    \  |\n9 |         *i = i / (*i).norm() ;\n  |                       ^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `norm` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp4ty09rl4.rs:10:35\n   |\n10 |         *i\
    \ = f64::from(*i) * (*i).norm();\n   |                                   ^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `norm` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmp4ty09rl4.rs:11:44\n   |\n11 |\
    \         *i = f64::from(*i) * f64::from(*i).norm();\n   |                   \
    \                         ^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `norm` found for type `f64` in the current scope\n  --> /tmp/tmp4ty09rl4.rs:12:44\n\
    \   |\n12 |         *i = f64::from(*i) / f64::from(*i).norm();\n   |         \
    \                                   ^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `norm` found for type `f64` in the current scope\n  --> /tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers.iter().min().unwrap();\n    let mut max = numbers.iter().max().unwrap();\n\
    \n    let mut range = (max - min) as f64;\n\n    numbers.iter().for_each(|number|\
    \ {\n        number -= min;\n        range = (range + number as f64) / 2;\n  \
    \  });\n    numbers += min as f64;\n    numbers += range as f64;\n    numbers\
    \ as Vec<f64>\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpf36tqexp.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpf36tqexp.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `&f64`\n\
    \  --> /tmp/tmpf36tqexp.rs:12:9\n   |\n12 |         number -= min;\n   |     \
    \    ------^^^^^^^\n   |         |\n   |         cannot use `-=` on type `&f64`\n\
    \   |\nhelp: `-=` can be used on `f64`, you can dereference `number`\n   |\n12\
    \ |         *number -= min;\n   |         +\n\nerror[E0277]: cannot divide `f64`\
    \ by `{integer}`\n  --> /tmp/tmpf36tqexp.rs:13:41\n   |\n13 |         range =\
    \ (range + number as f64) / 2;\n   |                                         ^\
    \ no implementation for `f64 / {integer}`\n   |\n   = help: the trait `Div<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n       "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = numbers;\n    let mut min_value = result.iter().min().unwrap();\n\
    \    let mut max_value = result.iter().max().unwrap();\n\n    while max_value\
    \ - min_value > std::f64::EPSILON {\n        if min_value == 0.0 {\n         \
    \   min_value = result.iter().next().unwrap();\n        } else {\n           \
    \ max_value = result.iter().next().unwrap();\n        }\n        result.iter_mut().for_each(|num|\
    \ {\n            *num = (*num - min_value) / (max_value - min_value) * (1.0 +\
    \ std::f64::EPSILON);\n        });\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4rweijaa.rs:7:39\n\
    \     |\n7    |     let mut min_value = result.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4rweijaa.rs:8:39\n\
    \     |\n8    |     let mut max_value = result.iter().max().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: can't compare `&f64` with `{float}`\n  --> /tmp/tmp4rweijaa.rs:11:22\n\
    \   |\n11 |         if min_value == 0.0 {\n   |                      ^^ no implementation\
    \ for `&f64 == {float}`\n   |\n   = help: the trait `PartialEq<{float}>` is not\
    \ implemented for `&f64`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Normalize the numbers to be in the range [0, 1]\n    let mut min_val =\
    \ std::f64::MAX;\n    let mut max_val = std::f64::MIN;\n    for &number in numbers.iter()\
    \ {\n        let value = *number;\n        // Clamp the value to [0, 1]\n    \
    \    value = if value < min_val {\n            min_val\n        } else if value\
    \ > max_val {\n            max_val\n        } else {\n            value\n    \
    \    };\n        *number = value;\n    }\n    // Convert the normalized numbers\
    \ to [0, 1]\n    let mut scaled_numbers = Vec::with_capacity(numbers.len());\n\
    \    for &number in numbers.iter() {\n        let value = *number;\n        scaled_numbers.push((value\
    \ - min_val) / (max_val - min_val));\n    }\n    scaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpz623p895.rs:10:21\n\
    \   |\n10 |         let value = *number;\n   |                     ^^^^^^^\n\n\
    error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpz623p895.rs:19:9\n\
    \   |\n19 |         *number = value;\n   |         ^^^^^^^\n\nerror[E0614]: type\
    \ `f64` cannot be dereferenced\n  --> /tmp/tmpz623p895.rs:24:21\n   |\n24 |  \
    \       let value = *number;\n   |                     ^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut sum: f64 = 0.0;\n    for n in numbers {\n        sum += n;\n    }\n\
    \n    let mut min_val = numbers.iter().min();\n    let mut max_val = numbers.iter().max();\n\
    \    let mut rescaled_numbers = Vec::new();\n\n    while sum > 1.0 {\n       \
    \ let mut idx = 0;\n        for n in numbers {\n            let new_val = n *\
    \ sum / n;\n            if new_val > max_val {\n                max_val = new_val;\n\
    \            }\n\n            if new_val < min_val {\n                min_val\
    \ = new_val;\n            }\n            rescaled_numbers.push(new_val);\n   \
    \         idx += 1;\n        }\n\n        sum += 1.0;\n    }\n\n    // now rescale\
    \ min-max to 0 and 1\n    for n in rescaled_numbers {\n        if n < min_val\
    \ {\n            rescaled_numbers[n] = min_val;\n        }\n\n        if n > max_val\
    \ {\n            rescaled_numbers[n] = max_val;\n        }\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpzvnpof2r.rs:11:38\n\
    \     |\n11   |     let mut min_val = numbers.iter().min();\n     |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpzvnpof2r.rs:12:38\n\
    \     |\n12   |     let mut max_val = numbers.iter().max();\n     |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzvnpof2r.rs:19:26\n   |\n19 |\
    \             if new_val > max_val {\n   |                          ^^^^^^^ expected\
    \ `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n         \
    \     found enum `Option<&f64>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvnpof2r.rs:20:27\n\
    \   |\n12 |     let mut max_val = numbers.iter().max();\n   |                \
    \       -------------------- expected due to this value\n...\n20 |           \
    \      max_val = new_val;\n   |                           ^^^^^^^ expected enum\
    \ `Option`, found `f64`\n   |\n   = note: expected enum `Option<&f64>`\n     \
    \         found type `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvnpof2r.rs:23:26\n\
    \   |\n23 |             if new_val < min_val {\n   |                         "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers.iter().min().unwrap();\n    let mut max = numbers.iter().max().unwrap();\n\
    \    max = 1.0 * max / min;\n    numbers.iter().map(|&x| x / max).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8odt9umq.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8odt9umq.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp8odt9umq.rs:8:11\n  |\n7 |    \
    \ let mut max = numbers.iter().max().unwrap();\n  |                   -----------------------------\
    \ expected due to this value\n8 |     max = 1.0 * max / min;\n  |           ^^^^^^^^^^^^^^^\n\
    \  |           |\n  |           expected `&f64`, found `f64`\n  |           help:\
    \ consider borrowing here: `&(1.0 * max / min)`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().cloned().chain(numbers.iter().cloned().reverse()).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `Cloned` in the\
    \ current scope\n --> /tmp/tmptpr5ojaq.rs:6:59\n  |\n6 |     numbers.iter().cloned().chain(numbers.iter().cloned().reverse()).cloned().collect()\n\
    \  |                                                           ^^^^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, f64>>`\n\nerror[E0271]: type mismatch\
    \ resolving `<std::slice::Iter<'_, f64> as Iterator>::Item == &&_`\n --> /tmp/tmptpr5ojaq.rs:6:70\n\
    \  |\n6 |     numbers.iter().cloned().chain(numbers.iter().cloned().reverse()).cloned().collect()\n\
    \  |                                                                      ^^^^^^\
    \ expected reference, found `f64`\n  |\n  = note: expected reference `&&_`\n \
    \            found reference `&f64`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, f64>>`\n  = note:\
    \ 1 redundant requirement hidden\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ f64>>, _>`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ f64>>, _>>`, but its trait bounds were not satisfied\n  --> /tmp/tmptpr5ojaq.rs:6:79\n\
    \   |\n6  |       numbers.iter().cloned().chain(numbers.iter().cloned().reverse()).cloned().collect()\n\
    \   |                                                                        \
    \         ^^^^^^^ method cannot be called on `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ f64>>, _>>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ f64>>, _> as Iterator>::Item = &_`\n           which is required by `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ f64>>, _>>: Iterator`\n           `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ f64>>, _>>: Iterator`\n           which is required by `&mut Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ f64>>, _>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSo"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let mut min_val = numbers[0].abs();\n \
    \   let mut max_val = numbers[0].abs();\n    for &n in &numbers[1..] {\n     \
    \   let new_val = min_val * n;\n        if new_val > max_val {\n            max_val\
    \ = new_val;\n        }\n        min_val = new_val;\n    }\n    let mut output:\
    \ Vec<f64> = Vec::with_capacity(numbers.len() - 1);\n    for n in &numbers[1..]\
    \ {\n        let value = n * max_val / min_val;\n        output.append(value);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptiemm3hw.rs:19:23\n   |\n\
    19 |         output.append(value);\n   |                       ^^^^^ expected\
    \ `&mut Vec<f64>`, found `f64`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<f64>`\n                           found type `f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = Vec::with_capacity(numbers.len());\n    for i in 0..numbers.len()\
    \ {\n        let a = numbers[i] + 1.0;\n        let b = numbers[i] - 1.0;\n  \
    \      if a < 0.0 && b >= 0.0 {\n            result .= vec![0.0];\n        } else\
    \ if a >= 0.0 && b < 0.0 {\n            result .= vec![0.0];\n        } else if\
    \ a < 0.0 && b < 0.0 {\n            result .= vec![1.0];\n        } else if a\
    \ > 0.0 && b > 0.0 {\n            result .= vec![1.0];\n        } else {\n   \
    \         result .= vec![a];\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `=`\n  --> /tmp/tmpuyjgrqoj.rs:11:21\n   |\n11\
    \ |             result .= vec![0.0];\n   |                     ^\n\nerror: unexpected\
    \ token: `=`\n  --> /tmp/tmpuyjgrqoj.rs:13:21\n   |\n13 |             result .=\
    \ vec![0.0];\n   |                     ^\n\nerror: unexpected token: `=`\n  -->\
    \ /tmp/tmpuyjgrqoj.rs:15:21\n   |\n15 |             result .= vec![1.0];\n   |\
    \                     ^\n\nerror: unexpected token: `=`\n  --> /tmp/tmpuyjgrqoj.rs:17:21\n\
    \   |\n17 |             result .= vec![1.0];\n   |                     ^\n\nerror:\
    \ unexpected token: `=`\n  --> /tmp/tmpuyjgrqoj.rs:19:21\n   |\n19 |         \
    \    result .= vec![a];\n   |                     ^\n\nerror: aborting due to\
    \ 5 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut length = numbers[0].abs_sub(min).unwrap();\n\
    \    for n in numbers {\n        length = length.mul(n).div(max.abs() - min.abs()).unwrap();\n\
    \    }\n    let mut result = vec![0.0; length as usize];\n    let mut i = 0;\n\
    \    for n in numbers {\n        result[i++] = min.abs();\n        result[i++]\
    \ = n.abs();\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpjmtiql12.rs:23:17\n\
    \   |\n23 |         result[i++] = min.abs();\n   |                 ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23 |         result[{\
    \ let tmp = i; i += 1; tmp }] = min.abs();\n   |                +++++++++++  ~~~~~~~~~~~~~~~\n\
    23 -         result[i++] = min.abs();\n23 +         result[i += 1] = min.abs();\n\
    \   | \n\nwarning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmpjmtiql12.rs:16:33\n \
    \  |\n16 |     let mut length = numbers[0].abs_sub(min).unwrap();\n   |      \
    \                           ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0599]: no method named `unwrap` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpjmtiql12.rs:16:46\n   |\n16 |     let mut length\
    \ = numbers[0].abs_sub(min).unwrap();\n   |                                  \
    \            ^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_max_idx = Vec::new();\n    let mut min_max = numbers[0..numbers.len()].iter().minmax();\n\
    \    min_max_idx.push(0);\n    min_max_idx.push(1);\n    for idx in min_max_idx\
    \ {\n        let num = numbers[idx];\n        numbers[idx] = num - min_max;\n\
    \        min_max -= num;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `minmax` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmp58nqm8z4.rs:7:56\n  |\n7 |     let mut min_max\
    \ = numbers[0..numbers.len()].iter().minmax();\n  |                          \
    \                              ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ f64>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    let mut smallest = numbers[0];\n    for n in numbers {\n\
    \        let delta = n - smallest;\n        new_numbers.push(smallest + delta\
    \ / numbers.len());\n        smallest = n;\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n  --> /tmp/tmpwoa0s8ay.rs:13:43\n\
    \   |\n13 |         new_numbers.push(smallest + delta / numbers.len());\n   |\
    \                                           ^ no implementation for `f64 / usize`\n\
    \   |\n   = help: the trait `Div<usize>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Div<Rhs>`:\n             <&'a f32\
    \ as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as\
    \ Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n\
    \             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n      \
    \       <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers.iter().min().unwrap();\n    let mut max = numbers.iter().max().unwrap();\n\
    \    min = 0;\n    max = 1.0;\n    numbers.iter().map(|x| x / max - min).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqedz6el8.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqedz6el8.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpqedz6el8.rs:8:11\n  |\n6 |    \
    \ let mut min = numbers.iter().min().unwrap();\n  |                   -----------------------------\
    \ expected due to this value\n7 |     let mut max = numbers.iter().max().unwrap();\n\
    8 |     min = 0;\n  |           ^ expected `&f64`, found integer\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqedz6el8.rs:9:11\n  |\n7 |     let mut max =\
    \ numbers.iter().max().unwrap();\n  |                   -----------------------------\
    \ expected due to this value\n8 |     min = 0;\n9 |     max = 1.0;\n  |      \
    \     ^^^\n  |           |\n  |           expected `&f64`, found floating-point\
    \ number\n  |           help: consider borrowing here: `&1.0`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter()\n        .zip(numbers.iter().cloned().rev())\n        .map(|(min,\
    \ max)| (min + (max - min) / (2 * numbers.len())).round() as f64)\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n --> /tmp/tmp68i0fz7a.rs:8:46\n\
    \  |\n8 |         .map(|(min, max)| (min + (max - min) / (2 * numbers.len())).round()\
    \ as f64)\n  |                                              ^ no implementation\
    \ for `f64 / usize`\n  |\n  = help: the trait `Div<usize>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Div<Rhs>`:\n\
    \            <&'a f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n      \
    \      <&'a i128 as Div<i128>>\n            <&'a i16 as Div<i16>>\n          \
    \  <&'a i32 as Div<i32>>\n            <&'a i64 as Div<i64>>\n            <&'a\
    \ i8 as Div<i8>>\n            <&'a isize as Div<isize>>\n          and 54 others\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp68i0fz7a.rs:6:5\n  |\n5 |   fn\
    \ rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n  |                      \
    \                      -------- expected `Vec<f64>` because of return type\n6\
    \ | /     numbers.iter()\n7 | |         .zip(numbers.iter().cloned().rev())\n\
    8 | |         .map(|(min, max)| (min + (max - min) / (2 * numbers.len())).round()\
    \ as f64)\n  | |___________________________________________________________________________________^\
    \ expected struct `Vec`, found struct `Map`\n  |\n  = note: expected struct `Vec<f64>`\n\
    \             found struct `Map<Zip<std::slice::Iter<'_, f64>, Rev<Cloned<std::slice::Iter<'_,\
    \ f64>>>>, _>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_v = numbers[0].unwrap();\n    let mut max_v = numbers[0].unwrap();\n\
    \    for n in numbers.iter().skip(1) {\n        if *n < min_v {\n            min_v\
    \ = *n;\n        }\n        if *n > max_v {\n            max_v = *n;\n       \
    \ }\n    }\n    let range = max_v - min_v;\n    let mut new_numbers = Vec::new();\n\
    \    new_numbers.extend_from_slice(&numbers);\n    for i in 0..new_numbers.len()\
    \ {\n        let mut v = new_numbers[i].unwrap();\n        v -= min_v + i * range\
    \ / new_numbers.len();\n        new_numbers[i].set(v);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n --> /tmp/tmponur8o6y.rs:6:32\n  |\n6 |     let mut min_v = numbers[0].unwrap();\n\
    \  |                                ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n --> /tmp/tmponur8o6y.rs:7:32\n\
    \  |\n7 |     let mut max_v = numbers[0].unwrap();\n  |                      \
    \          ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmponur8o6y.rs:20:36\n\
    \   |\n20 |         let mut v = new_numbers[i].unwrap();\n   |               \
    \                     ^^^^^^ method not found in `f64`\n\nerror[E0277]: cannot\
    \ multiply `usize` by `f64`\n  --> /tmp/tmponur8o6y.rs:21:24\n   |\n21 |     \
    \    v -= min_v + i * range / new_numbers.len();\n   |                       \
    \ ^ no implementation for `usize * f64`\n   |\n   = help: the trait `Mul<f64>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0599]: no method named `set` found for type\
    \ `f64` in the current scope\n   --> /tmp/tmponur8o6y.rs:22:24\n    |\n22  | \
    \        new_numbers[i].set(v);\n    |                        ^^^ method not found\
    \ in `f64`\n    |\nhelp: consider wrapping the receiver expression with the appropriate\
    \ type\n    |\n22  |         Pin::new(&mut new_numbers[i]).set(v);\n    |    \
    \     +++++++++++++               +\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers\n        .iter()\n        .cloned()\n        .map(|number| number.min(number))\n\
    \        .map(|number| number.max(number))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmpwiply6yg.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().cloned().map(|x| x / numbers.max()).collect::<Vec<f64>>()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `max` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmptkm_hdu6.rs:6:49\n    |\n6   |   \
    \    numbers.iter().cloned().map(|x| x / numbers.max()).collect::<Vec<f64>>()\n\
    \    |                                                   ^^^ method cannot be\
    \ called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `f64: Ord`\n       \
    \     which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n    \
    \        which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = Vec::new();\n    let mut min = (numbers[0] as f64).floor();\n\
    \    let mut max = min;\n    let mut scale = numbers[0] as f64;\n\n    for num\
    \ in numbers.iter() {\n        // Update min and max\n        if num < min {\n\
    \            min = num;\n        } else {\n            max = num;\n        }\n\
    \n        // Update scale based on new min and max\n        let delta_num = num\
    \ - min;\n        let new_scale = delta_num / max;\n        scale = scale * new_scale;\n\
    \    }\n\n    // Apply new scale and clamp to min/max\n    for (i, num) in numbers.iter().enumerate()\
    \ {\n        result[i] = ((num - min) * scale).min(num).max() as f64;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb3yvm2go.rs:13:18\n   |\n\
    13 |         if num < min {\n   |                  ^^^\n   |                 \
    \ |\n   |                  expected `&f64`, found `f64`\n   |                \
    \  help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpb3yvm2go.rs:14:19\n   |\n7  |     let mut min = (numbers[0] as f64).floor();\n\
    \   |                   --------------------------- expected due to this value\n\
    ...\n14 |             min = num;\n   |                   ^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |          \
    \   min = *num;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb3yvm2go.rs:16:19\n   |\n8  |     let mut max = min;\n   |    \
    \               --- expected due to this value\n...\n16 |             max = num;\n\
    \   |                   ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |             max = *num;\n   |         \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb3yvm2go.rs:27:47\n\
    \   |\n27 |         result[i] = ((num - min) * scale).min(num).max() as f64;\n\
    \   |                                               ^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n27 |         result[i]\
    \ = ((num - min) * scale).min(*num).max() as f64;\n   |                      \
    \                         +\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmpb3yvm2go.rs:27:52\n    |\n27  |  \
    \       result[i] = ((num - min) * scale).min(num).max() as f64;\n    |      \
    \                                              ^^^- supplied 0 arguments\n   \
    \ |                                                    |\n    |              \
    \                                      expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let mut min: f64 = numbers[0];\n    let\
    \ mut max: f64 = numbers[0];\n    let mut scale: f64;\n    for &n in numbers.iter()\
    \ {\n        if n > max {\n            max = n;\n        }\n        if n < min\
    \ {\n            min = n;\n        }\n    }\n    if min > 0.0 {\n        scale\
    \ = 1.0;\n    } else if max < 1.0 {\n        scale = -1.0;\n    } else {\n   \
    \     scale = -1.0;\n    }\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \    new_numbers.extend_from_slice(&vec![0.0; numbers.len()]);\n    for i in 0..numbers.len()\
    \ {\n        new_numbers[i] = numbers[i] / scale;\n    }\n    new_numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmphr44es0i.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_element = numbers[0];\n    let mut max_element = numbers[0];\n\
    \n    for number in numbers.iter().rev() {\n        if number < min_element {\n\
    \            min_element = number;\n        }\n        if number > max_element\
    \ {\n            max_element = number;\n        }\n    }\n\n    let scale = (max_element\
    \ as f64 - min_element as f64) / (2.0 * numbers.len() as f64);\n\n    let mut\
    \ new_numbers = Vec::new();\n\n    for number in numbers.iter() {\n        new_numbers.push((number\
    \ - min_element as f64) * scale);\n    }\n\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnf971o6k.rs:10:21\n   |\n\
    10 |         if number < min_element {\n   |                     ^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&min_element`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnf971o6k.rs:11:27\n   |\n6  |     let mut min_element\
    \ = numbers[0];\n   |                           ---------- expected due to this\
    \ value\n...\n11 |             min_element = number;\n   |                   \
    \        ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n11 |             min_element = *number;\n   |            \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnf971o6k.rs:13:21\n\
    \   |\n13 |         if number > max_element {\n   |                     ^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&max_element`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnf971o6k.rs:14:27\n   |\n7  |     let mut max_element\
    \ = numbers[0];\n   |                           ---------- expected due to this\
    \ value\n...\n14 |             max_element = number;\n   |                   \
    \        ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             max_element = *number;\n   |            \
    \               +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers\n        .iter()\n        .map(|n| n / std::f64::consts::E + 1.0)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.7357588823428847, 19.357184114454974]`,\n right: `[0.0, 1.0]`', /tmp/tmp4tf7ndhv.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() > 2);\n    let mut new_numbers = vec![];\n    for n\
    \ in numbers {\n        if n == 0.0 {\n            new_numbers.push(n);\n    \
    \    } else {\n            new_numbers.push(f64::from(n) * 1.0);\n        }\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: numbers.len() > 2', /tmp/tmp6srj9qlv.rs:6:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let scale = max - min;\n    let mut rescaled: Vec<f64> = Vec::new();\n  \
    \  numbers.iter().for_each(|x| rescaled.push((x - min) * scale + min));\n    rescaled\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3q5ukrid.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3q5ukrid.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().fold(0.0, |acc, n| {\n        let min = acc;\n        let\
    \ max = n;\n        let range = (max - min) as f64;\n        (min + (n / range))\
    \ as f64\n    })\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpa45yf35h.rs:6:25\n  |\n6 |\
    \     numbers.iter().fold(0.0, |acc, n| {\n  |                         ^^^ expected\
    \ struct `Vec`, found floating-point number\n  |\n  = note: expected struct `Vec<f64>`\n\
    \               found type `{float}`\n\nerror[E0277]: cannot subtract `Vec<f64>`\
    \ from `&f64`\n --> /tmp/tmpa45yf35h.rs:9:26\n  |\n9 |         let range = (max\
    \ - min) as f64;\n  |                          ^ no implementation for `&f64 -\
    \ Vec<f64>`\n  |\n  = help: the trait `Sub<Vec<f64>>` is not implemented for `&f64`\n\
    \  = help: the following other types implement trait `Sub<Rhs>`:\n           \
    \ <&'a f32 as Sub<f32>>\n            <&'a f64 as Sub<f64>>\n            <&'a i128\
    \ as Sub<i128>>\n            <&'a i16 as Sub<i16>>\n            <&'a i32 as Sub<i32>>\n\
    \            <&'a i64 as Sub<i64>>\n            <&'a i8 as Sub<i8>>\n        \
    \    <&'a isize as Sub<isize>>\n          and 48 others\n\nerror[E0369]: cannot\
    \ add `f64` to `Vec<f64>`\n  --> /tmp/tmpa45yf35h.rs:10:14\n   |\n10 |       \
    \  (min + (n / range)) as f64\n   |          --- ^ ----------- f64\n   |     \
    \     |\n   |          Vec<f64>\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter()\n        .min_by(|a, b| a.partial_cmp(b).unwrap())\n     \
    \   .map(|x| x.map(|y| y/x).unwrap_or(0.0))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `&f64` is not an iterator\n --> /tmp/tmp20dki2ry.rs:8:20\n\
    \  |\n8 |         .map(|x| x.map(|y| y/x).unwrap_or(0.0))\n  |               \
    \     ^^^ `&f64` is not an iterator\n  |\n  = note: the following trait bounds\
    \ were not satisfied:\n          `&f64: Iterator`\n          which is required\
    \ by `&mut &f64: Iterator`\n          `f64: Iterator`\n          which is required\
    \ by `&mut f64: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let mut min = numbers[0];\n    let mut\
    \ max = numbers[0];\n    for &n in numbers {\n        if n < min {\n         \
    \   min = n;\n        }\n        if n > max {\n            max = n;\n        }\n\
    \    }\n    if min == 0.0 {\n        return vec![];\n    }\n    let mut result:\
    \ Vec<f64> = vec![];\n    let diff = max - min;\n    for &n in numbers {\n   \
    \     let scale = n * diff / max - min;\n        result.push(scale + min);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprjcypza4.rs:9:9\n  |\n9 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprjcypza4.rs:22:9\n   |\n22 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().min(|a, b| a < b).map(|a| (a - 1.0) / 2.0).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8suayf_0.rs:6:20\n\
    \     |\n6    |     numbers.iter().min(|a, b| a < b).map(|a| (a - 1.0) / 2.0).collect()\n\
    \     |                    ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp8suayf_0.rs:6:20\n     |\n6    |     numbers.iter().min(|a, b|\
    \ a < b).map(|a| (a - 1.0) / 2.0).collect()\n     |                    ^^^ ------------\
    \ supplied 1 argument\n     |                    |\n     |                   \
    \ expected 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ `Option<f64>` is not an iterator\n   --> /tmp/tmp8suayf_0.rs:6:63\n    |\n6\
    \   |       numbers.iter().min(|a, b| a < b).map(|a| (a - 1.0) / 2.0).collect()\n\
    \    |                                                                 ^^^^^^^\
    \ `Option<f64>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Option<f64>: Iterator`\n            which\
    \ is required by `&mut Option<f64>: Iterator`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let mut rescaled_numbers = Vec::with_capacity(numbers.len());\n    for n\
    \ in numbers {\n        let n = n * max_number / min_number;\n        rescaled_numbers.push(n);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpawq4lxbr.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpawq4lxbr.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n\n  \
    \  for number in numbers.iter().cloned() {\n        if number < min {\n      \
    \      min = number;\n        }\n\n        if number > max {\n            max\
    \ = number;\n        }\n    }\n\n    numbers.iter_mut().for_each(|x| { x = x.map(|n|\
    \ n / max - min); });\n\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `&mut f64` is not an iterator\n  --> /tmp/tmpg_vb3szr.rs:19:45\n\
    \   |\n19 |     numbers.iter_mut().for_each(|x| { x = x.map(|n| n / max - min);\
    \ });\n   |                                             ^^^ `&mut f64` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `f64: Iterator`\n           which is required by `&mut f64: Iterator`\n\
    \           `&mut f64: Iterator`\n           which is required by `&mut &mut f64:\
    \ Iterator`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_num = &numbers[1..].iter().min().unwrap();\n    let max_num = &numbers[1..].iter().max().unwrap();\n\
    \    let length = numbers.len() as f64;\n    Vec::from_iter(\n        (0..=length).map(|i|\
    \ {\n            numbers[i] as f64 / min_num as f64 + max_num as f64 * (i as f64\
    \ / length as f64) as f64\n        }),\n    )\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsen9ffgo.rs:6:40\n\
    \     |\n6    |     let min_num = &numbers[1..].iter().min().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsen9ffgo.rs:7:40\n\
    \     |\n7    |     let max_num = &numbers[1..].iter().max().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0599]: no function or associated item named `from_iter` found for struct\
    \ `Vec<_, _>` in the current scope\n --> /tmp/tmpsen9ffgo.rs:9:10\n  |\n9 |  \
    \   Vec::from_iter(\n  |          ^^^^^^^^^ function or associated item not found\
    \ in `Vec<_, _>`\n  |\n  = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n  |\n1 | use std::iter::FromIterator;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsen9ffgo.rs:10:14\n   |\n10 |         (0..=length).map(|i|\
    \ {\n   |              ^^^^^^ expected integer, found `f64`\n\nerror[E0606]: casting\
    \ `&&f64` as `f64` is invalid\n  --> /tmp/tmpsen9ffgo.rs:11:33\n   |\n11 |   \
    \          numbers[i] as f64 / min_num as f64 + max_num a"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let mut min_val\
    \ = numbers[0];\n    let mut max_val = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < min_val {\n            min_val = numbers[i];\n  \
    \      }\n\n        if numbers[i] > max_val {\n            max_val = numbers[i];\n\
    \        }\n    }\n\n    if min_val == 0 {\n        return vec![0.0; numbers.len()];\n\
    \    }\n\n    let mut scale = (max_val - min_val) / (numbers[2..numbers.len()\
    \ - 1] as f64 - min_val) as f64;\n    let mut scaled_numbers = vec![0.0; numbers.len()\
    \ + 1];\n\n    scaled_numbers[2..] = min_val - scale * (numbers[2..numbers.len()\
    \ - 1] as f64 - min_val) as f64;\n\n    for i in 3..numbers.len() {\n        scaled_numbers[i]\
    \ = (numbers[i] - scaled_numbers[i - 3] + min_val) / scale;\n    }\n\n    scaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgyw4fz2u.rs:22:19\n   |\n\
    22 |     if min_val == 0 {\n   |                   ^\n   |                   |\n\
    \   |                   expected `f64`, found integer\n   |                  \
    \ help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgyw4fz2u.rs:29:27\n\
    \   |\n29 |     scaled_numbers[2..] = min_val - scale * (numbers[2..numbers.len()\
    \ - 1] as f64 - min_val) as f64;\n   |     -------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected slice `[{float}]`, found `f64`\n   |     |\n   |     expected due to\
    \ the type of this binding\n\nerror[E0277]: the size for values of type `[{float}]`\
    \ cannot be known at compilation time\n  --> /tmp/tmpgyw4fz2u.rs:29:5\n   |\n\
    29 |     scaled_numbers[2..] = min_val - scale * (numbers[2..numbers.len() - 1]\
    \ as f64 - min_val) as f64;\n   |     ^^^^^^^^^^^^^^^^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[{float}]`\n   = note: the left-hand-side of an assignment must have a\
    \ statically known size\n\nerror[E0605]: non-primitive cast: `[f64]` as `f64`\n\
    \  --> /tmp/tmpgyw4fz2u.rs:26:44\n   |\n26 |     let mut scale = (max_val - min_val)\
    \ / (numbers[2..numbers.len() - 1] as f64 - min_val) as f64;\n   |           \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as`\
    \ expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror[E0605]: non-primitive cast: `[f64]` as `f64`\n\
    \  --> /tmp/tmpgyw4fz2u.rs:29:46\n   |\n29 |     scaled_numbers[2..] = min_val\
    \ - scale * (numbers[2..numbers.len() - 1] as f64 - min_val) as f64;\n   |   \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = numbers;\n    let min = new_numbers.iter().min().unwrap();\n\
    \    new_numbers.iter_mut().for_each(|x| {\n        let max_val = if x == min\
    \ {\n            1.0\n        } else {\n            x\n        };\n        let\
    \ ratio = (x - min) / (max_val - min);\n        *x = ratio;\n    });\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpql9qdfwz.rs:7:34\n\
    \     |\n7    |     let min = new_numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpql9qdfwz.rs:12:13\n\
    \   |\n9  |           let max_val = if x == min {\n   |  _______________________-\n\
    10 | |             1.0\n   | |             --- expected because of this\n11 |\
    \ |         } else {\n12 | |             x\n   | |             ^ expected floating-point\
    \ number, found `&mut f64`\n13 | |         };\n   | |_________- `if` and `else`\
    \ have incompatible types\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    12 |             *x\n   |             +\n\nerror[E0369]: cannot subtract `&f64`\
    \ from `&mut f64`\n  --> /tmp/tmpql9qdfwz.rs:14:24\n   |\n14 |         let ratio\
    \ = (x - min) / (max_val - min);\n   |                      - ^ --- &f64\n   |\
    \                      |\n   |                      &mut f64\n   |\nhelp: `-`\
    \ can be used on `f64`, you can dereference `x`\n   |\n14 |         let ratio\
    \ = (*x - min) / (max_val - min);\n   |                      +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_val = numbers.iter().min().unwrap_or(-1.0);\n    let max_val = numbers.iter().max().unwrap_or(1.0);\n\
    \    let mut new_numbers = numbers.clone();\n    new_numbers.iter_mut().for_each(|x|\
    \ {\n        *x = (*x - min_val) / (max_val - min_val);\n    });\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpszbx4ise.rs:6:34\n\
    \     |\n6    |     let min_val = numbers.iter().min().unwrap_or(-1.0);\n    \
    \ |                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpszbx4ise.rs:6:50\n  |\n6 |    \
    \ let min_val = numbers.iter().min().unwrap_or(-1.0);\n  |                   \
    \                               ^^^^\n  |                                    \
    \              |\n  |                                                  expected\
    \ `&f64`, found floating-point number\n  |                                   \
    \               help: consider borrowing here: `&-1.0`\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n    --> /tmp/tmpszbx4ise.rs:7:34\n     |\n\
    7    |     let max_val = numbers.iter().max().unwrap_or(1.0);\n     |        \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpszbx4ise.rs:7:50\n  |\n7 |    \
    \ let max_val = numbers.iter().max().unwrap_or(1.0);\n  |                    \
    \                              ^^^\n  |                                      \
    \            |\n  |                                                  expected\
    \ `&f64`, found floating-point number\n  |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().map(|x| x / numbers[0]).collect::<Vec<f64>>()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 24.95]`,\n right: `[0.0, 1.0]`', /tmp/tmpl0_qkfwd.rs:11:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return vec![];\n    }\n    let mut min_val\
    \ = numbers[0];\n    let mut max_val = numbers[0];\n    for value in numbers {\n\
    \        min_val = std::cmp::min(min_val, value);\n        max_val = std::cmp::max(max_val,\
    \ value);\n    }\n    // Normalize min-max range to be a unit interval\n    let\
    \ scale = max_val - min_val;\n    min_val = min_val / scale;\n    max_val = max_val\
    \ / scale;\n    // Scale each number from min-max range to range 0-1.\n    //\
    \ Note the use of abs here to ensure the numbers are positive.\n    let mut scaled_numbers\
    \ = vec![];\n    for value in numbers {\n        scaled_numbers.push((value -\
    \ min_val).abs());\n    }\n    scaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpl_khu5ip.rs:12:19\n\
    \     |\n12   |         min_val = std::cmp::min(min_val, value);\n     |     \
    \              ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::cmp::min`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpl_khu5ip.rs:13:19\n\
    \     |\n13   |         max_val = std::cmp::max(max_val, value);\n     |     \
    \              ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::cmp::max`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n    let mut min =\
    \ numbers[0];\n    let mut max = numbers[0];\n    for i in numbers.iter() {\n\
    \        if min > i {\n            min = i;\n        }\n        if max < i {\n\
    \            max = i;\n        }\n    }\n    let mut length = numbers[0].abs();\n\
    \    for i in numbers.iter() {\n        length *= i;\n    }\n    let mut output\
    \ = Vec::new();\n    for i in 0..(numbers.len() - 1) {\n        let mut ratio\
    \ = i / (numbers.len() - 1);\n        let mut num = numbers.iter().skip(i).fold(ratio,\
    \ |t, &x| t * x).unwrap();\n        output.push(num);\n    }\n    output.push(1);\n\
    \    for i in 0..output.len() {\n        output[i] = output[i] / (max - min);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoqjvvuli.rs:12:18\n   |\n\
    12 |         if min > i {\n   |                  ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n12 |         if min > *i\
    \ {\n   |                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoqjvvuli.rs:13:19\n\
    \   |\n9  |     let mut min = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n13 |             min = i;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |             min = *i;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoqjvvuli.rs:15:18\n   |\n15 |         if max < i {\n  \
    \ |                  ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |         if max < *i {\n   |                  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoqjvvuli.rs:16:19\n   |\n10 |     let mut max\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n16 |             max = i;\n   |                   ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |          \
    \   max = *i;\n   |                   +\n\nerror[E0277]: cannot multiply `usize`\
    \ by `f64`\n  --> /tmp/tmpoqjvvuli.rs:26:68\n   |\n26 |         let mut num =\
    \ numbers.iter().skip(i).fold(ratio, |t, &x| t * x).unwrap();\n   |          \
    \                                                          ^ no implementation\
    \ for `usize * f64`\n   |\n   = help: the trait `Mul<f64>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0599]: no method named `unwrap` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmpoqjvvuli.rs:26:73\n   |\n26 |"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n\n    let mut min = numbers[0];\n    let mut\
    \ max = numbers[0];\n\n    for &n in &numbers {\n        if n > max {\n      \
    \      max = n;\n        }\n\n        if n < min {\n            min = n;\n   \
    \     }\n    }\n\n    let range = (max - min);\n    let scale = (range as f64)\
    \ / (2.0 * numbers[0]);\n\n    for &n in &numbers {\n        *n -= min;\n    }\n\
    \n    numbers[0]\n        .checked_mul(scale)\n        .ok_or(Error::<T>::InvalidNumber)\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Error`\n  -->\
    \ /tmp/tmpyibw9086.rs:30:16\n   |\n30 |         .ok_or(Error::<T>::InvalidNumber)\n\
    \   |                ^^^^^ use of undeclared type `Error`\n\nerror[E0412]: cannot\
    \ find type `T` in this scope\n  --> /tmp/tmpyibw9086.rs:30:24\n   |\n5  | fn\
    \ rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |                   - help:\
    \ you might be missing a type parameter: `<T>`\n...\n30 |         .ok_or(Error::<T>::InvalidNumber)\n\
    \   |                        ^ not found in this scope\n\nwarning: unnecessary\
    \ parentheses around assigned value\n  --> /tmp/tmpyibw9086.rs:21:17\n   |\n21\
    \ |     let range = (max - min);\n   |                 ^         ^\n   |\n   =\
    \ note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n21 -     let range = (max - min);\n21 +     let range = max - min;\n  \
    \ | \n\nerror[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpyibw9086.rs:25:9\n\
    \   |\n25 |         *n -= min;\n   |         ^^\n\nerror[E0599]: no method named\
    \ `checked_mul` found for type `f64` in the current scope\n  --> /tmp/tmpyibw9086.rs:29:10\n\
    \   |\n29 |         .checked_mul(scale)\n   |          ^^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0412, E0433, E0599, E0614.\nFor more\
    \ information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // We want to keep the smallest element 0 and the largest\n    // element\
    \ 1, so we'll scale the numbers down.\n    let mut scaled = numbers.clone();\n\
    \    scaled.rev().for_each(|n| {\n        // For each number, we want the smallest\
    \ to become 0 and the largest\n        // to become 1.\n        if n < 0 {\n \
    \           n += 1;\n        } else {\n            n /= 2;\n        }\n    });\n\
    \    scaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<f64>` is not an iterator\n   --> /tmp/tmpoym8xp8l.rs:9:12\n\
    \    |\n9   |       scaled.rev().for_each(|n| {\n    |              ^^^ `Vec<f64>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<f64>: Iterator`\n            which is required by `&mut Vec<f64>:\
    \ Iterator`\n            `[f64]: Iterator`\n            which is required by `&mut\
    \ [f64]: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Find the smallest and largest values\n    let max_value = numbers.iter().fold(f64::MAX,|a,\
    \ b| b.cmp(&a)?).unwrap();\n    let min_value = numbers.iter().fold(f64::MIN,|a,\
    \ b| b.cmp(&a)?).unwrap();\n    let mut scale = (max_value - min_value) / (numbers.len()\
    \ - 1);\n    let mut scale_values = Vec::with_capacity(numbers.len());\n\n   \
    \ for i in 0..numbers.len() {\n        let mut value = numbers[i].clone();\n \
    \       if value < min_value {\n            scale_values.push(-scale);\n     \
    \       scale *= -1;\n            value = -value;\n        }\n        if value\
    \ > max_value {\n            scale_values.push(scale);\n            scale /= 2;\n\
    \            value = value;\n        }\n        scale_values.push(value);\n  \
    \  }\n    scale_values\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `cmp` exists for reference `&f64`, but its trait\
    \ bounds were not satisfied\n --> /tmp/tmpwohg41vw.rs:7:59\n  |\n7 |     let max_value\
    \ = numbers.iter().fold(f64::MAX,|a, b| b.cmp(&a)?).unwrap();\n  |           \
    \                                                ^^^\n  |\n  = note: the following\
    \ trait bounds were not satisfied:\n          `f64: Ord`\n          which is required\
    \ by `&f64: Ord`\n          `&f64: Iterator`\n          which is required by `&mut\
    \ &f64: Iterator`\n          `f64: Iterator`\n          which is required by `&mut\
    \ f64: Iterator`\n\nerror[E0277]: the `?` operator can only be used in a closure\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \ --> /tmp/tmpwohg41vw.rs:7:66\n  |\n7 |     let max_value = numbers.iter().fold(f64::MAX,|a,\
    \ b| b.cmp(&a)?).unwrap();\n  |                                              \
    \    ----------------^\n  |                                                  |\
    \               |\n  |                                                  |    \
    \           cannot use the `?` operator in a closure that returns `f64`\n  | \
    \                                                 this function should return\
    \ `Result` or `Option` to accept `?`\n  |\n  = help: the trait `FromResidual<_>`\
    \ is not implemented for `f64`\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `f64` in the current scope\n --> /tmp/tmpwohg41vw.rs:7:69\n  |\n7 |\
    \     let max_value = numbers.iter().fold(f64::MAX,|a, b| b.cmp(&a)?).unwrap();\n\
    \  |                                                                     ^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: the method `cmp` exists for reference\
    \ `&f64`, but its trait bounds were not satisfied\n --> /tmp/tmpwohg41vw.rs:8:59\n\
    \  |\n8 |     let min_value = numbers.iter().fold(f64::MIN,|a, b| b.cmp(&a)?).unwrap();\n\
    \  |                                                           ^^^\n  |\n  = note:\
    \ the following trait bounds were not satisfied:\n          `f64: Ord`\n     \
    \     which is required by `&f64: Ord`\n          `&f64: Iterator`\n         \
    \ which is require"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.size() >= 2);\n    let mut sum = 0.0;\n    for &n in numbers\
    \ {\n        sum += n.abs();\n    }\n    let mut min_val = numbers[0];\n    let\
    \ mut max_val = numbers[0];\n    for &n in numbers {\n        if n > max_val {\n\
    \            max_val = n;\n        }\n        if n < min_val {\n            min_val\
    \ = n;\n        }\n    }\n\n    // Compute the new list\n    let mut new_numbers\
    \ = Vec::new();\n    new_numbers.push(0.0);\n    new_numbers.push(1.0);\n    for\
    \ (i, &n) in numbers.iter().enumerate() {\n        if i == 0 {\n            n\
    \ = n / sum;\n            new_numbers.push(n);\n        }\n        let mut new_n\
    \ = (n - min_val) / (max_val - min_val);\n        new_numbers.push(new_n);\n \
    \   }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<f64>` in the\
    \ current scope\n --> /tmp/tmpzpwv7lxl.rs:6:21\n  |\n6 |     assert!(numbers.size()\
    \ >= 2);\n  |                     ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpzpwv7lxl.rs:8:9\n\
    \  |\n8 |     for &n in numbers {\n  |         ^^    ------- this expression has\
    \ type `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzpwv7lxl.rs:13:9\n   |\n13 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Find the min-max of the list\n    let mut min_value = numbers[0];\n  \
    \  let mut max_value = numbers[0];\n    for x in numbers {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n\n    // Normalize the list, linearly\
    \ scaling the range to the min-max\n    let mut scale = (max_value - min_value)\
    \ as f64;\n    let mut result = Vec::new();\n    for x in numbers {\n        let\
    \ y = scale;\n        scale = scale - x;\n        result.push((x - min_value)\
    \ / y);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpx1bi2iem.rs:21:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n9   |     for x in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for x in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n9   |     for x in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = Vec::with_capacity(numbers.len() + 1);\n    for n in\
    \ &numbers {\n        if n > 0.0 {\n            new_numbers.push(n);\n       \
    \ }\n    }\n    if new_numbers.len() < 2 {\n        new_numbers.push(0.0);\n \
    \   }\n    new_numbers.pop().unwrap()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpe62vuagv.rs:8:16\n  |\n8 |\
    \         if n > 0.0 {\n  |                ^^^\n  |                |\n  |    \
    \            expected `&f64`, found floating-point number\n  |               \
    \ help: consider borrowing here: `&0.0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe62vuagv.rs:13:26\n   |\n13 |         new_numbers.push(0.0);\n   | \
    \                         ^^^\n   |                          |\n   |         \
    \                 expected `&f64`, found floating-point number\n   |         \
    \                 help: consider borrowing here: `&0.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe62vuagv.rs:15:5\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                                          --------\
    \ expected `Vec<f64>` because of return type\n...\n15 |     new_numbers.pop().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&f64`\n   |\n\
    \   = note: expected struct `Vec<f64>`\n           found reference `&f64`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n    let\
    \ mut min_num = numbers[0];\n    for n in numbers {\n        min_num = std::cmp::min(min_num,\
    \ n);\n        max_num = std::cmp::max(max_num, n);\n    }\n    let mut result\
    \ = vec![0.0; numbers.len()];\n    let mut i = 0;\n    while i < numbers.len()\
    \ {\n        result[i] = numbers[i] - min_num;\n        if i < numbers.len() -\
    \ 1 {\n            result[i + 1] = numbers[i + 1] - max_num;\n        }\n    \
    \    i = i + 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsf35627t.rs:10:19\n\
    \     |\n10   |         min_num = std::cmp::min(min_num, n);\n     |         \
    \          ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\nnote: required by a bound in `std::cmp::min`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsf35627t.rs:11:19\n\
    \     |\n11   |         max_num = std::cmp::max(max_num, n);\n     |         \
    \          ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\nnote: required by a bound in `std::cmp::max`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers[..].iter().cloned().map(|x| x / numbers.len() as f64).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 24.95]`,\n right: `[0.0, 1.0]`', /tmp/tmpcjuwnag8.rs:11:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // If the input is not of length at least 2, return input unchanged\n   \
    \ if numbers.len() < 2 {\n        return numbers;\n    }\n    let mut min: float;\n\
    \    let mut max: float;\n    let mut sum_of_squares: f64;\n    for (i, &number)\
    \ in numbers.iter().enumerate() {\n        // If the number is 0, don't change\
    \ it\n        if number == 0.0 {\n            continue;\n        }\n        //\
    \ If the number is not 0, compute min, max and sum\n        else {\n         \
    \   min = std::f64::MAX;\n            max = std::f64::MIN;\n            sum_of_squares\
    \ = 0.0;\n            for j in 0..i {\n                let curr_min: f64 = std::f64::MAX;\n\
    \                let curr_max: f64 = std::f64::MIN;\n                let curr_sum:\
    \ f64 = 0.0;\n                for k in 0..i {\n                    let curr_curr_min:\
    \ f64 = std::f64::MAX;\n                    let curr_curr_max: f64 = std::f64::MIN;\n\
    \                    let curr_curr_sum: f64 = 0.0;\n                    if i !=\
    \ k {\n                        curr_curr_sum += (numbers[k] - numbers[j]) * (numbers[k]\
    \ - numbers[j]);\n                        curr_curr_max = std::cmp::max(curr_curr_max,\
    \ numbers[k]);\n                        curr_curr_min = std::cmp::min(curr_curr_min,\
    \ numbers[k]);\n                    }\n                    let curr_sum: f64 =\
    \ curr_curr_sum + curr_sum;\n                    curr_max = std::cmp::max(curr_max,\
    \ curr_curr_max);\n                    curr_min = std::cmp::min(curr_min, curr_curr_min);\n\
    \                }\n                let curr_min: f64 = std::f64::MAX;\n     \
    \           let curr_max: f64 = std::f64::MIN;\n                let curr_sum:\
    \ f64 = curr_sum;\n                min = std::cmp::min(min, curr_min);\n     \
    \           max = std::cmp::max(max, curr_max);\n                sum_of_squares\
    \ += curr_sum;\n            }\n        }\n        // Normalize number to be between\
    \ 0 and 1\n        let normalized_number: f64 = number / (max - min);\n      \
    \  // Apply transformation to number\n        numbers[i] = normalized_number;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `float` in this scope\n  --> /tmp/tmpkjmus9us.rs:10:18\n\
    \   |\n10 |     let mut min: float;\n   |                  ^^^^^\n   |       \
    \           |\n   |                  not found in this scope\n   |           \
    \       help: perhaps you intended to use this type: `f32`\n\nerror[E0412]: cannot\
    \ find type `float` in this scope\n  --> /tmp/tmpkjmus9us.rs:11:18\n   |\n11 |\
    \     let mut max: float;\n   |                  ^^^^^\n   |                 \
    \ |\n   |                  not found in this scope\n   |                  help:\
    \ perhaps you intended to use this type: `f32`\n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmpkjmus9us.rs:33:41\n     |\n33 \
    \  |                         curr_curr_max = std::cmp::max(curr_curr_max, numbers[k]);\n\
    \     |                                         ^^^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |\n     = help: the following other types\
    \ implement trait `Ord`:\n               i128\n               i16\n          \
    \     i32\n               i64\n               i8\n               isize\n     \
    \          u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::cmp::max`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmpkjmus9us.rs:34:41\n     |\n34   |           \
    \              curr_curr_min = std::cmp::min(curr_curr_min, numbers[k]);\n   \
    \  |                                         ^^^^^^^^^^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\nnote: required by a bound in `std::cmp::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkjmus9us.rs:37:32\n\
    \     |\n37   |                     curr_max = std::cmp::max(curr_max, curr_curr_max);\n\
    \     |                                ^^^^^^^^^^^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().min(|a, b| a.abs() < b.abs()).collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0xs4jhd2.rs:6:20\n\
    \     |\n6    |     numbers.iter().min(|a, b| a.abs() < b.abs()).collect()\n \
    \    |                    ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0xs4jhd2.rs:6:20\n     |\n6    |     numbers.iter().min(|a, b|\
    \ a.abs() < b.abs()).collect()\n     |                    ^^^ ------------------------\
    \ supplied 1 argument\n     |                    |\n     |                   \
    \ expected 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ `Option<&f64>` is not an iterator\n   --> /tmp/tmp0xs4jhd2.rs:6:50\n    |\n\
    6   |       numbers.iter().min(|a, b| a.abs() < b.abs()).collect()\n    |    \
    \                                                ^^^^^^^ `Option<&f64>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<&f64>: Iterator`\n            which is required by `&mut\
    \ Option<&f64>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Get the min and max values, as floats\n    let min_num = numbers.iter().min().unwrap();\n\
    \    let max_num = numbers.iter().max().unwrap();\n    // Calculate the difference\
    \ between the max and min (we want the unit to go from 0 to 1)\n    let unit_diff\
    \ = (max_num - min_num);\n    // Calculate the new min and max\n    let min_new\
    \ = min_num - unit_diff;\n    let max_new = max_num + unit_diff;\n    // Finally,\
    \ return the new list\n    vec![min_new, max_new]\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp1uhfia_i.rs:10:21\n\
    \   |\n10 |     let unit_diff = (max_num - min_num);\n   |                   \
    \  ^                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n10 -     let unit_diff = (max_num - min_num);\n\
    10 +     let unit_diff = max_num - min_num;\n   | \n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1uhfia_i.rs:7:34\n     |\n\
    7    |     let min_num = numbers.iter().min().unwrap();\n     |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1uhfia_i.rs:8:34\n\
    \     |\n8    |     let max_num = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().map(|x| x.abs()).collect::<Vec<_>>().min() + numbers.iter().map(|x|\
    \ x.abs()).collect::<Vec<_>>().max().unwrap() / 2.0\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmperbupa5t.rs:6:57\n    |\n6   |   \
    \    numbers.iter().map(|x| x.abs()).collect::<Vec<_>>().min() + numbers.iter().map(|x|\
    \ x.abs()).collect::<Vec<_>>().max().unwrap() / 2.0\n    |                   \
    \                                        ^^^ method cannot be called on `Vec<f64>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `f64: Ord`\n            which is required by\
    \ `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&mut Vec<f64>: Ord`\n            `Vec<f64>: Iterator`\n            which\
    \ is required by `&mut Vec<f64>: Iterator`\n            `f64: Ord`\n         \
    \   which is required by `[f64]: Ord`\n            `[f64]: Ord`\n            which\
    \ is required by `&[f64]: Ord`\n            `[f64]: Ord`\n            which is\
    \ required by `&mut [f64]: Ord`\n            `[f64]: Iterator`\n            which\
    \ is required by `&mut [f64]: Iterator`\n\nerror[E0599]: the method `max` exists\
    \ for struct `Vec<f64>`, but its trait bounds were not satisfied\n   --> /tmp/tmperbupa5t.rs:6:117\n\
    \    |\n6   |       numbers.iter().map(|x| x.abs()).collect::<Vec<_>>().min()\
    \ + numbers.iter().map(|x| x.abs()).collect::<Vec<_>>().max().unwrap() / 2.0\n\
    \    |                                                                       \
    \                                                ^^^ method cannot be called on\
    \ `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `f64: Ord`\n            which\
    \ is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which\
    \ is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which\
    \ is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>: Iterator`\n    \
    \        which is required by `&mut Vec<f64>: Iterator`\n            `f64: Ord`\n\
    \            which is required by `[f64"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\n    for\
    \ val in numbers {\n        if val < min_val {\n            min_val = val;\n \
    \       }\n\n        if val > max_val {\n            max_val = val;\n        }\n\
    \    }\n\n    let mut new_vals = vec![];\n\n    for val in numbers {\n       \
    \ new_vals.push((val - min_val) / (max_val - min_val).sqrt());\n    }\n\n    new_vals\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbw3fmi_g.rs:21:16\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n9   |     for val in numbers {\n \
    \   |                ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for val in numbers {\n    |                ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n9   |     for val in &numbers\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_number = std::f64::MAX;\n    let mut max_number = 0.0;\n\n  \
    \  for n in numbers {\n        min_number = std::min(n * min_number, min_number);\n\
    \        max_number = std::max(n * max_number, max_number);\n    }\n\n    let\
    \ mut factor = (max_number - min_number) as f64;\n\n    if factor != 0.0 {\n \
    \       let mut new_numbers = Vec::with_capacity(numbers.len() + 1);\n       \
    \ for n in numbers {\n            new_numbers.push((n - min_number) / factor)\n\
    \        }\n\n        new_numbers.push(min_number)\n    } else {\n        new_numbers\
    \ = Vec::new();\n    }\n\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n  --> /tmp/tmpt3x9wxr8.rs:10:27\n\
    \   |\n10 |         min_number = std::min(n * min_number, min_number);\n   | \
    \                          ^^^ not found in `std`\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::min;\n   |\nhelp: if you import `min`,\
    \ refer to it directly\n   |\n10 -         min_number = std::min(n * min_number,\
    \ min_number);\n10 +         min_number = min(n * min_number, min_number);\n \
    \  | \n\nerror[E0425]: cannot find function `max` in crate `std`\n  --> /tmp/tmpt3x9wxr8.rs:11:27\n\
    \   |\n11 |         max_number = std::max(n * max_number, max_number);\n   | \
    \                          ^^^ not found in `std`\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\nhelp: if you import `max`,\
    \ refer to it directly\n   |\n11 -         max_number = std::max(n * max_number,\
    \ max_number);\n11 +         max_number = max(n * max_number, max_number);\n \
    \  | \n\nerror[E0425]: cannot find value `new_numbers` in this scope\n  --> /tmp/tmpt3x9wxr8.rs:24:9\n\
    \   |\n24 |         new_numbers = Vec::new();\n   |         ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `new_numbers` in this scope\n\
    \  --> /tmp/tmpt3x9wxr8.rs:27:5\n   |\n27 |     new_numbers\n   |     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Scale the values so that all elements are in the same range [0, 1]\n \
    \   let min = numbers[0];\n    let max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n\n    // Calculate the scale factor to\
    \ divide each value by\n    let scale = (max - min) / (std::f64::MAX - std::f64::MIN);\n\
    \n    // Apply the scale factor to each value in the vector\n    let mut res =\
    \ Vec::new();\n    for n in numbers {\n        res.push((n - min) / scale);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `min`\n  --> /tmp/tmplh609077.rs:11:13\n\
    \   |\n7  |     let min = numbers[0];\n   |         ---\n   |         |\n   |\
    \         first assignment to `min`\n   |         help: consider making this binding\
    \ mutable: `mut min`\n...\n11 |             min = n;\n   |             ^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `max`\n  --> /tmp/tmplh609077.rs:14:13\n   |\n8  |   \
    \  let max = numbers[0];\n   |         ---\n   |         |\n   |         first\
    \ assignment to `max`\n   |         help: consider making this binding mutable:\
    \ `mut max`\n...\n14 |             max = n;\n   |             ^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0382]: use of moved value: `numbers`\n\
    \   --> /tmp/tmplh609077.rs:23:14\n    |\n5   | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n9   | \
    \    for n in numbers {\n    |              ------- `numbers` moved due to this\
    \ implicit call to `.into_iter()`\n...\n23  |     for n in numbers {\n    |  \
    \            ^^^^^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `numbers`\nhelp: consider iterating\
    \ over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n\
    \    |\n9   |     for n in &numbers {\n    |              +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0].to_f64();\n    let mut max = numbers[0].to_f64();\n\
    \    for &x in numbers {\n        if x < min {\n            min = x;\n       \
    \ }\n        if x > max {\n            max = x;\n        }\n    }\n    let max_len\
    \ = max - min;\n    for &x in numbers {\n        *x = *x / max_len * 0.9999;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpxwvd8r8j.rs:6:30\n  |\n6 |     let mut min = numbers[0].to_f64();\n\
    \  |                              ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n --> /tmp/tmpxwvd8r8j.rs:7:30\n\
    \  |\n7 |     let mut max = numbers[0].to_f64();\n  |                        \
    \      ^^^^^^ method not found in `f64`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpxwvd8r8j.rs:8:9\n  |\n8 |     for &x in numbers {\n  |         ^^  \
    \  ------- this expression has type `Option<f64>`\n  |         |\n  |        \
    \ expected `f64`, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `x`\n  |\n  = note:   expected type `f64`\n          found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwvd8r8j.rs:17:9\n\
    \   |\n17 |     for &x in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min: f64;\n    let mut max: f64;\n    let mut min_index: usize =\
    \ 0;\n    let mut max_index: usize = 0;\n    let mut min_value: f64 = std::f64::MAX;\n\
    \    let mut max_value: f64 = std::f64::MIN;\n    for &num in numbers {\n    \
    \    let n = num;\n        let value = n * max_value;\n        if value < min_value\
    \ {\n            min = min_value;\n            min_index = min_index;\n      \
    \      min_index += 1;\n            min -= value;\n        } else {\n        \
    \    if value < min {\n                min = value;\n                min_index\
    \ = min_index;\n            }\n        }\n        let value = n * min_value;\n\
    \        if value > max_value {\n            max = max_value;\n            max_index\
    \ = max_index;\n            max_index += 1;\n            max += value;\n     \
    \   } else {\n            if value > max {\n                max = value;\n   \
    \             max_index = max_index;\n            }\n        }\n    }\n    if\
    \ min == std::f64::MAX {\n        return vec![];\n    }\n    if max == std::f64::MIN\
    \ {\n        return vec![0];\n    }\n\n    let mut output = Vec::new();\n    for\
    \ i in 0..min_index {\n        let value = min - min_value * (i - min_index) /\
    \ (min_index - 1);\n        output.push(value as f64);\n    }\n    for i in max_index..numbers.len()\
    \ {\n        let value = max - max_value * (i - max_index) / (max_index - 1);\n\
    \        output.push(value as f64);\n    }\n    output\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbnk0e317.rs:12:9\n   |\n\
    12 |     for &num in numbers {\n   |         ^^^^    ------- this expression has\
    \ type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbnk0e317.rs:43:21\n   |\n43 |         return\
    \ vec![0];\n   |                     ^\n   |                     |\n   |     \
    \                expected `f64`, found integer\n   |                     help:\
    \ use a float literal: `0.0`\n\nerror[E0277]: cannot multiply `f64` by `usize`\n\
    \  --> /tmp/tmpbnk0e317.rs:48:37\n   |\n48 |         let value = min - min_value\
    \ * (i - min_index) / (min_index - 1);\n   |                                 \
    \    ^ no implementation for `f64 * usize`\n   |\n   = help: the trait `Mul<usize>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0277]: cannot multiply `f64` by `usize`\n  -->\
    \ /tmp/tmpbnk0e317.rs:52:37\n   |\n52 |         let value = max - max_value *\
    \ (i - max_index) / (max_index - 1);\n   |                                   \
    \  ^ no implementation for `f64 * usize`\n   |\n   = help: the trait `Mul<usize>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting due to 4 previous errors\n\nSome e"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min: f64 = numbers.iter().min().unwrap();\n    let max: f64 = numbers.iter().max().unwrap();\n\
    \    let scale: f64 = max - min;\n    let mut ret: Vec<f64> = vec![];\n    for\
    \ i in numbers {\n        ret.push((i - min) / scale + 0.0);\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp522f_a5n.rs:6:35\n\
    \     |\n6    |     let min: f64 = numbers.iter().min().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp522f_a5n.rs:6:20\n  |\n6 |    \
    \ let min: f64 = numbers.iter().min().unwrap();\n  |              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |              |\n  |              expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n6 |     let\
    \ min: f64 = *numbers.iter().min().unwrap();\n  |                    +\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp522f_a5n.rs:7:35\n\
    \     |\n7    |     let max: f64 = numbers.iter().max().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp522f_a5n.rs:7:20\n  |\n7 |    \
    \ let max: f64 = numbers.iter().max().unwrap();\n  |              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |              |\n  |              expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n7 |     let\
    \ max: f64 = *numbers.iter().max().unwrap();\n  |                    +\n\nerror:"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return Vec::new();\n    }\n\n    let min:\
    \ f64 = numbers.iter().min().unwrap();\n    let max: f64 = numbers.iter().max().unwrap();\n\
    \n    if min >= 0.0 && max <= 0.0 {\n        return Vec::new();\n    }\n\n   \
    \ let mut scale: f64 = 1.0;\n    if min < 0.0 {\n        let mut min_: f64 = min;\n\
    \        min_ -= min_ * min;\n        scale = -min_ / min;\n    }\n\n    let mut\
    \ newnumbers = Vec::new();\n    for n in numbers {\n        newnumbers.push(n\
    \ * scale);\n    }\n    newnumbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpg45ffjey.rs:10:35\n\
    \     |\n10   |     let min: f64 = numbers.iter().min().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg45ffjey.rs:10:20\n   |\n10 |\
    \     let min: f64 = numbers.iter().min().unwrap();\n   |              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n   |              |\n   |              expected\
    \ due to this\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |     let\
    \ min: f64 = *numbers.iter().min().unwrap();\n   |                    +\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpg45ffjey.rs:11:35\n\
    \     |\n11   |     let max: f64 = numbers.iter().max().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg45ffjey.rs:11:20\n   |\n11 |\
    \     let max: f64 = numbers.iter().max().unwrap();\n   |              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n   |              |\n   |              expected\
    \ due to this\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |     let\
    \ max: f64 = *numbers.iter().max().unwrap();\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() <= 1 {\n        return numbers;\n    }\n    let mut min_val\
    \ = numbers[0];\n    let mut max_val = numbers[0];\n    for i in numbers {\n \
    \       if i < min_val {\n            min_val = i;\n        }\n        if i >\
    \ max_val {\n            max_val = i;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for i in numbers {\n        let x = i - min_val;\n      \
    \  let y = x / max_val;\n        rescaled_numbers.push((x) as f64);\n        rescaled_numbers.push(y\
    \ as f64);\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmphaatffy4.rs:20:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n11  |     for i in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for i in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for i in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        numbers;\n    }\n\n    let mut largest =\
    \ numbers[0];\n    let mut smallest = numbers[0];\n    for &n in numbers {\n \
    \       if n < smallest {\n            smallest = n;\n        }\n        if n\
    \ > largest {\n            largest = n;\n        }\n    }\n    numbers.iter().map(|x|\
    \ x / smallest as f64).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9997s9p6.rs:12:9\n   |\n\
    12 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled = Vec::new();\n    for num in numbers.iter() {\n       \
    \ let min = num as f64;\n        let max = num * 1.0;\n        rescaled.push(num\
    \ * (max - min) + min);\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0606]: casting `&f64` as `f64` is invalid\n --> /tmp/tmpmvttu1iu.rs:8:19\n\
    \  |\n8 |         let min = num as f64;\n  |                   ---^^^^^^^\n  |\
    \                   |\n  |                   cannot cast `&f64` as `f64`\n  |\
    \                   help: dereference the expression: `*num`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers[0];\n    let max = numbers[0];\n    let mut min_scale =\
    \ 100.0;\n    let mut max_scale = 1000.0;\n    for &n in numbers {\n        min\
    \ = min.min(&n);\n        max = max.max(&n);\n        let scale = n.abs() * max_scale;\n\
    \        if scale < min_scale {\n            min_scale = scale;\n        }\n \
    \       if scale > max_scale {\n            max_scale = scale;\n        }\n  \
    \  }\n    let mut new_min = min / min_scale;\n    let mut new_max = max / max_scale;\n\
    \    let mut scale = 100.0;\n    for n in &numbers {\n        new_min = new_min.min(&n);\n\
    \        new_max = new_max.max(&n);\n        scale = n.abs() * scale;\n    }\n\
    \    new_min *= min_scale;\n    new_max *= max_scale;\n    let mut new_numbers\
    \ = Vec::new();\n    new_numbers.extend_from_slice(&[new_min, new_max]);\n   \
    \ new_numbers.extend_from_slice(&numbers[1..]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn085fcsa.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn085fcsa.rs:11:23\n   |\n11 |         min =\
    \ min.min(&n);\n   |                       ^^ expected `f64`, found reference\n\
    \   |\n   = note:   expected type `f64`\n           found reference `&_`\nhelp:\
    \ consider removing the borrow\n   |\n11 -         min = min.min(&n);\n11 +  \
    \       min = min.min(n);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn085fcsa.rs:12:23\n\
    \   |\n12 |         max = max.max(&n);\n   |                       ^^ expected\
    \ `f64`, found reference\n   |\n   = note:   expected type `f64`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n12 -         max =\
    \ max.max(&n);\n12 +         max = max.max(n);\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn085fcsa.rs:25:31\n   |\n25 |         new_min = new_min.min(&n);\n\
    \   |                               ^^ expected `f64`, found `&&f64`\n   |\nhelp:\
    \ consider removing the `&` and dereferencing the borrow instead\n   |\n25 | \
    \        new_min = new_min.min(*n);\n   |                               ~\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpn085fcsa.rs:26:31\n   |\n26 |  \
    \       new_max = new_max.max(&n);\n   |                               ^^ expected\
    \ `f64`, found `&&f64`\n   |\nhelp: consider removing the `&` and dereferencing\
    \ the borrow instead\n   |\n26 |         new_max = new_max.max(*n);\n   |    \
    \                           ~\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // get the length of the list\n    let len = numbers.len();\n\n    // get\
    \ the minimum and maximum value in the list\n    let min_val = numbers[0];\n \
    \   let max_val = numbers[0];\n    for i in 1..len {\n        if numbers[i] >\
    \ max_val {\n            max_val = numbers[i];\n        }\n\n        if numbers[i]\
    \ < min_val {\n            min_val = numbers[i];\n        }\n    }\n\n    // calculate\
    \ a scaling factor\n    let mut scale: f64 = 1.0;\n    if max_val - min_val >\
    \ 0.0001 {\n        scale = max_val - min_val;\n    }\n\n    // apply the scaling\
    \ factor to the numbers\n    let mut result = Vec::new();\n    for i in 1..len\
    \ {\n        let x = numbers[i] - min_val;\n        result.push(x * scale);\n\
    \    }\n\n    // return the scaled values\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `max_val`\n  -->\
    \ /tmp/tmp91qyhd7s.rs:14:13\n   |\n11 |     let max_val = numbers[0];\n   |  \
    \       -------\n   |         |\n   |         first assignment to `max_val`\n\
    \   |         help: consider making this binding mutable: `mut max_val`\n...\n\
    14 |             max_val = numbers[i];\n   |             ^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `min_val`\n  --> /tmp/tmp91qyhd7s.rs:18:13\n   |\n10 |\
    \     let min_val = numbers[0];\n   |         -------\n   |         |\n   |  \
    \       first assignment to `min_val`\n   |         help: consider making this\
    \ binding mutable: `mut min_val`\n...\n18 |             min_val = numbers[i];\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min: f64 = numbers[0] as f64;\n    let max: f64 = numbers[0] as f64;\n\
    \    for n in numbers {\n        min = cmp::min(min, n as f64);\n        max =\
    \ cmp::max(max, n as f64);\n    }\n    (0..numbers.len()).map(|i| numbers[i] /\
    \ max as f64 * max - min as f64 + min).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpqp_48l9q.rs:9:15\n  |\n9 |         min = cmp::min(min, n as f64);\n\
    \  |               ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpqp_48l9q.rs:10:15\n\
    \   |\n10 |         max = cmp::max(max, n as f64);\n   |               ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut new_numbers = Vec::new();\n    new_numbers.push((numbers[0] + numbers[1]).min(numbers[0]).max(numbers[0]));\n\
    \    new_numbers.push(numbers[0].max(numbers[0]).min(numbers[0]));\n    new_numbers.push(numbers[0].max(numbers[0]).min(numbers[0]));\n\
    \    new_numbers.push(numbers[0].max(numbers[0]).min(numbers[0]));\n    new_numbers.push(1.0);\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 2.0, 2.0, 2.0, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpy58kzqks.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers.iter().min().unwrap();\n    let mut max = numbers.iter().max().unwrap();\n\
    \    if min < 0.0 {\n        min = 0.0;\n    }\n    if max < 1.0 {\n        max\
    \ = 1.0;\n    }\n    let mut ratio = max - min;\n    let mut scale = (min + max)\
    \ / 2.0;\n    ratio = ratio * scale as f64;\n    let mut offset = -min as f64;\n\
    \    if ratio == 0.0 {\n        offset = 0.0;\n    }\n    let mut result = Vec::with_capacity(numbers.len()\
    \ + 1);\n    for i in 0..numbers.len() {\n        if numbers[i] != 0.0 {\n   \
    \         result.push(numbers[i] * scale + offset);\n        } else {\n      \
    \      result.push(0.0);\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp42m14_ao.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp42m14_ao.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp42m14_ao.rs:8:14\n  |\n8 |    \
    \ if min < 0.0 {\n  |              ^^^\n  |              |\n  |              expected\
    \ `&f64`, found floating-point number\n  |              help: consider borrowing\
    \ here: `&0.0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp42m14_ao.rs:9:15\n\
    \  |\n6 |     let mut min = numbers.iter().min().unwrap();\n  |              \
    \     ----------------------------- expected due to this value\n...\n9 |     \
    \    min = 0.0;\n  |               ^^^\n  |               |\n  |             \
    \  expected `&f64`, found floating-point number\n  |               help: consider\
    \ borrowing here: `&0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp42m14_ao.rs:11:14\n\
    \   |\n11 |     if max < 1.0 {\n   |              ^^^\n   |              |\n \
    \  |              "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().enumerate().map(|(i, value)| {\n        let min = *i;\n  \
    \      let max = *i;\n        if value < min {\n            value = 0.0\n    \
    \    } else if value > max {\n            value = 1.0\n        } else {\n    \
    \        value = value / (max - min);\n        }\n        value\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n --> /tmp/tmpnyduvm6g.rs:7:19\n\
    \  |\n7 |         let min = *i;\n  |                   ^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n --> /tmp/tmpnyduvm6g.rs:8:19\n  |\n8 |    \
    \     let max = *i;\n  |                   ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnyduvm6g.rs:10:21\n   |\n6  |     numbers.iter().enumerate().map(|(i,\
    \ value)| {\n   |                                         ----- expected due to\
    \ the type of this binding\n...\n10 |             value = 0.0\n   |          \
    \           ^^^\n   |                     |\n   |                     expected\
    \ `&f64`, found floating-point number\n   |                     help: consider\
    \ borrowing here: `&0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnyduvm6g.rs:12:21\n\
    \   |\n6  |     numbers.iter().enumerate().map(|(i, value)| {\n   |          \
    \                               ----- expected due to the type of this binding\n\
    ...\n12 |             value = 1.0\n   |                     ^^^\n   |        \
    \             |\n   |                     expected `&f64`, found floating-point\
    \ number\n   |                     help: consider borrowing here: `&1.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnyduvm6g.rs:14:21\n   |\n6  |     numbers.iter().enumerate().map(|(i,\
    \ value)| {\n   |                                         ----- expected due to\
    \ the type of this binding\n...\n14 |             value = value / (max - min);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^\n   |                     |\n  \
    \ |                     expected `&f64`, found `f64`\n   |                   \
    \  help: consider borrowing here: `&(value / (max - min))`\n\nerror[E0277]: a\
    \ value of type `Vec<f64>` cannot be built from an iterator over elements of type\
    \ `&f64`\n    --> /tmp/tmpnyduvm6g.rs:17:8\n     |\n17   |     }).collect()\n\
    \     |        ^^^^^^^ value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n\
    \     |\n     = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote:"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() == 1 {\n        numbers\n    } else {\n        let mut new_numbers\
    \ = numbers.clone();\n        new_numbers.sort();\n        loop {\n          \
    \  let mut smallest = new_numbers[0];\n            let mut largest = new_numbers[0];\n\
    \            for number in &new_numbers {\n                smallest = number *\
    \ smallest / number;\n                largest = number * largest / number;\n \
    \           }\n            if smallest == 0.0 {\n                break;\n    \
    \        }\n            new_numbers[0] = smallest;\n            new_numbers[new_numbers.len()\
    \ - 1] = largest;\n        }\n        new_numbers\n    }\n}\n\nfn main() {\n \
    \   let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpnpk99qxw.rs:10:21\n\
    \    |\n10  |         new_numbers.sort();\n    |                     ^^^^ the\
    \ trait `Ord` is not implemented for `f64`\n    |\n    = help: the following other\
    \ types implement trait `Ord`:\n              i128\n              i16\n      \
    \        i32\n              i64\n              i8\n              isize\n     \
    \         u128\n              u16\n            and 4 others\nnote: required by\
    \ a bound in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().cloned().map(|x| x / numbers.iter().sum()).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0284]: type annotations needed: cannot satisfy `<f64 as Div<_>>::Output\
    \ == f64`\n --> /tmp/tmpl_oicix8.rs:6:39\n  |\n6 |     numbers.iter().cloned().map(|x|\
    \ x / numbers.iter().sum()).collect()\n  |                                   \
    \    ^ cannot satisfy `<f64 as Div<_>>::Output == f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0284`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let mut lowest = numbers[0];\n    let mut\
    \ highest = numbers[0];\n    for n in numbers {\n        if n < lowest {\n   \
    \         lowest = n;\n        }\n        if n > highest {\n            highest\
    \ = n;\n        }\n    }\n    let mut scale = (highest - lowest).min(0.0).max(0.1);\n\
    \    let mut new_numbers = vec![lowest];\n    for i in 0..numbers.len() {\n  \
    \      new_numbers[i] = scale*numbers[i] + lowest;\n    }\n    new_numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpb7vce212.rs:17:9\n\
    \   |\n17 |     let mut scale = (highest - lowest).min(0.0).max(0.1);\n   |  \
    \       ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `numbers`\n   --> /tmp/tmpb7vce212.rs:19:17\n    |\n5   | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n    |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    9   |     for n in numbers {\n    |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n19  |     for i in 0..numbers.len()\
    \ {\n    |                 ^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n9   |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers.iter().min().unwrap_or(0.);\n    let mut max = numbers.iter().max().unwrap_or(1.);\n\
    \    for number in numbers {\n        let ratio = number as f64 / max - min;\n\
    \        min = min(min, ratio);\n        max = max(max, ratio);\n    }\n    let\
    \ result = numbers.iter().map(|n| min + n * max as f64).collect();\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpup92guig.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap_or(0.);\n     |\
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpup92guig.rs:6:50\n  |\n6 |    \
    \ let mut min = numbers.iter().min().unwrap_or(0.);\n  |                     \
    \                             ^^\n  |                                        \
    \          |\n  |                                                  expected `&f64`,\
    \ found floating-point number\n  |                                           \
    \       help: consider borrowing here: `&0.`\n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmpup92guig.rs:7:34\n     |\n7   \
    \ |     let mut max = numbers.iter().max().unwrap_or(1.);\n     |            \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n    \
    \ |\n     = help: the following other types implement trait `Ord`:\n         \
    \      i128\n               i16\n               i32\n               i64\n    \
    \           i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpup92guig.rs:7:50\n  |\n7 |    \
    \ let mut max = numbers.iter().max().unwrap_or(1.);\n  |                     \
    \                             ^^\n  |                                        \
    \          |\n  |                                                  expected `&f64`,\
    \ found floating-point number\n  |                "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_element = numbers.iter().min().unwrap();\n    let max_element = numbers.iter().max().unwrap();\n\
    \    let scale = (max_element - min_element) / numbers.len();\n    numbers.iter().map(|num|\
    \ num * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0uc8ct_u.rs:6:38\n\
    \     |\n6    |     let min_element = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0uc8ct_u.rs:7:38\n\
    \     |\n7    |     let max_element = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: cannot divide `f64` by `usize`\n --> /tmp/tmp0uc8ct_u.rs:8:45\n\
    \  |\n8 |     let scale = (max_element - min_element) / numbers.len();\n  |  \
    \                                           ^ no implementation for `f64 / usize`\n\
    \  |\n  = help: the trait `Div<usize>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Div<Rhs>`:\n            <&'a f32\
    \ as Div<f32>>\n            <&'a f64 as Div<f64>>\n            <&'a i128 as Div<i128>>\n\
    \            <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n      \
    \      <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n            <&'a\
    \ isize as Div<isize>>\n          and 54 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n    let\
    \ mut scaled_numbers = Vec::new();\n\n    for num in numbers.iter() {\n      \
    \  min_num = std::min(min_num, num);\n        max_num = std::max(max_num, num);\n\
    \    }\n\n    for num in numbers {\n        scaled_numbers.push((num - min_num)\
    \ / (max_num - min_num));\n    }\n\n    scaled_numbers\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n  --> /tmp/tmpjl9w04uz.rs:11:24\n\
    \   |\n11 |         min_num = std::min(min_num, num);\n   |                  \
    \      ^^^ not found in `std`\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\nhelp: if you import `min`, refer to it directly\n\
    \   |\n11 -         min_num = std::min(min_num, num);\n11 +         min_num =\
    \ min(min_num, num);\n   | \n\nerror[E0425]: cannot find function `max` in crate\
    \ `std`\n  --> /tmp/tmpjl9w04uz.rs:12:24\n   |\n12 |         max_num = std::max(max_num,\
    \ num);\n   |                        ^^^ not found in `std`\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\nhelp: if you import\
    \ `max`, refer to it directly\n   |\n12 -         max_num = std::max(max_num,\
    \ num);\n12 +         max_num = max(max_num, num);\n   | \n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n\n    let mut max = 0.0;\n    let mut min =\
    \ 0.0;\n    for (i, &v) in numbers.into_iter().enumerate().take(numbers.len()\
    \ - 1).enumerate() {\n        min = f64::min(min, v);\n        max = f64::max(max,\
    \ v);\n    }\n\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \n    for v in numbers.into_iter().cloned() {\n        if min == 0.0 && max ==\
    \ 1.0 {\n            new_numbers.push(v);\n        } else {\n            let v\
    \ = v * (max - min) / (max - min);\n            new_numbers.push(v);\n       \
    \ }\n    }\n\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsarvsdcw.rs:10:13\n   |\n\
    10 |     for (i, &v) in numbers.into_iter().enumerate().take(numbers.len() - 1).enumerate()\
    \ {\n   |             ^^     -------------------------------------------------------------------\
    \ this expression has type `Option<(usize, (usize, f64))>`\n   |             |\n\
    \   |             expected tuple, found reference\n   |             help: you\
    \ can probably remove the explicit borrow: `v`\n   |\n   = note:  expected tuple\
    \ `(usize, f64)`\n           found reference `&_`\n\nerror[E0271]: type mismatch\
    \ resolving `<std::vec::IntoIter<f64> as Iterator>::Item == &_`\n    --> /tmp/tmpsarvsdcw.rs:17:34\n\
    \     |\n17   |     for v in numbers.into_iter().cloned() {\n     |          \
    \                        ^^^^^^ expected reference, found `f64`\n     |\n    \
    \ = note: expected reference `&_`\n                     found type `f64`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<f64>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmpsarvsdcw.rs:17:14\n   |\n17 |     for\
    \ v in numbers.into_iter().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found reference\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<f64>>`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `Cloned<std::vec::IntoIter<f64>>`\n\
    \nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<f64> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpsarvsdcw.rs:17:14\n   |\n17 |     for v in numbers.into_iter().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found reference\n\
    \   |\n   = note:   expected type `f64`\n           found reference `&_`\n   =\
    \ note: required because of the requirements on the impl of `Iterator` for `Cloned<std::vec::IntoIter<f64>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308.\nFor more information about an error, try `rustc"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().map(|n| n / numbers.iter().min(|a, b| a.abs() - b.abs()).unwrap()).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxx7bu8lh.rs:6:47\n\
    \     |\n6    |     numbers.iter().map(|n| n / numbers.iter().min(|a, b| a.abs()\
    \ - b.abs()).unwrap()).collect()\n     |                                     \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpxx7bu8lh.rs:6:47\n\
    \     |\n6    |     numbers.iter().map(|n| n / numbers.iter().min(|a, b| a.abs()\
    \ - b.abs()).unwrap()).collect()\n     |                                     \
    \          ^^^ ------------------------ supplied 1 argument\n     |          \
    \                                     |\n     |                              \
    \                 expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0277.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min: f64 = numbers.iter().min().unwrap();\n    let mut max: f64 =\
    \ numbers.iter().max().unwrap();\n    max -= min;\n    numbers.iter_mut().for_each(|num|\
    \ {\n        *num = *num * (max - min) / f64::from(num);\n    });\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpoyj5d0l2.rs:6:39\n\
    \     |\n6    |     let mut min: f64 = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpoyj5d0l2.rs:6:24\n  |\n6 |    \
    \ let mut min: f64 = numbers.iter().min().unwrap();\n  |                  ---\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  |          \
    \        |\n  |                  expected due to this\n  |\nhelp: consider dereferencing\
    \ the borrow\n  |\n6 |     let mut min: f64 = *numbers.iter().min().unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmpoyj5d0l2.rs:7:39\n     |\n7    |     let mut max:\
    \ f64 = numbers.iter().max().unwrap();\n     |                               \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoyj5d0l2.rs:7:24\n  |\n7 |     let mut max: f64\
    \ = numbers.iter().max().unwrap();\n  |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |                  |\n  |                  expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n7 |     let\
    \ mut max: f64 = *num"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().cloned().collect::<Vec<_>>().iter().map(|n| f64::new(n)).collect::<Vec<_>>().map(|n|\
    \ n.unwrap()).map(|n| n.recip()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `new` found for type\
    \ `f64` in the current scope\n --> /tmp/tmpcbp0wuzs.rs:6:69\n  |\n6 |     numbers.iter().cloned().collect::<Vec<_>>().iter().map(|n|\
    \ f64::new(n)).collect::<Vec<_>>().map(|n| n.unwrap()).map(|n| n.recip()).co...\n\
    \  |                                                                     ^^^ function\
    \ or associated item not found in `f64`\n\nerror[E0599]: `Vec<_>` is not an iterator\n\
    \   --> /tmp/tmpcbp0wuzs.rs:6:97\n    |\n6   |       numbers.iter().cloned().collect::<Vec<_>>().iter().map(|n|\
    \ f64::new(n)).collect::<Vec<_>>().map(|n| n.unwrap()).map(|n| n.recip()).co...\n\
    \    |                                                                       \
    \                            ^^^ `Vec<_>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<_>: Iterator`\n\
    \            which is required by `&mut Vec<_>: Iterator`\n            `[_]: Iterator`\n\
    \            which is required by `&mut [_]: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    // Compute\
    \ the range of the numbers (in ascending order)\n    let min = numbers[0];\n \
    \   let max = numbers[0];\n    for num in numbers.iter().rev() {\n        if num\
    \ < min {\n            min = num;\n        }\n\n        if num > max {\n     \
    \       max = num;\n        }\n    }\n\n    // Compute the range of values between\
    \ min and max\n    let range = max - min;\n\n    // Compute the rescaled values\n\
    \    let mut rescaled_numbers = Vec::with_capacity(numbers.len());\n    for num\
    \ in numbers {\n        let rescaled = num / range * 0.999999;\n        rescaled_numbers.push(rescaled);\n\
    \    }\n\n    // Return the rescaled numbers\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpygj1shzq.rs:14:18\n   |\n\
    14 |         if num < min {\n   |                  ^^^\n   |                 \
    \ |\n   |                  expected `&f64`, found `f64`\n   |                \
    \  help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpygj1shzq.rs:15:19\n   |\n11 |     let min = numbers[0];\n   |  \
    \             ---------- expected due to this value\n...\n15 |             min\
    \ = num;\n   |                   ^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n15 |             min = *num;\n   |\
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpygj1shzq.rs:18:18\n\
    \   |\n18 |         if num > max {\n   |                  ^^^\n   |          \
    \        |\n   |                  expected `&f64`, found `f64`\n   |         \
    \         help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpygj1shzq.rs:19:19\n   |\n12 |     let max = numbers[0];\n   | \
    \              ---------- expected due to this value\n...\n19 |             max\
    \ = num;\n   |                   ^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |             max = *num;\n   |\
    \                   +\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut res = vec![];\n    let mut minval = numbers[0] as f64;\n    let mut\
    \ maxval = numbers[0] as f64;\n    for n in numbers {\n        res.push((n - minval)\
    \ / (maxval - minval));\n        minval = n;\n        maxval = n;\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[NaN, inf]`,\n right: `[0.0, 1.0]`', /tmp/tmpg2fig_32.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let min_rescaled = min_number / max_number;\n    numbers.iter().map(|x| x\
    \ * min_rescaled).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpvlyo78za.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpvlyo78za.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers[0] as f64;\n    let mut max_value = numbers[0]\
    \ as f64;\n    for i in numbers.iter() {\n        min_value = std::min(min_value,\
    \ i);\n        max_value = std::max(max_value, i);\n    }\n    (min_value, max_value)\
    \ as Vec<f64>\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n --> /tmp/tmpzfgeiq94.rs:9:26\n\
    \  |\n9 |         min_value = std::min(min_value, i);\n  |                   \
    \       ^^^ not found in `std`\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::min;\n  |\nhelp: if you import `min`, refer to it directly\n\
    \  |\n9 -         min_value = std::min(min_value, i);\n9 +         min_value =\
    \ min(min_value, i);\n  | \n\nerror[E0425]: cannot find function `max` in crate\
    \ `std`\n  --> /tmp/tmpzfgeiq94.rs:10:26\n   |\n10 |         max_value = std::max(max_value,\
    \ i);\n   |                          ^^^ not found in `std`\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\nhelp: if you import\
    \ `max`, refer to it directly\n   |\n10 -         max_value = std::max(max_value,\
    \ i);\n10 +         max_value = max(max_value, i);\n   | \n\nerror[E0605]: non-primitive\
    \ cast: `(f64, f64)` as `Vec<f64>`\n  --> /tmp/tmpzfgeiq94.rs:12:5\n   |\n12 |\
    \     (min_value, max_value) as Vec<f64>\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return Vec::new();\n    }\n\n    let max_number\
    \ = numbers[0] as f64;\n    let mut min_number = numbers[0] as f64;\n\n    for\
    \ number in numbers.iter().skip(1) {\n        if number > max_number {\n     \
    \       max_number = number;\n        }\n        if number < min_number {\n  \
    \          min_number = number;\n        }\n    }\n\n    let scale = max_number\
    \ - min_number;\n    let mut numbers_rescaled = Vec::new();\n    for number in\
    \ numbers {\n        let value = number * (1.0 / scale);\n        numbers_rescaled.push(value);\n\
    \    }\n\n    numbers_rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphq7kfbux.rs:14:21\n   |\n\
    14 |         if number > max_number {\n   |                     ^^^^^^^^^^\n \
    \  |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&max_number`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphq7kfbux.rs:15:26\n   |\n10 |     let max_number\
    \ = numbers[0] as f64;\n   |                      ----------------- expected due\
    \ to this value\n...\n15 |             max_number = number;\n   |            \
    \              ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |             max_number = *number;\n   |             \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphq7kfbux.rs:17:21\n\
    \   |\n17 |         if number < min_number {\n   |                     ^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&min_number`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphq7kfbux.rs:18:26\n   |\n11 |     let mut min_number\
    \ = numbers[0] as f64;\n   |                          ----------------- expected\
    \ due to this value\n...\n18 |             min_number = number;\n   |        \
    \                  ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |             min_number = *number;\n   |             \
    \             +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().map(|n| n).map(|n| n * 2 / numbers.last().unwrap()).collect::<Vec<f64>>()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `&f64` by `{integer}`\n --> /tmp/tmp5d60pkkf.rs:6:41\n\
    \  |\n6 |     numbers.iter().map(|n| n).map(|n| n * 2 / numbers.last().unwrap()).collect::<Vec<f64>>()\n\
    \  |                                         ^ no implementation for `&f64 * {integer}`\n\
    \  |\n  = help: the trait `Mul<{integer}>` is not implemented for `&f64`\n  =\
    \ help: the following other types implement trait `Mul<Rhs>`:\n            <&'a\
    \ f32 as Mul<f32>>\n            <&'a f64 as Mul<f64>>\n            <&'a i128 as\
    \ Mul<i128>>\n            <&'a i16 as Mul<i16>>\n            <&'a i32 as Mul<i32>>\n\
    \            <&'a i64 as Mul<i64>>\n            <&'a i8 as Mul<i8>>\n        \
    \    <&'a isize as Mul<isize>>\n          and 49 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0] as f64;\n    let mut max = numbers[0] as f64;\n\
    \    for i in numbers.iter_mut() {\n        if i < min {\n            min = i;\n\
    \        }\n        if i > max {\n            max = i;\n        }\n    }\n   \
    \ let mut scale = (max - min) as f64 / 2.0;\n    for i in numbers.iter_mut() {\n\
    \        *i = *i / scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv00ay4c7.rs:9:16\n  |\n9 |\
    \         if i < min {\n  |                ^^^\n  |                |\n  |    \
    \            expected `&mut f64`, found `f64`\n  |                help: consider\
    \ mutably borrowing here: `&mut min`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv00ay4c7.rs:10:19\n   |\n6  |     let mut min = numbers[0] as f64;\n\
    \   |                   ----------------- expected due to this value\n...\n10\
    \ |             min = i;\n   |                   ^ expected `f64`, found `&mut\
    \ f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |            \
    \ min = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv00ay4c7.rs:12:16\n   |\n12 |         if i > max {\n   |           \
    \     ^^^\n   |                |\n   |                expected `&mut f64`, found\
    \ `f64`\n   |                help: consider mutably borrowing here: `&mut max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv00ay4c7.rs:13:19\n   |\n7  |\
    \     let mut max = numbers[0] as f64;\n   |                   -----------------\
    \ expected due to this value\n...\n13 |             max = i;\n   |           \
    \        ^ expected `f64`, found `&mut f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |             max = *i;\n   |                   +\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut n = numbers[0].abs();\n    for n in numbers {\n        if n > n {\n\
    \            n = n;\n        }\n    }\n    numbers.iter().map(|n| n.exp().ln()).collect::<Vec<_>>().iter().map(|n|\
    \ n * n).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `n`\n --> /tmp/tmpbtbi32os.rs:6:13\n  |\n6 |\
    \     let mut n = numbers[0].abs();\n  |             ^ help: if this is intentional,\
    \ prefix it with an underscore: `_n`\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: value assigned to `n` is never read\n --> /tmp/tmpbtbi32os.rs:9:13\n\
    \  |\n9 |             n = n;\n  |             ^\n  |\n  = note: `#[warn(unused_assignments)]`\
    \ on by default\n  = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n --> /tmp/tmpbtbi32os.rs:6:9\n  |\n6 |\
    \     let mut n = numbers[0].abs();\n  |         ----^\n  |         |\n  |   \
    \      help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign twice to immutable variable `n`\n --> /tmp/tmpbtbi32os.rs:9:13\n\
    \  |\n7 |     for n in numbers {\n  |         -\n  |         |\n  |         first\
    \ assignment to `n`\n  |         help: consider making this binding mutable: `mut\
    \ n`\n8 |         if n > n {\n9 |             n = n;\n  |             ^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \   --> /tmp/tmpbtbi32os.rs:12:5\n    |\n5   | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n6   |     let\
    \ mut n = numbers[0].abs();\n7   |     for n in numbers {\n    |             \
    \ ------- `numbers` moved due to this implicit call to `.into_iter()`\n...\n12\
    \  |     numbers.iter().map(|n| n.exp().ln()).collect::<Vec<_>>().iter().map(|n|\
    \ n * n).collect::<Vec<_>>()\n    |     ^^^^^^^^^^^^^^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `numbers`\n    = note: borrow occurs due to deref coercion to `[f64]`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n7   |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome\
    \ errors hav"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ n in numbers {\n        if n < smallest {\n            smallest = n;\n     \
    \   }\n        if n > largest {\n            largest = n;\n        }\n    }\n\n\
    \    let mut range = largest.abs() - smallest.abs();\n    for n in numbers {\n\
    \        if n > largest {\n            n /= range;\n            n += smallest;\n\
    \        }\n        range = largest.abs() - smallest.abs();\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `n` is never read\n  --> /tmp/tmpho5u_w5c.rs:21:13\n\
    \   |\n21 |             n += smallest;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0382]:\
    \ use of moved value: `numbers`\n   --> /tmp/tmpho5u_w5c.rs:18:14\n    |\n5  \
    \ | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |               \
    \     ------- move occurs because `numbers` has type `Vec<f64>`, which does not\
    \ implement the `Copy` trait\n...\n8   |     for n in numbers {\n    |       \
    \       ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpho5u_w5c.rs:20:13\n   |\n18 |     for n in numbers {\n  \
    \ |         -\n   |         |\n   |         first assignment to `n`\n   |    \
    \     help: consider making this binding mutable: `mut n`\n19 |         if n >\
    \ largest {\n20 |             n /= range;\n   |             ^^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `n`\n  --> /tmp/tmpho5u_w5c.rs:21:13\n   |\n18 |     for n in numbers\
    \ {\n   |         -\n   |         |\n   |         first assignment to `n`\n  \
    \ |         help: consider making this binding mutable: `mut n`\n...\n21 |   \
    \          n += smallest;\n   |             ^^^^^^^^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror[E0382]: use of moved value: `numbers`\n  -->\
    \ /tmp/tmpho5u_w5c.rs:25:5\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) ->\
    \ Vec<f64> {\n   |                    ------- move occurs because `numbers` has\
    \ type `Vec<f64>`, which does not implement the `Copy` trait\n...\n18 |     for\
    \ n in numbers {\n   |              ------- `num"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n    let mut min_number\
    \ = numbers[0];\n    let mut max_number = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        if min_number > numbers[i] {\n            min_number = numbers[i];\n\
    \        }\n        if max_number < numbers[i] {\n            max_number = numbers[i];\n\
    \        }\n    }\n    let range = max_number - min_number;\n    numbers.iter_mut().for_each(|num|\
    \ {\n        *num -= min_number;\n        *num *= (1.0 - range) / (1.0 + range);\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpj1c7_jzs.rs:20:5\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n20 |     numbers.iter_mut().for_each(|num|\
    \ {\n   |     ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max_num = numbers.iter().max().unwrap();\n    let mut rescaled: Vec<f64>\
    \ = Vec::new();\n    for x in numbers {\n        rescaled.push(x / (max_num -\
    \ x));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpk05_oilk.rs:6:34\n\
    \     |\n6    |     let max_num = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers.min();\n    let mut max_value = numbers.max();\n\
    \    let mut scale = 1;\n    while min_value != max_value {\n        if min_value\
    \ == 0.0 {\n            min_value = 0.0;\n        } else {\n            min_value\
    \ = min_value / scale;\n        }\n        if max_value == 1.0 {\n           \
    \ max_value = 1.0;\n        } else {\n            max_value = max_value / scale;\n\
    \        }\n        scale = scale / 2.0;\n    }\n    numbers.iter().map(|x| x\
    \ * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpu9kj_2c_.rs:6:33\n    |\n6   |   \
    \    let mut min_value = numbers.min();\n    |                               \
    \    ^^^ method cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n           \
    \ `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n       \
    \     `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>: Ord`\n\
    \            `Vec<f64>: Iterator`\n            which is required by `&mut Vec<f64>:\
    \ Iterator`\n            `f64: Ord`\n            which is required by `[f64]:\
    \ Ord`\n            `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n\
    \            `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n\
    \            `[f64]: Iterator`\n            which is required by `&mut [f64]:\
    \ Iterator`\n\nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpu9kj_2c_.rs:7:33\n    |\n\
    7   |       let mut max_value = numbers.max();\n    |                        \
    \           ^^^ method cannot be called on `Vec<f64>` due to unsatisfied trait\
    \ bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n  \
    \          `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n\
    \            `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>:\
    \ Ord`\n            `Vec<f64>: Iterator`\n            which is required by `&mut\
    \ Vec<f64>: Iterator`\n            `f64: Ord`\n            which is required by\
    \ `[f64]: Ord`\n            `[f64]: Ord`\n            which is required by `&[f64]:\
    \ Ord`\n            `[f64]: Ord`\n            which is required by `&mut [f64]:\
    \ Ord`\n            `[f64]: Iterator`\n            which is required by `&mut\
    \ [f64]: Iterator`\n\nerror[E0277]: cannot divide `{float}` by `{integer}`\n \
    \ --> /tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().map(|num| num / f64::from(*numbers.min()).unwrap()).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpjvahd5qe.rs:6:55\n    |\n6   |   \
    \    numbers.iter().map(|num| num / f64::from(*numbers.min()).unwrap()).collect()\n\
    \    |                                                         ^^^ method cannot\
    \ be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `f64: Ord`\n   \
    \         which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0599]: no method named `unwrap` found for type `f64` in the current scope\n\
    \ --> /tmp/tmpjvahd5qe.rs:6:62\n  |\n6 |     numbers.iter().map(|num| num / f64::from(*numbers.min()).unwrap()).collect()\n\
    \  |                                                              ^^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() > 2);\n    let min_num = numbers[0];\n    let max_num\
    \ = numbers[0];\n    for num in numbers.iter().skip(1) {\n        if num < min_num\
    \ {\n            min_num = num;\n        }\n        if num > max_num {\n     \
    \       max_num = num;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    new_numbers.extend_from_slice(&[min_num]);\n    new_numbers.extend_from_slice(&[max_num]);\n\
    \    new_numbers.extend_from_slice(&numbers.iter().cloned());\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq2kajnvo.rs:10:18\n   |\n\
    10 |         if num < min_num {\n   |                  ^^^^^^^\n   |         \
    \         |\n   |                  expected `&f64`, found `f64`\n   |        \
    \          help: consider borrowing here: `&min_num`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq2kajnvo.rs:11:23\n   |\n7  |     let min_num = numbers[0];\n\
    \   |                   ---------- expected due to this value\n...\n11 |     \
    \        min_num = num;\n   |                       ^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |          \
    \   min_num = *num;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq2kajnvo.rs:13:18\n   |\n13 |         if num > max_num\
    \ {\n   |                  ^^^^^^^\n   |                  |\n   |            \
    \      expected `&f64`, found `f64`\n   |                  help: consider borrowing\
    \ here: `&max_num`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq2kajnvo.rs:14:23\n\
    \   |\n8  |     let max_num = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n14 |             max_num = num;\n   |              \
    \         ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             max_num = *num;\n   |                   \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq2kajnvo.rs:20:35\n  \
    \ |\n20 |     new_numbers.extend_from_slice(&numbers.iter().cloned());\n   | \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^ expected slice `[f64]`,\
    \ found struct `Cloned`\n   |\n   = note: expected reference `&[f64]`\n      \
    \        found reference `&Cloned<std::slice::Iter<'_, f64>>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.is_empty() {\n        return vec![];\n    }\n    let mut min =\
    \ numbers[0];\n    let mut max = numbers[0];\n    for num in numbers {\n     \
    \   if num < min {\n            min = num;\n        }\n        if num > max {\n\
    \            max = num;\n        }\n    }\n    numbers.iter().map(|f| f - min\
    \ / max).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpsbfgiz0s.rs:19:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n11  |     for num in numbers {\n \
    \   |                ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     numbers.iter().map(|f| f - min / max).collect()\n    |     ^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `numbers`\n    = note: borrow occurs due to\
    \ deref coercion to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for num in &numbers\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Sort the numbers so that they are in ascending order\n    let mut numbers_sorted\
    \ = numbers.clone();\n    numbers_sorted.sort();\n\n    // Calculate the maximum\
    \ and minimum values in the list\n    let mut max_num = numbers_sorted[0];\n \
    \   let mut min_num = numbers_sorted[0];\n\n    for i in 1..numbers_sorted.len()\
    \ {\n        if numbers_sorted[i] > max_num {\n            max_num = numbers_sorted[i];\n\
    \        }\n\n        if numbers_sorted[i] < min_num {\n            min_num =\
    \ numbers_sorted[i];\n        }\n    }\n\n    // Calculate the actual range of\
    \ the numbers (max - min)\n    let actual_range = max_num - min_num;\n\n    //\
    \ Calculate the expected range\n    let expected_range: f64;\n    if numbers_sorted.len()\
    \ > 2 {\n        // The expected range is equal to the difference between the\
    \ largest and smallest elements\n        expected_range = (numbers_sorted[2] -\
    \ numbers_sorted[1])\n    } else {\n        // The expected range is equal to\
    \ the range (max-min)\n        expected_range = numbers_sorted[1] - numbers_sorted[0];\n\
    \    }\n\n    let mut new_numbers = Vec::new();\n    for i in 0..numbers_sorted.len()\
    \ {\n        // Calculate the percent of actual range that this number will be\
    \ in the new range\n        let percent_in_range = (numbers_sorted[i] - min_num)\
    \ / actual_range;\n\n        // Convert this percent to the new range\n      \
    \  let percent_in_new_range: f64 = percent_in_range * expected_range;\n\n    \
    \    // Calculate the new number by adding this percent of actual range to this\
    \ number\n        let new_number = numbers_sorted[i] + percent_in_new_range;\n\
    \n        // Add the new number to our new list\n        new_numbers.push(new_number);\n\
    \    }\n\n    return new_numbers;\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp9j6ifscw.rs:31:26\n\
    \   |\n31 |         expected_range = (numbers_sorted[2] - numbers_sorted[1])\n\
    \   |                          ^                                     ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n31 -         expected_range = (numbers_sorted[2] - numbers_sorted[1])\n\
    31 +         expected_range = numbers_sorted[2] - numbers_sorted[1]\n   | \n\n\
    error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmp9j6ifscw.rs:8:20\n\
    \    |\n8   |     numbers_sorted.sort();\n    |                    ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    numbers.iter().fold(0.0, |acc, x| acc + x / numbers.length).map(|x| x / numbers.length)\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `Vec<f64>`\n --> /tmp/tmpp9q0thdy.rs:6:57\n\
    \  |\n6 |     numbers.iter().fold(0.0, |acc, x| acc + x / numbers.length).map(|x|\
    \ x / numbers.length)\n  |                                                   \
    \      ^^^^^^ unknown field\n\nerror[E0599]: `f64` is not an iterator\n --> /tmp/tmpp9q0thdy.rs:6:65\n\
    \  |\n6 |     numbers.iter().fold(0.0, |acc, x| acc + x / numbers.length).map(|x|\
    \ x / numbers.length)\n  |                                                   \
    \              ^^^ `f64` is not an iterator\n  |\n  = note: the following trait\
    \ bounds were not satisfied:\n          `f64: Iterator`\n          which is required\
    \ by `&mut f64: Iterator`\n\nerror[E0609]: no field `length` on type `Vec<f64>`\n\
    \ --> /tmp/tmpp9q0thdy.rs:6:85\n  |\n6 |     numbers.iter().fold(0.0, |acc, x|\
    \ acc + x / numbers.length).map(|x| x / numbers.length)\n  |                 \
    \                                                                    ^^^^^^ unknown\
    \ field\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0] as f64;\n    let mut max = numbers[0] as f64;\n\
    \    for x in numbers.iter() {\n        if x < min {\n            min = x;\n \
    \       }\n        if x > max {\n            max = x;\n        }\n    }\n    let\
    \ mut ret = vec![];\n    for x in numbers {\n        if x < min {\n          \
    \  ret.append(0.0);\n        } else {\n            ret.append(x / max);\n    \
    \    }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsbtuypcm.rs:9:16\n  |\n9 |\
    \         if x < min {\n  |                ^^^\n  |                |\n  |    \
    \            expected `&f64`, found `f64`\n  |                help: consider borrowing\
    \ here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsbtuypcm.rs:10:19\n\
    \   |\n6  |     let mut min = numbers[0] as f64;\n   |                   -----------------\
    \ expected due to this value\n...\n10 |             min = x;\n   |           \
    \        ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n10 |             min = *x;\n   |                   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsbtuypcm.rs:12:16\n   |\n12 |         if x >\
    \ max {\n   |                ^^^\n   |                |\n   |                expected\
    \ `&f64`, found `f64`\n   |                help: consider borrowing here: `&max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsbtuypcm.rs:13:19\n   |\n7  |\
    \     let mut max = numbers[0] as f64;\n   |                   -----------------\
    \ expected due to this value\n...\n13 |             max = x;\n   |           \
    \        ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n13 |             max = *x;\n   |                   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsbtuypcm.rs:19:24\n   |\n19 |             ret.append(0.0);\n\
    \   |                        ^^^ expected `&mut Vec<_>`, found floating-point\
    \ number\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n        \
    \                   found type `{float}`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpsbtuypcm.rs:21:24\n   |\n21 |             ret.append(x / max);\n\
    \   |                        ^^^^^^^ expected `&mut Vec<_>`, found `f64`\n   |\n\
    \   = note: expected mutable reference `&mut Vec<_>`\n                       \
    \    found type `f64`\n\nerror: aborting due to 6 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min_value = numbers.iter().min().unwrap();\n    let mut max_value\
    \ = numbers.iter().max().unwrap();\n\n    if min_value < 0 {\n        min_value\
    \ = 0;\n    }\n\n    if max_value > 1.0 {\n        max_value = 1.0;\n    }\n\n\
    \    let factor = max_value - min_value;\n    numbers.iter_mut().for_each(|num|\
    \ {\n        *num = (num - min_value) / factor;\n    });\n\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbm2r7q2_.rs:6:40\n\
    \     |\n6    |     let mut min_value = numbers.iter().min().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbm2r7q2_.rs:7:40\n\
    \     |\n7    |     let mut max_value = numbers.iter().max().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpbm2r7q2_.rs:9:20\n  |\n9 |    \
    \ if min_value < 0 {\n  |                    ^ expected `&f64`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbm2r7q2_.rs:10:21\n   |\n6  |\
    \     let mut min_value = numbers.iter().min().unwrap();\n   |               \
    \          ----------------------------- expected due to this value\n...\n10 |\
    \         min_value = 0;\n   |                     ^ expected `&f64`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbm2r7q2_.rs:13:20\n   |\n13 |\
    \     if max_value > 1.0 {\n   |                    ^^^\n   |                \
    \    |\n   |                    expected `&f64`, found floating-point number\n\
    \   |                    help: consider borrowing here: `&1.0`\n\nerror[E0308]:\
    \ mismatch"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let mut min\
    \ = numbers[0];\n    let mut max = numbers[0];\n    for &number in numbers {\n\
    \        if number < min {\n            min = number;\n        }\n        if number\
    \ > max {\n            max = number;\n        }\n    }\n\n    let mut factor =\
    \ 1;\n    let mut result = Vec::with_capacity(numbers.len());\n    for &number\
    \ in numbers {\n        result.push(number * factor + min * factor - max * factor);\n\
    \        factor *= (max - min) / (number as f64 - min);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdr7mpyk1.rs:12:9\n   |\n\
    12 |     for &number in numbers {\n   |         ^^^^^^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `number`\n  \
    \ |\n   = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdr7mpyk1.rs:23:9\n   |\n23 |     for &number\
    \ in numbers {\n   |         ^^^^^^^    ------- this expression has type `Option<f64>`\n\
    \   |         |\n   |         expected `f64`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `number`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror[E0277]: cannot multiply\
    \ `f64` by `{integer}`\n  --> /tmp/tmpdr7mpyk1.rs:24:43\n   |\n24 |         result.push(number\
    \ * factor + min * factor - max * factor);\n   |                             \
    \              ^ no implementation for `f64 * {integer}`\n   |\n   = help: the\
    \ trait `Mul<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0277]: cannot\
    \ multiply `f64` by `{integer}`\n  --> /tmp/tmpdr7mpyk1.rs:24:58\n   |\n24 | \
    \        result.push(number * factor + min * factor - max * factor);\n   |   \
    \                                                       ^ no implementation for\
    \ `f64 * {integer}`\n   |\n   = help: the trait `Mul<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i6"
  exit_code: 1
  status: SyntaxError
