name: HumanEval_153_Strongest_Extension
language: rust
prompt: "/// You will be given the name of a class (a string) and a list of extensions.\n\
  /// The extensions are to be used to load additional classes to the class. The\n\
  /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  /// letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n/// You should find the strongest extension and return a string in this \n///\
  \ format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
  \ with the same strength, you should\n/// choose the one that comes first in the\
  \ list.\n/// For example, if you are given \"Slices\" as the class and a list of\
  \ the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
  /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
  \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
  \ extensions: Vec<String>) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
  Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
  eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
  Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
  YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
  ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
  t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
  ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
  __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
  Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]),\
  \ String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"),\
  \ vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"\
  -_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
  YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
  WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"\
  ));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"\
  Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]),\
  \ String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
  _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
  ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
  ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
completions: ["    let mut strongest_extension = format!(\"{}.0\", class_name);\n\n\
    \    for extension in extensions {\n        let (strength, name) = extension.chars().count();\n\
    \        if strength > strongest_extension.chars().count() as i32 {\n        \
    \    strongest_extension = format!(\"{}.{}\", class_name, name);\n        }\n\
    \    }\n\n    strongest_extension", "    let mut strength = -1i32;\n    for extension\
    \ in extensions {\n        match extension.chars().filter(|c| c.is_uppercase()).count()\
    \ {\n            2 => {\n                if strength > 0 {\n                 \
    \   return class_name + \".\" + extension;\n                } else {\n       \
    \             strength = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \                    return class_name + \".\" + extension;\n                }\n\
    \            },\n            _ => {\n                strength = strength.saturating_sub(extension.chars().filter(|c|\
    \ c.is_lowercase()).count());\n            }\n        }\n    }\n    if strength\
    \ > 0 {\n        return class_name + \".\" + extensions[0];\n    } else {\n  \
    \      return class_name;\n    }", "    let mut counter = String::new();\n   \
    \ let mut extensions_count = extensions[0].len() as f64;\n    for ext in extensions\
    \ {\n        if ext.len() == extensions_count {\n            counter.push_str(&ext);\n\
    \        } else {\n            counter.push_str(&ext[..(counter.len() - extensions_count)].to_ascii_lowercase());\n\
    \            extensions_count = ext.len() as f64;\n            counter.push_str(&ext[..(counter.len()\
    \ - extensions_count)].to_ascii_uppercase());\n        }\n    }\n    counter.push_str(&class_name[..counter.len()\
    \ - extensions_count].to_ascii_uppercase());\n    counter.push_str(&class_name[..counter.len()\
    \ - extensions_count].to_ascii_lowercase());\n    counter", "    // Your code\
    \ here\n    let mut s = String::new();\n    for e in extensions.iter() {\n   \
    \     if e.chars().filter(|x|x == char::ToUpper).count() > e.chars().filter(|x|x\
    \ == char::ToLower).count() {\n            s = s.push_str(e);\n        } else\
    \ {\n            s = s.push_str(&e);\n        }\n    }\n    s + \"_\" + class_name",
  "    let mut sm = 0;\n    let mut cap = 0;\n    for extension in extensions {\n\
    \        let mut extension_length = extension.len();\n        if extension_length\
    \ >= class_name.len() {\n            extension_length = class_name.len();\n  \
    \      }\n        for index in 0..extension_length {\n            if class_name.chars().any(|c|\
    \ c == extension[index]) {\n                sm = sm + 1;\n            }\n    \
    \        if class_name.chars().all(|c| c == extension[index].lowercase()) {\n\
    \                cap = cap + 1;\n            }\n        }\n    }\n    (1.0 * cap\
    \ as f64) / (1.0 * sm as f64) as String", "    let mut strength = -1;\n    let\
    \ mut name = \"\";\n    for extension in extensions {\n        let splitted_name\
    \ = extension.split(\"_\").map(|x| x.to_lowercase()).collect::<Vec<_>>();\n  \
    \      let caps = splitted_name.len();\n        let sms = splitted_name.len()\
    \ - caps;\n        assert!(sms == 0 || caps == 0, \"Unexpected extension's name\"\
    );\n        strength += caps as f64 - sms as f64;\n        name = splitted_name.iter().max().unwrap();\n\
    \    }\n    format!(\"{}{}.{}\", class_name, name, strength)", "    if extensions.len()\
    \ < 3 {\n        \"\".to_string()\n    }\n    let mut strength = 0usize;\n   \
    \ let mut max_extension = \"\".to_string();\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|&x| x > 'A' && x < 'Z').count();\n\
    \        let sm = extension.chars().filter(|&x| x > 'a' && x < 'z').count();\n\
    \        strength = if cap < sm { cap - sm } else { sm - cap };\n        if strength\
    \ > max_extension.len() {\n            max_extension = extension;\n        }\n\
    \    }\n    if strength != 0usize {\n        class_name + String::from(\".\")\
    \ + max_extension\n    } else {\n        class_name + String::from(\".\")\n  \
    \  }", "    if extensions.is_empty() {\n        return \"\";\n    }\n    let mut\
    \ class_name = class_name.to_string();\n    let mut best_extension: Vec<String>\
    \ = Vec::new();\n    let mut strongest_extension: String = String::from(\"\");\n\
    \    let mut is_best_extension = true;\n\n    for extension in extensions {\n\
    \        let mut extension = extension.to_string();\n        let mut first_letter\
    \ = String::from(\"-\");\n        for c in extension.chars() {\n            if\
    \ c.is_uppercase() {\n                first_letter = String::from(*c.to_ascii_lowercase());\n\
    \            }\n        }\n        let mut strength = first_letter.len() as i32;\n\
    \        let mut extension_parts = extension.split_by_ascii_lowercase();\n   \
    \     for part in extension_parts {\n            if part.len() <= strongest_extension.len()\
    \ {\n                strongest_extension = String::from(part.to_ascii_lowercase());\n\
    \            } else {\n                strength = (part.len() - strongest_extension.len())\
    \ as i32;\n            }\n        }\n        if strength > 0 {\n            if\
    \ best_extension.is_empty() || strength < best_extension[0].len() {\n        \
    \        best_extension.push(String::from(extension));\n            }\n      \
    \  } else {\n            strongest_extension = String::from(extension);\n    \
    \    }\n    }\n    if best_extension.is_empty() {\n        return strongest_extension;\n\
    \    }\n    for best_extension in best_extension {\n        let mut strength =\
    \ best_extension.len() as i32;\n        if strength > 0 {\n            is_best_extension\
    \ = false;\n            break;\n        }\n    }\n    if is_best_extension {\n\
    \        return class_name + \".\" + strongest_extension;\n    } else {\n    \
    \    return class_name;\n    }", "    let mut num_uppercase = String::new();\n\
    \    let mut num_lowercase = String::new();\n\n    for extension in extensions\
    \ {\n        let num_upper = extension.chars().filter(|&c| c.is_uppercase().unwrap()).count();\n\
    \        num_upper.to_string().push_str(&num_uppercase);\n        num_uppercase.push_str(&num_upper);\n\
    \n        let num_lower = extension.chars().filter(|&c| c.is_lowercase().unwrap()).count();\n\
    \        num_lower.to_string().push_str(&num_lowercase);\n        num_lowercase.push_str(&num_lower);\n\
    \    }\n\n    let mut strength = String::new();\n    if num_uppercase > num_lowercase\
    \ {\n        strength.push_str(&class_name.to_string().to_lowercase());\n    }\
    \ else {\n        strength.push_str(&class_name.to_string().to_uppercase());\n\
    \    }\n    strength.push_str(&extensions[extensions.len() - 1]);\n\n    strength",
  "    let mut max_strength = -1;\n    let mut max_extension_name = String::new();\n\
    \    for (i, e) in extensions.iter().enumerate() {\n        let (strength, extension)\
    \ = e.split('.').map(|s| s.parse().ok()).unwrap_or_else(|_| {\n            panic!(\"\
    Strongest_Extension: failed to parse extension {}\", e)\n        });\n       \
    \ if strength > max_strength {\n            max_strength = strength;\n       \
    \     max_extension_name = e.to_string();\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, max_extension_name)", "    let mut classname = String::from(class_name);\n\
    \    let mut extensions = extensions.iter().cloned();\n    let mut strength =\
    \ -1;\n    let mut best_extension = String::from(\"\");\n\n    loop {\n      \
    \  let mut extension = String::from(\"\");\n\n        match extension.chars().enumerate().find(|&(_,\
    \ n)| n == 0 {\n            0 => true,\n            _ => false\n        }) {\n\
    \            Some((i, _)) => extension = extensions[i - 1],\n            None\
    \ => break,\n        }\n\n        if extension != \"\" {\n            let cap_offset\
    \ = classname.chars().count() + extension.chars().count() - 1;\n            let\
    \ sma_offset = classname.chars().count() - extension.chars().count();\n      \
    \      strength = (cap_offset - sma_offset) as f64 / cap_offset;\n        }\n\n\
    \        if strength > 0 {\n            best_extension = extension.to_string()\
    \ + classname + best_extension;\n        } else {\n            best_extension\
    \ = extension.to_string() + classname;\n        }\n\n        if extensions.len()\
    \ == 0 || strength == -1 {\n            break;\n        }\n\n        extensions.remove(best_extension);\n\
    \        extension = String::from(\"\");\n    }\n\n    best_extension", "    let\
    \ mut counter: usize = 0;\n    for extension in extensions {\n        if extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() == 0 {\n            return format!(\"{}.{}\",\
    \ class_name, extension);\n        }\n        counter += extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    }\n    if counter == 0 {\n        return\
    \ format!(\"{}.{}\", class_name, extensions.iter().min().unwrap());\n    }\n \
    \   format!(\"{}.{}\", class_name, extensions.iter().sort_by_key(|&x| x.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count()).first().unwrap());", "    let mut result: usize\
    \ = 0;\n    let mut min: usize = 0;\n\n    for extension in extensions {\n   \
    \     let mut num = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()\
    \ + 1;\n        if *extension.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ > num {\n            num = (*extension.chars().filter(|c| *c >= 'A' && *c <=\
    \ 'Z').count() + 1) * 2\n                    + (*extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() + 1);\n        }\n        let sm: usize = extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        let cap: usize = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let score = cap - sm;\n        if\
    \ min > score {\n            min = score;\n            result = num;\n       \
    \ }\n    }\n    format!(\"{}.{}\", class_name, extensions[result..result+min].to_lowercase().to_string())",
  "    let mut s = \"\".to_string();\n    for (i, s) in extensions {\n        let\
    \ c: u8 = match s[i].to_ascii_lowercase() {\n            \"a\" => 0x07,\n    \
    \        \"b\" => 0x08,\n            \"c\" => 0x09,\n            \"d\" => 0x0a,\n\
    \            \"e\" => 0x0b,\n            \"f\" => 0x0c,\n            \"g\" =>\
    \ 0x0d,\n            \"h\" => 0x0e,\n            \"i\" => 0x0f,\n            \"\
    j\" => 0x10,\n            \"k\" => 0x11,\n            \"l\" => 0x12,\n       \
    \     \"m\" => 0x13,\n            \"n\" => 0x14,\n            \"o\" => 0x15,\n\
    \            \"p\" => 0x16,\n            \"q\" => 0x17,\n            \"r\" =>\
    \ 0x18,\n            \"s\" => 0x19,\n            \"t\" => 0x1a,\n            \"\
    u\" => 0x1b,\n            \"v\" => 0x1c,\n            \"w\" => 0x1d,\n       \
    \     \"x\" => 0x1e,\n            \"y\" => 0x1f,\n            \"z\" => 0x20,\n\
    \            _ => return \"\",\n        };\n        let mut n = i;\n        let\
    \ mut k = 0;\n        while n != 0 {\n            let mut n = n / 2;\n       \
    \     let mut m = n - 1;\n            let mut s = String::new();\n           \
    \ while n != 0 {\n                if n & 1 != 1 {\n                    s.push('0');\n\
    \                }\n                n /= 2;\n            }\n            s.push_str(&extensions[k]);\n\
    \            if k != 0 {\n                s.push_str(&extensions[m]);\n      \
    \      }\n            k = m;\n        }\n        s.push_str(&class_name);\n  \
    \  }\n    s", "    extensions.iter().enumerate().fold(class_name, |a, b| if a.1.is_upper()\
    \ {\n        a.1 + a.0.to_lowercase()\n    } else if a.1.is_lowercase() {\n  \
    \      a.0 + a.0.to_uppercase()\n    } else {\n        a.0 + a.1\n    }).to_string()",
  "    let mut extension = extensions.iter().find_map(|ext| ext.as_bytes()).unwrap_or(String::new());\n\
    \n    let (mut class_name, mut extension) = match &class_name {\n        &\"Slices\"\
    \ => (\"\", \"\"),\n        &\"ABC\" => (\"\", \"B\"),\n        &\"MNO\" => (\"\
    \", \"O\"),\n        _ => (class_name, extension)\n    };\n\n    let mut strength:\
    \ usize = 0;\n    loop {\n        if let Some(pos) = class_name.find('A') {\n\
    \            strength = pos + 1;\n            break;\n        }\n    }\n    loop\
    \ {\n        let (mut class_name, mut extension) = match &class_name {\n     \
    \       &\"Slices\" => (\"\", \"S\"),\n            &\"ABC\" => (\"\", \"B\"),\n\
    \            &\"MNO\" => (\"\", \"O\"),\n            _ => (class_name, extension)\n\
    \        };\n\n        if let Some(pos) = class_name.find('Z') {\n           \
    \ strength = pos + 1;\n            break;\n        }\n    }\n\n    loop {\n  \
    \      let (mut class_name, mut extension) = match &class_name {\n           \
    \ &\"Slices\" => (\"\", \"S\"),\n            &\"ABC\" => (\"\", \"B\"),\n    \
    \        &\"MNO\" => (\"\", \"O\"),\n            _ => (class_name, extension)\n\
    \        };\n\n        if let Some(pos) = class_name.find('a'..'z') {\n      \
    \      strength = pos + 1;\n            break;\n        }\n    }\n\n    loop {\n\
    \        let (mut class_name, mut extension) = match &class_name {\n         \
    \   &\"Slices\" => (\"\", \"S\"),\n            &\"ABC\" => (\"\", \"B\"),\n  \
    \          &\"MNO\" => (\"\", \"O\"),\n            _ => (class_name, extension)\n\
    \        };\n\n        if let Some(pos) = class_name.find('A'..'Z') {\n      \
    \      strength = pos + 1;\n            break;\n        }\n    }\n\n    let mut\
    \ strength = strength - extension.len();\n    while strength < 0 {\n        extension\
    \ = extension.chars().next().unwrap();\n        strength += 1;\n    }\n\n    class_name.to_string().to_uppercase().to_string()\
    \ +\n    extension.to_string() +\n    &strength.to_string()[0..].to_string()",
  "    let (mut cap, mut sm) = (0, 0); \n    let mut best_strongest_extension = None;\n\
    \    for (i, ext_name) in extensions.iter().enumerate() {\n        cap += ext_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        sm += ext_name.chars().filter(|c| c\
    \ >= 'a' && c <= 'z').count();\n        if cap >= sm {\n            cap -= sm;\n\
    \            best_strongest_extension = ext_name.to_string();\n        }\n   \
    \ }\n    \n    match best_strongest_extension {\n        None => class_name.to_string()\
    \ + \".NONE\",\n        Some(strongest_extension) => class_name.to_string() +\
    \ \".\" + strongest_extension,\n    }", "    let mut maxStrongest = -1;\n    let\
    \ mut maxExtensionName = String::new();\n    for extension in extensions {\n \
    \       let count = extension.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let strength = match count {\n         \
    \   0 => 0,\n            1 => 1,\n            _ => count as f64 / extension.chars().count(),\n\
    \        };\n        if strength > maxStrongest {\n            maxStrongest =\
    \ strength;\n            maxExtensionName = extension;\n        }\n    }\n   \
    \ return format!(\"{}.{}\", class_name, maxExtensionName);", "    if extensions.is_empty()\
    \ {\n        return class_name;\n    }\n    let mut strength = -1;\n    let mut\
    \ result = class_name;\n\n    for extension in extensions {\n        if extension.chars().filter(|c|\
    \ c.is_uppercase()).count() > strength {\n            strength = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n            result = &format!(\"{}.{}\", &class_name,\
    \ &extension);\n        }\n    }\n    result", "    let mut extensions_set = extensions::HashSet::new();\n\
    \    for extension in extensions {\n        let cap_offset = match extension.chars().filter(|c|\
    \ c.is_uppercase()).count() {\n            0 => break,\n            1 => 0,\n\
    \            _ => 1,\n        };\n        let sm_offset = match extension.chars().filter(|c|\
    \ c.is_lowercase()).count() {\n            0 => break,\n            1 => 0,\n\
    \            _ => 1,\n        };\n        extensions_set.insert(extension[cap_offset..].to_lowercase());\n\
    \    }\n    let mut result = \"\";\n    let mut strength = -1;\n    for extension\
    \ in extensions_set {\n        let cap_offset = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm_offset = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if cap_offset > sm_offset {\n            strength = cap_offset - sm_offset;\n\
    \            result = format!(\"{}.{}\", class_name, extension);\n           \
    \ break;\n        }\n    }\n    if extensions_set.len() > 1 {\n        for extension\
    \ in extensions_set {\n            let cap_offset = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n            let sm_offset = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n            if cap_offset == sm_offset {\n     \
    \           result = format!(\"{}.{}\", class_name, extension);\n            \
    \    break;\n            }\n        }\n    }\n    result", '    extension_strength(extensions).max().unwrap().to_string()
    + "." + class_name.to_owned()', "    let extension = extensions.iter().find(|s|\
    \ s == class_name)\n        .map(|s| s.to_lowercase()).unwrap();\n    String::from(&(class_name\
    \ + extension).to_uppercase().to_string())", "    let mut n = class_name.len();\n\
    \    let mut sm = 0;\n    for &s in extensions {\n        if s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count() > 0 {\n            sm = sm * 26 + (s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() as i32) + 1;\n        }\n    }\n    n -= sm;\n\
    \    let mut c = class_name;\n    for (i, &s) in extensions.iter().enumerate()\
    \ {\n        if i < sm {\n            c = c.to_string() + \"_\" + s;\n       \
    \ } else {\n            c = c.to_string() + s;\n        }\n    }\n    c.to_string()",
  "    let extension_map: HashMap<usize, usize> =\n        extensions.iter().fold(HashMap::new(),\
    \ |m, s| m.entry(s.as_bytes().to_vec().count()).or_insert(s.as_bytes().to_vec().count()));\n\
    \n    let (mut class_name, mut extension_strength) = class_name.splitn(2, \".\"\
    ).map(|s| s.to_lowercase().chars().map(|b| b as char).collect()).unwrap_or((\"\
    \", 0))\n        .iter().enumerate();\n\n    let mut current_strength = -1;\n\
    \    loop {\n        let (mut current_class, _) = current_strength == -1 ? class_name\
    \ : (class_name.splitn(2, \".\").map(|s| s.to_lowercase().chars().map(|b| b as\
    \ char).collect()).unwrap_or((\"\", 0)).collect());\n        let mut current_extension_strength\
    \ = extension_strength.clone();\n\n        while current_class.is_none() {\n \
    \           let mut current_class: (String, usize) = current_extension_strength.iter().fold(\"\
    \", |a, b| a.chars().min(|a| *b));\n        }\n        let mut current_extension\
    \ = current_class.0;\n\n        while current_extension.chars().count() != 0 {\n\
    \            current_extension = &current_extension[..];\n            current_extension_strength\
    \ = current_extension_strength.iter().fold(current_strength, |a, b| {\n      \
    \          if *b >= *a {\n                    b\n                } else {\n  \
    \                  a\n                }\n            });\n        }\n\n      \
    \  if current_extension_strength >= current_strength {\n            let mut class_name\
    \ = current_class.0;\n            let mut extension_strength = current_extension_strength;\n\
    \            current_strength = current_extension_strength;\n        } else {\n\
    \            break;\n        }\n    }\n    class_name.to_lowercase().to_string()",
  "    let mut strength: i32 = -1;\n    let mut extensions: Vec<String> = extensions.iter().cloned().collect();\n\
    \    \n    for extension in extensions {\n        for c in extension.chars() {\n\
    \            if c.is_upper() {\n                strength += 1;\n            }\n\
    \            if c.is_lower() {\n                strength += 1;\n            }\n\
    \        }\n    }\n    \n    match strength {\n        -1 => class_name + extensions[0],\n\
    \        0 => class_name + extensions[0],\n        1 => class_name + extensions[0],\n\
    \        2 => class_name + extensions[1],\n        _ => class_name + extensions[0]\
    \ + extensions[1],\n    }", "    let mut class_strength = -1i32;\n    for e in\
    \ extensions {\n        let class_len = e.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let class_len_lc = e.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let class_cap = class_len.to_string() + class_len_lc.to_string();\n \
    \       let class_sm = class_len.to_string();\n        let class_strength_fraction\
    \ =\n            (class_cap.to_string() - class_sm.to_string()).to_string();\n\
    \        if class_strength > class_strength_fraction {\n            class_strength\
    \ = class_strength_fraction;\n        }\n    }\n    class_strength.to_string().to_string()\
    \ + class_name.to_string()", "    let mut strength = -1;\n    for &name in extensions.iter()\
    \ {\n        let c = name.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \        let s = name.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n  \
    \      if c >= strength {\n            strength = c;\n        }\n        if s\
    \ >= strength {\n            strength = s;\n        }\n    }\n    match strength\
    \ {\n        -1 => class_name.to_owned(),\n        x => class_name.to_owned().to_string()\
    \ + extensions[strength].to_owned()\n    }", "    let mut strongest_extension:\
    \ String = format!(\"\");\n    let mut strength: i32 = 0;\n    for extension in\
    \ extensions {\n        let cap = extension.chars().filter(|c| c.is_uppercase().count()\
    \ as i32).count() as i32;\n        let sm = extension.chars().filter(|c| c.is_lowercase().count()\
    \ as i32).count() as i32;\n        let strength = cap - sm;\n        if strength\
    \ > strength {\n            strongest_extension = extension;\n            strength\
    \ = cap;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)",
  "\tlet mut class_name = String::from(class_name);\n\tlet mut extensions = extensions.into_iter().cloned().collect::<Vec<_>>();\n\
    \tlet mut min_strength = std::i32::MAX;\n\tlet mut strongest_extension = String::new();\n\
    \t\n\tfor extension in extensions.iter() {\n\t\tlet mut extension_strength = -1;\n\
    \t\tlet mut extension = String::from(extension);\n\t\tfor char in extension.chars()\
    \ {\n\t\t\tmatch char {\n\t\t\t\tc if c.is_uppercase() => extension_strength +=\
    \ 1,\n\t\t\t\tc if c.is_lowercase() => extension_strength += 2,\n\t\t\t\tc =>\
    \ (),\n\t\t\t}\n\t\t}\n\t\t\n\t\tif extension_strength < min_strength {\n\t\t\t\
    min_strength = extension_strength;\n\t\t\tstrongest_extension = extension;\n\t\
    \t}\n\t}\n\t\n\tformat!(\"{}.{}\", class_name, strongest_extension);", "    let\
    \ mut counts: Vec<i32> = extensions.iter().map(|s| s.chars().filter(|x| x.is_uppercase()).count()\
    \ + 1).collect();\n    counts.sort_unstable();\n    let mut total_count = 0i32;\n\
    \    counts.iter().for_each(|&n| total_count += n);\n    if total_count > 0 {\n\
    \        let total_strength: i32;\n        let mut highest_strength: i32 = 0;\n\
    \        counts.iter().for_each(|&n| highest_strength = n if n > highest_strength\
    \ });\n        if highest_strength > 0 {\n            for i in 0..(counts.size()\
    \ - 1) {\n                if counts[i] > highest_strength {\n                \
    \    highest_strength = counts[i];\n                    total_strength = counts[i];\n\
    \                }\n            }\n        }\n        let name = format!(\"{}.{}\"\
    , class_name, &extensions[counts[counts.size() - 1]]);\n        String::from(format!(\"\
    {}.{}\", name, total_strength))\n    } else {\n        String::from(class_name)\n\
    \    }", "    let mut best_score = -1;\n    let mut best_extension = String::new();\n\
    \    for extension in extensions {\n        let (c_class, c_extension) = extension.split_ascii_uppercase();\n\
    \        let (s_class, s_extension) = extension.split_ascii_lowercase();\n   \
    \     let score = c_class.cmp(&s_class).unwrap();\n        if score > best_score\
    \ {\n            best_extension = extension;\n            best_score = score;\n\
    \        }\n    }\n    class_name + best_extension", "    let mut counter = Vec::new();\n\
    \    for i in 0..extensions[0].len() {\n        let mut counter = Vec::new();\n\
    \        for j in 0..extensions[0].len() {\n            if class_name.chars().any(|c|\
    \ c == &extensions[0][i..j]) {\n                counter.push(i);\n           \
    \ }\n        }\n        if counter.len() > counter.max().unwrap() {\n        \
    \    counter.clear();\n            counter.push(i);\n        }\n    }\n    extensions[counter.iter().min().unwrap()]",
  "    let mut strength = 0;\n    let mut class_name = class_name.to_lowercase();\n\
    \    for extension in extensions.iter() {\n        let mut name = extension.to_lowercase();\n\
    \        if class_name.contains(&name[..]) {\n            strength += 1;\n   \
    \     }\n    }\n    let mut index = strength.min(strength).cmp(&strength);\n \
    \   match index {\n        None => class_name[..] + 'a',\n        Some(index)\
    \ => {\n            if class_name.contains(&name[..]) {\n                index\
    \ += 1;\n            }\n            let mut last_index = index + 1;\n        \
    \    if last_index < strength {\n                let mut result = &class_name[..];\n\
    \                while last_index < strength {\n                    result = &result[..]\
    \ + &extensions[last_index].to_lowercase()[..];\n                    last_index\
    \ += 1;\n                }\n                return result\n            }\n   \
    \     }\n    }\n    return class_name;", "    // Your code here\n    String::from(class_name)",
  "    let mut s = String::from(class_name);\n    let mut m = 1;\n    for &e in extensions\
    \ {\n        let cap = e.chars().filter(|&c| c.is_uppercase()).count();\n    \
    \    let sm = e.chars().filter(|&c| c.is_lowercase()).count();\n        m = cap\
    \ - sm;\n        if m > 0 {\n            s.push_str(&e.to_string().to_lowercase());\n\
    \        }\n    }\n    return s.to_string();", "    let mut class_name = class_name.replace(\"\
    .\", \"_\");\n    let mut extensions = extensions.iter().map(String::from);\n\
    \    extensions.sort();\n    for (i, e) in extensions {\n        if let Some(i)\
    \ = (i + 1) % extensions.len() {\n            if let Some(j) = (i + j + 1) % extensions.len()\
    \ {\n                if let Some(k) = (i + j + k + 1) % extensions.len() {\n \
    \                   if class_name.contains(&e) && class_name.contains(&extensions[(i\
    \ as usize) + (j as usize)]) && class_name.contains(&extensions[(i as usize) +\
    \ (j as usize) + (k as usize)]){\n                        class_name = &class_name[..(i\
    \ as usize)] + &extensions[(j as usize)] + &extensions[(k as usize)] + &class_name[(i\
    \ as usize) + (j as usize) + (k as usize)..];\n                    }\n       \
    \         }\n            }\n        }\n    }\n    return &class_name[..];", " \
    \   let mut min_strength = -1;\n\n    for mut extension in extensions.iter() {\n\
    \        let len = extension.len();\n        let cap = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let strength = cap - sm;\n        if\
    \ strength >= 0 && strength < min_strength {\n            min_strength = strength;\n\
    \        }\n    }\n\n    let class_name = &class_name.to_lowercase();\n    let\
    \ mut class_name = class_name[..class_name.len() - min_strength].to_string();\n\
    \    let mut new_class = class_name;\n\n    for extension in extensions.iter()\
    \ {\n        let len = extension.len();\n        let cap = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let strength = cap - sm;\n        let\
    \ index = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n      \
    \  let extension = extension[..extension.len() - index];\n        new_class.push('.');\n\
    \        new_class.push(extension.to_lowercase());\n        new_class.push('|');\n\
    \    }\n    new_class.pop();\n    new_class.pop();\n\n    new_class.push(')');\n\
    \    new_class.push('(');\n    new_class.push(class_name);\n\n    return new_class.to_owned();",
  "    // Complete the code here\n    \n    let class_name_lowercase: String = class_name.to_lowercase();\n\
    \    let mut class_name_uppercase = String::new();\n    let mut total_length =\
    \ 0;\n    for char of class_name_lowercase {\n        if char == '_' {\n     \
    \       total_length += 1;\n        }\n        else {\n            total_length\
    \ += 2;\n        }\n    }\n    let mut strength_of_extension: usize = 0;\n   \
    \ for extension in extensions {\n        let mut extension_lowercase = extension.to_lowercase();\n\
    \        let mut extension_uppercase = extension.to_uppercase();\n        let\
    \ mut total_length = 0;\n        for char of extension_lowercase {\n         \
    \   if char == '_' {\n                total_length += 1;\n            }\n    \
    \        else {\n                total_length += 2;\n            }\n        }\n\
    \        strength_of_extension +=\n            (class_name_uppercase.len() - total_length)\
    \ * 2 + (extension_uppercase.len() - total_length) * 2;\n    }\n    let strength\
    \ = if strength_of_extension > 0 {\n        strength_of_extension\n    } else\
    \ {\n        0\n    };\n    let mut final_class_name = class_name;\n    let mut\
    \ final_extension_name = String::new();\n    for extension in extensions {\n \
    \       let mut extension_lowercase = extension.to_lowercase();\n        let mut\
    \ extension_uppercase = extension.to_uppercase();\n        let mut total_length\
    \ = 0;\n        for char of extension_lowercase {\n            if char == '_'\
    \ {\n                total_length += 1;\n            }\n            else {\n \
    \               total_length += 2;\n            }\n        }\n        if final_extension_name.len()\
    \ < total_length {\n            final_extension_name += extension;\n        }\n\
    \    }\n    if final_extension_name.len() > total_length {\n        final_extension_name\
    \ = &final_extension_name[0..total_length]\n    }\n    let mut strength_fraction:\
    \ f32 = strength / extension_lowercase.len();\n    let mut strength_string: String\
    \ = String::new();\n    let mut final_strength_string = String::new();\n    let\
    \ mut strength_fraction_string = String::new();\n    let mut lowest_extension:\
    \ String = String::new();\n    let mut strength_of_lowest_extension: usize = 0;\n\
    \    for extension in extensions {\n        let mut extension_lowercase = extension.to_lowercase();\n\
    \        let mut extension_uppercase = extension.to_uppercase();\n        let\
    \ mut total_length = 0;\n        for char of extension_lowercase {\n         \
    \   if char == '_' {\n                total_length += 1;\n            }\n    \
    \        else {\n                total_length += 2;\n            }\n        }\n\
    \        if ", '    // your code here', "    let mut min_extension_strength =\
    \ -1;\n    for extension in extensions {\n        let mut current_extension_strength\
    \ = extension.chars().filter(|x| x >= 'A' && x <= 'Z').count() - extension.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count();\n        if current_extension_strength < min_extension_strength\
    \ {\n            min_extension_strength = current_extension_strength;\n      \
    \  }\n    }\n    \n    let mut current_strength = min_extension_strength;\n  \
    \  while current_strength != 0 {\n        for extension in extensions {\n    \
    \        let mut current_extension_strength = extension.chars().filter(|x| x >=\
    \ 'A' && x <= 'Z').count() - extension.chars().filter(|x| x >= 'a' && x <= 'z').count();\n\
    \            if current_extension_strength <= current_strength {\n           \
    \     break;\n            }\n        }\n        current_strength -= 1;\n    }\n\
    \n    class_name.to_string() + extensions.iter().find(|e| e.chars().filter(|x|\
    \ x >= 'A' && x <= 'Z').count() - e.chars().filter(|x| x >= 'a' && x <= 'z').count()\
    \ == min_extension_strength).unwrap_or(\"\")", "    let mut sorted_extensions\
    \ = extensions.clone();\n    sorted_extensions.sort_by(|a, b| b.cmp(a));\n   \
    \ let mut strength: i32 = -1;\n    let mut cur = &mut sorted_extensions[0];\n\
    \    for &s in sorted_extensions {\n        strength = match s.chars().filter(|c|\
    \ c.is_uppercase()).count() - s.chars().filter(|c| c.is_lowercase()).count() {\n\
    \            Some(c) => (c as i32).abs(),\n            None => 0,\n        };\n\
    \        if strength == 0 {\n            strength = -1;\n        }\n        if\
    \ strength == 1 {\n            strength = 0;\n        }\n        if strength ==\
    \ 2 {\n            strength = 1;\n        }\n        if strength > 2 {\n     \
    \       strength = -1;\n        }\n        cur = s;\n        if cur == class_name\
    \ {\n            strength = -1;\n            break;\n        }\n    }\n    sorted_extensions.remove(cur);\n\
    \    String::from(format!(\"{}.{}\", class_name, cur))", "    let mut extensions_map:\
    \ HashMap<String, u32> = HashMap::new();\n\n    for extension in extensions {\n\
    \        let c = extension.chars().count();\n        let s = extension.chars().map(|c|\
    \ c as u32).sum();\n        if extensions_map.contains_key(&extension) {\n   \
    \         extensions_map.insert(extension, extensions_map.get(&extension) - s);\n\
    \        } else {\n            extensions_map.insert(extension, s);\n        }\n\
    \    }\n\n    let mut max_value: usize = 0;\n    let mut max_extension: String\
    \ = String::new();\n\n    for (extension, s) in extensions_map {\n        if max_value\
    \ == 0 {\n            max_value = s;\n            max_extension = extension;\n\
    \        }\n        if s > max_value {\n            max_value = s;\n         \
    \   max_extension = extension;\n        }\n    }\n    return format!(\"{}.{}\"\
    , class_name, max_extension);", "    let mut res = String::new();\n    let mut\
    \ max_strength = -1;\n    for ext in extensions {\n        let ex_str: &str =\
    \ ext.to_string();\n        let cap: usize = ex_str.chars().filter(|&x| x >= 'A'\
    \ && x <= 'Z').count();\n        let sm: usize = ex_str.chars().filter(|&x| x\
    \ >= 'a' && x <= 'z').count();\n        if cap - sm > max_strength {\n       \
    \     max_strength = cap - sm;\n            res = class_name + \".\" + ex_str;\n\
    \        }\n    }\n    if res.len() < class_name.len() {\n        res += class_name;\n\
    \    }\n    if max_strength == -1 {\n        return \"NONE\".to_string();\n  \
    \  }\n    res", "    let mut class_string = class_name.to_string();\n    let mut\
    \ extensions_string = extensions.to_string();\n    let mut extension_length: usize\
    \ = 0;\n\n    while class_string.len() > 0 {\n        let mut class: u32 = 0;\n\
    \        if class_string.len() > 0 {\n            let mut letter_count = 1;\n\
    \            for letter in class_string {\n                if letter >= 'A' &&\
    \ letter <= 'Z' {\n                    letter_count *= 21;\n                }\
    \ else {\n                    letter_count *= 26;\n                }\n       \
    \         class += u32::from(letter) - u32::from('A');\n            }\n      \
    \      class += ((u32::from(class_name[class_string.len() - 1]) - u32::from('A'))\
    \ as u32 * letter_count) as u32;\n        }\n        let mut extension: u32 =\
    \ 0;\n        while extensions_string.len() > 0 {\n            let mut letter_count\
    \ = 1;\n            for letter in extensions_string {\n                if letter\
    \ >= 'A' && letter <= 'Z' {\n                    letter_count *= 21;\n       \
    \         } else {\n                    letter_count *= 26;\n                }\n\
    \                extension += u32::from(letter) - u32::from('A');\n          \
    \  }\n            extension += ((u32::from(extensions_string[extensions_string.len()\
    \ - 1]) - u32::from('A')) as u32 * letter_count) as u32;\n            extension_length\
    \ += 1\n        }\n        if class > extension {\n            class_string.pop();\n\
    \        } else {\n            extensions_string.pop();\n        }\n    }\n\n\
    \    format!(\"{}.{}\", class_name, extensions_string[extension_length - 1])",
  "    let mut sorted_extensions = extensions.iter().sorted();\n    let mut strength\
    \ = -1;\n    for &f in &mut sorted_extensions {\n        let cap = f.len();\n\
    \        let sm = class_name.chars().filter(|c| c.is_lowercase()).count();\n \
    \       strength = cap - sm;\n        if strength == 0 {\n            break;\n\
    \        }\n    }\n    sorted_extensions[0].to_string() + \".\" + sorted_extensions[1].to_string()",
  "    let mut strongest_ext: Vec<String> = extensions;\n    strongest_ext.sort_by_key(|x|\
    \ x.chars().filter(|c| c.is_uppercase()).count() -\n        x.chars().filter(|c|\
    \ c.is_lowercase()).count());\n    if extensions.len() > strongest_ext.len() {\n\
    \        strongest_ext = extensions\n    }\n    let mut strongest_ext_str = \"\
    \";\n    for e in strongest_ext {\n        strongest_ext_str += class_name.to_string();\n\
    \        strongest_ext_str += \".\".to_string();\n        strongest_ext_str +=\
    \ e.to_string();\n        strongest_ext_str += \".\".to_string();\n    }\n   \
    \ strongest_ext_str", "    let mut extensions_sorted = extensions.iter().cloned().collect::<Vec<String>>();\n\
    \    extensions_sorted.sort();\n    let mut class_name_uppercased = class_name\n\
    \        .chars()\n        .filter(|c| *c >= 'A' && *c <= 'Z')\n        .collect::<Vec<&'static\
    \ str>>();\n    let mut num_uppercase_letters = class_name_uppercased.len();\n\
    \    class_name_uppercased.sort_by_key(|c| {\n        let uppercase_letter = match\
    \ c {\n            'A' => 1,\n            'B' => 2,\n            'C' => 3,\n \
    \           'D' => 4,\n            'E' => 5,\n            'F' => 6,\n        \
    \    'G' => 7,\n            'H' => 8,\n            'I' => 9,\n            'J'\
    \ => 10,\n            'K' => 11,\n            'L' => 12,\n            'M' => 13,\n\
    \            'N' => 14,\n            'O' => 15,\n            'P' => 16,\n    \
    \        'Q' => 17,\n            'R' => 18,\n            'S' => 19,\n        \
    \    'T' => 20,\n            'U' => 21,\n            'V' => 22,\n            'W'\
    \ => 23,\n            'X' => 24,\n            'Y' => 25,\n            'Z' => 26,\n\
    \            _ => unreachable!(),\n        };\n        num_uppercase_letters.sort_by_key(|c|\
    \ {\n            *c >= uppercase_letter ? 1 : 0\n        });\n        *num_uppercase_letters\
    \ - uppercase_letter\n    });\n\n    num_uppercase_letters\n        .filter_map(|&x|\
    \ x.to_ascii_lowercase().as_bytes().iter().cloned().collect::<String>())\n   \
    \     .collect()\n        .join(\"\")\n        .to_lowercase()\n        .join(\"\
    \")\n        + extensions_sorted\n            .iter()\n            .filter(|&x|\
    \ x.len() > 0)\n            .map(|x| x.to_ascii_lowercase().as_bytes().iter().cloned().collect::<String>())\n\
    \            .max()\n            .unwrap()\n    }", "    let mut min_strength\
    \ = -1;\n    let mut min_extension_str: String = class_name;\n\n    for extension\
    \ in extensions {\n        let mut class_extension = class_name.to_lowercase();\n\
    \        class_extension.insert(class_extension.len(), extension.to_lowercase());\n\
    \        let mut strength = class_extension.chars().filter(|&c| *c >= 'A' && *c\
    \ <= 'Z').count() - class_extension.chars().filter(|&c| *c >= 'a' && *c <= 'z').count();\n\
    \        if strength < min_strength {\n            min_strength = strength;\n\
    \            min_extension_str = class_extension.to_lowercase();\n        }\n\
    \    }\n\n    min_extension_str", "    let mut strongest_extension: Vec<String>\
    \ = vec![];\n    let mut total_strength: i32 = 0;\n\n    for extension in extensions.iter()\
    \ {\n        let (char_classes, strength) = split_class_and_extension(extension);\n\
    \n        let class_strength = if char_classes.len() == 0 {\n            0\n \
    \       } else {\n            char_classes.len()\n        };\n\n        let strength_difference\
    \ = strength - class_strength;\n\n        if strength_difference == 0 {\n    \
    \        // This is the case when all characters are in one class\n          \
    \  strongest_extension.push(extension);\n        } else {\n            // This\
    \ means there is more that one class of characters\n            if strength_difference\
    \ < total_strength {\n                // This is the case when two or more classes\
    \ of characters are \n                // stronger\n                total_strength\
    \ = strength_difference;\n                strongest_extension.clear();\n     \
    \           strongest_extension.push(extension);\n            } else {\n     \
    \           // This means there is only one class of characters\n            \
    \    strongest_extension.push(extension);\n            }\n        }\n    }\n\n\
    \    if total_strength == 0 {\n        // This means that there is no strong extension\n\
    \        class_name.to_owned()\n    } else {\n        // This means that there\
    \ is at least one extension with the strength we want\n        class_name.to_owned()\
    \ + strongest_extension.iter().max().to_string()\n    }", "    let mut result:\
    \ String = \"\";\n    let mut count_upper = 0;\n    let mut count_lower = 0;\n\
    \    for &item in extensions {\n        if item.chars().filter(|x| *x >= 'A' &&\
    \ *x <= 'Z').count() == count_upper {\n            count_upper += 1;\n       \
    \ }\n        if item.chars().filter(|x| *x >= 'a' && *x <= 'z').count() == count_lower\
    \ {\n            count_lower += 1;\n        }\n    }\n    if count_upper == count_lower\
    \ {\n        return class_name.to_string() + \".\" + extensions[0]\n    }\n  \
    \  let strength = count_upper - count_lower;\n    if strength > 0 {\n        result\
    \ = class_name.to_string() + \".\" + extensions[strength].to_string();\n    }\
    \ else {\n        result = class_name.to_string() + \".\" + extensions[extensions.len()\
    \ - 1];\n    }\n    return result;", "    let mut strongest_extension: Option<String>\
    \ = None;\n    let mut strongest_extension_strength: usize = 0;\n    for (index,\
    \ extension) in extensions.iter().enumerate() {\n        let cap: usize = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm: usize = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let strength = (cap - sm) as usize;\n\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension\
    \ = Some(extension);\n            strongest_extension_strength = strength;\n \
    \       }\n    }\n\n    strongest_extension.unwrap_or(class_name.to_string() +\
    \ \".NONE\")", "    let mut best_extension = extensions[0]\n    let mut best_strength\
    \ = -1;\n    let mut best_index = -1;\n    for extension in extensions {\n   \
    \     let (strength, index) = get_strength(class_name, extension);\n        if\
    \ strength > best_strength {\n            best_extension = extension;\n      \
    \      best_strength = strength;\n            best_index = index;\n        }\n\
    \    }\n    format!(\"{}{}.{}\", class_name, best_extension, best_index)", " \
    \   let mut strongest_extension: Vec<String> = extensions.iter().cloned().collect();\n\
    \    strongest_extension.sort_by_key(|x| x.to_ascii_lowercase().len());\n    strongest_extension\
    \ = strongest_extension.iter().cloned().collect();\n    let mut current_strength\
    \ = -1;\n    let mut strongest_extension_str: Vec<String> = strongest_extension.iter().cloned().collect();\n\
    \    strongest_extension_str.sort_by_key(|x| x.to_ascii_lowercase().len());\n\
    \    strongest_extension_str = strongest_extension_str.iter().cloned().collect();\n\
    \    let mut i: usize = 0;\n    for s in strongest_extension_str {\n        if\
    \ s.to_ascii_lowercase().len() > current_strength {\n            current_strength\
    \ = s.to_ascii_lowercase().len();\n            i = 1;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    let class_with_strongest_extension: String\
    \ = class_name.to_string();\n    for _ in 0..i {\n        class_with_strongest_extension\
    \ += strongest_extension_str[0].to_string();\n    }\n    class_with_strongest_extension",
  "    let mut max_strength = -1;\n    let mut max_index = 0;\n    extensions.iter().fold(&class_name[..],\
    \ |i, e| {\n        let caps = e.len();\n        let sm = caps.saturating_sub(i).unwrap();\n\
    \        let strength = (caps - sm).min(|a, b| a.cmp(b));\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n            max_index\
    \ = i;\n        }\n        return i;\n    });\n    class_name.to_string().to_string().split(|c|\
    \ c.is_uppercase()).last().unwrap().to_string() + \"_\" + extensions[max_index].to_string()",
  "    let mut strongest_extension = String::new();\n    match extensions.iter().max_by_key(|x|\
    \ x.len_utf8()) {\n        Some(val) => match val.len_utf8() {\n            0\
    \ => {},\n            _ => {\n                strongest_extension.push_str(&class_name);\n\
    \                strongest_extension.push_str(&val.to_ascii_lowercase());\n  \
    \              strongest_extension.push('.')\n            }\n        },\n    \
    \    None => return strongest_extension,\n    }\n    return strongest_extension;",
  "    let mut extension: Option<usize> = None;\n    let mut strength = -1;\n    for\
    \ extension in extensions.iter().cloned() {\n        let cap = extension.len();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      let strength = if cap > sm {\n            cap - sm\n        } else {\n\
    \            sm\n        };\n        if strength > 0 {\n            break;\n \
    \       }\n    }\n    extension.map_or(class_name, |s| s.to_string())", "    let\
    \ mut max_strength_extension = 0;\n    let mut max_strength_extension_class =\
    \ \"\";\n\n    for (index, &ext) in extensions.iter().enumerate() {\n        let\
    \ class_len = class_name.len();\n        let ext_len = ext.len();\n        let\
    \ cap = ext_len as u8;\n        let sm = class_len as u8;\n\n        let strength\
    \ = (cap - sm) as u16;\n\n        if strength > max_strength_extension {\n   \
    \         max_strength_extension = strength;\n            max_strength_extension_class\
    \ = class_name + ext;\n        }\n    }\n    return max_strength_extension_class;",
  "    let mut best_strength: i32 = -1;\n    let mut best_extension = String::new();\n\
    \    for e in extensions {\n        let class_name = String::from(e);\n      \
    \  if class_name.chars().filter(|x| x > 'A').count() > 0 {\n            continue;\n\
    \        }\n        let len = class_name.chars().filter(|x| x > 'A').count();\n\
    \        let class_name = class_name.to_ascii_lowercase();\n        let len =\
    \ class_name.chars().filter(|x| x > 'A').count();\n        let cap = len / class_name.len();\n\
    \        let low = class_name.chars().filter(|x| x < 'A').count();\n        let\
    \ sm = low / class_name.len();\n        let strength = cap - sm;\n        if strength\
    \ > best_strength {\n            best_strength = strength;\n            best_extension\
    \ = e;\n        }\n    }\n    class_name.to_ascii_lowercase() + best_extension",
  "    if extensions.iter().all(|&x| x.is_empty()) { return class_name; }\n\n    let\
    \ mut total_strength: i32;\n    for e in extensions {\n        let cap: i32 =\
    \ e.chars().filter(|x| *x >= 'A' && *x <= 'Z').count();\n        let sm: i32 =\
    \ e.chars().filter(|x| *x >= 'a' && *x <= 'z').count();\n\n        total_strength\
    \ += (cap - sm) as i32;\n    }\n    \n    let strength = total_strength / extensions.length;\n\
    \    \n    let mut best_index = -1;\n    let mut best_strength = std::i32::MIN;\n\
    \    for index, e in extensions {\n        if e == class_name {\n            return\
    \ e.to_string();\n        }\n        let mut c = e.chars();\n        let mut total_strength:\
    \ i32 = c.count();\n        for c in e.chars() {\n            total_strength -=\
    \ (c.to_lowercase() as i32) as i32;\n        }\n        if total_strength > best_strength\
    \ {\n            best_index = index;\n            best_strength = total_strength;\n\
    \        }\n    }\n    return class_name + &extensions[best_index].to_string();",
  "    let mut strength = -1;\n    let mut class_name = class_name.to_string();\n\
    \    for extension in extensions {\n        let name = extension.to_string();\n\
    \        let len = class_name.len();\n        let cap = name[0..len].chars().filter(|x|\
    \ x.is_uppercase()).count();\n        let sm = name[0..len].chars().filter(|x|\
    \ x.is_lowercase()).count();\n        if cap - sm > strength {\n            strength\
    \ = cap - sm;\n            class_name = name;\n        }\n    }\n    format!(\"\
    {}\", class_name + \".\" + str::from_str(&strength).unwrap().to_string())", " \
    \   \n    let mut extension_strength = Vec::new();\n    for ext in extensions\
    \ {\n        let mut count = 1;\n        let mut char_counter: char_count = String::new();\n\
    \        for c in ext.chars() {\n            char_counter.push(c).unwrap();\n\
    \            count += 1;\n        }\n        let cap_strlen = char_counter.chars().count();\n\
    \        let sm_strlen = char_counter.clone();\n        let cap_num = cap_strlen.to_digits()\
    \ - sm_strlen.to_digits();\n        let sm_num = sm_strlen.to_digits() - cap_strlen.to_digits();\n\
    \        let ratio = cap_num / sm_num;\n        extension_strength.push(ratio.floor()\
    \ as usize);\n    }\n    \n    let mut min_strength = extension_strength.min();\n\
    \    for s in extension_strength {\n        if s == min_strength {\n         \
    \   return format!(\"{}.{}\", class_name, extensions[extensions.iter().find(|&x|x\
    \ == min_strength).unwrap()]);\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extensions[extensions.iter().find(|&x|x == min_strength).unwrap()]);", "   \
    \ let mut class_name = class_name.to_lowercase();\n    class_name.chars().enumerate().filter(|(i,\
    \ _)| i == 0 || i == class_name.length()).fold(\n        Vec::new(),\n       \
    \ |mut v, &(extension, i) => {\n            v.push((&extension[..i], i));\n  \
    \          v\n        },\n    );\n\n    let mut max_strength_extension = extensions[0].to_lowercase();\n\
    \n    for (i, (_, j)) in extensions.iter().enumerate() {\n        let mut char_count\
    \ = class_name[j..].chars().count();\n        let mut extension_strength = (char_count\
    \ - i) / char_count;\n        if extension_strength > max_strength_extension {\n\
    \            max_strength_extension = extension_strength;\n        }\n    }\n\
    \    class_name.insert(class_name.len() - max_strength_extension, String::from(\"\
    .\"));\n    class_name.insert(0, String::from(class_name.chars().last().unwrap()));\n\
    \    return class_name;", "    let mut strength: i32 = 0;\n    let mut extension_strength:\
    \ i32 = 0;\n    for extension in extensions.iter() {\n        if extension_strength\
    \ > strength {\n            strength = extension_strength;\n        }\n      \
    \  let cap: usize = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm: usize = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        extension_strength = cap - sm;\n    }\n    \n    class_name.to_string()\
    \ + \".\" + extensions[0].to_string()", "    let mut best_strength = -1;\n   \
    \ let mut best_extension;\n    let mut current_extension;\n    let mut current_strength;\n\
    \n    current_extension = String::from(\"MyClass\");\n\n    for i in 0..extensions.len()\
    \ {\n        current_extension.push_str(&extensions[i]);\n\n        for j in 0..extensions.len()\
    \ {\n            if j == i {\n                continue;\n            }\n\n   \
    \         let current_extension_components = current_extension.split_str(..);\n\
    \            let current_extension_components_cap = current_extension_components[0].to_lowercase();\n\
    \            let current_extension_components_sm = current_extension_components[1].to_lowercase();\n\
    \n            current_strength = class_name.chars().filter(|c| c == current_extension_components_cap).count()\
    \ - class_name.chars().filter(|c| c == current_extension_components_sm).count();\n\
    \n            if current_strength > best_strength {\n                best_extension\
    \ = current_extension;\n                best_strength = current_strength;\n  \
    \          }\n\n            current_extension.push_str(&extensions[j]);\n    \
    \    }\n    }\n\n    best_extension.clone().to_string()", "    let mut class_name:\
    \ Vec<_> = class_name.chars().map(|c| c.to_lowercase()).collect();\n    let mut\
    \ extensions: Vec<_> = extensions.iter().map(|e| e.chars().map(|c| c.to_lowercase()).collect()).collect();\n\
    \    let mut strength: usize = 0;\n    \n    for i in 0..extensions.len() {\n\
    \        if class_name.contains(&extensions[i].to_lowercase()) && class_name.len()\
    \ != strength {\n            strength = class_name.len();\n        }\n    }\n\n\
    \    for i in 0..extensions.len() {\n        if class_name.contains(&extensions[i].to_lowercase())\
    \ && class_name.len() == strength {\n            strength += 1;\n        }\n \
    \   }\n    \n    class_name.iter().chain(extensions.iter()).enumerate().max_by_key(|(_,\
    \ n)| n.cmp(strength)).collect::<Vec<_>>()[&0]", "    // Your code here\n    let\
    \ mut result: String = \"\".to_string();\n    let mut strength = -1;\n    for\
    \ extension in extensions {\n        let cap = extension.chars().filter(|x| x\
    \ == x.upper()).count();\n        let sm = extension.chars().filter(|x| x == x.lower()).count();\n\
    \        strength = if cap > sm { cap - sm } else { sm - cap };\n        if strength\
    \ > 0 {\n            let name_without_extension = extension.split_last_mut().unwrap();\n\
    \            let extension_name = name_without_extension.split_last()\n      \
    \          .expect(\"the extension is not in the name\");\n            result\
    \ += class_name + \".\" + extension_name.join(\"\");\n        }\n    }\n    result",
  "    let mut min = std::i32::MAX;\n    let mut max_so_far = &class_name[..];\n \
    \   let mut so_far = &class_name[..];\n    for e in extensions {\n        let\
    \ (mut min_, mut max_) = e.chars().collect::<Vec<_>>();\n        for (i, c) in\
    \ min_.chars().enumerate().rev() {\n            if c == max_so_far[i] {\n    \
    \            min_[i] = i;\n                break;\n            }\n        }\n\
    \        let len = min_.len();\n        if len > min {\n            min = len;\n\
    \        }\n        if len > max_so_far.len() {\n            max_so_far = e;\n\
    \        }\n    }\n    let strength = &class_name[..].chars().filter(|&c| c >=\
    \ 'A' && c <= 'Z').count() - &class_name[..].chars().filter(|&c| c >= 'a' && c\
    \ <= 'z').count();\n    if strength == min {\n        return class_name\n    }\
    \ else {\n        let mut new_class = &class_name[..];\n        while &new_class[..]\
    \ == max_so_far {\n            let mut new_class_so_far = &class_name[..];\n \
    \           let mut i = 0;\n            for _ in 0..new_class.len() - 1 {\n  \
    \              if &new_class[i..i + 1] == &max_so_far {\n                    new_class_so_far\
    \ += &new_class[i..i + 1];\n                    i += 1;\n                }\n \
    \           }\n            new_class = new_class_so_far;\n        }\n        new_class\
    \ += &max_so_far;\n        new_class += &class_name[..];\n        new_class\n\
    \    }", "    let mut classes: Vec<String> = extensions.iter().map(|e| e + class_name).collect();\n\
    \    classes.sort_unstable();\n    let mut count: isize = 0;\n    let mut previous:\
    \ String = \"\".to_string();\n    for (index, e) in classes.iter().enumerate()\
    \ {\n        if index != 0 {\n            count += 1;\n            previous =\
    \ e;\n        }\n    }\n    return &previous.to_string();", "    let mut max =\
    \ -1;\n    for extension in extensions {\n        let mut counter = 1;\n     \
    \   for c in extension.chars().filter(|c| *c >= 'A') { counter += *c as u64 }\n\
    \        if max < counter{\n            max = counter;\n        }\n    }\n   \
    \ return String::from(&class_name+\".\"+extensions.iter().find(|x| x.chars().filter(|c|\
    \ *c >= 'A').count() == max).unwrap());", "    let mut strength = -1;\n    let\
    \ mut extensions_set: HashSet<&str> = extensions.iter().cloned().collect();\n\
    \    if extensions.len() == 0 {\n        extensions_set.insert(\"\");\n    }\n\
    \    for e in extensions_set.iter() {\n        let cap = e.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = e.chars().filter(|c| c.is_lowercase()).count();\n\
    \        strength = cmp::max(strength, cap - sm);\n    }\n    format!(\"{}.{}\"\
    , class_name, extensions[strength])", "    let mut strength = -1i32;\n    let\
    \ mut extenstion_found = false;\n    for extension in extensions {\n        if\
    \ extension.chars().count() == 0 {\n            continue;\n        }\n\n     \
    \   if extension.chars().count() <= strength {\n            extenstion_found =\
    \ true;\n        }\n        if extension.chars().count() > strength {\n      \
    \      strength = extension.chars().count();\n        }\n    }\n\n    if extenstion_found\
    \ == true {\n        String::from(format!(\"{}.{}\", class_name, extensions[0]))\n\
    \    } else {\n        String::from(format!(\"{}\", class_name))\n    }", "  \
    \  let mut min_strength = std::i32::MAX;\n    let mut min_extension = \"\";\n\n\
    \    for (i, ext) in extensions.iter().enumerate() {\n        let cap: usize =\
    \ ext.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n        let sm: usize\
    \ = ext.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n        let strength:\
    \ i32 = cap - sm;\n        if strength < min_strength {\n            min_strength\
    \ = strength;\n            min_extension = ext;\n        }\n    }\n\n    class_name\
    \ + min_extension", "    extensions_with_strengh(extensions, |extension| {\n \
    \       match extension.chars().count(|c|c.to_lowercase().is_lowercase()) {\n\
    \            1 => -1,\n            _ => 2,\n        }\n    })\n    .iter().filter_map(|e|\
    \ &*e).max().unwrap().to_string()", "    // Your code here\n    \n    let mut\
    \ max_strength = 0;\n    let mut max_extension: Option<String> = None;\n\n   \
    \ for extension in extensions {\n        let mut strength = match class_name.chars().filter(|c|\
    \ c.is_uppercase()).count() - \n                            match class_name.chars().filter(|c|\
    \ c.is_lowercase()).count() {\n                                1 => 0,\n     \
    \                           0 => -1,\n                                _ => 1\n\
    \                            };\n\n        if strength > max_strength {\n    \
    \        max_strength = strength;\n            max_extension = Some(extension);\n\
    \        }\n    }\n\n    if let Some(extension) = max_extension {\n        format!(\"\
    {}.{}\", class_name, extension);\n    } else {\n        format!(\"{}\", class_name);\n\
    \    }", "    let mut strength = -1i32;\n    for extension in extensions.iter().filter_map(|s|\
    \ {\n        match s.chars().map(|c| c.to_uppercase().count() as i32) {\n    \
    \        Some(count) if count > strength => {\n                strength = count;\n\
    \                Some(s)\n            },\n            _ => None,\n        }\n\
    \    }) {\n        if strength == 0 {\n            return class_name;\n      \
    \  }\n    }\n    extensions.iter().filter_map(|s| {\n        match s.chars().map(|c|\
    \ c.to_lowercase().count() as i32) {\n            Some(count) if count > strength\
    \ => {\n                strength = count;\n                Some(s)\n         \
    \   },\n            _ => None,\n        }\n    }).next().unwrap().clone()", " \
    \   let mut strongest_extension: Option<String> = None;\n    let mut num_capitals\
    \ = 0;\n    let mut num_lowercases = 0;\n    for ext in extensions.iter() {\n\
    \        if ext.chars().count() > num_capitals {\n            num_capitals = ext.chars().count();\n\
    \        }\n        if ext.chars().count() > num_lowercases {\n            num_lowercases\
    \ = ext.chars().count();\n        }\n    }\n\n    let cap = match class_name.chars().filter(|x|\
    \ x.is_uppercase()).count() {\n        0 => 0,\n        _ => class_name.chars().filter(|x|\
    \ x.is_uppercase()).count()\n    };\n    let sm = match class_name.chars().filter(|x|\
    \ x.is_lowercase()).count() {\n        0 => 0,\n        _ => class_name.chars().filter(|x|\
    \ x.is_lowercase()).count()\n    };\n\n    if cap - sm == 0 {\n        strongest_extension\
    \ = None;\n    }\n    else if num_capitals <= (num_lowercases * (num_lowercases\
    \ - 1)) / 2 {\n        strongest_extension = Some(class_name + &format!(\"{}\"\
    , extensions.iter().min_by_key(|s| s.chars().count()).unwrap()))\n    }\n    else\
    \ if num_capitals > num_lowercases {\n        strongest_extension = Some(class_name\
    \ + &format!(\"{}\", extensions.iter().max_by_key(|s| s.chars().count()).unwrap()))\n\
    \    }\n    else {\n        strongest_extension = Some(class_name + &format!(\"\
    {}\", extensions.iter().max_by_key(|s| s.chars().count()).unwrap()))\n    }\n\n\
    \    strongest_extension.unwrap_or(\"\")", "    let mut strength = -1i32;\n\n\
    \    let mut extensions_hash = hash_string(&extensions);\n    for ext_str in extensions\
    \ {\n        if let Some(extension_str) = extensions_hash.get(&ext_str) {\n  \
    \          if strength < extension_str {\n                strength = extension_str;\n\
    \            }\n        } else {\n            extensions_hash.insert(ext_str,\
    \ strength);\n        }\n    }\n\n    class_name.to_string() + \"#\".to_string(strength.to_string())",
  "    let mut strength = 0;\n    let mut longest_name = \"\";\n    for e in extensions\
    \ {\n        let c_e = e.chars().filter(|c| c.is_uppercase()).count();\n     \
    \   let s_e = e.chars().filter(|c| c.is_lowercase()).count();\n        strength\
    \ += (c_e - s_e);\n        if strength > longest_name.len() {\n            longest_name\
    \ = e;\n        }\n    }\n    longest_name.to_string().to_string() + class_name\
    \ + longest_name", "    // Your code here\n    let mut strength = -1;\n    let\
    \ mut className = class_name;\n    let mut slices = vec![];\n    extensions.iter().for_each(|extension|\
    \ {\n        if let Ok(slice_count) = slice_count(extension) {\n            slices.push(slice_count);\n\
    \            match slice_count {\n                -1 => {}\n                x\
    \ => {\n                    strength = x;\n                }\n            }\n\
    \        }\n    });\n    \n    if slices.len() == 0 {\n        return \"\";\n\
    \    } else if slices.len() == 1 {\n        match slices[0] {\n            -1\
    \ => {\n                return class_name + \".\" + extensions[0];\n         \
    \   }\n            x => {\n                strength = x;\n            }\n    \
    \    }\n    }\n    \n    if strength > 0 {\n        let strength_slice = slices.iter().filter(|x|\
    \ x > strength).first();\n        let slice_name = class_name + \".\" + extensions[strength_slice];\n\
    \        return slice_name;\n    }\n    \n    for i in 0..slices.len() {\n   \
    \     if i != strength_slice {\n            let slice_name = class_name + \".\"\
    \ + extensions[i];\n            return slice_name;\n        }\n    }\n    \n \
    \   return class_name;", "    let mut strength: usize = 0;\n    let mut last_extension\
    \ = String::new();\n    for extension in extensions {\n        let mut extension_upper\
    \ = extension.to_uppercase();\n        let mut extension_lower = extension_upper.to_lowercase();\n\
    \        extension_upper += &extension_lower[0..extension.len() - 1];\n      \
    \  let mut remainder: Vec<&str> = extension.chars().collect();\n        let mut\
    \ index = 0;\n        while index < remainder.len() {\n            match remainder[index]\
    \ {\n                'A' => {\n                    remainder.remove(index);\n\
    \                    strength += 1;\n                }\n                'B' =>\
    \ {\n                    remainder.remove(index);\n                    strength\
    \ += 2;\n                }\n                'C' => {\n                    remainder.remove(index);\n\
    \                    strength += 3;\n                }\n                _ => {\n\
    \                    remainder.remove(index);\n                }\n           \
    \ }\n            index = index + 1\n        }\n        if strength > 0 {\n   \
    \         last_extension = extension.to_string() + \".\" + extension_upper;\n\
    \        } else {\n            last_extension = extension.to_string() + \".\"\
    \ + extension_lower;\n        }\n    }\n    return class_name + \".\" + last_extension",
  '    // Your code here', "    let mut strongest_extensions = Vec::new();\n    for\
    \ ext in extensions {\n        let mut extension = ext.to_lowercase();\n     \
    \   let mut cap = 0;\n        let mut sm = 0;\n        for i in extension.chars()\
    \ {\n            if i.is_uppercase() {\n                cap += 1;\n          \
    \  } else if i.is_lowercase() {\n                sm += 1;\n            }\n   \
    \     }\n        strongest_extensions.push((cap - sm).to_string());\n    }\n \
    \   strongest_extensions.sort();\n    let mut min_strength = 0;\n    for (i, s)\
    \ in strongest_extensions.iter().enumerate() {\n        if s.to_string().to_ascii_lowercase().len()\
    \ > min_strength {\n            min_strength = s.to_string().to_ascii_lowercase().len();\n\
    \        }\n    }\n    if min_strength == 0 {\n        format!(\"{}.{}\", class_name,\
    \ extensions[0])\n    } else {\n        format!(\"{}.{}.{}\", class_name, extensions[strongest_extensions.iter().position(|&x|\
    \ *x == min_strength).unwrap()], min_strength)\n    }", "    let mut min_strength\
    \ = std::i32::MAX;\n    let mut strongest_extension: String;\n    for extension\
    \ in extensions {\n        let strength = class_name.chars().filter(|c| c.is_uppercase()).count()\
    \ - class_name.chars().filter(|c| c.is_lowercase()).count();\n        if strength\
    \ < min_strength {\n            min_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    strongest_extension", "    let mut strength\
    \ = -1i32;\n    let mut best_extension = String::from(\"\");\n    extensions.iter().for_each(|extension|\
    \ {\n        let (class_len, _) = extension.chars().count();\n        let (_,\
    \ class_name) = extension.split_first();\n        match class_name.chars().count()\
    \ {\n            1 => {},\n            2 => {\n                strength = -1;\n\
    \            },\n            3 | _ => {\n                strength = match strength\
    \ {\n                    -1 => match class_name.chars().count() {\n          \
    \              0 => 0,\n                        1 => 1,\n                    \
    \    2 => 2,\n                        _ => {\n                            let\
    \ mut counter = 0;\n                            for letter in class_name {\n \
    \                               if letter >= 'A' && letter <= 'Z' {\n        \
    \                            counter += 1;\n                                }\n\
    \                            }\n                            counter.saturating_sub(class_len\
    \ as i32) as i32 / class_len as i32\n                        }\n             \
    \       },\n                    s => {\n                        match class_name.chars().count()\
    \ {\n                            1 => 1,\n                            2 => 2,\n\
    \                            3 => 3,\n                            _ => s\n   \
    \                     }\n                    }\n                };\n         \
    \   }\n        }\n    })\n    if strength > -1 {\n        best_extension = format!(\"\
    {}.{}\", class_name, best_extension);\n    }\n    return best_extension;", " \
    \   let mut strength = -1;\n    let mut extension = String::new();\n\n    for\
    \ (i, e) in extensions.iter().enumerate() {\n        let cap = e.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = e.chars().filter(|c| c.is_lowercase()).count();\n\
    \n        match cap - sm {\n            0 => (),\n            d => {\n       \
    \         extension = e.to_string() + extension;\n                strength = d;\n\
    \            }\n        }\n    }\n\n    format!(\"{}.{}\", class_name, extension)",
  "    let mut strength: usize = 0;\n    let mut extension = String::new();\n    for\
    \ extension in extensions {\n        if extension.chars().filter(|&x| x == &class_name.chars().first()).count()\
    \ > 0 {\n            strength -= extension.chars().filter(|&x| x == &class_name.chars().first()).count();\n\
    \            if strength < 1 {\n                break;\n            }\n      \
    \  }\n    }\n    \n    class_name.to_string() + extension.to_string() + extensions[extensions.len()\
    \ - strength].to_string()", "    if extensions.len() <= 0 {\n        return class_name;\n\
    \    }\n    let mut max = -1;\n    let mut max_index = -1;\n    for (i, ext) in\
    \ extensions.iter().enumerate() {\n        let mut current_ext = ext;\n      \
    \  let mut current_max = -1;\n        for (c, n) in ext.chars().filter(|c| *c\
    \ >= 'A' && *c <= 'Z').enumerate() {\n            if *n - c > current_max {\n\
    \                current_max = *n - c;\n                current_ext = String::from(\"\
    \\\n                \".to_string().push_str(&ext.chars()[n - c].to_string()).unwrap());\n\
    \            }\n        }\n        if *current_max - max < 0 {\n            max_index\
    \ = i;\n            max = *current_max;\n        }\n    }\n    if max_index ==\
    \ -1 {\n        return class_name;\n    }\n    return &String::from(\"{}.{}\"\
    ).format(class_name, &extensions[max_index]);", "    let mut max_strength = -1;\n\
    \    let mut max_extension = String::new();\n    let mut counter = 1;\n    \n\
    \    for extension in extensions {\n        let mut c = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let mut s = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let strength = if c > s { c - s } else\
    \ { s - c };\n        if strength > max_strength {\n            max_extension\
    \ = extension;\n            max_strength = strength;\n        } else if strength\
    \ == max_strength {\n            if counter == 1 {\n                max_extension\
    \ = extension;\n            } else {\n                if counter > 1 {\n     \
    \               max_extension = String::from(format!(\"{}.{}\", max_extension,\
    \ max_extension));\n                }\n            }\n            counter++;\n\
    \        }\n    }\n\n    let (className, extensionName) = class_name.split('.').collect::<Vec<&str>>();\n\
    \    if counter == 1 {\n        return format!(\"{}.{}\", className, max_extension);\n\
    \    } else {\n        return format!(\"{}.{}\", className, max_extension);\n\
    \    }", "    let mut max_strength = -1i32;\n    let mut min_strength = MAX_INT;\n\
    \n    for extension in extensions.iter() {\n        let len: usize = extension.chars().count();\n\
    \        let cap: usize = extension.chars().filter(|&c| c.is_uppercase()).count();\n\
    \        let sm: usize = extension.chars().filter(|&c| c.is_lowercase()).count();\n\
    \        let score: i64 = len.abs() * cap.abs() - (cap.abs() + sm.abs()) as i64;\n\
    \        max_strength = max(max_strength, score);\n        min_strength = min(min_strength,\
    \ score);\n    }\n\n    let result = String::from(class_name);\n    max_strength\n\
    \        .min(min_strength)\n        .unwrap_or(MAX_INT)\n        .to_string()\n\
    \        + extensions[0].to_string()", "    let mut strength = -1i32;\n    let\
    \ mut result: Option<String> = None;\n    for extension in extensions {\n    \
    \    let num_upper = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let num_lower = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let frac = num_upper - num_lower;\n        if frac > strength {\n   \
    \         strength = frac;\n            result = Some(String::from(extension));\n\
    \        }\n    }\n    result.unwrap_or(String::from(class_name + \".\"))", " \
    \   let mut counter: Vec<i32> = vec![-1, 0, 0];\n\n    for i in 0..extensions.len()\
    \ {\n        counter[extensions[i].chars().filter(|&c| c.is_uppercase()).count()\
    \ - 1] += 1;\n    }\n\n    let mut max_counter = counter.iter().max().unwrap();\n\
    \    let mut max_i = -1;\n\n    for i in 0..counter.len() {\n        if counter[i]\
    \ >= max_counter {\n            max_counter = counter[i];\n            max_i =\
    \ i;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, extensions[max_i].to_lowercase())",
  "    let mut min_strength = -1;\n    let mut min_extension = String::new();\n  \
    \  \n    for extension in extensions.iter() {\n        let mut strength = 0;\n\
    \        let mut caps = String::new();\n        let mut sms = String::new();\n\
    \        \n        for char in extension {\n            if char == 'A' {\n   \
    \             caps += char.to_string();\n            }\n            if char ==\
    \ 'S' {\n                sms += char.to_string();\n            }\n           \
    \ strength += 1;\n        }\n        if strength > min_strength {\n          \
    \  min_strength = strength;\n            min_extension = extension;\n        }\n\
    \    }\n    class_name + \".\" + min_extension", "    let mut max_extension =\
    \ Vec::new();\n    for ext in extensions {\n        let mut extension = ext.to_lowercase();\n\
    \        let mut cap_letters = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let mut sm_letters = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let strength = cap_letters - sm_letters;\n        if strength > 0 {\n\
    \            if let Some(mut index) = max_extension.iter().position(|&x| x ==\
    \ extension) {\n                *index = *index + 1;\n            } else {\n \
    \               max_extension.push(extension);\n            }\n        }\n   \
    \ }\n    if let Some(mut index) = max_extension.iter().position(|&x| x.to_lowercase()\
    \ == class_name) {\n        *index = *index + 1;\n    }\n    max_extension.iter().cloned().collect::<Vec<_>>().join(\"\
    .\") + Strongest_Extension_Strength(max_extension)", "    let mut s = String::from(class_name);\n\
    \    for i in extensions.iter().rposition(|&x| x.is_upper()) {\n        let len:\
    \ isize = i.len();\n        let cap = i.as_str()[..len];\n        let sm = i.as_str()[len..];\n\
    \        s.push_str(&cap.to_lowercase(&));\n        s.push_str(&sm.to_lowercase(&));\n\
    \        s.push_str(&String::from(\".\").to_lowercase(&));\n    }\n    s", " \
    \   let mut counters = vec![];\n    for (i, name) in extensions.iter().enumerate()\
    \ {\n        let c = name.chars().filter(|c| c.is_uppercase()).count();\n    \
    \    let s = name.chars().filter(|c| c.is_lowercase()).count();\n        let mut\
    \ c = c - s;\n        if c > 0 {\n            counters.push(c as i64);\n     \
    \   }\n    }\n    \n    let mut min = counters[0];\n    let mut max = -1;\n  \
    \  let mut maxix = -1;\n    for (i, &c) in counters.iter().enumerate() {\n   \
    \     if max < c {\n            max = c;\n            maxix = i;\n        }\n\
    \    }\n    \n    let mut s = String::new();\n    format!(\"{}.{}\", class_name,\
    \ extensions[maxix]);", "    // Your code here\n    let mut n = 0.0\n    let mut\
    \ s = 0.0\n    for ext: &str in extensions {\n        let cap = ext.chars().filter(|c|\
    \ c.is_upper()).count();\n        let sm = ext.chars().filter(|c| c.is_lower()).count();\n\
    \        let frac = cap - sm;\n        n = n + frac;\n        s = s + frac;\n\
    \    }\n    if n == 0.0 {\n        return \"\";\n    }\n    let n = n as f64;\n\
    \    let s = s as f64;\n    let cap = s.sqrt() as f64;\n    let sm = cap.sqrt();\n\
    \    if cap == sm {\n        return class_name.to_string();\n    }\n    let mut\
    \ min_frac = 0.0;\n    let mut min_index = -1;\n    for index, frac in extensions[0].chars().enumerate()\
    \ {\n        let n = frac * cap as f64;\n        let s = frac * sm as f64;\n \
    \       if n == 0.0 || s == 0.0 {\n            return class_name.to_string();\n\
    \        }\n        if n > min_frac {\n            min_frac = n;\n           \
    \ min_index = index;\n        }\n    }\n    if min_index >= 0 {\n        return\
    \ class_name.to_string();\n    }\n    for index, frac in extensions[extensions.len()\
    \ - 1].chars().enumerate() {\n        let n = frac * cap as f64;\n        let\
    \ s = frac * sm as f64;\n        if n == 0.0 || s == 0.0 {\n            return\
    \ class_name.to_string();\n        }\n        if n < min_frac {\n            min_frac\
    \ = n;\n            min_index = index;\n        }\n    }\n    \n    return extensions[min_index].to_string();",
  "    // Your code here\n    let mut counts = vec![0; extensions.len()];\n\n    for\
    \ &e in extensions {\n        for &c in e.chars() {\n            match c {\n \
    \               'A' => {\n                    counts[1] += 1;\n              \
    \  }\n                'B' => {\n                    counts[2] += 1;\n        \
    \        }\n                'C' => {\n                    counts[3] += 1;\n  \
    \              }\n                'D' => {\n                    counts[4] += 1;\n\
    \                }\n                'E' => {\n                    counts[5] +=\
    \ 1;\n                }\n                'F' => {\n                    counts[6]\
    \ += 1;\n                }\n                'G' => {\n                    counts[7]\
    \ += 1;\n                }\n                'H' => {\n                    counts[8]\
    \ += 1;\n                }\n                'I' => {\n                    counts[9]\
    \ += 1;\n                }\n                'J' => {\n                    counts[10]\
    \ += 1;\n                }\n                'K' => {\n                    counts[11]\
    \ += 1;\n                }\n                'L' => {\n                    counts[12]\
    \ += 1;\n                }\n                'M' => {\n                    counts[13]\
    \ += 1;\n                }\n                'N' => {\n                    counts[14]\
    \ += 1;\n                }\n                'O' => {\n                    counts[15]\
    \ += 1;\n                }\n                'P' => {\n                    counts[16]\
    \ += 1;\n                }\n                'Q' => {\n                    counts[17]\
    \ += 1;\n                }\n                'R' => {\n                    counts[18]\
    \ += 1;\n                }\n                'S' => {\n                    counts[19]\
    \ += 1;\n                }\n                'T' => {\n                    counts[20]\
    \ += 1;\n                }\n                'U' => {\n                    counts[21]\
    \ += 1;\n                }\n                'V' => {\n                    counts[22]\
    \ += 1;\n                }\n                'W' => {\n                    counts[23]\
    \ += 1;\n                }\n                'X' => {\n                    counts[24]\
    \ += 1;\n                }\n                'Y' => {\n                    counts[25]\
    \ += 1;\n                }\n                'Z' => {\n                    counts[26]\
    \ += 1;\n                }\n                c => {\n                    counts[0]\
    \ += 1;\n                }\n            }\n        }\n    }\n\n    let strength\
    \ = counts[0] - counts[1] - counts[2] - counts[3] - counts[4] - counts[5] - counts[6]\
    \ - counts[7] - counts[8] - counts[9] - counts[10] - counts[11] - counts[12] -\
    \ counts[13] - counts[14] - counts[15] - counts[16] - counts[17] - counts[18]\
    \ - counts[19] - counts[20] - counts[21] - counts[22] - counts[23", '    // Your
    code goes here', "    let mut min_strength: i64 = -1;\n    let mut min_extension:\
    \ Option<String> = None;\n    let mut min_extension_strength: i64 = -1;\n    for\
    \ extension in extensions {\n        let (mut cap, mut sm) = (match class_name.chars().nth(0)\
    \ \n                                    {Some(c) => c, None} \n              \
    \                      {None => panic!(\"Capital letters missing in class name\"\
    )});\n        for c in extension {\n            match c.to_ascii_lowercase() {\n\
    \                Some('a'..'z') => cap = cap - 1,\n                Some('A'..'Z')\
    \ => cap = cap - 65,\n                _ => (),\n            }\n            match\
    \ c.to_ascii_uppercase() {\n                Some('a'..'z') => sm = sm - 1,\n \
    \               Some('A'..'Z') => sm = sm - 65,\n                _ => (),\n  \
    \          }\n        }\n        let (strength, mut extension) = (match sm, cap\
    \ {\n            (x, y) => {\n                if x == 0 {\n                  \
    \  min_strength = Some(-x + 1)\n                } else {\n                   \
    \ let strength = x - y;\n                    if strength < min_strength {\n  \
    \                      min_strength = Some(strength)\n                    } else\
    \ {\n                        min_strength = None\n                    }\n    \
    \            }\n                None\n            }\n            _ => panic!(\"\
    Invalid extension name\"),\n        });\n        if extension.is_some() {\n  \
    \          if extension_strength(extension) == min_extension_strength {\n    \
    \            min_extension = Some(extension.unwrap())\n            } else {\n\
    \                min_extension = None\n            }\n        }\n        min_extension_strength\
    \ = min_strength;\n    }\n    min_extension.take().unwrap()", "    let mut best_extension\
    \ = \"\";\n    let mut best_strength = -1;\n\n    for extension in extensions\
    \ {\n        let strength = Extension::to_string(class_name).unwrap().chars().filter(|c|\
    \ c.is_uppercase().is_ok()).count() - extension.chars().filter(|c| c.is_lowercase().is_ok()).count();\n\
    \n        if strength > best_strength {\n            best_strength = strength;\n\
    \            best_extension = extension;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, best_extension)", "    if extensions.iter().map(|x| x.chars().filter(|c|\
    \ c.is_ascii_uppercase).count() as u32).max() > extensions.iter().map(|x| x.chars().filter(|c|\
    \ c.is_ascii_lowercase).count() as u32).max() {\n        return class_name.concat(\"\
    .\").concat(extensions.iter().map(|x| x.chars().filter(|c| c.is_ascii_lowercase).count()\
    \ as u32).max().to_string());\n    }\n    if extensions.iter().map(|x| x.chars().filter(|c|\
    \ c.is_ascii_uppercase).count() as u32).max() == 0 {\n        return class_name.concat(\"\
    .\").concat(extensions.iter().map(|x| x.chars().filter(|c| c.is_ascii_lowercase).count()\
    \ as u32).min().to_string());\n    }\n    return class_name.concat(\".\").concat(extensions.iter().map(|x|\
    \ x.chars().filter(|c| c.is_ascii_lowercase).count() as u32).min().to_string());",
  "    let mut s = class_name.to_string();\n    let mut num_upper = 0;\n    for e\
    \ in extensions {\n        let cap = e.chars().filter(|c|c == 'A'..='Z').count();\n\
    \        let sm = e.chars().filter(|c|c == 'a'..='z').count();\n        let diff\
    \ = cap - sm;\n        if diff > num_upper {\n            num_upper = diff;\n\
    \            s = e;\n        }\n    }\n    return s;", "    // Your code here\n\
    \    let mut strength = -1;\n    let mut ext = String::new();\n    for e in extensions\
    \ {\n        if e.chars().filter(|&c| c.is_upper()).count() > strength {\n   \
    \         ext = e;\n            strength = e.chars().filter(|&c| c.is_upper()).count();\n\
    \        }\n    }\n    ext", "    if extensions.len() <= 1 {\n        return class_name;\n\
    \    }\n    let mut strength: i32;\n    for (i, s) in extensions.iter().enumerate()\
    \ {\n        if s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() >= 2 {\n\
    \            strength = i;\n            break;\n        }\n    }\n    if strength\
    \ == 0 {\n        return class_name;\n    }\n    let cap = match strength {\n\
    \        0 => 0,\n        1 => 1,\n        2 => 1,\n        _ => 0,\n    };\n\
    \    let sm = match strength {\n        0 => 0,\n        1 => 2,\n        2 =>\
    \ 3,\n        _ => 0,\n    };\n    let cap_extensions = extensions.iter().filter(|s|\
    \ s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() == cap);\n    let sm_extensions\
    \ = extensions.iter().filter(|s| s.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ == sm);\n    if cap_extensions.iter().any(|s| s != class_name) && sm_extensions.iter().any(|s|\
    \ s != class_name) {\n        return class_name;\n    }\n    let mut strongest_extension\
    \ = extensions[cap - 1];\n    for i in 0..extensions.len() - 1 {\n        if strongest_extension\
    \ == extensions[i] {\n            strongest_extension = extensions[i - 1];\n \
    \       } else {\n            break;\n        }\n    }\n    match strongest_extension\
    \ {\n        Some(extension) => extension,\n        None => \"\",\n    }", " \
    \   let mut max_strength = -1;\n    let mut max_strength_class = \"\";\n    for\
    \ (i, ext) in extensions.iter().enumerate() {\n        let mut ext_class = ext\n\
    \            .to_lowercase()\n            .chars()\n            .map(|c| c.to_uppercase())\n\
    \            .collect::<Vec<String>>()\n            .iter()\n            .take(ext.len())\n\
    \            .collect::<Vec<_>>();\n        let strength = ext_class.iter().filter(|c|\
    \ c.chars().count() > 0).count();\n        if strength > max_strength {\n    \
    \        max_strength = strength;\n            max_strength_class = ext;\n   \
    \     }\n    }\n    let strength = max_strength;\n    let strongest_extension\
    \ = format!(\"{}.{}\", class_name, max_strength_class);\n    if strength == 0\
    \ {\n        return format!(\"{}\", strongest_extension);\n    }\n    let mut\
    \ max_strength_class: Vec<_> = extensions.iter().filter(|ext| ext.chars().count()\
    \ > 0).collect();\n    max_strength_class.pop();\n    for (i, ext) in extensions.iter().enumerate()\
    \ {\n        let ext_class = ext.to_lowercase().chars().filter(|c| c.to_uppercase()\
    \ == ext).collect::<Vec<_>>();\n        if ext_class.len() > max_strength {\n\
    \            max_strength = ext_class.len();\n            max_strength_class =\
    \ ext;\n        }\n    }\n    let strength = max_strength;\n    let strongest_extension\
    \ = format!(\"{}.{}\", class_name, max_strength_class);\n    if strength == 0\
    \ {\n        return format!(\"{}\", strongest_extension);\n    }", "    let mut\
    \ strength = -1i32;\n    let mut strongest_extension = None;\n    let mut i =\
    \ 0;\n    while i < extensions.len() {\n        if extensions[i].to_lowercase()\n\
    \            .chars()\n            .filter(|c| c >= 'A' && c <= 'Z')\n       \
    \     .count() == 1 {\n            let char: u8 = extensions[i].to_lowercase().nth(i);\n\
    \            strength += (char - 'A').min(char - 'a');\n            i += 1;\n\
    \        } else {\n            if strength >= 0 {\n                strongest_extension\
    \ = Some(extensions[i]);\n                break;\n            } else {\n     \
    \           strongest_extension = None;\n            }\n        }\n    }\n   \
    \ strongest_extension.ok_or_else(|| format!(\"{}\", class_name))", "    let mut\
    \ min_strength: i32 = -1;\n    let mut best_name: String = class_name;\n    let\
    \ mut first_extension: Option<String> = None;\n    for (i, e) in extensions.iter().enumerate()\
    \ {\n        let c = e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n \
    \       let s = e.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n      \
    \  if c < s {\n            if *c < min_strength {\n                min_strength\
    \ = *c;\n                best_name = class_name + &e[0..(i + 1)];\n          \
    \      first_extension = Some(e);\n            }\n        }\n    }\n    first_extension.as_ref().map_or(class_name,\
    \ |e| &e + \".\" + first_extension.as_ref().unwrap_or(&e[1..]))", "    let mut\
    \ min_extensions = String::new();\n    let mut min_extensions_strength = -1;\n\
    \    for (i, e) in extensions.iter().enumerate() {\n        let c: &str = &e.to_string();\n\
    \        let c: &str = &c.to_string();\n        let c = c.to_ascii_lowercase();\n\
    \        let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n   \
    \     let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n      \
    \  let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n        let\
    \ c = c.to_string();\n        let c = c.to_ascii_lowercase();\n        let c =\
    \ c.to_string();\n        let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n\
    \        let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n   \
    \     let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n      \
    \  let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n        let\
    \ c = c.to_ascii_uppercase();\n        let c = c.to_string();\n        let c =\
    \ c.to_ascii_lowercase();\n        let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n\
    \        let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n   \
    \     let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n      \
    \  let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n        let\
    \ c = c.to_string();\n        let c = c.to_ascii_uppercase();\n        let c =\
    \ c.to_string();\n        let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n\
    \        let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n   \
    \     let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n      \
    \  let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n        let\
    \ c = c.to_ascii_lowercase();\n        let c = c.to_string();\n        let c =\
    \ c.to_ascii_uppercase();\n        let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n\
    \        let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n   \
    \     let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n      \
    \  let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n        let\
    \ c = c.to_string();\n        let c = c.to_ascii_lowercase();\n        let c =\
    \ c.to_string();\n        let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n\
    \        let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n   \
    \     let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n      \
    \  let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n        let\
    \ c = c.to_ascii_uppercase();\n        let c = c.to_string();\n        let c =\
    \ c.to_ascii_lowercase();\n        let c = c.to_string();\n        let ", "  \
    \  \n    let mut strongest_extensions = extensions.clone();\n    strongest_extensions.sort();\n\
    \    strongest_extensions.pop();\n    \n    if extensions.len() > 0 {\n      \
    \  let mut class_name_len = 0;\n        class_name_len = class_name.len();\n \
    \       \n        for extension in strongest_extensions {\n            let mut\
    \ count = 1;\n            for c in extension {\n                if c >= 'A' &&\
    \ c <= 'Z' {\n                    count += 1;\n                }\n           \
    \     else if c >= 'a' && c <= 'z' {\n                    count += 1;\n      \
    \          }\n            }\n            let frac = class_name_len - count;\n\
    \            if frac > 0 {\n                let mut count_cap = 0;\n         \
    \       let mut count_sm = 0;\n                for c in extension {\n        \
    \            if c >= 'A' && c <= 'Z' {\n                        count_cap += 1;\n\
    \                    }\n                    else if c >= 'a' && c <= 'z' {\n \
    \                       count_sm += 1;\n                    }\n              \
    \  }\n                let frac = frac / count_cap;\n                let frac =\
    \ frac + (count_sm / count_cap);\n                strongest_extensions.insert(strongest_extensions.len()\
    \ - 1, &format!(\"{}.{}\", class_name, extension));\n                break;\n\
    \            }\n        }\n    }\n    return strongest_extensions.last();", " \
    \   let mut strength = 0;\n    extensions.sort_by_key(|x|x.chars().map(|x|x.to_lowercase()).collect::<Vec<_>>().iter().sum());\n\
    \    \n    match extensions.iter().find(|x|x.chars().map(|x|x.to_lowercase()).collect::<Vec<_>>().iter().sum()\
    \ >= strength){\n        Some(x) => x.to_string() + class_name,\n        None\
    \ => \"\".to_string() + class_name\n    }", "    let mut class_to_extensions =\
    \ HashMap::new();\n    for extension in extensions {\n        let extension_class\
    \ = String::from(extension.chars().filter(|c| c >= 'A' && c <= 'Z').collect::<String>());\n\
    \        let extension_strength = extension.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count() - extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        class_to_extensions.insert(extension_class, extension_strength);\n  \
    \  }\n    let strength = class_to_extensions.get(&class_name).unwrap();\n    let\
    \ max_strength = class_to_extensions.max_by_key(|&(_, strength)| strength).unwrap().1;\n\
    \    if max_strength == 0 {\n        return String::from(class_name);\n    }\n\
    \    let mut class_extensions = HashMap::new();\n    for (_, strength) in class_to_extensions\
    \ {\n        if strength == 0 {\n            continue;\n        }\n        class_extensions.insert(strength,\
    \ \"\");\n    }\n    let mut class_to_extensions_sorted_by_strength = class_extensions.iter().map(|(_,\
    \ value)| *value).collect::<Vec<_>>();\n    class_to_extensions_sorted_by_strength.sort_by_key(|&value|\
    \ value);\n    let mut class_name = class_name.to_string();\n    let mut strength_found\
    \ = false;\n    while !strength_found {\n        let extension = class_to_extensions_sorted_by_strength.first().unwrap();\n\
    \        let extension_strength = extension.len();\n        let mut class_extension\
    \ = String::from(extension.chars().filter(|c| c >= 'a' && c <= 'z').collect::<String>());\n\
    \        class_extension.truncate(class_extension.len() - extension_strength);\n\
    \        class_to_extensions.insert(class_extension, extension);\n        for\
    \ (_, value) in class_to_extensions {\n            if value == &extension {\n\
    \                strength_found = true;\n            }\n        }\n        class_to_extensions_sorted_by_strength.remove(&extension);\n\
    \        class_name.replace_range(class_name.len()+1, class_name.len()+extension_strength.to_string().len(),\
    \ &class_extension);\n    }\n    class_name", "    let mut strongest = Vec::new();\n\
    \    let mut num_caps = 0;\n    let mut num_sms = 0;\n\n    for e in extensions\
    \ {\n        let c = &e.chars().filter(|x| x.is_uppercase()).count();\n      \
    \  let s = &e.chars().filter(|x| x.is_lowercase()).count();\n        \n      \
    \  let cap_frac = &c - &s;\n        let cap_frac: i32 = cap_frac.to_i();\n   \
    \     \n        if cap_frac == 0 {\n            strongest.push(e);\n        }\
    \ else {\n            if cap_frac > num_caps {\n                num_caps = cap_frac;\n\
    \                strongest.clear();\n                strongest.push(e);\n    \
    \        } else if cap_frac == num_caps {\n                strongest.push(e);\n\
    \            }\n        }\n    }\n    \n    if num_caps > 0 {\n        let mut\
    \ c = 0.0;\n        \n        for s in strongest {\n            c += s.chars().filter(|x|\
    \ x.is_lowercase()).count();\n        }\n        \n        let strongest = &strongest.first().to_string();\n\
    \        let cap_frac: i32 = num_caps.to_i() - c.to_i();\n        \n        if\
    \ cap_frac == 0 {\n            return strongest;\n        } else {\n         \
    \   if cap_frac > num_caps {\n                return class_name.to_string() +\
    \ \". \" + strongest;\n            } else {\n                return class_name.to_string()\
    \ + \". \" + strongest + \". \";\n            }\n        }\n    } else {\n   \
    \     return class_name.to_string();\n    }", '    // TODO: Implement this!',
  "    let mut strength = -1i32;\n    for extension in extensions {\n        let (class_cap,\
    \ class_sm) = extension.to_uppercase().chars().count();\n        let (extension_cap,\
    \ extension_sm) =  extension.to_lowercase().chars().count();\n        let strength\
    \ = if class_cap - class_sm > extension_cap - extension_sm {\n            class_cap\
    \ - class_sm\n        } else {\n            extension_cap - extension_sm\n   \
    \     }\n    }\n    class_name.to_string() + extensions[strength].to_string()",
  "    let mut strength = -1i32;\n    let mut extension = String::new();\n    for\
    \ ext: &str in extensions {\n        let cap = ext.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = ext.chars().filter(|c| c.is_lowercase()).count();\n        if\
    \ cap > sm {\n            extension = ext;\n            strength = cap - sm;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)", "    if extensions.is_empty()\
    \ {\n        String::from(class_name)\n    } else {\n        let mut best_strength\
    \ = 0;\n        let mut best_extension = String::from(\"\");\n        for extension\
    \ in extensions {\n            let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \            let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \            let strength = cap - sm;\n            if strength > best_strength\
    \ {\n                best_strength = strength;\n                best_extension\
    \ = extension;\n            }\n        }\n        String::from(class_name) + &best_extension\n\
    \    }", "    \n    let mut class_name = String::from(class_name);\n    let mut\
    \ extensions = extensions.iter().map(String::from).collect::<Vec<_>>();\n    let\
    \ mut strength = 1;\n    \n    for &item in extensions {\n        let mut char_counter:\
    \ Vec<usize> = item.chars().map(|c| match c {\n            Some(c) => {\n    \
    \            char_counter.push(c.to_ascii_uppercase().len() - c.to_ascii_lowercase().len());\n\
    \                char_counter\n            }\n            _ => 0,\n        }).collect::<Vec<_>>();\n\
    \        let mut max_char_counter: usize = char_counter.iter().max().unwrap();\n\
    \        if char_counter.iter().any(|&item|item == max_char_counter) {\n     \
    \       char_counter.iter().filter(|&item|item == max_char_counter).count();\n\
    \        } else {\n            char_counter.push(0);\n        }\n        char_counter\
    \ = char_counter.iter().sum();\n        \n        let mut min_char_counter: usize\
    \ = char_counter.iter().min().unwrap();\n        if char_counter.iter().any(|&item|item\
    \ == min_char_counter) {\n            char_counter.iter().filter(|&item|item ==\
    \ min_char_counter).count();\n        } else {\n            char_counter.push(0);\n\
    \        }\n        char_counter = char_counter.iter().sum();\n        \n    \
    \    let mut max_char_counter_to_class = char_counter.iter().max().unwrap() -\
    \ char_counter.iter().min().unwrap();\n        let mut min_char_counter_to_class\
    \ = char_counter.iter().min().unwrap() - char_counter.iter().max().unwrap();\n\
    \        let mut max_char_counter_to_class_and_name = max_char_counter_to_class\
    \ * char_counter.iter().count() / char_counter.iter().sum();\n        let mut\
    \ min_char_counter_to_class_and_name = min_char_counter_to_class * char_counter.iter().count()\
    \ / char_counter.iter().sum();\n        \n        if char_counter_to_class_and_name\
    \ > max_char_counter_to_class_and_name {\n            strength = -1;\n       \
    \     break;\n        }\n        if char_counter_to_class_and_name == max_char_counter_to_class_and_name\
    \ {\n            if min_char_counter_to_class_and_name > max_char_counter_to_class_and_name\
    \ {\n                strength = -1;\n                break;\n            }\n \
    \       }\n        if char_counter_to_class_and_name == min_char_counter_to_class_and_name\
    \ {\n            if min_char_counter_to_class > max_char_counter_to_class {\n\
    \                strength = -1;\n                break;\n            }\n     \
    \   }\n    }", "    let mut result = String::new();\n    let mut strength = 0;\n\
    \    let mut prev_class = \"\";\n    let mut extensions = extensions.clone();\n\
    \    let mut has_previous_class = false;\n    let mut i = 0;\n    \n    // while\
    \ we still have extensions\n    while i < extensions.len(){\n        let extension\
    \ = extensions[i];\n        \n        // if the extension is not the one that\
    \ is already on the class\n        if !class_name.starts_with(extension){\n  \
    \          \n            // if the extension has lower or uppercase letters\n\
    \            if extension.chars().any(|c| !c.is_uppercase() && !c.is_lowercase()){\n\
    \                strength -= 1;\n            }\n            \n            // if\
    \ the extension has more than one uppercase letter\n            if extension.chars().filter(|c|\
    \ c.is_uppercase()).count() > 1 {\n                strength -= 1;\n          \
    \  }\n            \n            // if the extension has more than one lowercase\n\
    \            if extension.chars().filter(|c| c.is_lowercase()).count() > 1 {\n\
    \                strength -= 1;\n            }\n            \n            // if\
    \ the extension's name is empty\n            if extension.len() == 0 {\n     \
    \           strength -= 1;\n            }\n            \n            // if the\
    \ extension's name is one letter\n            if extension.len() == 1 {\n    \
    \            strength += 1;\n            }\n            \n            // if the\
    \ extension's name is greater than the class\n            if extension.len() >\
    \ class_name.len() {\n                strength += 1;\n            }\n        \
    \    \n            // if the extension's name is greater than the class\n    \
    \        if extension.len() > class_name.len() {\n                strength +=\
    \ 1;\n            }\n            \n            // if the extension's name is greater\
    \ than the class\n            if extension.len() > class_name.len() {\n      \
    \          strength += 1;\n            }\n            \n            // if the\
    \ extension's name is greater than the class\n            if extension.len() >\
    \ class_name.len() {\n                strength += 1;\n            }\n        \
    \    \n            // if the extension's name is greater than the class\n    \
    \        if extension.len() > class_name.len() {\n                strength +=\
    \ 1;\n            }\n            \n            // if the extension's name is greater\
    \ than the class\n            if extension.len() > class_name.len() {\n      \
    \          strength += 1;\n            }\n            \n            // if the\
    \ extension's name is greater than the class\n            if extension.len() >\
    \ class_name.len() {\n                strength += 1;\n            }\n        \
    \    \n            // if the extension's name is greater than the class\n    \
    \        if extension.len() > class_name.len() {\n                strength +=\
    \ 1;\n            }\n            \n            // if the extension's name is greater\
    \ than the class\n            if extension.len() > class_name.len() {\n      \
    \          strength += 1;\n            }\n            \n            // if the\
    \ extension's name is greater than the class\n            if extension.len() >\
    \ class_name.", "    let mut classname = ClassName::new(&class_name);\n    let\
    \ mut extension = Extension::new();\n    extension.strength = -1;\n    let mut\
    \ extension_strings = Vec::new();\n    let mut strength = extension.strength;\n\
    \n    for extension in extensions {\n        if classname.extension_exists(extension)\
    \ {\n            extension.strength = strength;\n            extension_strings.push(extension.to_string());\n\
    \        } else {\n            classname.add(extension.to_lowercase()).unwrap();\n\
    \            strength = -1;\n        }\n    }\n\n    classname.strongest_extension().unwrap()",
  "    let mut min = extensions[0].to_ascii_lowercase();\n    let mut max = extensions[0].to_ascii_lowercase();\n\
    \    for &extension in extensions.iter() {\n        let mut counter = 0;\n   \
    \     for &letter in extension.to_ascii_lowercase() {\n            counter +=\
    \ if letter == min { 1 } else { -1 };\n        }\n        if counter == 0 {\n\
    \            min = extension.to_ascii_lowercase();\n        } else {\n       \
    \     max = extension.to_ascii_lowercase();\n        }\n    }\n    let mut strength\
    \ = max[0].to_ascii_lowercase().chars().count() - min[0].to_ascii_lowercase().chars().count();\n\
    \    if strength == 0 {\n        class_name\n    } else {\n        class_name.to_ascii_lowercase().to_string()\
    \ + String::from(\"_\").to_string(strength + 1).to_string()\n    }", "    if extensions.iter().any(|&x|\
    \ x.chars().filter(|&y| y.is_uppercase()).count() > 1) {\n        assert!(false);\n\
    \    }\n    if extensions.iter().any(|&x| x.chars().filter(|&y| y.is_lowercase()).count()\
    \ > 1) {\n        assert!(false);\n    }\n    if extensions.iter().any(|&x| x.chars().filter(|&y|\
    \ !y.is_lowercase()).count() > 1) {\n        assert!(false);\n    }\n    if extensions.iter().any(|&x|\
    \ x.chars().filter(|&y| !y.is_uppercase()).count() > 1) {\n        assert!(false);\n\
    \    }\n    let mut count = 1;\n    for e in extensions {\n        if e.chars().filter(|&c|\
    \ c.is_lowercase()).count() > 1 {\n            count += 1;\n        }\n      \
    \  if e.chars().filter(|&c| c.is_uppercase()).count() > 1 {\n            count\
    \ += 1;\n        }\n    }\n    if count > 1 {\n        return format!(\"{}.{}\"\
    , class_name, extensions.iter().sorted().filter(|&x| x.chars().filter(|&y| y.is_lowercase()).count()\
    \ > 1).next().unwrap());\n    }\n    if count == 1 {\n        return format!(\"\
    {}.{}\", class_name, extensions.iter().sorted().filter(|&x| x.chars().filter(|&y|\
    \ y.is_uppercase()).count() > 1).next().unwrap());\n    }\n    format!(\"{}.{}\"\
    , class_name, extensions.iter().sorted().filter(|&x| x.chars().filter(|&y| !y.is_lowercase()).count()\
    \ > 1).next().unwrap());", "    let mut max_extension = 0.;\n    let mut best_extension\
    \ = String::new();\n    let mut best_index = -1;\n    for extension in extensions.iter().cloned().take(extensions.len())\
    \ {\n        let strength = extension.chars().filter(|c| c.is_uppercase().collect::<String>().len()\
    \ - c.is_lowercase().collect::<String>().len()).count();\n        if strength\
    \ > max_extension {\n            max_extension = strength;\n            best_extension\
    \ = extension;\n            best_index = extensions.iter().cloned().position(|e|\
    \ e == extension).unwrap();\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ best_extension)", "    let mut min_extension = std::cmp::Ordering::Equal;\n\
    \    let mut min_strength = std::cmp::Ordering::Equal;\n    extensions.iter().filter(|&e|\
    \ e.is_ascii_lowercase()).for_each(|e| {\n        if e.is_ascii_uppercase() {\n\
    \            let cap_len = e.len() - e.to_ascii_lowercase().len();\n         \
    \   if cap_len < min_strength {\n                min_extension = std::cmp::Ordering::Less;\n\
    \                min_strength = cap_len;\n            }\n        } else {\n  \
    \          let sm_len = e.len() - e.to_ascii_uppercase().len();\n            if\
    \ sm_len < min_strength {\n                min_extension = std::cmp::Ordering::Less;\n\
    \                min_strength = sm_len;\n            }\n        }\n    });\n \
    \   match min_strength {\n        std::cmp::Ordering::Equal => class_name,\n \
    \       std::cmp::Ordering::Less => format!(\"{}.{}\", class_name, min_extension),\n\
    \        std::cmp::Ordering::Greater => format!(\"{}.{}\", class_name, min_extension),\n\
    \    }", "    let mut max = -1;\n    for ext in extensions.iter() {\n        let\
    \ cap = ext.chars().count();\n        let sm = ext.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').count();\n        let strength = cap - sm;\n        if strength\
    \ > max {\n            max = strength;\n        }\n    }\n\n    let mut class\
    \ = String::from(class_name);\n    let mut ex = String::from(\"\");\n    match\
    \ max {\n        -1 => {\n            return class;\n        }\n        1 => ex\
    \ = &extensions[0],\n        2 => ex = &extensions[1],\n        _ => ex = &extensions[extensions.len()\
    \ - 1],\n    }\n    class.push(ex.as_str());\n    class", "    let mut min_value\
    \ = std::i32::MAX;\n    let mut min_extension = \"\".to_string();\n    for (i,\
    \ ext) in extensions.iter().enumerate() {\n        let cap = ext.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let sm = ext.chars().filter(|c| *c\
    \ >= 'a' && *c <= 'z').count();\n        if cap < sm {\n            min_value\
    \ = *ext < min_value ? -1 : *ext;\n            min_extension = ext;\n        }\
    \ else if cap == sm {\n            if *ext < min_value {\n                min_value\
    \ = *ext;\n                min_extension = ext;\n            }\n        }\n  \
    \  }\n    class_name.to_string().to_lowercase() + \".\" + min_extension", "  \
    \  let mut strength_map = HashMap::new();\n    \n    for extension in extensions\
    \ {\n        let cap_len = extension.len();\n        let sml_len = class_name.len();\n\
    \        let strength = cap_len - sml_len;\n        if strength_map.contains_key(&strength)\
    \ {\n            if let Some(existing) = strength_map.get_mut(&strength) {\n \
    \               existing.push_front(&extension);\n            } else {\n     \
    \           strength_map.insert(strength, vec![&extension]);\n            }\n\
    \        } else {\n            strength_map.insert(strength, vec![&extension]);\n\
    \        }\n    }\n\n    let strength_max: i64 = strength_map.iter().max().unwrap().len()\
    \ as i64;\n\n    let mut selected_extension: Vec<String> = vec![];\n    for (_,\
    \ elements) in strength_map.iter() {\n        let len: usize = elements.len();\n\
    \        if len == 1 {\n            selected_extension = elements[0];\n      \
    \      break;\n        }\n        if len > 1 {\n            break;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, selected_extension)", "    let extensions:\
    \ Vec<String> = extensions.into_iter().collect();\n    extensions.iter().fold(class_name,\
    \ |a, b| {\n        let mut x = a.to_string();\n        let mut y = b.to_string();\n\
    \        for (c1, c2) in y.chars().zip(x.chars()) {\n            if c1 == c2 {\n\
    \                x = x.to_string() + c1.to_string();\n            }\n        }\n\
    \        x.to_string()\n    })", "    let mut c = String::from(\"\");\n    let\
    \ mut exts = vec![];\n    for ext in extensions {\n        if ext.is_empty() {\n\
    \            continue;\n        }\n        let mut n = ext.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        n += ext.chars().filter(|c| *c >=\
    \ 'a' && *c <= 'z').count();\n        if n < 2 {\n            continue;\n    \
    \    }\n        exts.push(ext);\n    }\n    let mut total_exts = exts.iter().filter(|ext|\
    \ *ext != \"_\").count();\n    let cap = total_exts.cmp(&total_exts).unwrap();\n\
    \    let sm = ext.chars().filter(|c| *c == '_').count();\n    let strength = cap\
    \ - sm;\n    if strength == 0 {\n        return format!(\"{}.{}\", class_name,\
    \ \"_\");\n    }\n    exts.sort_unstable_by(|a, b| b.cmp(a).unwrap());\n    for\
    \ ext in exts {\n        if ext.contains(\"_\") {\n            continue;\n   \
    \     }\n        c = c.to_string() + format!(\"{}.{}\", class_name, ext);\n  \
    \  }\n    return c;", "    let mut strength = -1i32;\n    let mut extension =\
    \ String::new();\n\n    for extension in extensions.iter() {\n        let s =\
    \ extension.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        if s == strength {\n            return format!(\"\
    {}.{}\", class_name, extension);\n        }\n\n        if s < strength {\n   \
    \         strength = s;\n            extension = extension.to_owned();\n     \
    \   }\n    }\n\n    return format!(\"{}.{}\", class_name, extension);", "    //\
    \ write your code here\n    println!(\"{}\", class_name);\n    for (index, s)\
    \ in extensions.iter().enumerate() {\n        println!(\"{:?} {:?}\", s, index);\n\
    \    }\n\n    if extensions.len() == 0 {\n        class_name\n    } else {\n \
    \       let mut num_cap = class_name.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let mut num_small = class_name.chars().filter(|c| c.is_lowercase()).count();\n\
    \        for (i, s) in extensions.iter().enumerate() {\n            if s.is_lowercase()\
    \ {\n                num_small -= 1;\n            } else {\n                num_cap\
    \ -= 1;\n            }\n        }\n        let strength = num_cap - num_small;\n\
    \        if strength < 0 {\n            format!(\"{}.{}\", class_name, extensions.iter().next().unwrap())\n\
    \        } else {\n            format!(\"{}.{}\", class_name, extensions[strength].clone())\n\
    \        }\n    }", "    if extensions.iter().any(|e| e.is_empty()) {\n      \
    \  panic!(\"An extension can not be empty\");\n    }\n    let mut total_strength:\
    \ usize = 0;\n    let mut max_extension = &extensions.iter().cloned().max().unwrap();\n\
    \    for extension in extensions {\n        let mut letters = 0;\n        for\
    \ letter in extension {\n            if letter == 'A' || letter == 'B' || letter\
    \ == 'C' || letter == 'D' || letter == 'E' || letter == 'F' ||\n             \
    \   letter == 'G' || letter == 'H' || letter == 'I' || letter == 'J' || letter\
    \ == 'K' || letter == 'L' ||\n                letter == 'M' || letter == 'N' ||\
    \ letter == 'O' || letter == 'P' || letter == 'Q' || letter == 'R' ||\n      \
    \          letter == 'S' || letter == 'T' || letter == 'U' || letter == 'V' ||\
    \ letter == 'W' || letter == 'X' ||\n                letter == 'Y' || letter ==\
    \ 'Z' {\n                letters += 1;\n            }\n        }\n        let\
    \ strength = letters - total_strength;\n        total_strength += strength;\n\
    \        if strength > 0 {\n            continue;\n        }\n        max_extension\
    \ = extension;\n    }\n    class_name.to_string() + \".\" + max_extension.cloned()",
  "    let mut class_with_extension = class_name.to_lowercase();\n    let mut extensions_with_strength\
    \ = vec![];\n    \n    for extension in extensions {\n        let mut extension_with_strength\
    \ = extension.to_lowercase();\n        let mut upper_case_letters = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let mut lowercase_letters = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        \n        if upper_case_letters == lowercase_letters\
    \ {\n            extensions_with_strength.push(extension_with_strength);\n   \
    \     }\n    }\n    \n    let mut current_strength = -1;\n    let mut current_extension\
    \ = String::new();\n    for extension in extensions_with_strength {\n        if\
    \ let Some(strength) = extension.chars().count() {\n            if strength >\
    \ current_strength {\n                current_strength = strength;\n         \
    \       current_extension = extension;\n            }\n        }\n    }\n    return\
    \ class_with_extension.concat(\".\").concat(current_extension);", "    let mut\
    \ sorted_extensions = extensions.iter().cloned().sort_by_key(|x|x.to_lowercase());\n\
    \    let strength = sorted_extensions.len();\n    let class_extension = sorted_extensions.iter().filter(|x|\
    \ x.to_lowercase() == class_name.to_lowercase()).nth(strength);\n    let mut class_name\
    \ = class_name.to_string();\n    class_name = class_name.to_string().to_lowercase();\n\
    \    class_name = &class_name.to_lowercase().replace(class_extension.to_lowercase(),\
    \ \"\");\n    class_name += &class_extension.to_lowercase();\n    class_name =\
    \ &class_name.to_string();\n    class_name = &class_name.to_string().to_lowercase();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string", "    let mut extension = Vec::new();\n\
    \    let mut max_strength = 0;\n    for (i, extension) in extensions.iter().enumerate()\
    \ {\n        extension.insert(i, class_name[i]);\n        let cap = extension.iter().filter(|&x|\
    \ x == x.to_uppercase()).count();\n        let sm = extension.iter().filter(|&x|\
    \ x == x.to_lowercase()).count();\n        let strength = cap - sm;\n        if\
    \ strength > max_strength {\n            max_strength = strength;\n        }\n\
    \    }\n    extension.iter().filter(|&x| x == x.to_lowercase()).nth(max_strength).cloned()",
  "    // Your code here\n    let mut max = String::new();\n    \n    for el in extensions\
    \ {\n        let mut num_caps = 0;\n        let mut num_sms = 0;\n        let\
    \ mut num_others = 0;\n        for c in el.chars() {\n            if c.is_uppercase()\
    \ {\n                num_caps += 1;\n            } else if c.is_lowercase() {\n\
    \                num_sms += 1;\n            } else {\n                num_others\
    \ += 1;\n            }\n        }\n        let strength = num_caps - num_sms;\n\
    \        if strength > 0 {\n            let mut name = el.clone();\n         \
    \   name.to_string().chars().sort_by_key(|x| x.to_ascii_lowercase()).collect::<Vec<_>>().pop().to_string();\n\
    \            max = match max {\n                Some(max) => match max {\n   \
    \                 max if max == name => max,\n                    max if max.len()\
    \ > name.len() => max\n                },\n                None => name\n    \
    \        }\n        }\n    }\n    max + &class_name + &extensions[0]", "    let\
    \ mut class_name = class_name.to_uppercase();\n    class_name.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if let Some(mut c) = c.to_lowercase() {\n            class_name.insert(i,\
    \ c);\n        }\n    })\n    .collect::<Vec<_>>();\n    let mut sorted_extensions\
    \ = extensions;\n    sorted_extensions.sort();\n    \n    if class_name.len()\
    \ < sorted_extensions.len() {\n        return class_name.to_string() + \".\" +\
    \ sorted_extensions[0].to_string();\n    }\n    \n    let mut strength = 0;\n\
    \    for i in 0..class_name.len() - 1 {\n        if class_name.chars()[i..(i +\
    \ 1)].iter().all(|c| c.is_uppercase()) {\n            strength += 1;\n       \
    \ }\n    }\n    \n    for i in 1..sorted_extensions.len() {\n        if sorted_extensions[i\
    \ - 1].chars()[i..(i + 1)].iter().all(|c| c.is_lowercase()) {\n            strength\
    \ -= 1;\n        }\n    }\n    \n    String::from(class_name.to_string() + \n\
    \                \n                // The Strongest Extension must be the one\
    \ with the most lowercase letters\n                match strength {\n        \
    \            // If we have two or more of the same characters (same uppercase\
    \ and lowercase ones)\n                    -1 => sorted_extensions[strength -\
    \ 1].chars()[i..(i + 1)].iter().filter(|c| c.is_lowercase()).count(),\n      \
    \              _ => sorted_extensions[strength].chars()[i..(i + 1)].iter().filter(|c|\
    \ c.is_lowercase()).count()\n                }.to_string() + \"\\n\")", "    let\
    \ mut strengths = HashMap::new();\n    for (i, ext) in extensions.iter().enumerate()\
    \ {\n        let c = ext.chars().map(|c| c.to_lowercase()).count();\n        let\
    \ s = ext.chars().map(|c| c.to_lowercase()).filter(|c| c.is_upper()).count();\n\
    \        if c > s {\n            strengths.insert(ext, -1);\n        } else {\n\
    \            strengths.insert(ext, c);\n        }\n    }\n    let strength = match\
    \ strengths.get(&class_name).cloned() {\n        Some(s) => s,\n        None =>\
    \ 0,\n    };\n    let mut s = class_name.to_owned();\n    strengths.entry(&class_name).or_insert(strength).for_each(|r|\
    \ s += &r.to_string());\n    s", "  \n  let mut strength = -1;\n  let mut extension\
    \ = &extensions[0];\n  \n  for e in extensions {\n    if e.chars().count() > strength\
    \ {\n      strength = e.chars().count();\n      extension = &e;\n    }\n  }\n\
    \  \n  format!(\"{}{}\", class_name, extension)", "    let mut strength: i32 =\
    \ -1;\n    for extension in extensions {\n        let (first_letter, second_letter)\
    \ = extension.chars().nth(1).unwrap().to_ascii_uppercase().chars().nth(1).unwrap().to_ascii_lowercase();\n\
    \        let first_letter = first_letter.unwrap();\n        let second_letter\
    \ = second_letter.unwrap();\n        strength = (strength * 26) + first_letter\
    \ - second_letter;\n    }\n    strength\n        .checked_mul(extensions.length)\n\
    \        .checked_add(1)\n        .unwrap_or(-1)\n        .toString()\n      \
    \  .to_string() + class_name + extensions.to_owned()", "    let mut min_strength\
    \ = -1;\n    let mut min_extension = String::from(\"\");\n    let mut extension_count\
    \ = 0;\n    for (i, ext) in extensions.iter().enumerate() {\n        let cap =\
    \ ext.chars().filter(|c| c.is_uppercase()).count();\n        let sm = ext.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let strength = cap - sm;\n        if strength\
    \ < min_strength {\n            min_strength = strength;\n            min_extension\
    \ = ext;\n        }\n        if i == extensions.len() - 1 {\n            extension_count\
    \ = i;\n        }\n    }\n    let strength = min_strength;\n    let extension\
    \ = min_extension;\n    String::from(class_name) + String::from(extension) + \"\
    .\" + extensions[extension_count]", "    // Solution below is very similar to\
    \ the solution presented in the question, \n    // but the code was modified in\
    \ the following ways: \n    // - Instead of using map() function, used collect()\
    \ method. \n    // - Modified the logic in two places.\n    let mut extensions_cap\
    \ = extensions.iter().map(|e| e.chars().filter(|c| *c == c).count()).collect::<Vec<_>>();\n\
    \    let mut extensions_sm = extensions.iter().map(|e| e.chars().filter(|c| *c\
    \ != c).count()).collect::<Vec<_>>();\n    let mut max = extensions_cap.iter().max().unwrap();\n\
    \    let mut min = extensions_sm.iter().min().unwrap();\n\n    let mut min_extensions\
    \ = extensions_sm.iter().cloned().collect::<Vec<_>>();\n    let mut max_extensions\
    \ = extensions_cap.iter().cloned().collect::<Vec<_>>();\n    for element in extensions_cap\
    \ {\n        if element < min {\n            min = element;\n            match\
    \ max_extensions.iter().position(|x| x == element) {\n                Some(_)\
    \ => min_extensions.pop(),\n                None => ()\n            }\n      \
    \  }\n        if element > max {\n            max = element;\n            match\
    \ min_extensions.iter().position(|x| x == element) {\n                Some(_)\
    \ => max_extensions.pop(),\n                None => ()\n            }\n      \
    \  }\n    }\n    // The next line is added to ensure that the extension list has\
    \ the\n    // same number of elements as the original extension list.\n    min_extensions.extend(max_extensions.iter().cloned());\n\
    \    \n    format!(\"{}.{}\", class_name, min_extensions)", "    extensions.iter().fold(\n\
    \        \"\",\n        |mut last_extension, ext| {\n            let mut next_letter\
    \ = ext.to_lowercase();\n            let cap = next_letter.chars().filter(|c|\
    \ c.is_uppercase()).count();\n            let sm = next_letter.chars().filter(|c|\
    \ c.is_lowercase()).count();\n            let strength = cap - sm;\n         \
    \   assert!(strength >= 0);\n            if strength > 0 {\n                if\
    \ last_extension == \"\" {\n                    return &format!(\"{}.{}\", class_name,\
    \ ext);\n                } else {\n                    if last_extension.contains(&'.')\
    \ {\n                        last_extension = &format!(\"{}.{}{}\", last_extension,\
    \ ext, last_extension[..]);\n                    } else {\n                  \
    \      last_extension = &format!(\"{}.{}\", last_extension, ext);\n          \
    \          }\n                }\n            } else {\n                last_extension\
    \ = ext;\n            }\n            last_extension\n        },\n    )", '    extensions.iter().filter(|ext|
    ext.contains(&class_name.to_lowercase())).max().unwrap()', "    let mut s = String::from(class_name);\n\
    \    for i in 0..extensions.len() {\n        let mut s = String::from(s);\n  \
    \      let letters = extensions[i].chars().count();\n        let strength = letters\
    \ - i;\n        s = format!(\"{}.{}\", s, strength);\n    }\n    s", "    // Your\
    \ code here\n    let mut best_extensions = Vec::new();\n    for e in extensions\
    \ {\n        let cap_len = e.chars().filter(|&c| c >= 'A' && c <= 'Z').count();\n\
    \        let sm_len = e.chars().filter(|&c| c >= 'a' && c <= 'z').count();\n \
    \       if cap_len < sm_len {\n            let mut cur_len = 0;\n            let\
    \ mut cur_char = e[cur_len..].to_lowercase();\n            for c in e.chars()\
    \ {\n                cur_len = cur_len + c.len_of();\n                cur_char\
    \ = cur_char.chars().filter(|&c| c >= 'a' && c <= 'z').count() as String;\n  \
    \          }\n            best_extensions.insert(cur_len + sm_len, e.clone());\n\
    \        }\n    }\n\n    if best_extensions.len() > 0 {\n        let mut cur_len\
    \ = 0;\n        let mut cur_char = class_name.to_lowercase();\n        for c in\
    \ class_name.chars() {\n            cur_len = cur_len + c.len_of();\n        \
    \    cur_char = cur_char.chars().filter(|&c| c >= 'a' && c <= 'z').count() as\
    \ String;\n        }\n        best_extensions.sort().nth(best_extensions.len()).unwrap()\n\
    \    } else {\n        class_name\n    }", "    let mut min_strength = -1;\n \
    \   for extension in extensions {\n        let (class_name, extension) = extension.split_terminator('.');\n\
    \        let class_name = class_name.trim_left_matches('_');\n        let class_name\
    \ = class_name.to_lowercase();\n        let class_name = class_name.to_uppercase();\n\
    \        let class_name = &class_name + \"_\";\n        let class_name = class_name.to_string();\n\
    \        if class_name != class_name.chars().map(|c| *c).collect::<String>() {\n\
    \            continue;\n        }\n        let strength = extension.chars().filter(|c|\
    \ *c == c).count();\n        let strength = strength.to_f64().unwrap_or(0.0);\n\
    \        if strength < min_strength {\n            min_strength = strength;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, min_strength.ceil() as String)",
  "    extensions\n        .iter()\n        .fold(String::new(), |mut acc, e| acc.push_str(&format!(\"\
    {}.{}\", class_name, e)))\n        .chars()\n        .fold(String::new(), |mut\
    \ acc, c| acc.push_str(c.to_ascii_lowercase()))\n        .chars()\n        .fold(String::new(),\
    \ |mut acc, c| acc.push_str(c.to_ascii_uppercase()))\n        .to_string()", " \
    \   if extensions.len() == 0 {\n        return class_name;\n    }\n    let mut\
    \ min_extensions: Vec<String> = Vec::new();\n    for (i, &ext) in extensions.iter().enumerate()\
    \ {\n        if ext.chars().count() == 0 {\n            continue;\n        }\n\
    \        if ext.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count() < ext.chars().filter(|&c|\
    \ *c >= 'a' && *c <= 'z').count() {\n            continue;\n        }\n      \
    \  let num = ext.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count() + ext.chars().filter(|&c|\
    \ *c >= 'a' && *c <= 'z').count();\n        let cap = ext.chars().filter(|&c|\
    \ *c == *c.upcase()).count();\n        let sm = ext.chars().filter(|&c| *c ==\
    \ *c.downcase()).count();\n        let strength = (num - cap - sm) as i32 / num;\n\
    \        min_extensions.push((ext.to_string(), strength));\n    }\n    min_extensions.sort_by_key(|&(key,\
    \ _)| key.1);\n    min_extensions.iter().next().unwrap().0", "    // Your code\
    \ here\n    let mut strength: i32 = -1;\n    let mut best_extension = String::new();\n\
    \    for (i, extension) in extensions.iter().enumerate() {\n        let extension\
    \ = extension.trim_right_matches('A'..'Z').to_lowercase();\n        if i > 0 &&\
    \ extension <= best_extension {\n            continue;\n        }\n        let\
    \ c: i32 = (class_name.len()-extension.len()) as i32 / 2;\n        if strength\
    \ < c {\n            strength = c;\n            best_extension = extension;\n\
    \        }\n    }\n    class_name\n        + String::from(best_extension)", " \
    \ extensions_count => {\n    let mut strongest_extension = &class_name[..class_name.length()];\n\
    \    for i in 0..extensions_count {\n      strongest_extension = &class_name[..strongest_extension.len()\
    \ - extensions[i].len()];\n      if extensions[i].chars().filter(|&c| c.is_uppercase()\
    \ == true).count() > 0 {\n        break;\n      }\n      if extensions[i].chars().filter(|&c|\
    \ c.is_lowercase() == true).count() > 0 {\n        break;\n      }\n    }\n  \
    \  strongest_extension\n  }", "    let mut extensions_sorted = extensions.clone();\n\
    \    extensions_sorted.sort();\n    let mut strongest_extension: String = String::from(\"\
    \");\n    let mut strength: i32 = 0;\n    for extension in extensions_sorted {\n\
    \        let cap: usize = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        let sm: usize = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        let strength = cap - sm;\n        if strength > 0 {\n            if strongest_extension.is_empty()\
    \ {\n                strongest_extension = class_name + \".\" + extension;\n \
    \           } else {\n                if strength > strength {\n             \
    \       strongest_extension = class_name + \".\" + extension;\n              \
    \      strength = strength;\n                }\n            }\n        }\n   \
    \ }\n    return strongest_extension;", "    let mut strength = 0u8;\n    let mut\
    \ found: usize = 0;\n\n    for e in extensions {\n        if e == class_name {\n\
    \            return format!(\"{}.{}\", class_name, extensions[found]);\n     \
    \   }\n\n        if e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() == 1\
    \ {\n            let c = e.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n\
    \            strength += c as u8;\n            found += 1;\n        }\n    }\n\
    \n    format!(\"{}.{}\", class_name, extensions[found])", "    if extensions.iter().any(|x|\
    \ !x.is_empty()) {\n        extensions.iter().filter(|x| !x.is_empty()).sort_by_key(|x|\
    \ x.chars().count()).next().unwrap()\n    } else {\n        class_name\n    }",
  "    extensions\n        .iter()\n        .fold(String::new(), |acc: &String, ext:\
    \ &str| {\n            let first_char = ext.chars().next().unwrap();\n       \
    \     acc.to_string()\n                .split_last_mut()\n                .filter(|c|\
    \ c != first_char)\n                .collect::<Vec<_>>()\n                .sort_by(|a,\
    \ b| b.cmp(a)).first()\n                .to_string()\n        })\n        .to_string()\
    \ + String::from(class_name)", "    let mut classes: Vec<(String, usize)> = extensions.iter().cloned().map(\n\
    \        |x| {\n            let mut split = x.splitn(2, |&x| x.is_ascii_uppercase());\n\
    \            (split[0].to_lowercase(), split[1] as usize)\n        }\n    ).collect();\n\
    \    classes.sort_by(|a, b| b.1.cmp(&a.1));\n    let mut strength = -1;\n    let\
    \ mut class = \"\";\n    for (class_name, class_count) in classes {\n        if\
    \ class_name.starts_with(class_name.to_lowercase()) {\n            let mut class_extensions\
    \ = class_name.split(&class_name[0]).last().unwrap().splitn(2, |&x| x.is_ascii_uppercase());\n\
    \            if strength < class_extensions[0].to_lowercase().len_utf8() {\n \
    \               class = class_name.to_lowercase();\n                strength =\
    \ class_extensions[0].to_lowercase().len_utf8();\n            }\n        }\n \
    \   }\n    class.to_string().to_string().as_bytes().to_vec().to_string()", " \
    \   if extensions.iter().filter(|&e| e.is_ascii()).count() > 2 || extensions.iter().filter(|&e|\
    \ e.is_lowercase()).count() > 2 {\n        panic!(\"More than two extensions given\
    \ to Strongest_Extension!\");\n    }\n\n    let mut extensions_map = Vec::new();\n\
    \    for (i, e) in extensions.iter().enumerate() {\n        if e.is_ascii() {\n\
    \            extensions_map.push(e.to_ascii_lowercase());\n        } else {\n\
    \            extensions_map.push(e.to_lowercase());\n        }\n    }\n    let\
    \ mut extensions_sorted = extensions_map.iter().sorted();\n    let mut max_strength\
    \ = -1;\n    let mut max_extension = \"\";\n    for extension in extensions_sorted\
    \ {\n        if extensions_map.len() > 0 {\n            let (class_str, _) = extension.splitn(2,\
    \ \".\");\n            let mut class_map = vec![class_name.to_string()];\n   \
    \         let mut class_extension = extension;\n            if i < extensions_map.len()\
    \ - 1 {\n                let (class_str, _) = extensions_sorted[i + 1].splitn(2,\
    \ \".\");\n                let mut class_map = vec![class_name.to_string()];\n\
    \                let mut class_extension = extensions_sorted[i + 1];\n       \
    \     }\n            let class_id = class_map.iter().position(|&v| v == class_str).unwrap();\n\
    \            let extension_id = extensions_map.iter().position(|&v| v == extension).unwrap();\n\
    \            let strength = extension_id - class_id;\n            if strength\
    \ > max_strength {\n                max_strength = strength;\n               \
    \ max_extension = class_extension.to_string();\n            }\n        }\n   \
    \ }\n    return max_extension.to_string();", "    let mut max_extension_strength\
    \ = -1;\n\n    for extension in extensions {\n        let cap = extension.chars().filter(|&c|\
    \ c.is_uppercase()).count();\n        let sm = extension.chars().filter(|&c| c.is_lowercase()).count();\n\
    \n        let strength = if cap > sm {\n            cap - sm\n        } else {\n\
    \            sm - cap\n        };\n\n        if strength > max_extension_strength\
    \ {\n            max_extension_strength = strength;\n        }\n    }\n\n    format!(\"\
    {}.{}\", class_name, max_extension_strength)", "    let mut class_name = String::from(class_name);\n\
    \    class_name = &class_name[0..class_name.length() as usize];\n    let mut strength_counter\
    \ = vec![];\n    for &x in extensions {\n        let mut y = String::from(x);\n\
    \        y = &y[0..y.len() as usize];\n        strength_counter.push(y.len() as\
    \ u8);\n    }\n    strength_counter.sort_unstable_by(|x, y| x.cmp(y));\n    let\
    \ mut extension_str = \"\".to_string();\n    let mut current_strength = 0;\n \
    \   for &s in strength_counter {\n        if s == 1 {\n            extension_str.append(&class_name[0..current_strength]);\n\
    \            current_strength += 1;\n        }\n    }\n    extension_str.append(&class_name[0..current_strength]);\n\
    \    extension_str", "\tlet mut extensions_count = extensions_count(extensions);\n\
    \textensions_count += 1;\n\t\n\tlet mut extension_count = extensions_count(extensions);\n\
    \textension_count -= 1;\n\t\n\tif extension_count > extensions_count {\n\t\treturn\
    \ format!(\"{}.{}\", class_name, extensions[0]);\n\t}\n\t\n\tlet mut strength\
    \ = -1;\n\tlet mut index = 0;\n\tlet mut current_strength = 0;\n\t\n\tloop {\n\
    \t\tif current_strength == 0 {\n\t\t\treturn format!(\"{}.{}\", class_name, extensions[index]);\n\
    \t\t}\n\t\t\n\t\tlet cap = index / 2;\n\t\tlet sm = index - cap;\n\t\t\n\t\tcurrent_strength\
    \ = extension_count / cap - extension_count / sm;\n\t\t\n\t\tif current_strength\
    \ > strength {\n\t\t\tstrength = current_strength;\n\t\t}\n\t\t\n\t\tindex = index\
    \ + 1;\n\t}", "    let mut num_upper = String::new();\n    let mut num_lower =\
    \ String::new();\n    let mut num = 0;\n\n    for extension in extensions {\n\
    \        let mut temp_str = extension.to_string();\n        let mut temp_str =\
    \ temp_str.chars();\n        while let Some(c) = temp_str.next() {\n         \
    \   match c {\n                'A'..='Z' => num_upper.push_str(c.to_string()),\n\
    \                'a'..='z' => num_upper.push_str(c.to_string()),\n           \
    \     '0'..='9' => num_upper.push_str(c.to_string()),\n                c => num_upper.push_str(c.to_string()),\n\
    \            }\n        }\n        temp_str = temp_str.collect::<String>();\n\
    \        temp_str = temp_str.chars();\n        while let Some(c) = temp_str.next()\
    \ {\n            match c {\n                'a'..='z' => num_lower.push_str(c.to_string()),\n\
    \                '0'..='9' => num_lower.push_str(c.to_string()),\n           \
    \     c => num_lower.push_str(c.to_string()),\n            }\n        }\n    \
    \    temp_str = temp_str.collect::<String>();\n        temp_str = temp_str.chars();\n\
    \        num = num_upper.chars().filter(|c| *c != c).count() + num_lower.chars().filter(|c|\
    \ *c != c).count();\n        num_upper = num_upper.to_string();\n        num_lower\
    \ = num_lower.to_string();\n    }\n\n    if num == 0 {\n        String::from(class_name.to_string())\n\
    \    } else {\n        let mut num_upper = num_upper.chars().filter(|c| *c !=\
    \ c).count();\n        num_upper = String::from(format!(\"{}.{}\", class_name.to_string(),\
    \ num_upper.to_string()))\n    }", "    let mut strength = String::new();\n  \
    \  for extension in extensions.iter() {\n        let c = extension.chars().filter(|x|x.is_uppercase()).count();\n\
    \        let s = extension.chars().filter(|x|x.is_lowercase()).count();\n    \
    \    let diff = c.saturating_sub(s).unwrap_or(0);\n        if diff > 0 {\n   \
    \         strength.push_str(extension);\n        }\n    }\n    match strength.chars().count()\
    \ {\n        0 => class_name.to_string(),\n        _ => class_name.to_string().to_string()\
    \ + &format!(\"{}.{}\", strength, &extensions[0]),\n    }", "    let mut strongest_extensions\
    \ = Vec::new();\n\n    for extension in extensions {\n        let (c_name, extension_name)\
    \ = extension.split('.');\n        let cap_n = c_name.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm_n = c_name.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap_n.checked_sub(sm_n).unwrap().to_string();\n        strongest_extensions.push((&c_name,\
    \ &extension_name, strength));\n    }\n\n    match strongest_extensions.iter().min_by_key(|(_,\
    \ _, strength)| strength) {\n        Some((c, _, _)) => &class_name + c.to_uppercase()\
    \ + &\"_\".to_lowercase() + &strongest_extensions.iter().filter(|(_, _, strength)|\
    \ strength == 0).min_by_key(|(_, _, strength)| strength).unwrap().0,\n       \
    \ None => \"\".to_string(),\n    }", '    // Your code here', "    let mut max_strength\
    \ = -1i32;\n    let mut max_extension = String::new();\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c == 'A' || c == 'B' || c\
    \ == 'C').count();\n        let sm = extension.chars().filter(|c| c == 'a' ||\
    \ c == 'b' || c == 'c').count();\n        let strength = cap - sm;\n        if\
    \ strength > max_strength {\n            max_strength = strength;\n          \
    \  max_extension = extension;\n        }\n    }\n    class_name.concat(\".\").concat(max_extension)",
  "    let mut extension_strongest: String = &class_name;\n    let mut extension_strength:\
    \ i64 = 1;\n    for extension in extensions {\n        let mut temp_extension_strongest:\
    \ String = extension;\n        let mut temp_extension_strength: i64 = 1;\n   \
    \     for c in temp_extension_strongest {\n            if c >= 'A' && c <= 'Z'\
    \ {\n                temp_extension_strength *= 10;\n                temp_extension_strength\
    \ += c - 'A' + 1;\n            } else {\n                temp_extension_strength\
    \ *= 10;\n                temp_extension_strength += c - 'a' + 1;\n          \
    \  }\n        }\n        if temp_extension_strength > extension_strength {\n \
    \           extension_strongest = temp_extension_strongest;\n            extension_strength\
    \ = temp_extension_strength;\n        }\n    }\n    extension_strongest.to_string()",
  "    if extensions.iter().filter(|&x| x.chars().any(|x| *x == x))\n        .count()\
    \ > 1\n    {\n        let mut min_strength: i32 = i32::MAX;\n        let mut min_extension:\
    \ Vec<&str> = Vec::new();\n        for extension in &extensions {\n          \
    \  let cap = extension.chars().filter(|x| *x == x).count();\n            let sm\
    \ = extension.chars().filter(|x| *x != x).count();\n            let strength =\
    \ cap - sm;\n            if strength < min_strength {\n                min_strength\
    \ = strength;\n                min_extension = vec![&extension];\n           \
    \ }\n            else {\n                if strength == min_strength {\n     \
    \               min_extension.push(&extension);\n                }\n         \
    \   }\n        }\n        // Find the one that comes first in the list.\n    \
    \    let mut min_extension = min_extension\n            .iter()\n            .cloned()\n\
    \            .enumerate()\n            .min_by_key(|i, &x| {\n               \
    \ if *i == 0 {\n                    1\n                } else {\n            \
    \        *i\n                }\n            });\n        let mut strongest_extension\
    \ = String::new();\n        for (i, extension) in min_extension {\n          \
    \  if i == 0 {\n                strongest_extension.push_str(&extension);\n  \
    \          }\n            else {\n                strongest_extension.push_str(&class_name).push_str(&extension);\n\
    \            }\n        }\n        strongest_extension.clone().to_string()\n \
    \   }\n    else {\n        let mut min_strength: i32 = i32::MAX;\n        let\
    \ mut min_extension: Vec<&str> = Vec::new();\n        for extension in &extensions\
    \ {\n            let cap = extension.chars().filter(|x| *x == x).count();\n  \
    \          let sm = extension.chars().filter(|x| *x != x).count();\n         \
    \   let strength = cap - sm;\n            if strength < min_strength {\n     \
    \           min_strength = strength;\n                min_extension = vec![&extension];\n\
    \            }\n            else {\n                if strength == min_strength\
    \ {\n                    min_extension.push(&extension);\n                }\n\
    \            }\n        }\n        let mut min_extension = min_extension\n   \
    \         .iter()\n            .cloned()\n            .enumerate()\n         \
    \   .min_by_key(|i, &x| {\n                if *i == 0 {\n                    1\n\
    \                } else {\n                    *i\n                }\n       \
    \     });\n        let mut strongest_extension = String::new();\n        for (i,\
    \ extension) in min_extension {\n            if i == 0 {\n                strongest_extension.push_str(&extension);\n\
    \            }\n", "    let mut extensions = extensions\n        .iter()\n   \
    \     .filter_map(|e| e.to_lowercase())\n        .collect::<Vec<String>>();\n\
    \    let mut class_name = class_name.to_lowercase();\n\n    let mut num: i64 =\
    \ 0;\n    let mut prev_num: i64 = 0;\n    let mut cur_max: i64 = extensions[0].to_lowercase().chars().count()\
    \ - 1;\n    let mut best_name = \"\";\n    for e in extensions {\n        let\
    \ c = e.to_lowercase().chars().count();\n        if c < cur_max {\n          \
    \  return format!(\"{}\", class_name.to_lowercase());\n        }\n        num\
    \ += c - cur_max;\n        prev_num = cur_max;\n        cur_max = c;\n       \
    \ if num > best_name.chars().count() {\n            best_name = format!(\"{}.{}\"\
    , class_name, e);\n        }\n    }\n    format!(\"{}.{}\", class_name, best_name);",
  "    let mut current_strength = -1;\n\n    for &extension in extensions.iter() {\n\
    \        let strength = extension.chars().filter(|c| c.is_uppercase()).count()\
    \ as usize\n             - extension.chars().filter(|c| c.is_lowercase()).count()\
    \ as usize;\n        if strength > current_strength {\n            current_strength\
    \ = strength;\n        }\n    }\n\n    if current_strength > 0 {\n        format!(\"\
    {}.{}\", class_name, extensions[extensions.iter().filter(|e| e.chars().count()\
    \ == current_strength).next()].to_uppercase())\n    } else {\n        format!(\"\
    {}\", class_name)\n    }", "    // Your code here\n    let mut counter: usize\
    \ = 0;\n    for &e in extensions {\n        counter += e.chars().filter(|c| *c\
    \ >= 'A' && *c <= 'Z').count();\n    }\n\n    if counter > 0 {\n        let cap\
    \ = class_name.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n        let\
    \ sm = class_name.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n      \
    \  let strength = (cap - sm) as usize;\n        let mut pos = 0;\n        let\
    \ mut max_pos = 0;\n        for &e in extensions {\n            pos += e.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n            if pos > strength {\n        \
    \        max_pos = pos;\n            }\n        }\n\n        let mut max_extension\
    \ = &class_name[..max_pos];\n        for &e in extensions {\n            if *e\
    \ >= max_extension {\n                let mut pos = 0;\n                let mut\
    \ max_pos = 0;\n                for &e in extensions {\n                    pos\
    \ += e.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n                 \
    \   if pos > strength {\n                        max_pos = pos;\n            \
    \        }\n                }\n                max_extension = &class_name[..max_pos];\n\
    \            }\n        }\n        return class_name + &max_extension;\n    }\
    \ else {\n        return class_name;\n    }", "    let mut strongest_extension:\
    \ Vec<String> = Vec::new();\n\n    for extension in extensions.iter() {\n    \
    \    let mut fractional_cap = extension.chars().filter(|c| c.is_uppercase()).count()\
    \ - extension.chars().filter(|c| c.is_lowercase()).count();\n        let mut fractional_sm\
    \ = extension.chars().filter(|c| !c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ !c.is_lowercase()).count();\n        let mut strength: usize = 0;\n        if\
    \ fractional_cap > fractional_sm {\n            strength = fractional_cap;\n \
    \       } else {\n            strength = fractional_sm;\n        }\n        strongest_extension.push((extension.clone(),\
    \ strength));\n    }\n\n    let mut min_strength = std::i32::MAX;\n    let mut\
    \ min_extension: Option<String> = None;\n\n    for entry in strongest_extension.iter()\
    \ {\n        if entry.1.unwrap() <= min_strength {\n            min_extension\
    \ = Some(entry.0);\n            min_strength = entry.1.unwrap();\n        }\n\
    \    }\n    min_extension.cloned()", "    let mut class1 = class_name.chars();\n\
    \    let mut class2 = class1.cloned();\n    let mut extension1 = extensions.iter().cloned();\n\
    \    let mut extension2 = extension1.clone();\n    \n    let mut s = String::new();\n\
    \    \n    // Get the number of uppercase letters in class2\n    let cap = class2.count();\n\
    \    \n    // Get the number of lowercase letters in class2\n    let sm = class1.count();\n\
    \    \n    // Calculate the strength of the extension\n    let strength = (cap\
    \ - sm) as i32;\n    \n    \n    // Sort extensions by strength\n    extension1.sort_by_key(|x|\
    \ *x.chars().count());\n    extension2.sort_by_key(|x| *x.chars().count());\n\
    \    \n    // Check if extensions have the same strength\n    let mut same = true;\n\
    \    for (i, v1) in extension1.iter().enumerate() {\n        let mut v2 = extension2[i];\n\
    \        if v1 != v2 {\n            same = false;\n            break;\n      \
    \  }\n    }\n    \n    // If there are two extensions with the same strength choose\
    \ the one that\n    // comes first in the list\n    if same {\n        // Check\
    \ if extension2 has any elements\n        let mut has_elements = false;\n    \
    \    for (i, v) in extension2.iter().enumerate() {\n            has_elements =\
    \ true;\n            break;\n        }\n        if !has_elements {\n         \
    \   return String::from(\"\");\n        }\n        return String::from(&class_name.to_string()\
    \ + &extension2[0]);\n    }\n    \n    // Extensions have different strengths\
    \ so choose the one that comes first\n    for (i, v1) in extension1.iter().enumerate()\
    \ {\n        let mut v2 = extension2[i];\n        if v1 < v2 {\n            return\
    \ String::from(&class_name.to_string() + &v1);\n        }\n    }\n    return String::from(\"\
    \");", "    extensions.iter().fold(class_name, |class_name, extension| {\n   \
    \     // find the extension that has highest strength value\n        let strength\
    \ = extension.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        if strength == 0 {\n            class_name\
    \ + extension\n        } else {\n            class_name + extension.to_uppercase().to_string()\
    \ + extension.chars().filter(|c| c.is_lowercase()).count() + strength.to_string()\n\
    \        }\n    })", "    let mut strongest_extension = String::new();\n    let\
    \ mut letter_counter = vec![String::new(), String::new(), String::new()];\n  \
    \  for extension in extensions {\n        let letter_counter = extension.chars().collect::<Vec<_>>().zip([CAP,\
    \ SM]).collect();\n        let strength = letter_counter.get(0).unwrap() - letter_counter.get(1).unwrap();\n\
    \        strongest_extension.push_str(&format!(\"{}.{}\", class_name, extension));\n\
    \        strongest_extension.push_str(&format!(\"{:?}\", strength));\n       \
    \ strongest_extension.push_str(\",\");\n    }\n    strongest_extension.truncate(format!(\"\
    {}\", strongest_extension.len()).len());\n    strongest_extension.clone_from_slice(strongest_extension.chars().collect::<String>().clone());",
  "    extensions.iter().fold(class_name, |mut cur_class, &mut ext| {\n        let\
    \ num_upper = ext.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ num_lower = ext.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let\
    \ cap = num_upper.max(num_lower);\n        let sm = num_lower.max(num_upper);\n\
    \        let strength = cap - sm;\n        cur_class + \".\" + ext.to_string()\
    \ + &\".\"[strength];\n    });", "    let mut extensions_len = extensions.len();\n\
    \    let mut max_strength = -1;\n    let mut max_extension = String::new();\n\
    \    for &e in extensions {\n        let mut cur_len = e.len();\n        let mut\
    \ cur_max_strength = -1;\n        for i in 0..cur_len {\n            if e.chars().any(|c|c.is_uppercase()\
    \ && i >= cur_len/2) {\n                if cur_max_strength == -1 {\n        \
    \            cur_max_strength = i;\n                } else {\n               \
    \     cur_max_strength = cmp::min(cur_max_strength, i);\n                }\n \
    \           }\n        }\n        if cur_max_strength > max_strength {\n     \
    \       max_strength = cur_max_strength;\n            max_extension = e;\n   \
    \     }\n    }\n    format!(\"{}.{}\", class_name, max_extension)", "    let mut\
    \ strength: i32 = -1;\n    let mut extension: String = String::from(\"\");\n \
    \   for extension in extensions {\n        if extension.chars().filter(|c| c ==\
    \ c.to_ascii_uppercase()).count() > 0 {\n            if strength == -1 {\n   \
    \             strength = extension.chars().filter(|c| c == c.to_ascii_lowercase()).count()\n\
    \            } else {\n                strength = min(strength, extension.chars().filter(|c|\
    \ c == c.to_ascii_lowercase()).count());\n            }\n        }\n    }\n  \
    \  extension.to_lowercase() + class_name.to_lowercase() + extensions[extensions.len()\
    \ - strength].to_lowercase()", "    let mut result = String::new();\n\n    let\
    \ mut cap_len = 0.0;\n    let mut sm_len = 0.0;\n    for e in extensions {\n \
    \       match e.chars().count(|&x| x >= 'A' && x <= 'Z') {\n            1 => cap_len\
    \ += 1.0,\n            2 => cap_len += 0.5,\n            _ => (),\n        }\n\
    \        match e.chars().count(|&x| x >= 'a' && x <= 'z') {\n            1 =>\
    \ sm_len += 1.0,\n            2 => sm_len += 0.5,\n            _ => (),\n    \
    \    }\n    }\n\n    let cap = cap_len as f64 / extensions.len() as f64;\n   \
    \ let sm = sm_len as f64 / extensions.len() as f64;\n    if cap >= sm {\n    \
    \    result.append(&format!(\"{}.{}\", class_name, &extensions[extensions.len()\
    \ - 1]));\n    } else {\n        result.append(&format!(\"{}..{}\", &extensions[0],\
    \ &extensions[extensions.len() - 1]));\n    }\n\n    result", "    debug!(\"Strongest_Extension\
    \ start\");\n    let mut strongest_extension: String = String::from(\"\");\n\n\
    \    for extension in extensions {\n        let mut class_extension: String =\
    \ String::from(\"\");\n        let mut extension_length: usize = 0;\n        let\
    \ mut counter: usize = 0;\n\n        for char in extension.chars() {\n       \
    \     match char {\n                'A' as char => counter += 1,\n           \
    \     'B' as char => counter += 1,\n                'C' as char => counter +=\
    \ 1,\n                'D' as char => counter += 1,\n                'E' as char\
    \ => counter += 1,\n                'F' as char => counter += 1,\n           \
    \     'G' as char => counter += 1,\n                'H' as char => counter +=\
    \ 1,\n                'I' as char => counter += 1,\n                'J' as char\
    \ => counter += 1,\n                'K' as char => counter += 1,\n           \
    \     'L' as char => counter += 1,\n                'M' as char => counter +=\
    \ 1,\n                'N' as char => counter += 1,\n                'O' as char\
    \ => counter += 1,\n                'P' as char => counter += 1,\n           \
    \     'Q' as char => counter += 1,\n                'R' as char => counter +=\
    \ 1,\n                'S' as char => counter += 1,\n                'T' as char\
    \ => counter += 1,\n                'U' as char => counter += 1,\n           \
    \     'V' as char => counter += 1,\n                'W' as char => counter +=\
    \ 1,\n                'X' as char => counter += 1,\n                'Y' as char\
    \ => counter += 1,\n                'Z' as char => counter += 1,\n           \
    \     _ => counter += 1,\n            }\n        }\n\n        match class_name.chars().count(|c|\
    \ *c == char) {\n            1 => strongest_extension += class_name + extension,\n\
    \            _ => class_extension += class_name + extension,\n        }\n\n  \
    \      if class_extension == strongest_extension {\n            strongest_extension\
    \ += extension;\n        }\n    }\n\n    debug!(\"Strongest_Extension end\");\n\
    \    strongest_extension", '    // Your code here', "    let mut total_strength:\
    \ usize = 0;\n    let mut current_class: &'static str = class_name;\n    let mut\
    \ extensions: &'static [String] = extensions.iter().collect::<Vec<_>>();\n   \
    \ for (index, extension) in extensions.iter().enumerate().rev() {\n        let\
    \ (name_char, extension_char) = (extension[0].chars(), extension.chars());\n \
    \       let (name_char_len, extension_char_len) = (name_char.len(), extension_char.len());\n\
    \        let cap_diff = name_char_len - extension_char_len;\n        let strength\
    \ = cap_diff / cap_diff.min(name_char.len(), extension_char.len());\n        total_strength\
    \ += strength;\n        if total_strength > 0 {\n            current_class = class_name\
    \ + &extension[index];\n        }\n    }\n    current_class", "    extensions.iter().fold(class_name,\
    \ |best_str, extension| {\n        let mut best_len = best_str.len();\n      \
    \  for suffix in extensions.iter() {\n            if suffix.len() > best_len {\n\
    \                best_len = suffix.len();\n                best_str = suffix;\n\
    \            }\n        }\n        best_str\n    })", "    // Your code here\n\
    \    let mut min_strength = std::cmp::min(0., extensions.iter().map(|s| s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() - s.chars().filter(|c| c >= 'a' && c <= 'z').count()).sum());\n\
    \    extensions.iter().for_each(|s| {\n        let c = s.chars().filter(|c| c\
    \ >= 'A' && c <= 'Z').count() - s.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        min_strength = std::cmp::min(min_strength, c.floor());\n    });\n   \
    \ let mut best_extension = String::from(\"\");\n    extensions.iter().for_each(|s|\
    \ {\n        let c = s.chars().filter(|c| c >= 'A' && c <= 'Z').count() - s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        if min_strength <= c {\n           \
    \ best_extension = s;\n            min_strength = c;\n        }\n    });\n   \
    \ return class_name + \".\" + best_extension;", "    let extensions = extensions.iter().cloned().collect();\n\
    \    let mut strength = -1;\n    let mut extension: &mut String;\n    for extension\
    \ in extensions {\n        if extension.chars().filter(|c| c.is_ascii_uppercase()).count()\
    \ > strength {\n            strength = extension.chars().filter(|c| c.is_ascii_uppercase()).count();\n\
    \            extension = &mut extensions[extensions.iter().position(|x| x == extension).unwrap()]\n\
    \        };\n    }\n    class_name.to_string() + extension.to_string()", "   \
    \ let mut strongest_extension: String = class_name;\n    for extension in extensions\
    \ {\n        let strength = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count()\
    \ - extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        strongest_extension\
    \ += extension.chars().filter(|c| c >= 'A' && c <= 'Z').count() + extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() as char;\n        if strength != 0 {\n       \
    \     let strength_ratio = (strength / extensions.len()) as char;\n          \
    \  strongest_extension += (strength_ratio as isize);\n        }\n    }\n    strongest_extension.chars().filter(|c|\
    \ *c == 0).count() as char", "    let mut best_extension = String::new();\n  \
    \  let mut best_score = -1;\n    for (i, s) in extensions.iter().enumerate() {\n\
    \        let cap = s.chars().filter(|c| c >= 'A').count();\n        let sm = s.chars().filter(|c|\
    \ c >= 'a').count();\n        let score = cap - sm;\n        if score > best_score\
    \ {\n            best_score = score;\n            best_extension = s;\n      \
    \  }\n    }\n    class_name.to_string() + best_extension.to_string()", "    let\
    \ (class_name, extensions) = str_to_vec((class_name, extensions)).unwrap();\n\
    \    let mut max_strength = -1;\n    let mut best_extension: Option<String> =\
    \ None;\n    for ext in extensions.iter() {\n        let (classname, _) = str_to_vec(ext.clone()).unwrap();\n\
    \        let ext = classname.to_lowercase();\n        let strength = ext.chars().count();\n\
    \        if strength > max_strength {\n            max_strength = strength;\n\
    \            best_extension = Some(ext);\n        }\n    }\n    if let Some(ext)\
    \ = best_extension {\n        format!(\"{}.{}\", class_name, ext)\n    } else\
    \ {\n        format!(\"{}.\", class_name)\n    }", "    let mut counter: u32 =\
    \ 0;\n    let mut max_strongest = String::from(\"\");\n    for ext:String in extensions\
    \ {\n        if ext.chars().map(|c|c).count() > 2 { \n            continue;\n\
    \        }\n        let mut counter = ext.chars().map(|c|c).count();\n       \
    \ counter /= class_name.chars().map(|c|c).count();\n        max_strongest = if\
    \ counter > max_strongest.chars().map(|c|c).count() {\n            max_strongest.push_str(&ext);\n\
    \        }\n    }\n    if max_strongest.is_empty() {\n        max_strongest =\
    \ \"None\";\n    }\n    class_name\n        + &max_strongest\n        .chars()\n\
    \        .map(|c|c)\n        .collect()\n        .join(\".\")", "    let mut class\
    \ = String::from(class_name);\n    let mut max_extension_strength: i32 = -1;\n\
    \    for extension in extensions {\n        let mut s = String::from(extension);\n\
    \        let mut cap: i32 = 0;\n        let mut sm: i32 = 0;\n        for x in\
    \ s.chars() {\n            if x.to_ascii_lowercase() == x {\n                sm++;\n\
    \            } else if x.to_ascii_uppercase() == x {\n                cap++;\n\
    \            }\n        }\n        if cap > sm {\n            cap = cap - sm;\n\
    \        } else {\n            sm = sm - cap;\n        }\n        if cap > max_extension_strength\
    \ {\n            max_extension_strength = cap;\n            class += &s.to_ascii_lowercase();\n\
    \        }\n    }\n    return class + \".\" + max_extension_strength.to_string();",
  "    let mut counter = String::new();\n\n    for extension in extensions {\n   \
    \     let mut counter = String::new();\n\n        for letter in extension {\n\
    \            if letter == letter[0] {\n                counter.push('-');\n  \
    \          } else {\n                counter.push(letter);\n            }\n  \
    \      }\n\n        let strength = counter.chars().count();\n\n        if strength\
    \ > 0 {\n            counter.push_str(&format!(\"{}.{}\", class_name, extension));\n\
    \            break;\n        } else {\n            counter.push_str(&format!(\"\
    {}.{}\", class_name, extension));\n        }\n    }\n\n    match (counter.chars().count(),\
    \ counter) {\n        (_, _) if counter.len() == 2 => format!(\"{}.{}\", class_name,\
    \ counter.clone()),\n        _ => format!(\"{}.{}\", class_name, counter.clone()),\n\
    \    }", "    let mut total_class_length = class_name.chars().count();\n    let\
    \ mut total_extension_length = 0;\n\n    for extension in extensions {\n     \
    \   total_extension_length += extension.chars().count();\n    }\n\n    let (class_strength,\
    \ extension_strength) = if class_name.len() > total_class_length {\n        (class_name.chars().count()\
    \ - total_class_length, 0)\n    } else {\n        (0, extensions.chars().count()\
    \ - total_extension_length)\n    };\n\n    if class_strength < extension_strength\
    \ {\n        let mut class_length = class_name.chars().count();\n        let mut\
    \ extension_length = 0;\n        let mut index = 0;\n\n        while index < class_length\
    \ {\n            let c = class_name[index];\n            if !c.is_uppercase()\
    \ {\n                class_length -= 1;\n            } else {\n              \
    \  extension_length += 1;\n            }\n            index +=1;\n        }\n\n\
    \        (class_strength, extension_length / class_length)\n    } else {\n   \
    \     (extension_strength, extension_length)\n    }", "    debugln!(\"{} -> {}\"\
    , class_name, extensions.iter().map(|x| x.to_ascii_lowercase()).collect::<Vec<_>>());\n\
    \    let mut max_strength = -1;\n    let mut best_extension = String::new();\n\
    \    for extension in extensions {\n        let sb = String::from(\"{}.{}\", class_name,\
    \ extension);\n        let sc = String::from_utf8(sb);\n        if sc.contains(&class_name.to_ascii_lowercase())\
    \ {\n            if let Ok(strength) = Extension::strength_from_name(extension)\
    \ {\n                if strength > max_strength {\n                    best_extension\
    \ = sb;\n                    max_strength = strength;\n                }\n   \
    \         }\n        }\n    }\n    debugln!(\"{} -> {}\", class_name, best_extension);\n\
    \    \n    if max_strength == -1 {\n        return class_name;\n    }\n    \n\
    \    best_extension", "    if extensions.is_empty() {\n        return class_name;\n\
    \    }\n\n    let mut best_strength = -1;\n    let mut best_extension = String::new();\n\
    \n    for extension in extensions {\n        let count = extension.chars().filter(|c|\
    \ c.is_upper()).count();\n        let count_lower_case = extension.chars().filter(|c|\
    \ c.is_lower()).count();\n\n        let strength = count - count_lower_case;\n\
    \n        if strength > best_strength {\n            best_extension = extension;\n\
    \            best_strength = strength;\n        }\n    }\n\n    format!(\"{}{}.{}\"\
    , class_name, best_extension, best_strength)", "    let mut extensions_map = HashMap::new();\n\
    \    \n    for (i, ext) in extensions.iter().enumerate() {\n        let mut ext\
    \ = ext.to_lowercase();\n        if i > 0 {\n            if ext.chars().any(|c|\
    \ c != ext.chars().nth(i).unwrap()) {\n                ext.push((ext.chars().nth(i).unwrap()\
    \ + ext.chars().nth(i - 1).unwrap()) as u8);\n                ext.pop();\n   \
    \         }\n        }\n        extensions_map.insert(ext, i as usize);\n    }\n\
    \    \n    let strength = extensions_map.values().iter().fold(0, |acc, x| acc\
    \ + (x.0.to_lowercase().chars().count() - x.1.to_lowercase().chars().count()));\n\
    \    \n    let mut ret = \"\";\n    \n    for (i_str, i) in extensions_map.iter().enumerate()\
    \ {\n        let mut ext = \"\";\n        for (j, c) in i_str.chars().enumerate()\
    \ {\n            if i == j {\n                ext.push(c);\n            } else\
    \ {\n                ext.push(c);\n            }\n        }\n        ret += class_name\
    \ + \".\" + ext.to_string();\n    }\n    \n    let mut max_strength = extensions_map.iter().map(|x|\
    \ x.1).max().unwrap();\n    for i_ret in ret.split('.').skip(1).filter(|x| !x.is_empty())\
    \ {\n        if ret[i_ret].chars().count() > max_strength {\n            max_strength\
    \ = ret[i_ret].chars().count();\n        }\n    }\n    \n    ret + \".\" + max_strength.to_string()",
  "    let mut classes: Vec<String> = extensions.iter().cloned().collect();\n    classes.sort();\n\
    \    let mut highest_strength = -1;\n    let mut current_strength = 0;\n    for\
    \ &x in classes {\n        if x.len() < class_name.len() {\n            continue;\n\
    \        }\n        let strength = x.len().chars().map(|c| *c).filter(|c| *c >=\
    \ 'A' && *c <= 'Z').count() - x.len().chars().map(|c| *c).filter(|c| *c >= 'a'\
    \ && *c <= 'z').count();\n        if strength > current_strength {\n         \
    \   current_strength = strength;\n            highest_strength = current_strength;\n\
    \        }\n    }\n    format!(\"{}{}\", class_name, highest_strength)", "   \
    \ \n    let mut strength: i32 = 0;\n    let mut cur_extension: Option<String>\
    \ = None;\n    for e in extensions {\n        let letters = e.chars().filter(|c|\
    \ !c.is_lowercase()).count();\n        strength = (letters as f64 - cur_extension.unwrap().chars().filter(|c|\
    \ c.is_lowercase()).count()) / letters as i32;\n        if strength > 0 {\n  \
    \          cur_extension = Some(e);\n        }\n    }\n    cur_extension.take().unwrap()\
    \ + &class_name + &extensions[extensions.len() - 1];", "  assert!(extensions.iter().all(|&e|\
    \ e.chars().all(|c| ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))), \"Invalid\
    \ class name\");\n  assert!(extensions.iter().all(|&e| e.chars().all(|c| ('0'\
    \ <= c && c <= '9'))), \"Invalid class name\");\n\n  let mut min_strength: i64\
    \ = std::cmp::Ordering::Less::default();\n  let mut strength: i64 = 0;\n\n  for\
    \ ext in extensions {\n    let mut c = ext.chars().map(|c| if ('A' <= c && c <=\
    \ 'Z') then c - 'A' else c - 'a').collect::<Vec<u8>>();\n    if c.len() == 1 {\n\
    \      c = c.iter().cloned().collect::<Vec<u8>>();\n    }\n    for c in c {\n\
    \      strength += (c.to_digit(16) - c.to_digit(10));\n      if strength > min_strength\
    \ {\n        min_strength = strength;\n      }\n    }\n  }\n\n  format!(\"{}.{}\"\
    , class_name, min_strength)", "    let mut counter: u32 = class_name.to_ascii_uppercase().chars().count();\n\
    \    for extension in extensions {\n        if extension.chars().count() > counter\
    \ {\n            counter = extension.chars().count();\n        }\n    }\n    let\
    \ strength = (-counter).saturating_add(1);\n    \"{}.{}\".to_string(&class_name).format(class_name,\
    \ extensions[0][strength..]);", "    extensions.iter().\n        filter_map(|&s|\
    \ s.chars().count(|c| c.is_uppercase() / c.is_lowercase())).\n        max(|a,\
    \ b| a.cmp(b)).\n        cloned()\n        .unwrap_or(String::new())", "    //\
    \ Your code here\n    \n    let mut min_strength = extensions[0][..].chars().filter(|x|x.is_uppercase()).count()\
    \ - extensions[0][..].chars().filter(|x|x.is_lowercase()).count();\n    let mut\
    \ max_strength = extensions[0][..].chars().filter(|x|x.is_lowercase()).count()\
    \ - extensions[0][..].chars().filter(|x|x.is_uppercase()).count();\n    let mut\
    \ max_strength_extension = extensions[0];\n    for ext in extensions.iter() {\n\
    \        let num_upper = ext[..].chars().filter(|x|x.is_uppercase()).count();\n\
    \        let num_lower = ext[..].chars().filter(|x|x.is_lowercase()).count();\n\
    \        let strength = num_upper - num_lower;\n        if strength < min_strength\
    \ {\n            min_strength = strength;\n            max_strength_extension\
    \ = ext;\n        }\n        if strength > max_strength {\n            max_strength\
    \ = strength;\n        }\n    }\n    \n    \"{}.{}\".format(class_name, max_strength_extension);",
  "    let mut min: i32 = -1;\n    let mut strongest: Option<String> = None;\n   \
    \ for extension in extensions {\n        let cap = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let strength = cap - sm;\n        if\
    \ min == -1 || strength > min {\n            min = strength;\n            strongest\
    \ = Some(extension.clone());\n        }\n    }\n    let new_str = strongest.unwrap_or(class_name.clone());\n\
    \    new_str.push_str(min);\n    new_str"]
stop_tokens:
- "\n}"
