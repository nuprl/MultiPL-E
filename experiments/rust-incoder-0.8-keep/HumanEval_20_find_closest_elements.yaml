name: HumanEval_20_find_closest_elements
language: rust
prompt: "/// From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n/// other and return them in order (smaller\
  \ number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64)\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
  \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
  \ (2.2, 3.1));\n}\n"
completions: ["    let mut closest_val = numbers[0];\n    let mut closest_dist = std::f64::MAX;\n\
    \n    for &number in &numbers[1..] {\n        let dist = number.abs() - closest_val.abs();\n\
    \        if dist < closest_dist {\n            closest_dist = dist;\n        \
    \    closest_val = number;\n        }\n    }\n\n    (closest_val, closest_dist)",
  "    let mut smallest_difference = std::f64::MAX;\n    let mut largest_difference\
    \ = std::f64::MIN;\n    for (index, &number) in numbers.iter().enumerate() {\n\
    \        let difference = number - numbers[index];\n        if smallest_difference\
    \ > difference {\n            smallest_difference = difference;\n        }\n \
    \       if largest_difference < difference {\n            largest_difference =\
    \ difference;\n        }\n    }\n    (numbers[numbers.iter().enumerate().find(|(_,\
    \ v)| v == smallest_difference).unwrap().1],\n     numbers[numbers.iter().enumerate().find(|(_,\
    \ v)| v == largest_difference).unwrap().1])", "    numbers.sort_by(|a, b| a.abs()\
    \ as i64);\n\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] - smallest > largest -\
    \ numbers[i] {\n            smallest = numbers[i];\n        } else {\n       \
    \     largest = numbers[i];\n        }\n    }\n\n    (smallest, largest)", " \
    \   if numbers.len() < 2 {\n        return numbers[0], numbers[0];\n    }\n\n\
    \    // sort numbers in reverse order\n    numbers.sort_unstable_by_key(|num|\
    \ num.clone());\n\n    // find two closest numbers\n    let mut lower = numbers[0]\
    \ as f64;\n    let mut upper = numbers[0] as f64;\n    for num in numbers.iter_mut()\
    \ {\n        if num > upper {\n            upper = num;\n        }\n\n       \
    \ if num < lower {\n            lower = num;\n        }\n    }\n\n    return (lower,\
    \ upper);", "    if numbers.is_empty() {\n        return (0.0, 0.0);\n    }\n\n\
    \    let mut min1 = numbers[0].min(numbers[1]);\n    let mut min2 = numbers[0].min(numbers[1]);\n\
    \n    for i in 0..numbers.len() - 1 {\n        let mut min3 = numbers[i].min(numbers[i\
    \ + 1]);\n        let mut min4 = numbers[i].min(numbers[i + 1]);\n\n        if\
    \ min1 < min2 {\n            min1 = min3;\n        } else {\n            min2\
    \ = min4;\n        }\n    }\n\n    (min1, min2)", "    let mut min_dist = std::f64::MAX;\n\
    \    let mut min_val = numbers[0];\n\n    for (i, v) in numbers.iter().enumerate()\
    \ {\n        let dist = std::f64::abs(v - min_val);\n        if dist < min_dist\
    \ {\n            min_dist = dist;\n            min_val = v;\n        }\n    }\n\
    \n    (min_val, min_dist)", "    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for n in numbers {\n        if n < smallest {\n         \
    \   smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)", "    let mut min1: f64;\n  \
    \  let mut min2: f64;\n    let mut min: Vec<f64> = Vec::new();\n    let mut max:\
    \ Vec<f64> = Vec::new();\n\n    for i in numbers.iter() {\n        let mut index\
    \ = Vec::new();\n        let mut min_diff = ::std::f64::MAX;\n\n        for j\
    \ in 0..(numbers.len() - 1) {\n            if numbers[j] > i {\n             \
    \   break;\n            }\n\n            let diff = (numbers[j] - i).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        index = (j + 0, j + 1);\n            }\n        }\n\n        if index\
    \ != (Vec::new(), Vec::new()) {\n            min1 = numbers[index[0]];\n     \
    \       min2 = numbers[index[1]];\n            min.push(min1);\n            max.push(min2);\n\
    \        } else {\n            min1 = i;\n            min2.push(min1);\n     \
    \       min.push(min2);\n        }\n    }\n\n    (min.iter().min_by_key(|x| x).unwrap(),\
    \ max.iter().min_by_key(|x| x).unwrap())", "    let mut min_distance = f64::MAX;\n\
    \    let mut min_distance = Vec::new();\n    for i in 0..numbers.len() {\n   \
    \     let mut max_distance = f64::MAX;\n        let mut max_distance = Vec::new();\n\
    \        let mut min_distance = Vec::new();\n        // iterate through all the\
    \ elements and find the max and min distance\n        for j in 0..numbers.len()\
    \ {\n            let distance = numbers[i] - numbers[j];\n            if distance\
    \ > max_distance {\n                max_distance = distance;\n            } else\
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \         }\n        }\n        min_distance.push(min_distance);\n        min_distance.push(max_distance);\n\
    \    }\n    min_distance.sort_unstable();\n    (min_distance[0], min_distance[1])",
  "    let mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n\n    for &n\
    \ in numbers {\n        min = std::min(n,\n                      min);\n     \
    \   max = std::max(n,\n                      max);\n    }\n    (min, max)", " \
    \   let mut min_distance = std::f64::MAX;\n    let mut min_number = std::f64::MAX;\n\
    \n    for (i, number) in numbers.iter().enumerate() {\n        if number < min_number\
    \ {\n            min_number = number;\n            min_distance = i;\n       \
    \ }\n    }\n\n    let mut max_number = numbers[min_distance];\n    let mut max_distance\
    \ = min_distance;\n\n    for number in numbers.iter().skip(min_distance + 1) {\n\
    \        if number > max_number {\n            max_number = number;\n        \
    \    max_distance = i;\n        }\n    }\n\n    (min_number, max_number)", " \
    \   let mut smallest = std::f64::MAX;\n    let mut largest = -std::f64::MAX;\n\
    \    for n in numbers {\n        let n = *n;\n        if n < smallest {\n    \
    \        smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    (smallest, largest)", "    let mut smallest: Vec<f64>\
    \ = Vec::new();\n    let mut largest: Vec<f64> = Vec::new();\n\n    for number\
    \ in numbers {\n        if number < numbers[0] {\n            smallest.push(number);\n\
    \        } else {\n            largest.push(number);\n        }\n    }\n\n   \
    \ (smallest[0], largest[0])", "    let mut smallest_difference = numbers[0];\n\
    \    let mut smallest_number = numbers[0];\n    let mut largest_difference = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for i in 1..numbers.len() {\n \
    \       let difference = numbers[i] - numbers[i - 1];\n        if difference <\
    \ smallest_difference {\n            smallest_difference = difference;\n     \
    \       smallest_number = numbers[i];\n        }\n        if difference > largest_difference\
    \ {\n            largest_difference = difference;\n            largest_number\
    \ = numbers[i];\n        }\n    }\n    (smallest_number, largest_number)", " \
    \   let min = numbers[0].cloned();\n    let max = numbers[0].cloned();\n    for\
    \ &x in numbers {\n        let delta = x - min;\n        if delta < 0 {\n    \
    \        min = x;\n        } else {\n            max = x;\n        }\n    }\n\n\
    \    (min, max)", "    assert!(numbers.len() >= 2);\n    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for &n in numbers {\n        if min > n {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    (min, max)", "    if numbers.len() < 2 {\n        (0.0,\
    \ numbers[0])\n    } else {\n        let mut smallest_diff: f64 = numbers[0] as\
    \ f64;\n        let mut second_closest: f64 = numbers[1] as f64;\n        for\
    \ n in numbers[2..] {\n            let new_diff = smallest_diff - n;\n       \
    \     if new_diff < 0 {\n                smallest_diff = -new_diff;\n        \
    \        second_closest = n;\n            } else {\n                smallest_diff\
    \ = new_diff;\n            }\n        }\n        (second_closest, smallest_diff)\n\
    \    }", "    let mut minimum = numbers[0];\n    let mut maximum = numbers[0];\n\
    \n    for n in numbers {\n        if n < minimum {\n            minimum = n;\n\
    \        }\n        if n > maximum {\n            maximum = n;\n        }\n  \
    \  }\n\n    (minimum, maximum)", "    let mut closest_element = numbers[0];\n\
    \    let mut furthest_element = numbers[0];\n\n    for &x in numbers {\n     \
    \   if f64::abs(x - closest_element) < f64::abs(x - furthest_element) {\n    \
    \        closest_element = x\n        } else {\n            furthest_element =\
    \ x\n        }\n    }\n\n    (closest_element, furthest_element)", "    if numbers.len()\
    \ < 2 {\n        return (0, numbers[0]);\n    }\n    let mut min_dist = ::std::f64::MAX;\n\
    \    let mut best_value = numbers[0];\n    let mut best_idx = 1;\n    for i in\
    \ 2..=numbers.len() {\n        let dist = ::std::f64::MAX;\n        for (j, value)\
    \ in numbers.iter().enumerate() {\n            if i == j {\n                continue;\n\
    \            }\n            let dist = dist::abs(value - numbers[j]);\n      \
    \      if dist < min_dist {\n                min_dist = dist;\n              \
    \  best_value = value;\n                best_idx = j;\n            }\n       \
    \ }\n        (best_value, best_idx)\n    }\n    (best_value, best_idx)", "   \
    \ let mut current = numbers[0];\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers.iter().skip(1) {\n        current\
    \ = n;\n        if current < smallest {\n            smallest = current;\n   \
    \     }\n        if current > largest {\n            largest = current;\n    \
    \    }\n    }\n    (smallest, largest)", "    let mut min = std::f64::MAX;\n \
    \   let mut max = std::f64::MIN;\n\n    for &num in numbers {\n        if num\
    \ < min {\n            min = num;\n        }\n        if num > max {\n       \
    \     max = num;\n        }\n    }\n\n    (min, max)", "    let mut lowest = numbers[0].0\
    \ * numbers[0];\n    let mut highest = numbers[0].0 * numbers[0];\n    for number\
    \ in numbers.iter() {\n        if number > highest {\n            highest = number;\n\
    \        }\n        if number < lowest {\n            lowest = number;\n     \
    \   }\n    }\n    (lowest, highest)", "    let mut best = Vec::new();\n    best\
    \ = numbers.iter().fold(best.clone(), |mut b, x| {\n        if b < x {\n     \
    \       b = x;\n        }\n        b\n    });\n    best = numbers.iter().fold(best.clone(),\
    \ |mut b, x| {\n        if b > x {\n            b = x;\n        }\n        b\n\
    \    });\n    (best.0, best.1)", "    let mut min_dist = numbers[0];\n    let\
    \ mut min_element = numbers[0];\n    let mut min_distance = numbers[0]\n     \
    \   .sqrt()\n        .floor()\n        .unwrap();\n    let mut max_element = numbers[0];\n\
    \    let mut max_distance = numbers[0]\n        .sqrt()\n        .floor()\n  \
    \      .unwrap();\n\n    for n in numbers {\n        if n != min_element {\n \
    \           let distance = n.sqrt() - min_distance;\n            if distance <\
    \ min_distance {\n                min_distance = distance;\n                min_element\
    \ = n;\n            }\n        }\n    }\n    for n in numbers {\n        if n\
    \ != max_element {\n            let distance = n.sqrt() - max_distance;\n    \
    \        if distance > max_distance {\n                max_distance = distance;\n\
    \                max_element = n;\n            }\n        }\n    }\n    (min_element,\
    \ max_element)", "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut diff\
    \ = max - min;\n    if diff < .01 * min {\n        (min, max)\n    } else {\n\
    \        let mut midx = (min + max) / 2;\n        let midy = (min + max) / 2;\n\
    \        for n in numbers {\n            if n < midx {\n                midx =\
    \ n;\n            }\n            if n > midy {\n                midy = n;\n  \
    \          }\n        }\n        (midx, midy)\n    }", "    numbers.sort();\n\
    \    let mut smallest_number = numbers[0];\n    let mut greatest_number = numbers[0];\n\
    \n    for i in 1 .. numbers.len() {\n        if numbers[i] < smallest_number {\n\
    \            smallest_number = numbers[i];\n        }\n        if numbers[i] >\
    \ greatest_number {\n            greatest_number = numbers[i];\n        }\n  \
    \  }\n\n    (smallest_number, greatest_number)", "    match numbers[..] {\n  \
    \      vec![number, number] => {\n            if number - numbers[2] < number\
    \ - numbers[3] {\n                (numbers[2], numbers[3])\n            } else\
    \ {\n                (numbers[3], numbers[2])\n            }\n        }\n    \
    \    vec![number, number, number] => {\n            if number - numbers[1] < number\
    \ - numbers[3] {\n                (numbers[1], numbers[3])\n            } else\
    \ {\n                (numbers[3], numbers[1])\n            }\n        }\n    \
    \    vec![number, number, number, number] => {\n            if number - numbers[2]\
    \ < number - numbers[1] {\n                (numbers[2], numbers[1])\n        \
    \    } else {\n                (numbers[1], numbers[2])\n            }\n     \
    \   }\n        vec![number, number, number, number, number] => {\n           \
    \ if number - numbers[3] < number - numbers[2] {\n                (numbers[3],\
    \ numbers[2])\n            } else {\n                (numbers[2], numbers[3])\n\
    \            }\n        }\n        vec![number, number, number, number, number,\
    \ number] => {\n            if number - numbers[4] < number - numbers[3] {\n \
    \               (numbers[4], numbers[3])\n            } else {\n             \
    \   (numbers[3], numbers[4])\n            }\n        }\n        vec![number, number,\
    \ number, number, number, number, number] => {\n            if number - numbers[5]\
    \ < number - numbers[4] {\n                (numbers[5], numbers[4])\n        \
    \    } else {\n                (numbers[4], numbers[5])\n            }\n     \
    \   }\n        vec![number, number, number, number, number, number, number, number]\
    \ => {\n            if number - numbers[6] < number - numbers[5] {\n         \
    \       (numbers[6], numbers[5])\n            } else {\n                (numbers[5],\
    \ numbers[6])\n            }\n        }\n        vec![number, number, number,\
    \ number, number, number, number, number, number] => {\n            if number\
    \ - numbers[7] < number - numbers[6] {\n                (numbers[7], numbers[6])\n\
    \            } else {\n                (numbers[6], numbers[7])\n            }\n\
    \        }\n        _ => {\n            (numbers[3], numbers[3])\n        }\n\
    \    }", "    let numbers = numbers[..2];\n    let mut min_dist = std::f64::MAX;\n\
    \    let mut min_element;\n    for i in 0..numbers.len() {\n        let current_dist\
    \ = f64::abs(numbers[i] - numbers[i - 1]);\n        if current_dist < min_dist\
    \ {\n            min_dist = current_dist;\n            min_element = i;\n    \
    \    }\n    }\n    (numbers[min_element as usize], numbers[min_element + 1] as\
    \ f64)", "    let mut small = numbers[0];\n    let mut large = numbers[0];\n \
    \   for (i, num) in numbers.iter().enumerate() {\n        if num < small {\n \
    \           small = num;\n        }\n        if num > large {\n            large\
    \ = num;\n        }\n    }\n\n    small, large", "    numbers.sort_unstable_by_key(|n|\
    \ n.abs());\n    let mut lower = numbers[..2].iter().min().unwrap();\n    let\
    \ mut upper = numbers[2..4].iter().max().unwrap();\n    lower.min(upper)", " \
    \   if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n    }\n\n\
    \    let mut min_diff = numbers[0] - numbers[1];\n    let mut min_diff = numbers[0]\
    \ - numbers[1];\n    let mut min_diff = numbers[0] - numbers[1];\n\n    let mut\
    \ min_pos = 0;\n    let mut min_pos = 0;\n\n    let mut min_pos = 1;\n    let\
    \ mut min_pos = 1;\n\n    for i in 2..numbers.len() {\n        let diff = numbers[i]\
    \ - numbers[i - 1];\n\n        if diff < min_diff {\n            min_diff = diff;\n\
    \            min_pos = i - 1;\n        }\n\n        if diff < min_diff {\n   \
    \         min_diff = diff;\n            min_pos = i - 1;\n        }\n    }\n\n\
    \    (numbers[min_pos], numbers[min_pos])", "    numbers.sort();\n    let mut\
    \ min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers.iter()\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    (min, max)", "    let mut smallest\
    \ = numbers[0];\n    let mut biggest = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < smallest {\n            smallest = numbers[i];\n\
    \        }\n        if numbers[i] > biggest {\n            biggest = numbers[i];\n\
    \        }\n    }\n    (smallest, biggest)", "    let mut smallest: Option<f64>\
    \ = None;\n    let mut largest: Option<f64> = None;\n    for n in numbers {\n\
    \        let diff = n - numbers.iter().skip(1).fold(f64::max, |max, &x| max);\n\
    \        if smallest == None || (diff < smallest.unwrap()) {\n            smallest\
    \ = Some(diff);\n        }\n        if largest == None || (diff > largest.unwrap())\
    \ {\n            largest = Some(diff);\n        }\n    }\n    (smallest.unwrap(),\
    \ largest.unwrap())", "    let mut min = numbers[0].clone(); // the number with\
    \ minimal absolute value\n    let mut max = numbers[0].clone(); // the number\
    \ with maximal absolute value\n    for (idx, number) in\n        numbers.iter().enumerate()\
    \ { // iterate over numbers\n            if *number < min { min = *number; }\n\
    \            if *number > max { max = *number; }\n        }\n    (min, max)",
  "    let mut smallest = (numbers[0] as f64).min(numbers[1] as f64);\n    let mut\
    \ largest = (numbers[0] as f64).max(numbers[1] as f64);\n\n    for n in numbers[2..].iter()\
    \ {\n        let diff = (n - smallest).abs();\n        if diff < smallest {\n\
    \            smallest = n;\n        }\n        if diff > largest {\n         \
    \   largest = n;\n        }\n    }\n    (smallest, largest)", "    let mut min_diff:\
    \ f64 = numbers[0];\n    let mut min_number: f64 = numbers[0];\n\n    for (i,\
    \ &number) in numbers.iter().enumerate() {\n        let diff = number.abs() -\
    \ min_diff.abs();\n        if diff < min_diff {\n            min_diff = diff;\n\
    \            min_number = number;\n        }\n    }\n    min_number, min_diff",
  "    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    let mut\
    \ min_idx = numbers[0];\n    let mut max_idx = numbers[0];\n\n    for n in numbers.iter()\
    \ {\n        if n < min_val {\n            min_val = n;\n            min_idx =\
    \ n;\n        } else if n > max_val {\n            max_val = n;\n            max_idx\
    \ = n;\n        }\n    }\n\n    (min_val, max_idx)", "    let mut min = std::i32::MAX;\n\
    \    let mut max = std::i32::MIN;\n    for &i in numbers {\n        let delta\
    \ = i - min;\n        if delta < 0 {\n            max = i;\n        } else {\n\
    \            min = i;\n        }\n    }\n\n    (min, max)", "    let mut max_number\
    \ = 0.0f64;\n    let mut min_number = 0.0f64;\n    let mut min_distance = std::f64::MAX;\n\
    \    for (index, number) in numbers.iter().enumerate() {\n        let distance\
    \ = std::f64::MAX;\n        for element in &numbers[index..] {\n            let\
    \ distance = match element - number {\n                n if n < min_number =>\
    \ std::f64::MAX,\n                n if n > max_number => std::f64::MAX,\n    \
    \            n => std::f64::MAX,\n            };\n            if distance < distance\
    \ {\n                min_number = number;\n                min_distance = distance;\n\
    \            }\n        }\n        max_number = number;\n    }\n    (min_number,\
    \ max_number)", "    // Convert to a map and sort by the distance to the second\
    \ element\n    let mut sorted_map = numbers;\n    sorted_map.sort_by_key(|x| x.abs());\n\
    \n    // Return the second\n    (sorted_map[1], sorted_map.last())", "    let\
    \ mut min: f64 = numbers[0] as f64;\n    let mut max: f64 = numbers[0] as f64;\n\
    \    for (i, number) in numbers.iter().enumerate() {\n        let delta = number.abs()\
    \ as f64;\n        if delta < min {\n            min = delta;\n        }\n   \
    \     if delta > max {\n            max = delta;\n        }\n    }\n\n    let\
    \ mut i = 0;\n    let mut j = numbers.len();\n    while i <= j {\n        let\
    \ mut delta = numbers[i - 1].abs() as f64;\n        if delta < numbers[i].abs()\
    \ {\n            delta = numbers[i].abs() as f64;\n        }\n        if delta\
    \ < min {\n            min = delta;\n        }\n        if delta > max {\n   \
    \         max = delta;\n        }\n        let mut swap = numbers[i - 1];\n  \
    \      numbers[i - 1] = numbers[i];\n        numbers[i] = swap;\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    (min, max)", "    let mut min_val = f64::MAX;\n\
    \    let mut max_val = f64::MIN;\n\n    for number in numbers {\n        if number\
    \ < min_val {\n            min_val = number;\n        }\n\n        if number >\
    \ max_val {\n            max_val = number;\n        }\n    }\n\n    (min_val,\
    \ max_val)", "    let mut lowest_element = numbers.iter().min().unwrap();\n  \
    \  let mut second_lowest_element = numbers.iter().min().unwrap();\n    let mut\
    \ closest_elements = Vec::new();\n\n    for (index, number) in numbers.iter().enumerate()\
    \ {\n        if number == lowest_element {\n            closest_elements.push(number);\n\
    \        }\n        if number == second_lowest_element {\n            closest_elements.push(number);\n\
    \        }\n        if index < numbers.len() - 1 {\n            if number > lowest_element\
    \ {\n                second_lowest_element = number;\n            }\n        \
    \    if number < second_lowest_element {\n                lowest_element = number;\n\
    \            }\n        }\n    }\n    (lowest_element, second_lowest_element)",
  "    match numbers.len() {\n        0 => return(f64::INFINITY, f64::INFINITY),\n\
    \        _ => {\n            let mut lowest = numbers[0];\n            let mut\
    \ highest = numbers[0];\n            for n in numbers {\n                if n\
    \ < lowest {\n                    lowest = n;\n                } else if n > highest\
    \ {\n                    highest = n;\n                }\n            }\n    \
    \        (lowest, highest)\n        }\n    }", "    if numbers.len() < 2 {\n \
    \       return (numbers[0], numbers[0]);\n    }\n\n    let mut lowest = numbers[0];\n\
    \    let mut highest = numbers[0];\n    let mut current_index = 0;\n    let mut\
    \ current_delta = 0;\n    for i in 0..numbers.len() - 1 {\n        let number\
    \ = numbers[i];\n        let delta = number - lowest;\n        if current_delta\
    \ == 0 || delta < current_delta {\n            lowest = number;\n            current_index\
    \ = i;\n            current_delta = delta;\n        }\n        let delta = number\
    \ - highest;\n        if delta > current_delta {\n            highest = number;\n\
    \            current_index = i;\n            current_delta = delta;\n        }\n\
    \    }\n\n    (lowest, highest)", "    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[1])\n    } else {\n        let mut min1 = numbers[0];\n        let mut\
    \ min2 = numbers[1];\n\n        for n in numbers.iter().skip(2) {\n          \
    \  let mut diff = f64::MAX;\n            for m in numbers.iter().skip(2) {\n \
    \               diff = f64::min(diff, f64::abs(n - m));\n            }\n     \
    \       min1 = min(min1, diff);\n            min2 = min(min2, diff);\n       \
    \ }\n        (min1, min2)\n    }", "    let mut smallest_dist = std::f64::MAX;\n\
    \    let mut closest_to_smallest = std::f64::MAX;\n    for &n in numbers {\n \
    \       let dist = n - closest_to_smallest;\n        if dist < smallest_dist {\n\
    \            smallest_dist = dist;\n            closest_to_smallest = n;\n   \
    \     }\n    }\n    (closest_to_smallest, smallest_dist)", "    assert!(numbers.len()\
    \ >= 2);\n\n    // Convert to a sorted vector so we don't have to check all the\
    \ numbers every time.\n    let mut sorted_numbers = numbers.iter().cloned().collect::<Vec<_>>().sort();\n\
    \n    let min_diff = sorted_numbers[0] - sorted_numbers[1];\n    let mut smallest\
    \ = sorted_numbers[1];\n    let mut largest = sorted_numbers[0];\n\n    for number\
    \ in sorted_numbers.iter().skip(1).rev() {\n        if number - largest < smallest\
    \ - number {\n            smallest = number;\n        }\n\n        if largest\
    \ - number < smallest - number {\n            largest = number;\n        }\n \
    \   }\n\n    (smallest, largest)", "    assert!(numbers.len() >= 2);\n\n    let\
    \ mut smallest_diff: f64 = numbers[0].abs();\n    let mut largest_diff: f64 =\
    \ numbers[0].abs();\n\n    let mut smallest: f64 = numbers[0];\n    let mut largest:\
    \ f64 = numbers[0];\n\n    for x in numbers {\n        smallest_diff = if x <\
    \ smallest {\n            smallest\n        } else {\n            smallest_diff\n\
    \        };\n\n        largest_diff = if x > largest {\n            largest_diff\n\
    \        } else {\n            largest_diff\n        };\n\n        smallest =\
    \ if x < smallest {\n            x\n        } else {\n            smallest\n \
    \       };\n\n        largest = if x > largest {\n            x\n        } else\
    \ {\n            largest\n        };\n    }\n\n    (smallest, largest)", "   \
    \ numbers[2..].iter().zip(numbers[0..].iter()).enumerate().min(|a, b| {\n    \
    \    (a.1 - b.1).abs()\n    })", "    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[0])\n    } else {\n        let mut min_distance = numbers[0];\n    \
    \    let mut min_value = numbers[0];\n        let mut max_value = numbers[0];\n\
    \n        for n in numbers {\n            let distance = std::f64::abs(n - min_value);\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                min_value = n;\n            } else {\n                max_value\
    \ = n;\n            }\n        }\n\n        (min_value, max_value)\n    }", " \
    \   let mut min = numbers[0]\n    let mut max = numbers[0]\n    for n in numbers\
    \ {\n        if n < min {\n            min = n\n        }\n        if n > max\
    \ {\n            max = n\n        }\n    }\n    (min, max)", "    let mut min_distance\
    \ = 1.0;\n    let mut min_element = numbers[0];\n    let mut max_element = numbers[0];\n\
    \    for i in numbers.iter() {\n        let distance = std::f64::abs(i - min_element);\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_element = i;\n        }\n        if i > max_element {\n     \
    \       max_element = i;\n        }\n    }\n    (min_element, max_element)", " \
    \   assert!(numbers.size() > 2);\n    let mut min_diff = f64::MAX;\n    let mut\
    \ min_diff = numbers[0] - numbers[1];\n    let mut min_element1 = numbers[0];\n\
    \    let mut min_element2 = numbers[0];\n    let mut min_elements = Vec::new();\n\
    \    for num in numbers.iter().skip(1) {\n        let diff = num - min_element1;\n\
    \        if diff < min_diff {\n            min_diff = diff;\n            min_element1\
    \ = num;\n        }\n        let diff = num - min_element2;\n        if diff <\
    \ min_diff {\n            min_diff = diff;\n            min_element2 = num;\n\
    \        }\n    }\n    min_elements.push(min_element1);\n    min_elements.push(min_element2);\n\
    \    min_elements", "    let mut closest_one = numbers[0];\n    let mut closest_two\
    \ = numbers[0];\n\n    for i in 1..numbers.len() {\n        let two = numbers[i];\n\
    \n        if two > closest_two {\n            closest_two = two;\n        }\n\n\
    \        if closest_two < two {\n            closest_one = two;\n        }\n\n\
    \        if closest_one < two {\n            closest_two = two;\n        }\n \
    \   }\n\n    (closest_one, closest_two)", "    let mut min = numbers[0];\n   \
    \ let mut max = numbers[0];\n\n    for i in 1..numbers.len() {\n        let a\
    \ = numbers[i];\n        if a < min {\n            min = a;\n        }\n     \
    \   if a > max {\n            max = a;\n        }\n    }\n\n    (min, max)", " \
    \   let mut smallest = std::f64::MAX;\n    let mut largest = std::f64::MIN;\n\n\
    \    for n in numbers {\n        let delta = n.abs() - smallest;\n        if delta\
    \ < smallest {\n            smallest = delta;\n        }\n\n        if delta >\
    \ largest {\n            largest = delta;\n        }\n    }\n\n    (smallest,\
    \ largest)", "    let mut closest_val = (numbers[0], numbers[0]);\n    let mut\
    \ closest_distance = std::f64::MAX;\n    for val in numbers.iter().rev() {\n \
    \       let distance = val - closest_val.0;\n        if distance < closest_distance\
    \ {\n            closest_distance = distance;\n            closest_val = val;\n\
    \        }\n    }\n    closest_val", "    let mut min = numbers.iter().min_by_key(|x|\
    \ x.abs());\n    let mut max = numbers.iter().max_by_key(|x| x.abs());\n\n   \
    \ while let Some(i) = (min + max).iter().min() {\n        if numbers.iter().any(|x|\
    \ x.abs() == i) {\n            return (i, i);\n        }\n\n        if numbers.iter().any(|x|\
    \ x.abs() == max) {\n            max = (*max).max();\n        } else {\n     \
    \       min = (*min).min();\n        }\n    }\n\n    (max, min)", "    let mut\
    \ closest = numbers[0];\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    let mut smallest_index = vec![];\n    let mut largest_index\
    \ = vec![];\n    for i in numbers.iter() {\n        let dist = i - closest;\n\
    \        if dist < smallest {\n            smallest = dist;\n            smallest_index.push(i);\n\
    \        }\n        if dist > largest {\n            largest = dist;\n       \
    \     largest_index.push(i);\n        }\n    }\n\n    // Make sure that the smallest\
    \ and largest are both in the list\n    let mut smallest_i = vec![];\n    let\
    \ mut largest_i = vec![];\n    for num in smallest_index {\n        smallest_i.push(num);\n\
    \    }\n    for num in largest_index {\n        largest_i.push(num);\n    }\n\n\
    \    smallest_i.reverse();\n    largest_i.reverse();\n\n    (closest, smallest_i.last())",
  "    if numbers.len() < 2 {\n        (numbers[0], numbers[0])\n    } else {\n  \
    \      let mut smallest = numbers[0];\n        let mut largest = numbers[0];\n\
    \        for i in 1..numbers.len() {\n            let mut this: Vec<_> = numbers[i\
    \ as usize].iter().cloned().collect();\n            if this.len() < 2 {\n    \
    \            this.push(numbers[i]);\n            }\n            this[0] = this[0]\
    \ / this[1];\n            let this1 = this.len() as f64;\n            if this1\
    \ > smallest {\n                smallest = this1;\n            }\n           \
    \ if this1 < largest {\n                largest = this1;\n            }\n    \
    \    }\n        (smallest, largest)\n    }", "    let mut min_distance: f64 =\
    \ numbers.iter().min().unwrap();\n    let mut second_closest: Option<f64> = None;\n\
    \    let mut third_closest: Option<f64> = None;\n    let mut fourth_closest: Option<f64>\
    \ = None;\n    let mut fifth_closest: Option<f64> = None;\n    for number in numbers.iter()\
    \ {\n        if min_distance == number {\n            if second_closest == None\
    \ || number < second_closest.unwrap() {\n                second_closest = Some(number);\n\
    \            }\n        } else {\n            if third_closest == None || number\
    \ < third_closest.unwrap() {\n                third_closest = Some(number);\n\
    \            }\n            if fourth_closest == None || number < fourth_closest.unwrap()\
    \ {\n                fourth_closest = Some(number);\n            }\n         \
    \   if fifth_closest == None || number < fifth_closest.unwrap() {\n          \
    \      fifth_closest = Some(number);\n            }\n        }\n        min_distance\
    \ = number;\n    }\n\n    (second_closest, third_closest)\n        .collect::<(Option<f64>,\
    \ Option<f64>)>()\n        .try_fold(first_closest: None, second_closest: Some,\
    \ third_closest: Some, fourth_closest: Some, fifth_closest: Some)\n        .unwrap()",
  "    if numbers.len() < 2 {\n        return (0., 0.);\n    }\n\n    let mut current_min\
    \ = numbers[0];\n    let mut current_max = numbers[0];\n\n    for i in 1..numbers.len()\
    \ {\n        if current_min > numbers[i] {\n            current_min = numbers[i];\n\
    \        }\n        if current_max < numbers[i] {\n            current_max = numbers[i];\n\
    \        }\n    }\n\n    (current_min, current_max)", "    let mut min = f64::MAX;\n\
    \    let mut max = f64::MIN;\n    for num in numbers.iter() {\n        let delta\
    \ = num - min;\n        if delta < 0.0 {\n            min = num;\n        } else\
    \ {\n            max = num;\n        }\n    }\n    (min, max)", "    debug_assert!(numbers.len()\
    \ >= 2);\n    let mut min_a = numbers.iter().min().unwrap();\n    let mut max_a\
    \ = numbers.iter().max().unwrap();\n    let mut min_b = numbers.iter().min_by_key(|n|\
    \ n as f64).unwrap();\n    let mut max_b = numbers.iter().max_by_key(|n| n as\
    \ f64).unwrap();\n    while min_a == min_b {\n        min_b = numbers.iter().min_by_key(|n|\
    \ n as f64).unwrap();\n    }\n    while max_a == max_b {\n        max_b = numbers.iter().max_by_key(|n|\
    \ n as f64).unwrap();\n    }\n    (min_a, max_a), (min_b, max_b)", "    let mut\
    \ min_diff = numbers[0] - numbers[1];\n    let mut min_element = numbers[1];\n\
    \    for &n in &numbers[2..] {\n        let d = n - min_element;\n        if d\
    \ < min_diff {\n            min_diff = d\n        } else {\n            min_element\
    \ = n;\n        }\n    }\n    (min_element, min_diff)", "    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n\n    for &n in numbers {\n\
    \        if n == largest {\n            largest = n;\n        } else if n == smallest\
    \ {\n            smallest = n;\n        } else {\n            if n > largest {\n\
    \                largest = n;\n            } else if n < smallest {\n        \
    \        smallest = n;\n            }\n        }\n    }\n    (smallest, largest)",
  "    if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n    }\n\n\
    \    let mut closest = (numbers[0], numbers[0]);\n    let mut smallest_diff =\
    \ numbers[1];\n    let mut largest_diff = numbers[1];\n\n    for num in numbers[2..]\
    \ {\n        let diff = (num - closest.0).abs();\n\n        if diff < smallest_diff\
    \ {\n            smallest_diff = diff;\n            closest = (num, num);\n  \
    \      }\n        if diff > largest_diff {\n            largest_diff = diff;\n\
    \            closest = (num, num);\n        }\n    }\n\n    (closest, smallest_diff)",
  "    let mut smallest_distance = numbers[0];\n    let mut largest_distance = numbers[0];\n\
    \    for &number in numbers {\n        smallest_distance = std::fmin(smallest_distance,\
    \ number);\n        largest_distance = std::fmax(largest_distance, number);\n\
    \    }\n    (smallest_distance, largest_distance)", "    match numbers.len() {\n\
    \        2 => numbers.iter().min(|a, b| b - a).unwrap(),\n        _ => panic!(\"\
    Too many input arguments. Must be at least 2.\"),\n    }", "    let mut smallest\
    \ = numbers[0].abs();\n    let mut largest = numbers[0].abs();\n    let mut index\
    \ = 0;\n    for number in numbers {\n        let difference = number.abs() - smallest;\n\
    \        if smallest < number && difference < largest {\n            smallest\
    \ = number;\n            largest = difference;\n        }\n        index += 1\n\
    \    }\n    (numbers[index - 1], numbers[index])", "    numbers.iter()\n     \
    \   .enumerate()\n        .filter_map(|(index, number)| {\n            if index\
    \ == 0 {\n                Some(number as f64)\n            } else {\n        \
    \        let prev = (numbers[index - 1] as f64).abs();\n                Some((prev\
    \ + (number as f64).abs()) as f64)\n            }\n        })\n        .min_by(|a,\
    \ b| a.cmp(b))\n        .expect(\"find_closest_elements should never fail\")",
  "    if numbers.is_empty() {\n        return (0, 0);\n    }\n    let mut min_index\
    \ = 0;\n    let mut max_index = 1;\n\n    let mut min_distance = numbers[0] as\
    \ f64;\n    let mut max_distance = numbers[0] as f64;\n    for &n in numbers[1..]\
    \ {\n        let distance = match n.cmp(&min_distance) {\n            Ordering::Greater\
    \ => numbers[0] as f64,\n            Ordering::Less => n as f64,\n           \
    \ Ordering::Equal => min_distance,\n        };\n        if distance < min_distance\
    \ {\n            min_distance = distance;\n            min_index = 0;\n      \
    \  }\n        if distance > max_distance {\n            max_distance = distance;\n\
    \            max_index = 1;\n        }\n    }\n    (min_distance, max_distance)",
  "    let mut smaller = numbers[0];\n    let mut larger = numbers[0];\n\n    for\
    \ i in numbers.iter().rev() {\n        if smaller < i {\n            smaller =\
    \ i;\n        }\n        if larger > i {\n            larger = i;\n        }\n\
    \    }\n\n    (smaller, larger)", "    let mut min_value = numbers[0] as f64;\n\
    \    let mut max_value = numbers[0] as f64;\n\n    for &n in numbers {\n     \
    \   if n < min_value {\n            min_value = n as f64;\n        }\n       \
    \ if n > max_value {\n            max_value = n as f64;\n        }\n    }\n\n\
    \    return (min_value, max_value);", "    let mut min_element = numbers[0];\n\
    \    let mut max_element = numbers[0];\n    for i in 1..numbers.len() {\n    \
    \    if numbers[i] > max_element {\n            max_element = numbers[i];\n  \
    \      }\n        if numbers[i] < min_element {\n            min_element = numbers[i];\n\
    \        }\n    }\n    (min_element, max_element)", "    numbers\n        .iter()\n\
    \        .enumerate()\n        .min_by(|(i, _)| {\n            if i > 0 && f64::abs(numbers[i]\
    \ - numbers[i - 1]) < f64::abs(numbers[i] - numbers[i]) {\n                numbers[i],\
    \ numbers[i - 1]\n            } else {\n                numbers[i], numbers[i]\n\
    \            }\n        })\n        .unwrap_or((numbers[0], numbers[0]))", " \
    \   let mut min_d = std::f64::MAX;\n    let mut min_i = -1;\n    for i in 0..numbers.len()\
    \ {\n        let d = std::f64::f64::from(numbers[i] - numbers[min_i]);\n     \
    \   if d < min_d {\n            min_d = d;\n            min_i = i;\n        }\n\
    \    }\n    (numbers[min_i], numbers[min_i + 1])", "    let mut min_value = numbers[0].clone()\
    \ + 1.0; // to avoid a divide by zero error\n    let mut max_value = numbers[0].clone()\
    \ - 1.0; // to avoid a divide by zero error\n    for i in numbers.iter_mut() {\n\
    \        *i = *i / max_value.clone(); // dividing each element by max_value\n\
    \        if *i < min_value {\n            min_value = *i;\n        }\n    }\n\
    \    for i in numbers.iter_mut() {\n        *i = *i / min_value.clone(); // dividing\
    \ each element by min_value\n        if *i > max_value {\n            max_value\
    \ = *i;\n        }\n    }\n    (min_value, max_value)", "    let mut smallest\
    \ = numbers[0].clone() as f64;\n    let mut largest = numbers[0].clone() as f64;\n\
    \    for n in numbers {\n        if n.abs() < smallest.abs() {\n            smallest\
    \ = n.clone();\n        }\n        if n.abs() > largest.abs() {\n            largest\
    \ = n.clone();\n        }\n    }\n    (smallest, largest)", "    // Find two numbers\
    \ that minimally increase the distance to eachother\n    let mut min_dist = std::f64::INFINITY;\n\
    \    let mut min_i = -1;\n    for i in 0..numbers.len() {\n        let dist =\
    \ numbers[i] - numbers[min_i];\n        if dist < min_dist {\n            min_dist\
    \ = dist;\n            min_i = i;\n        }\n    }\n    (numbers[min_i], numbers[min_i\
    \ + 1])", "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for i in numbers.iter().rev() {\n        if smallest > i {\n            smallest\
    \ = i;\n        }\n        if largest < i {\n            largest = i;\n      \
    \  }\n    }\n    (smallest, largest)", "    let mut smallest_distance = FLT_MAX;\n\
    \    let mut largest_distance = -FLT_MAX;\n    for number in numbers {\n     \
    \   let distance = number.abs();\n        if distance < smallest_distance {\n\
    \            smallest_distance = distance;\n        }\n        if distance > largest_distance\
    \ {\n            largest_distance = distance;\n        }\n    }\n    if smallest_distance\
    \ == largest_distance {\n        smallest_distance\n    } else {\n        (smallest_distance,\
    \ largest_distance)\n    }", "    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for number in numbers.iter().rev() {\n        if\
    \ number < smallest {\n            smallest = number;\n        }\n        if number\
    \ > largest {\n            largest = number;\n        }\n    }\n    (smallest,\
    \ largest)", "    let mut smallest = numbers[0].0; //smallest\n    let mut largest\
    \ = numbers[0].0; //largest\n\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number;\n        }\n        if number >\
    \ largest {\n            largest = number;\n        }\n    }\n\n    smallest,\
    \ largest", "    if numbers.len() < 2 {\n        return (0, numbers.last().unwrap());\n\
    \    }\n\n    let mut smallest = numbers[0].min(numbers[1]);\n    let mut largest\
    \ = numbers[0].max(numbers[1]);\n\n    for &n in numbers[2..] {\n        let tmp\
    \ = n.min(smallest);\n        if tmp < smallest {\n            smallest = tmp;\n\
    \        }\n\n        if tmp > largest {\n            largest = tmp;\n       \
    \ }\n    }\n\n    (smallest, largest)", "    let mut closest = numbers[0];\n \
    \   let mut second_closest = numbers[0];\n\n    for &n in numbers {\n        if\
    \ n > closest {\n            second_closest = closest;\n            closest =\
    \ n;\n        } else if n < closest {\n            second_closest = 1;\n     \
    \       closest = n;\n        } else {\n            second_closest = 1;\n    \
    \    }\n    }\n\n    (closest, second_closest)", "    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n\n    for &n in numbers {\n        let curr_min\
    \ = min;\n        let curr_max = max;\n\n        if n < curr_min {\n         \
    \   min = n;\n        }\n        if n > curr_max {\n            max = n;\n   \
    \     }\n    }\n    (min, max)", "    if numbers.is_empty() {\n        (0.0, 0.0)\n\
    \    }\n    let mut min_val: f64 = numbers[0];\n    let mut max_val: f64 = numbers[0];\n\
    \    for i in numbers.iter().rev() {\n        if i < min_val {\n            min_val\
    \ = i;\n        }\n        if i > max_val {\n            max_val = i;\n      \
    \  }\n    }\n    (min_val, max_val)", "    let mut min: f64 = numbers.iter().min().unwrap();\n\
    \    let mut max: f64 = numbers.iter().max().unwrap();\n    let mut smallest =\
    \ min;\n    let mut largest = max;\n    let mut index: usize = 0;\n    while index\
    \ < numbers.len() {\n        if numbers[index] < smallest {\n            smallest\
    \ = numbers[index];\n            index += 1;\n        } else if numbers[index]\
    \ > largest {\n            largest = numbers[index];\n            index += 1;\n\
    \        }\n    }\n    (smallest, largest)", "    let mut lower = numbers[0];\n\
    \    let mut higher = numbers[0];\n    for (number, index) in numbers.iter().enumerate()\
    \ {\n        if number < lower {\n            lower = number;\n        }\n   \
    \     if number > higher {\n            higher = number;\n        }\n    }\n\n\
    \    let mut i = 1;\n    let mut closest = lower as f64;\n    let mut closest\
    \ = higher as f64;\n    while i < numbers.len() {\n        let mut curr = numbers[i];\n\
    \        let mut j = i;\n        while j < numbers.len() {\n            let mut\
    \ delta = curr - numbers[j];\n            if delta < closest {\n             \
    \   closest = delta;\n            }\n            j += 1;\n        }\n        i\
    \ += 1;\n    }\n\n    (lower, closest)", "    numbers\n        .iter()\n     \
    \   .enumerate()\n        .min_by_key(|(_, i)| numbers[i] - numbers[i - 1]);",
  "    if numbers.is_empty() {\n        return (0.0, 0.0);\n    }\n\n    if numbers.len()\
    \ < 2 {\n        return (numbers[0], numbers[0]);\n    }\n\n    let mut min_val\
    \ = numbers[0];\n    let mut max_val = numbers[0];\n    let mut min_val = numbers[0];\n\
    \    let mut max_val = numbers[0];\n    let mut min_val = numbers[0];\n    let\
    \ mut max_val = numbers[0];\n    for &num in numbers {\n        if *num < min_val\
    \ {\n            min_val = *num;\n        }\n        if *num > max_val {\n   \
    \         max_val = *num;\n        }\n    }\n\n    for &num in numbers {\n   \
    \     if *num < min_val {\n            min_val = *num;\n        }\n        if\
    \ *num > max_val {\n            max_val = *num;\n        }\n    }\n\n    let mut\
    \ min_diff = std::f64::MAX;\n    let mut max_diff = std::f64::MIN;\n    let mut\
    \ min_diff = std::f64::MAX;\n    let mut max_diff = std::f64::MIN;\n    let mut\
    \ min_diff = std::f64::MAX;\n    let mut max_diff = std::f64::MIN;\n    for &num\
    \ in numbers {\n        if *num < min_val {\n            min_val = *num;\n   \
    \     }\n        if *num > max_val {\n            max_val = *num;\n        }\n\
    \    }\n\n    for &num in numbers {\n        if *num < min_val {\n           \
    \ min_diff = std::f64::MAX;\n        }\n        if *num > max_val {\n        \
    \    max_diff = std::f64::MIN;\n        }\n        if *num < min_diff {\n    \
    \        min_diff = *num;\n        }\n        if *num > max_diff {\n         \
    \   max_diff = *num;\n        }\n    }\n\n    if max_diff < min_diff {\n     \
    \   return (min_val, max_val);\n    }\n\n    return (min_diff, max_diff);", " \
    \   let mut closest = numbers[0];\n    let mut closest = numbers[0];\n    for\
    \ i in 1..numbers.len() {\n        if numbers[i] - closest < closest - numbers[i]\
    \ {\n            closest = numbers[i];\n        }\n    }\n    (numbers[0], closest)",
  "    let mut a = numbers.iter().cloned().collect::<Vec<_>>();\n    let mut b = numbers.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest = vec![];\n    let mut smallest = vec![];\n    let mut largest\
    \ = vec![];\n    let mut a0 = a[0];\n    let mut b0 = b[0];\n    let mut c_mut_a\
    \ = a.clone();\n    let mut c_mut_b = b.clone();\n    let mut c_mut_c_mut_a =\
    \ c_mut_a.clone();\n    let mut c_mut_c_mut_b = c_mut_b.clone();\n    for i in\
    \ 0..a.len() {\n        for j in 0..b.len() {\n            let diff = a[i] - b[j];\n\
    \            if diff <= 0.0 {\n                continue;\n            }\n    \
    \        let mut smallest_j = smallest[j].iter().cloned().collect::<Vec<_>>();\n\
    \            let mut largest_j = largest[j].iter().cloned().collect::<Vec<_>>();\n\
    \            if diff < smallest[j].len() {\n                smallest[j] = vec![c_mut_a[i]];\n\
    \            } else {\n                smallest[j].push(c_mut_a[i]);\n       \
    \     }\n            if diff > largest[j].len() {\n                largest[j]\
    \ = vec![c_mut_b[i]];\n            } else {\n                largest[j].push(c_mut_b[i]);\n\
    \            }\n            if diff <= 0.0 {\n                continue;\n    \
    \        }\n            smallest_j.iter().cloned().cloned().sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(c_mut_b[j]);\n            largest_j.iter().cloned().cloned().sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(c_mut_a[j]);\n        }\n    }\n    smallest.sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(largest.last().cloned());\n    largest.sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(smallest.last().cloned());\n    let mut ret1\
    \ = smallest.iter().cloned().cloned().take(1).unwrap().clone();\n    let mut ret2\
    \ = largest.iter().cloned().cloned().take(1).unwrap().clone();\n    ret1.sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(ret2.last().cloned());\n    ret2.", "    if\
    \ numbers.is_empty() {\n        return (0., 0.);\n    }\n    let mut best = Vec::new();\n\
    \    let mut best = Vec::new();\n    let mut best = Vec::new();\n    let mut best\
    \ = Vec::new();\n    let mut best = Vec::new();\n    let mut best = Vec::new();\n\
    \    for n in numbers {\n        let mut best1 = 0.;\n        let mut best2 =\
    \ 0.;\n        let mut best3 = 0.;\n        let mut best4 = 0.;\n        for n\
    \ in numbers {\n            match n {\n                n if n == n => { best1\
    \ = best; best2 = best; best3 = best; best4 = best; },\n                n if n\
    \ < n => { best1 = best; best2 = best; },\n                n if n > n => { best1\
    \ = best; best2 = best; },\n                _ => { }\n            }\n        }\n\
    \        best = if best1 < best2 && best3 < best4 { (best1, best3) } else if best2\
    \ < best1 && best3 < best4 { (best2, best3) } else { if best1 < best2 && best2\
    \ < best4 { (best1, best2) } else { if best1 < best2 && best3 < best4 { (best1,\
    \ best3) } else { if best2 < best1 && best3 < best4 { (best2, best3) } } };\n\
    \    }\n    (best.0, best.1)", "    let mut min = f64::MAX;\n    let mut max =\
    \ f64::MIN;\n    for n in numbers {\n        if n < min {\n            min = n;\n\
    \        }\n        if n > max {\n            max = n;\n        }\n    }\n   \
    \ (min, max)", "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \n    for i in numbers.iter().rev() {\n        if i < min {\n            min =\
    \ i;\n        }\n\n        if i > max {\n            max = i;\n        }\n   \
    \ }\n\n    (min, max)", "    let mut smallest = numbers[0] as f64;\n    let mut\
    \ biggest = numbers[0] as f64;\n    for &n in numbers {\n        if n >= smallest\
    \ {\n            smallest = n;\n        } else if n < smallest {\n           \
    \ smallest = n;\n        }\n        if n <= biggest {\n            biggest = n;\n\
    \        } else if n > biggest {\n            biggest = n;\n        }\n    }\n\
    \    (smallest, biggest)", "    let mut lowest_found = (numbers[0], numbers[0]);\n\
    \n    for i in 1..numbers.len() {\n        let (current, minimum) = lowest_found;\n\
    \        let difference = numbers[i] - current;\n        if difference < minimum\
    \ {\n            lowest_found = (numbers[i], numbers[i]);\n        }\n    }\n\
    \    lowest_found", "    let mut smallest = numbers[0];\n    let mut largest =\
    \ numbers[0];\n\n    for i in 1..numbers.len() {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i];\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i];\n        }\n    }\n\n    (smallest, largest)",
  "    let mut min_distance = numbers[0].abs();\n    let mut min_number = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        let distance = numbers[i].abs();\n \
    \       if distance < min_distance {\n            min_distance = distance;\n \
    \           min_number = numbers[i];\n        }\n    }\n    (min_number, min_distance)",
  "    // Sort numbers so we can find the closest one first\n    let sorted_numbers\
    \ = numbers.iter().sorted();\n    // If the first number is 0 then there is no\
    \ number\n    if sorted_numbers.first() == f64::from(0.0)\n        || (sorted_numbers.last()\
    \ == f64::from(0.0)\n            && numbers.len() > 1)\n    {\n        return\
    \ (sorted_numbers.last().unwrap(), sorted_numbers.last().unwrap());\n    }\n \
    \   // If the first and last numbers are the same, return the middle number\n\
    \    if sorted_numbers.first() == sorted_numbers.last() {\n        return (sorted_numbers.last(),\
    \ sorted_numbers.last().unwrap());\n    }\n    let first_number = sorted_numbers.first().unwrap();\n\
    \    let last_number = sorted_numbers.last().unwrap();\n    let mut result = vec![(first_number,\
    \ first_number)];\n    for (i, number) in sorted_numbers.iter().skip(1) {\n  \
    \      let current_number = number;\n        let distance = if i == 0 {\n    \
    \        first_number - current_number\n        } else {\n            last_number\
    \ - current_number\n        };\n        let closest_number = if distance < 0 {\n\
    \            result[result.len() - 1].1.unwrap() + distance\n        } else {\n\
    \            result[result.len() - 1].0.unwrap() + distance\n        };\n    \
    \    // Update the result vector\n        result.push((current_number, closest_number));\n\
    \    }\n    // If there are any remaining numbers, return the nearest to them\
    \ in order\n    if let Some(number) = sorted_numbers.last() {\n        result.push((number,\
    \ number));\n    }\n    // Return the results\n    result.into_iter().collect::<Vec<_>>()",
  "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\n    for\
    \ &n in &numbers[1..] {\n        if n < smallest {\n            smallest = n;\n\
    \        }\n\n        if n > largest {\n            largest = n;\n        }\n\
    \    }\n\n    (smallest, largest)", "    let mut min_value = numbers[0].min();\n\
    \    let mut max_value = numbers[0].max();\n\n    for number in numbers.iter().rev()\
    \ {\n        if number < min_value {\n            min_value = number;\n      \
    \  }\n        if number > max_value {\n            max_value = number;\n     \
    \   }\n    }\n\n    let min_distance = min_value - max_value;\n    let mut min_value\
    \ = min_value + min_distance;\n    let mut max_value = max_value - min_distance;\n\
    \    min_value = min_value..max_value;\n\n    (min_value, max_value)", "    let\
    \ min_diff = numbers.iter().min().unwrap();\n    let max_diff = numbers.iter().max().unwrap();\n\
    \    if min_diff == max_diff {\n        return (min_diff, min_diff);\n    }\n\
    \    let mut min_closest = max_diff;\n    let mut max_closest = min_diff;\n  \
    \  let mut min_idx = 0;\n    let mut max_idx = numbers.len() - 1;\n    while min_idx\
    \ < max_idx {\n        let diff = (min_closest + max_closest) / 2; // make sure\
    \ diff is even\n        let closest = match numbers[min_idx..max_idx].iter().cloned().min_max_element::<f64>()\n\
    \            .map(|v| (v - diff).abs()).min_max_element::<f64>()\n        {\n\
    \            Some((a, b)) if a < b => (a, b)\n            Some((a, b)) if a >\
    \ b => (b, a)\n            Some((a, b)) => return (a, b)\n            None =>\
    \ return (min_diff, max_diff)\n        };\n        if closest < min_closest {\n\
    \            min_closest = closest;\n            min_idx = min_idx + 1;\n    \
    \    } else if closest > max_closest {\n            max_closest = closest;\n \
    \           max_idx = max_idx - 1;\n        }\n    }\n    (min_diff, max_diff)",
  "    numbers.iter()\n        .enumerate()\n        .filter_map(|(idx, num)| {\n\
    \            if idx > 0 {\n                Some((\n                    num - numbers[idx\
    \ - 1].unwrap(),\n                    numbers[idx].unwrap(),\n               \
    \ ))\n            } else {\n                Some((\n                    num -\
    \ numbers[numbers.len() - 1].unwrap(),\n                    numbers[0].unwrap(),\n\
    \                ))\n            }\n        })\n        .nth(1)\n        .unwrap_or((numbers[0],\
    \ numbers[1]))", "    assert!(numbers.len() >= 2);\n\n    let mut min = 0.0;\n\
    \    let mut max = numbers[0];\n    for (index, number) in numbers.iter().enumerate()\
    \ {\n        if number < min {\n            min = number;\n        }\n       \
    \ if number > max {\n            max = number;\n        }\n    }\n\n    let mut\
    \ min_index = 0;\n    let mut max_index = numbers[0] as usize;\n\n    for (index,\
    \ number) in numbers.iter().enumerate() {\n        if number < min {\n       \
    \     min = number;\n            min_index = index;\n        }\n        if number\
    \ > max {\n            max = number;\n            max_index = index;\n       \
    \ }\n    }\n\n    (numbers[min_index], numbers[max_index])", "    if numbers.len()\
    \ < 2 {\n        // too few numbers, nothing to do\n        return (0.0,0.0);\n\
    \    }\n    let mut smallest_value = numbers[0];\n    let mut largest_value =\
    \ numbers[0];\n\n    for num in numbers.iter().skip(1) {\n        if num > largest_value\
    \ {\n            largest_value = num;\n        }\n\n        if num < smallest_value\
    \ {\n            smallest_value = num;\n        }\n    }\n\n    (smallest_value,\
    \ largest_value)", "    let mut min_distance = numbers[0].0; // initialize min\
    \ distance to first number in list\n    let mut max_distance = numbers[0].0;\n\
    \n    // iterate through numbers to find min and max distance\n    for number\
    \ in numbers {\n        let distance = if number < min_distance {\n          \
    \  min_distance\n        } else {\n            max_distance\n        };\n\n  \
    \      // update min and max distance\n        if distance < min_distance {\n\
    \            min_distance = number;\n        }\n        if distance > max_distance\
    \ {\n            max_distance = number;\n        }\n    }\n\n    // return min\
    \ and max distances in order\n    (min_distance, max_distance)", "    // TODO:\
    \ this could be made more efficient by sorting the list first and going through\
    \ the list once\n    let mut min1 = numbers[0]\n    let mut min2 = numbers[0]\n\
    \    for i in 1..numbers.len() {\n        let dist = &numbers[i] - &numbers[i\
    \ - 1];\n        if dist < min1 {\n            min1 = dist;\n        }\n     \
    \   if dist < min2 {\n            min2 = dist;\n        }\n    }\n    (min1, min2)",
  "    numbers.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());\n\n    let mut\
    \ index = 0;\n    let mut result = (numbers[0], numbers[0]);\n    while index\
    \ < numbers.len() {\n        let current = numbers[index];\n        if current\
    \ < result.0 {\n            result = (numbers[index], numbers[index]);\n     \
    \   } else if current > result.0 {\n            result = (numbers[index], result);\n\
    \        }\n\n        index = index + 1;\n    }\n\n    result", "    // Find closest\
    \ number in the array and return it in the array\n    let mut smaller = numbers[0];\n\
    \    let mut larger = numbers[0];\n    for i in numbers {\n        if i < smaller\
    \ { smaller = i }\n        else if i > larger { larger = i }\n    }\n    (smaller,\
    \ larger)", "    let mut smallest = f64::MAX;\n    let mut largest = -smallest;\n\
    \    let mut mid = numbers.len() / 2;\n\n    for n in numbers {\n        if n\
    \ < smallest {\n            smallest = n;\n        }\n        if n > largest {\n\
    \            largest = n;\n        }\n        if n == smallest {\n           \
    \ mid = numbers.len() / 2;\n        }\n    }\n\n    (smallest, largest)", "  \
    \  if numbers.len() < 2 {\n        return (0., 0.);\n    }\n\n    let mut largest\
    \ = numbers[0];\n    let mut smallest = numbers[0];\n    for &x in &numbers[1..]\
    \ {\n        if x < largest {\n            largest = x;\n        } else if x >\
    \ smallest {\n            smallest = x;\n        }\n    }\n    (smallest, largest)",
  "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ num in numbers {\n        if num < smallest {\n            smallest = num;\n\
    \        }\n        if num > largest {\n            largest = num;\n        }\n\
    \    }\n    smallest, largest", "    let mut best = vec![numbers[0] - 1, numbers[0]\
    \ - 1];\n    let mut closest = numbers[0];\n    let mut worst = numbers[0];\n\
    \    for &n in numbers {\n        if n > best {\n            best = n;\n     \
    \   }\n        if n < worst {\n            worst = n;\n        }\n    }\n    let\
    \ mut min_difference = best.min(&worst) - 1;\n    for i in numbers.iter().rev()\
    \ {\n        let difference = i + 1;\n        if difference > min_difference {\n\
    \            min_difference = difference;\n            closest = i;\n        }\n\
    \    }\n    (closest, min_difference)", "    if numbers.len() < 2 {\n        return\
    \ (numbers[0], numbers[0]);\n    }\n    let mut index = 0;\n    let mut best_distance\
    \ = numbers[0] - numbers[1];\n    let mut best_index = index;\n    while index\
    \ < numbers.len() {\n        if numbers[index] - best_distance < best_distance\
    \ {\n            best_distance = numbers[index] - best_distance;\n           \
    \ best_index = index;\n        }\n        index += 1;\n    }\n    (numbers[best_index],\
    \ numbers[best_index + 1])", "    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[1])\n    } else {\n        let mut min_diff = numbers[0] - numbers[1];\n\
    \        let mut min_diff = numbers[1] - numbers[0];\n\n        let mut first_number\
    \ = numbers[0];\n        let mut second_number = numbers[1];\n\n        for n\
    \ in numbers[2..] {\n            let diff = n - first_number;\n            if\
    \ diff < min_diff {\n                min_diff = diff;\n                first_number\
    \ = n;\n            } else if diff == min_diff {\n                second_number\
    \ = n;\n            }\n        }\n        (first_number, second_number)\n    }",
  "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ &n in numbers {\n        if n < smallest {\n            smallest = n;\n    \
    \    }\n        if n > largest {\n            largest = n;\n        }\n    }\n\
    \    (smallest, largest)", "    let mut smallest = numbers[0].clone(); let mut\
    \ largest = numbers[0].clone();\n\n    for &x in numbers {\n        if x < smallest\
    \ {\n            smallest = x;\n        }\n        if x > largest {\n        \
    \    largest = x;\n        }\n    }\n\n    (smallest, largest)", "    if numbers.len()\
    \ < 2 {\n        return (f64::NAN, f64::NAN);\n    }\n    let mut index = 0;\n\
    \    let mut min = numbers[index];\n    let mut max = numbers[index];\n    for\
    \ (i, n) in numbers.iter().enumerate() {\n        if n == min {\n            index\
    \ = i;\n            min = n;\n        }\n        if n == max {\n            index\
    \ = i;\n            max = n;\n        }\n    }\n    (min, max)", "    numbers.iter().cloned().zip(numbers)\n\
    \        .enumerate()\n        .filter_map(|(i, number)| {\n            if i ==\
    \ 0 {\n                Some((number, number))\n            } else {\n        \
    \        let distance = std::f64::distance(number, numbers[i - 1]);\n        \
    \        if distance < number {\n                    Some((number, numbers[i -\
    \ 1]))\n                } else {\n                    None\n                }\n\
    \            }\n        })\n        .collect::<Vec<_>>()", "    let mut min_dist\
    \ = Vec::new();\n    min_dist.push((numbers[0], numbers[0]));\n    for &n in numbers\
    \ {\n        let d = n - min_dist[0][1];\n        min_dist.push((n, min_dist[0][1]\
    \ + d));\n    }\n    min_dist.iter().fold(\n        (0, 0.0),\n        |(min_dist1,\
    \ min_dist2), &(v, w)) => (\n                min_dist1.1.min(|&(_, d)| d < w ?\
    \ d : w),\n                min_dist2.1.max(|&(_, d)| d > w ? d : w)\n        \
    \    )", "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \n    for number in numbers.iter() {\n        if number < smallest {\n       \
    \     smallest = number;\n        }\n\n        if number > largest {\n       \
    \     largest = number;\n        }\n    }\n\n    (smallest, largest)", "    let\
    \ mut smallest = numbers.iter().min().unwrap();\n    let mut largest = numbers.iter().max().unwrap();\n\
    \    let mut i = 0;\n    for (index, x) in numbers.iter().enumerate() {\n    \
    \    if index == i {\n            continue;\n        }\n        if x < smallest\
    \ {\n            smallest = x;\n            i = index;\n        }\n        if\
    \ x > largest {\n            largest = x;\n            i = index;\n        }\n\
    \    }\n    (smallest, largest)", "    if numbers.len() < 2 {\n        return\
    \ (0..numbers.len()).fold(0.0, |acc, i| {\n            return if acc < numbers[0]\
    \ {\n                numbers[0]\n            } else if acc > numbers[0] {\n  \
    \              numbers[1]\n            } else if numbers[0] < numbers[1] {\n \
    \               numbers[0]\n            } else {\n                numbers[1]\n\
    \            }\n        })\n    }\n    let mut result = vec![numbers[0]];\n  \
    \  for i in 1..numbers.len() {\n        if result[0] < numbers[i] {\n        \
    \    result.swap(0, i);\n        }\n    }\n    result", "    // Find the first\
    \ element from the left side that is larger than the last\n    let mut leftmost_element\
    \ = numbers[0];\n\n    // Find the first element from the right side that is smaller\
    \ than the last\n    let mut rightmost_element = numbers[0];\n\n    for n in numbers\
    \ {\n        if n <= leftmost_element {\n            leftmost_element = pq(n)?;\n\
    \        } else {\n            rightmost_element = pq(n)?;\n        }\n    }\n\
    \n    // Return the smallest element to the right of our last element and the\
    \ biggest to the left\n    (rightmost_element, leftmost_element)", "    let mut\
    \ largest = numbers[0];\n    let mut smallest = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        let current = numbers[i];\n        if current > largest {\n     \
    \       largest = current;\n        }\n        if current < smallest {\n     \
    \       smallest = current;\n        }\n    }\n    smallest, largest", "    let\
    \ mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for i in\
    \ 1..numbers.len() {\n        smallest = numbers[i] as f64;\n        largest =\
    \ numbers[i] as f64;\n        for j in i..numbers.len() {\n            let dist\
    \ = numbers[j] as f64 - smallest as f64;\n            if dist < 0 {\n        \
    \        smallest = numbers[j];\n            } else {\n                largest\
    \ = numbers[j];\n            }\n        }\n    }\n    (smallest, largest)", " \
    \   let mut min = numbers[0];\n    let mut max = numbers[0];\n\n    for i in numbers.iter().rev()\
    \ {\n        if *i < min {\n            min = *i;\n        }\n        if *i >\
    \ max {\n            max = *i;\n        }\n    }\n\n    (min, max)", "    let\
    \ mut min_val = numbers[0]\n    let mut max_val = numbers[0]\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max_val {\n            max_val = numbers[i]\n   \
    \     }\n        if numbers[i] < min_val {\n            min_val = numbers[i]\n\
    \        }\n    }\n    (min_val, max_val)", "    let mut min = numbers[0];\n \
    \   let mut max = numbers[0];\n    for &n in numbers {\n        if n < min {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    let mut i = 0;\n    for &n in numbers {\n        if n ==\
    \ min {\n            i += 1;\n            continue;\n        }\n        if n ==\
    \ max {\n            return (&numbers[i], &numbers[i + 1]);\n        }\n    }\n\
    \    (min, max)", "    if numbers.len() < 2 {\n        (numbers[0], numbers[1])\n\
    \    } else {\n        let mut smallest = numbers[0];\n        let mut largest\
    \ = numbers[0];\n\n        for &n in numbers {\n            if smallest > n {\n\
    \                smallest = n;\n            }\n            if largest < n {\n\
    \                largest = n;\n            }\n        }\n\n        (smallest,\
    \ largest)\n    }", "    let mut min_dist = std::f64::MAX;\n    let mut min_element\
    \ = numbers[0];\n    let mut min_element_index = numbers[0];\n    let mut max_element\
    \ = numbers[0];\n    let mut max_element_index = numbers[0];\n    for i in 0..numbers.len()\
    \ {\n        let dist = numbers[i] - min_element;\n        if dist < min_dist\
    \ {\n            min_dist = dist;\n            min_element = numbers[i];\n   \
    \         min_element_index = i;\n        }\n        let dist = numbers[i] - max_element;\n\
    \        if dist > max_dist {\n            max_dist = dist;\n            max_element\
    \ = numbers[i];\n            max_element_index = i;\n        }\n    }\n    (min_element,\
    \ min_element_index), (max_element, max_element_index)", "    let mut min = numbers[0]\n\
    \    let mut max = numbers[0]\n    for &n in numbers {\n        if n > min {\n\
    \            max = n;\n        } else if n < max {\n            min = n;\n   \
    \     }\n    }\n    (min, max)", "    numbers.sort();\n    let mut smallest_number\
    \ = numbers[0];\n    let mut largest_number = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > largest_number {\n            largest_number = numbers[i];\n\
    \        }\n        if numbers[i] < smallest_number {\n            smallest_number\
    \ = numbers[i];\n        }\n    }\n    (smallest_number, largest_number)", " \
    \   assert!(numbers.length >= 2);\n    let mut closest = numbers[0];\n    let\
    \ mut farthest = numbers[0];\n    for n in numbers.iter().skip(1) {\n        let\
    \ d = n.f64() - closest.f64();\n        if d < closest {\n            closest\
    \ = n;\n        }\n        if d > farthest {\n            farthest = n;\n    \
    \    }\n    }\n    (closest, farthest)", "    debug_assert_eq!(numbers.len(),\
    \ 2);\n\n    let min_ind = 0..numbers[0].cmp(&numbers[1]);\n    let min_ind =\
    \ min_ind.iter().cloned().collect();\n\n    let max_ind = numbers[0].cmp(&numbers[1]);\n\
    \    let max_ind = max_ind.iter().cloned().collect();\n\n    (min_ind[0], min_ind[1])",
  "    let mut smallest_square = std::f64::MAX;\n    let mut closest_value = 0.0;\n\
    \    let mut closest_index = 0;\n\n    for i in 0..numbers.len() {\n        if\
    \ numbers[i] < closest_value {\n            closest_value = numbers[i];\n    \
    \        closest_index = i;\n        }\n\n        if smallest_square > numbers[i]\
    \ * numbers[i] {\n            smallest_square = numbers[i] * numbers[i];\n   \
    \     }\n    }\n\n    (closest_value, closest_index)", "    let mut index = 0;\n\
    \n    while index < numbers.len() {\n        let new_value = numbers[index] +\
    \ 1.0;\n        let mut new_value = std::f64::MAX;\n        let mut index = index\
    \ + 1;\n\n        while index < numbers.len() {\n            if new_value < numbers[index]\
    \ {\n                new_value = numbers[index];\n            }\n            index\
    \ = index + 1;\n        }\n        (numbers[index & 1], new_value)\n    }", " \
    \   numbers.windows(2).min_by_key(|&(mut a, _)| a).enumerate()\n        .find(|(_,\
    \ mut b)| b == numbers.last())\n        .expect(\"two numbers are too close\"\
    )\n        .1", "    if numbers.len() < 2 {\n        (0.0, 0.0)\n    }\n    else\
    \ {\n        let mut smallest_number = numbers[0];\n        let mut largest_number\
    \ = numbers[0];\n        for number in numbers {\n            if number < smallest_number\
    \ {\n                smallest_number = number;\n            }\n            if\
    \ number > largest_number {\n                largest_number = number;\n      \
    \      }\n        }\n        (smallest_number, largest_number)\n    }", "    if\
    \ numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n    }\n\n   \
    \ let mut closest_1 = numbers[0];\n    let mut closest_2 = numbers[0];\n    let\
    \ mut index = 1;\n\n    while index < numbers.len() {\n        if f64::from(closest_1)\
    \ < f64::from(numbers[index]) {\n            closest_1 = numbers[index];\n   \
    \     }\n\n        if f64::from(closest_2) < f64::from(numbers[index]) {\n   \
    \         closest_2 = numbers[index];\n        }\n\n        index += 1\n    }\n\
    \n    (closest_1, closest_2)", "    let mut min = numbers[0].abs();\n    let mut\
    \ max = numbers[0].abs();\n\n    for &n in numbers {\n        if n < min {\n \
    \           min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    if min > max {\n        (max, min)\n    } else {\n    \
    \    (min, max)\n    }", "    let mut smallest_dist = std::f64::MAX;\n    let\
    \ mut second_smallest_dist = std::f64::MAX;\n\n    for num in numbers {\n    \
    \    let distance = num.abs() - (numbers.iter().skip(1).take(1).sum().unwrap());\n\
    \        if distance < &mut smallest_dist {\n            smallest_dist = distance;\n\
    \        }\n        if distance < &mut second_smallest_dist {\n            second_smallest_dist\
    \ = distance;\n        }\n    }\n    (numbers[numbers.iter().skip(1).take(1).sum().unwrap()],\
    \ numbers[second_smallest_dist])", "    let mut smallest_diff;\n    let mut closest_i\
    \ = 0;\n    for &n in &numbers {\n        let diff_i = n.abs() - &numbers[closest_i].abs();\n\
    \        if diff_i < smallest_diff {\n            smallest_diff = diff_i;\n  \
    \          closest_i = *numbers.iter().position(|n| *n >= *n).unwrap();\n    \
    \    }\n    }\n    (&numbers[closest_i], &numbers[closest_i + 1])", "    let mut\
    \ smallest_index = -1;\n    let mut largest_index = -1;\n\n    for &num in numbers\
    \ {\n        let index = numbers.iter().position(|x| x.abs() < num).unwrap();\n\
    \        if index > smallest_index {\n            smallest_index = index;\n  \
    \      }\n\n        if index > largest_index {\n            largest_index = index;\n\
    \        }\n    }\n\n    (numbers[smallest_index], numbers[largest_index])", " \
    \   let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort();\n  \
    \  let first_elem = sorted_numbers[0];\n    let mut closest_elem = sorted_numbers[0];\n\
    \    let mut current_min_val = first_elem;\n    let mut current_max_val = first_elem;\n\
    \    for i in sorted_numbers.iter_mut().skip(1) {\n        if *i < current_min_val\
    \ {\n            current_min_val = *i;\n            closest_elem = i;\n      \
    \  }\n        if *i > current_max_val {\n            current_max_val = *i;\n \
    \       }\n    }\n    (current_min_val, closest_elem)", "    let mut min: f64\
    \ = numbers[0];\n    let mut max: f64 = numbers[0];\n\n    for (index, number)\
    \ in numbers.iter().enumerate() {\n        if number < min {\n            min\
    \ = number;\n        }\n        if number > max {\n            max = number;\n\
    \        }\n    }\n\n    // The min and max are now the closest elements.\n  \
    \  let mut smallest_index = index;\n    let mut biggest_index = index;\n\n   \
    \ for &index in numbers.iter().rev() {\n        let number = numbers[index];\n\
    \        if number < min {\n            min = number;\n            smallest_index\
    \ = index;\n        }\n        if number > max {\n            max = number;\n\
    \            biggest_index = index;\n        }\n    }\n\n    (min, max)", "  \
    \  if numbers.len() < 2 {\n        return (numbers[0], numbers[0])\n    }\n  \
    \  let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ n in numbers {\n        if n <= smallest {\n            smallest = n;\n    \
    \    }\n        if n >= largest {\n            largest = n;\n        }\n    }\n\
    \    (smallest, largest)", "    // Find smallest and largest\n    let smallest\
    \ = numbers.iter().min_by_key(|num| num);\n    let largest = numbers.iter().max_by_key(|num|\
    \ num);\n\n    // If smallest == largest we still have two numbers to return so\
    \ the second value isn't needed\n    if smallest == largest {\n        return\
    \ smallest, smallest;\n    }\n\n    // Calculate delta\n    let mut delta: f64;\n\
    \    delta = largest - smallest;\n\n    // Calculate the first value\n    let\
    \ first_value = smallest + delta;\n\n    // Calculate the second value by finding\
    \ the closest value to the first one\n    let second_value = numbers.iter().find(|num|\
    \ num == first_value).unwrap();\n    (first_value, second_value)", "    numbers.iter()\n\
    \        .enumerate()\n        .filter_map(|(i, num)| {\n            if i < 2\
    \ {\n                Some(num)\n            } else {\n                let (min_val,\
    \ max_val) = numbers.iter().min_max();\n                Some((num - min_val).abs(),\
    \ max_val.abs())\n            }\n        })\n        .min()\n        .last()",
  "    let min_element = numbers.iter().min();\n    let max_element = numbers.iter().max();\n\
    \n    (min_element, max_element)", "    let mut lowest_difference = numbers[0]\
    \ - numbers[1];\n    let mut best_val = numbers[0];\n    for &n in numbers[1..]\
    \ {\n        let difference = n - best_val;\n        if difference < lowest_difference\
    \ {\n            lowest_difference = difference;\n            best_val = n;\n\
    \        }\n    }\n    (best_val, lowest_difference)", '    numbers[0..numbers.len().min(2)].iter().cloned().min().unwrap()',
  "    let min_val = numbers.iter().min();\n    let max_val = numbers.iter().max();\n\
    \n    // get the index of the two elements that are closest to eachother\n   \
    \ let mut min_val_ix: usize = 0;\n    let mut max_val_ix: usize = 0;\n    for\
    \ i in numbers.iter().cloned().skip(1) {\n        // check if the ith number is\
    \ closer to the minimum than the minimum so far\n        let closest_val = min(i,\
    \ min_val);\n        let current_val_ix = min_val_ix;\n        if closest_val\
    \ == current_val_ix {\n            // if this element has already been found,\
    \ then just use the smallest index to search for the second element\n        \
    \    min_val_ix = i;\n        }\n        else {\n            // if this element\
    \ has not already been found then set the new minimum index to the current index\
    \ and the second\n            // index to the smallest index to search for elements\
    \ with the current value\n            min_val_ix = current_val_ix;\n         \
    \   max_val_ix = i;\n        }\n    }\n\n    // return the two closest values\
    \ to the minimum value\n    (numbers[min_val_ix], numbers[max_val_ix])", "   \
    \ let mut min = numbers[0].clone();\n    let mut max = numbers[0].clone();\n \
    \   for i in 1..numbers.len() {\n        if numbers[i] - numbers[i - 1] > 0.0\
    \ {\n            if numbers[i - 1] > numbers[i] {\n                max = numbers[i\
    \ - 1];\n            } else {\n                min = numbers[i];\n           \
    \ }\n        } else {\n            if numbers[i - 1] < numbers[i] {\n        \
    \        min = numbers[i - 1];\n            } else {\n                max = numbers[i];\n\
    \            }\n        }\n    }\n    (min, max)", "    numbers.sort_unstable_by_key(|x|\
    \ x.abs());\n    (numbers[0], numbers[1])", "    let mut min: f64 = numbers.iter().min().unwrap();\n\
    \    let mut max: f64 = numbers.iter().max().unwrap();\n\n    for number in numbers.iter().skip(2)\
    \ {\n        if number < min {\n            min = number;\n        }\n       \
    \ if number > max {\n            max = number;\n        }\n    }\n\n    (min,\
    \ max)", "    let mut smallest_distance = std::f64::MAX;\n    let mut second_smallest_distance\
    \ = std::f64::MAX;\n\n    for number in numbers {\n        let distance = numbers.iter().position(|x|\
    \ x < number).unwrap_or(numbers.len());\n        if smallest_distance > number\
    \ {\n            smallest_distance = number;\n        }\n        if second_smallest_distance\
    \ > number {\n            second_smallest_distance = number;\n        }\n    }\n\
    \n    (smallest_distance, second_smallest_distance)", "    if numbers.len() <\
    \ 2 {\n        return (0., numbers[0]);\n    }\n\n    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    let mut min_index = -1;\n    let mut max_index\
    \ = -1;\n\n    for i in 1..numbers.len() {\n        if numbers[i] < min {\n  \
    \          min = numbers[i];\n            min_index = i;\n        }\n        if\
    \ numbers[i] > max {\n            max = numbers[i];\n            max_index = i;\n\
    \        }\n    }\n\n    (min, max)", "    if numbers.len() < 2 {\n        return\
    \ (numbers[0], numbers[0]);\n    }\n    let mut min_distance = numbers[0];\n \
    \   let mut min_number = numbers[0];\n    for i in 1..numbers.len() {\n      \
    \  let distance = numbers[i] - numbers[i - 1];\n        if distance < min_distance\
    \ {\n            min_distance = distance;\n            min_number = numbers[i\
    \ - 1];\n        }\n    }\n    (min_number, min_distance)", "    let mut min_val\
    \ = numbers[0];\n    let mut max_val = numbers[0];\n\n    for n in numbers {\n\
    \        if n < min_val {\n            min_val = n;\n        }\n        if n >\
    \ max_val {\n            max_val = n;\n        }\n    }\n\n    (min_val, max_val)",
  "    let mut smallest: Vec<_> = Vec::new();\n    let mut largest: Vec<_> = Vec::new();\n\
    \n    for i in numbers.iter() {\n        if i == numbers.last().unwrap() {\n \
    \           smallest.push(i);\n            largest.push(i);\n        } else {\n\
    \            let mut smallest_index = -1;\n            let mut largest_index =\
    \ -1;\n\n            for j in smallest.iter() {\n                if i.abs() <\
    \ j.abs() {\n                    smallest_index = j;\n                }\n    \
    \        }\n\n            for j in largest.iter() {\n                if i.abs()\
    \ < j.abs() {\n                    largest_index = j;\n                }\n   \
    \         }\n\n            if smallest_index == -1 && largest_index == -1 {\n\
    \                smallest.push(i);\n                largest.push(i);\n       \
    \     } else if largest_index == -1 {\n                smallest.push(smallest[smallest.len()\
    \ - 1]);\n                smallest.push(i);\n            } else if smallest_index\
    \ == -1 {\n                largest.push(largest[largest.len() - 1]);\n       \
    \         largest.push(i);\n            } else {\n                if i == smallest[smallest_index]\
    \ {\n                    smallest.push(smallest[smallest_index]);\n          \
    \      } else {\n                    largest.push(largest[largest_index]);\n \
    \               }\n            }\n        }\n    }\n\n    (smallest[smallest.len()\
    \ - 1], largest[largest.len() - 1]);", "    let mut smaller = numbers[0];\n  \
    \  let mut larger = numbers[0];\n    for &x in &numbers {\n        if x < smaller\
    \ { smaller = x; }\n        if x > larger { larger = x; }\n    }\n    (smaller,\
    \ larger)", "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for i in numbers {\n        if i < smallest {\n            smallest = i;\n\
    \        }\n        if i > largest {\n            largest = i;\n        }\n  \
    \  }\n    (smallest, largest)", "    use std::f64;\n    let mut min = f64::MAX;\n\
    \    let mut max = f64::MIN;\n\n    for &n in numbers {\n        if n <= min {\n\
    \            min = n;\n        }\n\n        if n > max {\n            max = n;\n\
    \        }\n    }\n\n    (min, max)", "    let mut min_value = numbers[0];\n \
    \   let mut max_value = numbers[0];\n\n    for value in numbers {\n        min_value\
    \ = std::cmp::min(min_value, value);\n        max_value = std::cmp::max(max_value,\
    \ value);\n    }\n\n    (min_value, max_value)", "    let mut minimum = numbers[0]\
    \ as f64;\n    let mut maximum = numbers[0] as f64;\n    for &n in numbers {\n\
    \        let difference = n - minimum;\n        if difference < 0 {\n        \
    \    minimum = n;\n        } else if difference > 0 {\n            maximum = n;\n\
    \        } else {\n            minimum = n;\n            maximum = n;\n      \
    \  }\n    }\n    (minimum, maximum)", "    assert!(numbers.get(0).is_finite());\n\
    \    assert!(numbers.get(1).is_finite());\n\n    // Find two closest elements\n\
    \    let mut smallest = f64::MAX;\n    let mut largest = numbers.get(0);\n   \
    \ for &n in numbers.iter().skip(1) {\n        let d = n.abs() - smallest;\n  \
    \      if d < 0.0 {\n            smallest = n;\n        } else {\n           \
    \ largest = n;\n        }\n    }\n\n    (smallest, largest)", "    let mut largest\
    \ = numbers.iter().max().unwrap();\n    let mut smallest = numbers.iter().min().unwrap();\n\
    \n    for number in numbers {\n        if number > largest {\n            largest\
    \ = number;\n        }\n        if number < smallest {\n            smallest =\
    \ number;\n        }\n    }\n\n    (smallest, largest)", "    let mut min_d =\
    \ std::f64::MAX;\n    let mut min_d = numbers[0];\n    let mut min_d_idx = 1;\n\
    \    let mut min_d_idx = 1;\n    for &d in numbers {\n        if d < min_d {\n\
    \            min_d = d;\n            min_d_idx = min_d_idx;\n        }\n     \
    \   if d == min_d {\n            min_d_idx += 1;\n        }\n    }\n    (min_d,\
    \ min_d_idx)", "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    (min, max)",
  "    let mut closest_numbers = numbers;\n    closest_numbers.sort();\n    closest_numbers.shrink_to_fit();\n\
    \n    (closest_numbers[1], closest_numbers[0])", "    let mut smallest = numbers[0].clone()\
    \ as f64;\n    let mut biggest = numbers[0].clone() as f64;\n\n    for number\
    \ in numbers.iter().rev() {\n        if number < smallest {\n            smallest\
    \ = number;\n        }\n        if number > biggest {\n            biggest = number;\n\
    \        }\n    }\n\n    (smallest, biggest)", "    let mut smallest_difference\
    \ = numbers.iter().cloned().min_by(|a, b| a.abs() < b.abs()).unwrap();\n    let\
    \ mut closest_number: Vec<f64> = vec![];\n    let mut larger_number: Vec<f64>\
    \ = vec![];\n\n    for i in numbers {\n        let difference = i.abs() - smallest_difference.abs();\n\
    \        if difference < smallest_difference.abs() {\n            closest_number.push(i);\n\
    \        } else {\n            larger_number.push(i);\n        }\n        smallest_difference\
    \ = difference;\n    }\n    (smallest_difference, closest_number, larger_number)",
  "    numbers.iter()\n        .zip(numbers.iter().cloned())\n        .map(|(a, b)|\
    \ (*a - *b).abs())\n        .sorted()\n        .take(2)\n        .expect(\"there\
    \ should be exactly two numbers\")", "    let mut min_distance = 1.0;\n    let\
    \ mut closest_element = (numbers[0], numbers[1]);\n    for (index, number) in\
    \ numbers.iter().enumerate() {\n        let distance = f64::abs (number - closest_element[1]);\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            closest_element = (number, numbers[index]);\n        }\n    }\n \
    \   closest_element", "    let mut min_dist = 1.0;\n    let mut min_number = numbers[0];\n\
    \    let mut max_number = numbers[0];\n\n    for number in numbers.iter() {\n\
    \        let dist = abs(number - min_number);\n\n        if dist < min_dist {\n\
    \            min_number = number;\n            min_dist = dist;\n        }\n\n\
    \        if dist > max_dist {\n            max_number = number;\n            max_dist\
    \ = dist;\n        }\n    }\n\n    (min_number, max_number)", "    if numbers.len()\
    \ < 2 {\n        return (0., 0.);\n    }\n\n    let mut min_distance = numbers.iter().map(|x|\
    \ f64::max(x, f64::EPSILON)).fold(f64::EPSILON, |a, b| a.saturating_sub(b));\n\
    \    let mut max_distance = (numbers[0], numbers[0]);\n    for i in numbers[1..].iter()\
    \ {\n        let distance = numbers.iter().map(|x| x.abs()).fold(f64::EPSILON,\
    \ |a, b| a.saturating_sub(b));\n        if distance < min_distance {\n       \
    \     min_distance = distance;\n            max_distance = (numbers[i], numbers[i]);\n\
    \        } else if distance == min_distance {\n            if max_distance.0 >=\
    \ i {\n                max_distance = (numbers[i], numbers[i]);\n            }\n\
    \        }\n    }\n    (min_distance, max_distance)", "    let mut smallest =\
    \ numbers[0];\n    let mut largest = numbers[0];\n    let mut smallest_index =\
    \ -1;\n    let mut largest_index = -1;\n\n    for i in numbers.iter().rev() {\n\
    \        smallest = i;\n        if i < (&numbers[0]).cloned() {\n            smallest_index\
    \ = numbers.len() - 1;\n        }\n\n        if i > (&numbers[0]).cloned() {\n\
    \            largest_index = 0;\n        }\n\n        if smallest_index == -1\
    \ && largest_index == -1 {\n            break;\n        }\n\n        if smallest\
    \ < numbers[0] {\n            smallest = numbers[0];\n            smallest_index\
    \ = numbers.len() - 1;\n        }\n\n        if largest < numbers[0] {\n     \
    \       largest = numbers[0];\n            largest_index = 0;\n        }\n\n \
    \       if smallest > largest {\n            break;\n        }\n\n        if smallest_index\
    \ == -1 && largest_index == -1 {\n            break;\n        }\n\n        let\
    \ tmp = &numbers[smallest_index];\n        let tmp_diff = tmp - &numbers[0];\n\
    \        let tmp_length = numbers.size();\n\n        if largest < tmp {\n    \
    \        if tmp_length < largest_index {\n                largest_index = tmp_length;\n\
    \            }\n            let tmp_diff = tmp - &numbers[largest_index];\n  \
    \          let tmp_length = numbers.size();\n            largest = tmp;\n    \
    \        if tmp_diff > largest {\n                largest = &numbers[largest_index];\n\
    \                largest_index = numbers.len() - 1;\n            }\n        }\n\
    \n        if smallest > tmp {\n            if tmp_length < smallest_index {\n\
    \                smallest_index = tmp_length;\n            }\n            let\
    \ tmp_diff = tmp - &numbers[smallest_index];\n            let tmp_length = numbers.size();\n\
    \            smallest = tmp;\n            if tmp_diff < smallest {\n         \
    \       smallest = &numbers[smallest_index];\n                smallest_index =\
    \ numbers.len() - 1;\n            }\n        }\n    }\n\n    (smallest, largest)",
  "    let mut i = 0;\n    let mut j = 0;\n    let mut min = numbers[0]; // first\
    \ element of array must be the minimum\n    let mut max = numbers[0]; // second\
    \ element of array must be the maximum\n    let mut mid = numbers[0]; // mid point\
    \ of array must be the first element of the array\n    while i < numbers.len()\
    \ && j < numbers.len() {\n        if numbers[i].abs() < numbers[j].abs() {\n \
    \           min = numbers[i];\n            j = j + 1;\n        } else {\n    \
    \        max = numbers[j];\n            i = i + 1;\n        }\n    }\n    if j\
    \ > 0 {\n        mid = min + (max - min) / 2;\n    } else {\n        mid = min;\n\
    \    }\n    (min, mid)", "    numbers.iter().cloned().windows(2).flat_map(|numbers|\n\
    \        (numbers[0].abs() as i64, numbers[1].abs() as i64).min(|a, b| a.abs()\
    \ < b.abs())\n    )\n    .collect()", "    let mut smallest = numbers[0];\n  \
    \  let mut largest = numbers[0];\n    for i in numbers.iter().rev() {\n      \
    \  if *i < smallest {\n            smallest = *i;\n        }\n        if *i >\
    \ largest {\n            largest = *i;\n        }\n    }\n    (smallest, largest)",
  "    numbers.sort_unstable();\n    let smallest = numbers[0];\n    let largest =\
    \ numbers[0];\n    for element in &numbers {\n        if element < smallest {\n\
    \            smallest = element;\n        }\n        if element > largest {\n\
    \            largest = element;\n        }\n    }\n    (smallest, largest)", " \
    \   let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n    for\
    \ number in numbers.iter() {\n        if number < min {\n            min = number;\n\
    \        }\n        if number > max {\n            max = number;\n        }\n\
    \    }\n    (min, max)", "    if numbers.len() < 2 {\n        (numbers[0], numbers[1])\n\
    \    } else {\n        let mut smallest: f64 = numbers[0];\n        let mut largest_minus_smallest:\
    \ f64 = numbers[1];\n        for n in numbers[2..] {\n            let midpoint\
    \ = (n + smallest) as f64 / 2.0;\n            smallest = midpoint if midpoint\
    \ < smallest { smallest = midpoint };\n            largest_minus_smallest = midpoint\
    \ if midpoint > largest_minus_smallest { largest_minus_smallest = midpoint };\n\
    \        }\n        (smallest, largest_minus_smallest)\n    }", "    // Find the\
    \ two smallest numbers and make sure they are in order\n    let mut smallest_num\
    \ = numbers[0];\n    let mut other_num = numbers[0];\n\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < smallest_num {\n            smallest_num = numbers[i];\n\
    \        }\n        if numbers[i] > other_num {\n            other_num = numbers[i];\n\
    \        }\n    }\n    // Return the smallest and other number in order\n    (smallest_num,\
    \ other_num)", "    if numbers.len() < 2 {\n        return (0.0, 0.0);\n    }\n\
    \n    let mut smallest = numbers[0].clone();\n    let mut largest = numbers[0].clone();\n\
    \    for (i, _) in numbers.iter().enumerate() {\n        if largest < numbers[i]\
    \ {\n            largest = numbers[i].clone();\n        }\n        if smallest\
    \ > numbers[i] {\n            smallest = numbers[i].clone();\n        }\n    }\n\
    \n    (smallest, largest)", "    let mut smallest_number = numbers[0];\n    let\
    \ mut largest_number = numbers[0];\n    for i in numbers {\n        if i < smallest_number\
    \ {\n            smallest_number = i;\n        }\n        if i > largest_number\
    \ {\n            largest_number = i;\n        }\n    }\n    (smallest_number,\
    \ largest_number)", "    assert!(numbers.len() >= 2);\n    let mut smallest =\
    \ numbers[0];\n    let mut largest = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > largest {\n            largest = numbers[i];\n  \
    \      }\n        if numbers[i] < smallest {\n            smallest = numbers[i];\n\
    \        }\n    }\n    (smallest, largest)", "    let mut min_dist = FLT_MAX;\n\
    \    let mut min_index = 0;\n    for (index, &value) in numbers.iter().enumerate()\
    \ {\n        let dist = value - min_dist;\n        if dist < min_dist {\n    \
    \        min_dist = dist;\n            min_index = index;\n        }\n    }\n\
    \    (numbers[min_index], numbers[min_index + 1])", "    let mut current_min =\
    \ std::f64::MAX;\n    let mut current_max = std::f64::MIN;\n\n    for number in\
    \ numbers.iter() {\n        if number > current_max {\n            current_max\
    \ = number;\n        }\n        if number < current_min {\n            current_min\
    \ = number;\n        }\n    }\n\n    (current_min, current_max)", "    let mut\
    \ smaller: f64 = numbers[0];\n    let mut larger: f64 = numbers[0];\n    for &n\
    \ in numbers {\n        if n < smaller { smaller = n; }\n        if n > larger\
    \ { larger = n; }\n    }\n    (smaller, larger)", "    assert!(numbers.len() >=\
    \ 2);\n    let mut min_value = numbers[0];\n    let mut min_diff = f64::MAX;\n\
    \n    for n in numbers.iter().skip(1) {\n        let diff = n - min_value;\n\n\
    \        if diff < min_diff {\n            min_value = n;\n            min_diff\
    \ = diff;\n        }\n    }\n\n    return (min_value, min_diff);", "    // Make\
    \ sure we have at least two elements.\n    if numbers.len() < 2 {\n        return\
    \ (numbers[0], numbers[0]);\n    }\n    // Sort them by distance.\n    numbers.sort_by_key(|number|\
    \ number.to_f64());\n    let mut smallest = numbers[0];\n    let mut largest =\
    \ numbers[0];\n    for &n in numbers {\n        if n < smallest {\n          \
    \  smallest = n;\n        }\n        if n > largest {\n            largest = n;\n\
    \        }\n    }\n    (smallest, largest)", "    let mut smallest_diff = F64::MIN;\n\
    \    let mut smaller_number = numbers[0];\n    for number in &numbers[1..] {\n\
    \        let diff = abs(number - smaller_number);\n        if diff < smallest_diff\
    \ {\n            smallest_diff = diff;\n            smaller_number = number;\n\
    \        }\n    }\n    (smaller_number, smallest_diff)"]
stop_tokens:
- "\n}"
