name: HumanEval_59_largest_prime_factor
language: rust
prompt: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
  /// 2\nfn largest_prime_factor(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
  \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n  \
  \  assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
completions: ["    (1..=n)\n        .filter(|factor| n % factor == 0)\n        .max().unwrap()",
  "    let mut i = 2;\n    let mut j = 2;\n    while i * j <= n {\n        if n %\
    \ i == 0 {\n            i += 1;\n            j += 1;\n        }\n        else\
    \ {\n            i += j;\n            j = i;\n        }\n    }\n    i", "    if\
    \ n < 2 || is_prime(n) {\n        return n;\n    }\n\n    let mut f = 2;\n   \
    \ let mut m = n;\n    while !is_prime(m) {\n        f += 1;\n        while m %\
    \ f == 0 {\n            m /= f;\n        }\n    }\n\n    f", "    let mut i =\
    \ 2;\n    let mut max_i = i;\n    let mut j = i;\n    while i < n {\n        while\
    \ j > 1 && n % j == 0 {\n            j += i;\n        }\n        if j == i {\n\
    \            max_i = i;\n        }\n        i += 1;\n        j = i;\n    }\n \
    \   max_i", "    use std::cmp::Ordering;\n\n    let mut f = 1;\n    let mut i\
    \ = 3u64;\n\n    while i * i <= n {\n        if n % i == 0 {\n            i +=\
    \ 1;\n        } else {\n            f += i;\n        }\n    }\n\n    if f <= n\
    \ {\n        f\n    } else {\n        n\n    }", "    let mut ret = 1;\n    let\
    \ mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            ret = i;\n\
    \            i += 2;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    ret", "    // TODO: more efficient way\n    if n % 2 == 0 {\n        n /\
    \ 2\n    } else {\n        let i = 2u64;\n        n / i while i <= n / 2\n   \
    \ }", "    if n > 1 {\n        let mut i = 2;\n        while i * i <= n {\n  \
    \          i += 1;\n        }\n        if n % i == 0 {\n            i\n      \
    \  } else {\n            i\n        }\n    } else {\n        1\n    }", "    //\
    \ First check that the number is a prime.\n    if n <= 1 {\n        return 1;\n\
    \    }\n\n    // Check if the number is composite.\n    if n%2 == 0 {\n      \
    \  return 2;\n    }\n\n    let mut m = n as isize;\n    // Find the largest factor\
    \ of n.\n    for _ in 0..n {\n        m += 1;\n        if m > n {\n          \
    \  break;\n        }\n    }\n    m", "    let mut i = 2;\n\n    // Keep finding\
    \ largest prime factors, starting with i.\n    while i <= n {\n        let m =\
    \ n % i;\n\n        if m != 0 {\n            return i;\n        }\n        i +=\
    \ 1;\n    }\n\n    // No factors found. Return 1.\n    1", "    use std::cmp::Ordering;\n\
    \n    let mut factors = Vec::new();\n    factors.push(2);\n\n    for &factor in\
    \ &factors {\n        if n % factor == 0 {\n            factors.push(factor);\n\
    \            n /= factor;\n        }\n    }\n\n    if n > 1 {\n        factors.push(1);\n\
    \    }\n\n    factors.iter().max().unwrap()", "    let mut i = 2;\n    let mut\
    \ factor = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            factor\
    \ *= i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    factor", "    let mut factors = vec![1];\n    for num in 2..=n {\n\
    \        if n % num == 0 {\n            let factor: isize = num;\n           \
    \ factors.push(factor);\n            n /= num;\n        }\n    }\n\n    factors\n\
    \        .iter()\n        .skip(1)\n        .max()\n        .unwrap()", "    let\
    \ mut largest_factor = 0;\n    let mut primes_taken = HashSet::new();\n    let\
    \ mut i = 2;\n    while i <= n {\n        if primes_taken.insert(&i).is_ok() {\n\
    \            if n % i == 0 {\n                largest_factor = i;\n          \
    \  }\n        }\n        i += 1;\n    }\n    largest_factor", '    largest_prime_factor_helper(n,
    1, 0, Vec::new())', "    let mut i = 2;\n    let mut factor = 1;\n    while i\
    \ * i <= n {\n        if n % i == 0 {\n            factor *= i;\n            n\
    \ /= i;\n        } else {\n            i += 1;\n        }\n    }\n    factor",
  "    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   return i;\n        }\n        i += 1;\n    }\n    return n;", "    (1..).skip_while(|x|\
    \ *x % n != 0)\n        .skip_while(|x| *x == 0)\n        .max()", "    let mut\
    \ i = 2;\n    while i <= n {\n        while n % i == 0 {\n            i += 1;\n\
    \        }\n        if i == 2 {\n            break;\n        }\n        i += 1;\n\
    \    }\n    i", "    let mut m = n;\n    let mut factor = 1;\n    while m > 1\
    \ {\n        let p = &*m / factor;\n        if *p == 1 {\n            return factor;\n\
    \        }\n        if p % 2 == 0 {\n            m = (*p * m) / 2;\n         \
    \   factor = factor * 2;\n        } else {\n            m = (*p * m) / 3;\n  \
    \          factor = factor * 3;\n        }\n    }\n    factor", '    largest_factor(n).unwrap()',
  "    let mut i = 2;\n    let mut m = i;\n    while i <= n {\n        let p1 = i;\n\
    \        while p1 % m == 0 {\n            p1 /= m;\n        }\n        p1 = m;\n\
    \        while p1 % (i * i) == 0 {\n            p1 /= i * i;\n        }\n    \
    \    if p1 < n {\n            m = p1;\n        }\n        i += 1;\n    }\n   \
    \ m", "    let mut m = n / 2;\n    while m % 2 == 0 {\n        m /= 2;\n    }\n\
    \    m", "    let mut n = n as u64;\n    let mut i = 2;\n\n    loop {\n      \
    \  loop {\n            if n % i == 0 {\n                n /= i;\n            \
    \    return i;\n            }\n\n            i += 1;\n        }\n    }", "   \
    \ (2..=n).fold(1, |a, b| {\n        if n % a == 0 {\n            a\n        }\
    \ else {\n            if n % b == 0 {\n                b\n            } else {\n\
    \                (a * b) / b\n            }\n        }\n    })", "    let mut\
    \ n = n;\n    let mut i = 2;\n    let mut m = 3;\n    while i * i <= n {\n   \
    \     if n % i == 0 {\n            i += m;\n        } else {\n            i +=\
    \ 2;\n        }\n        m += 2;\n    }\n    i", "    let mut m = n;\n    let\
    \ mut k = m;\n    let mut i = 2;\n    while i <= k {\n        if n % i == 0 {\n\
    \            m = i;\n            k = n / i;\n        }\n        i += 1;\n    }\n\
    \    m", '    prime_factors(n).iter().max().unwrap()', "    debug_assert!(n >\
    \ 1);\n    let mut result = 1;\n    for i in 2..n {\n        if n % i == 0 {\n\
    \            result = i;\n            break;\n        }\n    }\n    result", " \
    \   let mut i = 2; // 2 is the smallest possible factor\n    loop {\n        while\
    \ i * i <= n {\n            if n % i == 0 {\n                n /= i;\n       \
    \         break\n            }\n            i += 1;\n        }\n    }\n    n",
  "    let mut max_divisor = 1;\n    let mut i = 2;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            max_divisor = i;\n            i += 1;\n        } else\
    \ {\n            i += 2;\n        }\n    }\n    max_divisor", "    let mut is_prime\
    \ = true;\n    let mut max_factor = 1;\n    let mut factor = 2 * n + 1;\n    while\
    \ factor <= n {\n        if n % factor == 0 {\n            is_prime = false;\n\
    \        }\n        factor = factor * 2 + 1;\n    }\n    if is_prime {\n     \
    \   max_factor\n    } else {\n        factor\n    }", "    // Fast path: n is\
    \ small or is not a prime\n    if n <= 2 || n % 2 == 0 {\n        return 1;\n\
    \    }\n\n    // Largest prime factor is less than n\n    let mut i = 2;\n   \
    \ let mut prime_found = false;\n    while i * i < n && !prime_found {\n      \
    \  if n % i == 0 {\n            prime_found = true;\n        } else {\n      \
    \      i += 2;\n        }\n    }\n\n    // Only prime factors larger than n are\
    \ returned\n    if prime_found && i > n {\n        i\n    } else {\n        i\n\
    \    }", "    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            i += 1;\n        } else {\n            i -= 1;\n        }\n    }\n\
    \    i", "    let mut m = 0;\n    for i in 2..=n {\n        if n % i == 0 {\n\
    \            m = i;\n        }\n    }\n    m", "    let mut i = 1;\n    let mut\
    \ max = 1;\n    while i < n {\n        if n % i == 0 {\n            i += 2;\n\
    \        } else {\n            i += 1;\n            max = i;\n        }\n    }\n\
    \    max", "    let mut i = 2;\n    let mut s = i;\n    while s < n {\n      \
    \  if n % i == 0 {\n            i += 2;\n        }\n        i += 1;\n        s\
    \ -= i;\n    }\n    s", "    let mut i: isize = 2;\n    let mut m = 0;\n    while\
    \ i <= n {\n        if n % i == 0 {\n            i += 1;\n            m += 1;\n\
    \        } else {\n            i += 2;\n        }\n    }\n    m", "    let mut\
    \ i = 2;\n    while i <= sqrt(n as u64) {\n        if n % i == 0 {\n         \
    \   return i;\n        }\n        i += 1;\n    }\n    n", "    if n == 1 {\n \
    \       return 1;\n    }\n\n    let mut i = 2;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            return i;\n        }\n        i += 2;\n    }\n\n \
    \   n", "    let mut i = 2;\n    let mut f = 1;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            i += 1;\n        } else {\n            f += 1;\n \
    \       }\n    }\n    f", "    // n is prime\n    if n < 2 {\n        return 1;\n\
    \    }\n\n    // n is a prime\n    if n == 2 {\n        return 1;\n    }\n\n \
    \   // n is a perfect power of two\n    if n == std::i32::MAX {\n        return\
    \ n;\n    }\n\n    let mut n = n; while n >= 2 {\n        if n % 2 == 0 {\n  \
    \          n /= 2;\n        } else {\n            return n;\n        }\n    }\n\
    \n    // n isn't a prime but n != std::i32::MAX\n    n", "    let mut res = 2i32;\n\
    \    let mut i = 2i32;\n    while i < n {\n        if n % i == 0 {\n         \
    \   i += 1;\n        } else {\n            res = i;\n            break;\n    \
    \    }\n    }\n    res", "    // https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_number\n\
    \    fn test_primality(n: isize) -> bool {\n        // https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_number\n\
    \        // https://en.wikipedia.org/wiki/Primality_test#Test_of_prime_number\n\
    \        if n <= 1 {\n            return true;\n        }\n        if n % 2 ==\
    \ 0 {\n            return false;\n        }\n        for d in prime_divisors(n)\
    \ {\n            if n % d == 0 {\n                return false;\n            }\n\
    \        }\n        return true;\n    }\n    fn max_factor(n: isize) -> isize\
    \ {\n        if n % 2 == 0 {\n            return 2;\n        }\n        let mut\
    \ max_factor = 2;\n        for d in prime_divisors(n) {\n            if n % d\
    \ == 0 {\n                let new_factor = max_factor * d;\n                if\
    \ new_factor < n {\n                    return max_factor;\n                }\n\
    \                max_factor = new_factor;\n            }\n        }\n        return\
    \ max_factor;\n    }\n    // https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_number\n\
    \    // https://en.wikipedia.org/wiki/Primality_test#Test_of_prime_number\n  \
    \  if test_primality(n) {\n        return max_factor(n);\n    }\n    // https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_number\n\
    \    // https://en.wikipedia.org/wiki/Primality_test#Test_of_prime_number\n  \
    \  for d in prime_divisors(n) {\n        if n % d == 0 {\n            return max_factor(n);\n\
    \        }\n    }\n    return 2;", "    let mut i = 3;\n    loop {\n        if\
    \ n % i == 0 {\n            i += 1;\n        }\n        else {\n            return\
    \ i;\n        }\n    }", '    largest_prime_factor_factor_internal(n, 1, n)',
  "    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   i *= 2;\n        } else {\n            i += 1;\n        }\n    }\n    i",
  "    // Look at each divisor from 1 to sqrt(n).\n    let mut factors = Vec::new();\n\
    \    for i in (1..n).step_by(2) {\n        let divisor = n - i;\n        if divisor\
    \ % 2 == 0 {\n            factors.push(divisor / 2);\n        } else {\n     \
    \       factors.push(i);\n        }\n    }\n    // Keep the largest prime factor\
    \ of n.\n    factors.iter().max().unwrap_or(n)", "    let mut i = 2;\n    let\
    \ mut largest = i;\n\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest = i;\n            i += 1;\n        } else if i != 1 {\n       \
    \     i += 1;\n        }\n    }\n\n    largest", "    let mut factors = Vec::new();\n\
    \    for (i, &p) in factor(n).iter().enumerate() {\n        if i == 0 {\n    \
    \        factors.push(p as isize);\n        } else {\n            if p > factors[i\
    \ - 1].unwrap() {\n                factors.truncate(i);\n                break;\n\
    \            }\n        }\n    }\n    factors.pop()", "    // First calculate\
    \ the squareroot of n\n    let sqrt_n = isize::sqrt(n);\n\n    // Now we calculate\
    \ the largest prime factor of the squareroot\n    let mut largest_prime_factor\
    \ = 1;\n    while sqrt_n >= 4 {\n        largest_prime_factor += 1;\n        sqrt_n\
    \ = sqrt_n / 4;\n    }\n    largest_prime_factor", '    largest_prime_factor_factor_iter(n).unwrap()',
  "    let mut prime_divisor = 2isize;\n    let mut prime_divisor_found = false;\n\
    \    for i in 2..=n.bit_count() {\n        prime_divisor = i if n % i == 0 &&\
    \ !prime_divisor_found {\n            prime_divisor;\n        };\n        prime_divisor_found\
    \ = (prime_divisor as bool);\n    }\n    prime_divisor", "    let mut i = 2;\n\
    \    while i <= n {\n        if n % i == 0 {\n            return i;\n        }\n\
    \        i += 1;\n    }\n    n", "    let mut i = 1u64;\n    let mut factor =\
    \ 1;\n\n    while i * factor <= n {\n        if n % i == 0 {\n            factor\
    \ *= i;\n            i += 1;\n        }\n        else {\n            i += 1;\n\
    \        }\n    }\n    factor", "    let mut max_factor = 0;\n    let mut i =\
    \ 2;\n    while i * i <= n {\n        if n % i == 0 {\n            if max_factor\
    \ < i {\n                max_factor = i;\n            }\n        }\n        i\
    \ += 1;\n    }\n    max_factor", "    let mut i = 2;\n    let mut primes: Vec<isize>\
    \ = vec![0; n];\n    while i <= n {\n        if n % i == 0 {\n            primes.push(i);\n\
    \            i += 2;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    if primes.len() == 1 {\n        primes[0]\n    } else {\n        let mut\
    \ max = primes[0];\n        for prime in primes {\n            if prime > max\
    \ {\n                max = prime;\n            }\n        }\n        max\n   \
    \ }", "    (2..=n).fold(1, |acc, factor| {\n        if n % factor == 0 {\n   \
    \         acc\n        } else {\n            acc * factor\n        }\n    })",
  "    let mut factor = 2;\n    let mut i = 2;\n    while i <= sqrt(n as usize) {\n\
    \        if n % i == 0 {\n            factor *= i;\n            i += 1;\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    factor", "    let mut\
    \ i = 2;\n    let mut prime_factor = 1;\n\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            prime_factor = i;\n            i += 1;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    prime_factor", "    let mut\
    \ max_factor: isize = 0;\n    let mut n: isize = n;\n    while n > 1 {\n     \
    \   max_factor = n;\n        // Find largest prime factor\n        for p in sieve(n.checked_mul(max_factor).ok())\
    \ {\n            if p.checked_mul(max_factor).is_one() {\n                max_factor\
    \ = p.checked_mul(max_factor).unwrap();\n                break;\n            }\n\
    \        }\n        // If no prime factor is found, stop\n        if max_factor\
    \ == 1 {\n            break;\n        }\n        n = n.checked_mul(max_factor).unwrap();\n\
    \    }\n    max_factor", '    largest_prime_factor_factors(&[&n])', "    let mut\
    \ i: isize = 0;\n    while i < n {\n        i += 2;\n        if n % i == 0 {\n\
    \            n = n / i;\n        } else {\n            break;\n        }\n   \
    \ }\n    n", "    let mut res = 1;\n    while n % res == 0 {\n        n /= res;\n\
    \        res++;\n    }\n    res", "    let mut result = n;\n    let mut max_factor\
    \ = 2;\n    while result == 1 {\n        if n % max_factor == 0 {\n          \
    \  max_factor += 1;\n        }\n        result /= max_factor;\n    }\n    result",
  "    let mut i = 2; // Only odd numbers.\n    loop {\n        if n % i == 0 {\n\
    \            i += 1;\n        } else if i * i > n { break }\n    }\n    i", " \
    \   let mut n2 = 2isize;\n    let mut prime: isize = 2;\n    while n2 <= n {\n\
    \        if n % n2 == 0 {\n            prime += 2;\n            n /= n2;\n   \
    \     }\n        n2 += 1;\n    }\n    prime", "    if n < 2 {\n        return\
    \ n;\n    }\n    let mut f: isize = 1;\n    while f * f <= n {\n        if n %\
    \ f == 0 {\n            break;\n        }\n        f += 1;\n    }\n    f", " \
    \   let mut f = 3usize;\n    while n % f == 0 { f *= 2; }\n    f", "    let mut\
    \ i = 2; // start at 2 since 2 is the first prime factor of n\n\n    while i*i\
    \ <= n { // while i*i still less than n\n        if n % i == 0 { // if n%i zero,\
    \ then n is not a prime\n            break;\n        }\n        i += 1;\n    }\n\
    \    i // i is the greatest prime factor of n", "    let mut max_factor = 1;\n\
    \    let mut max_factor_size = 1;\n    let mut i = 2;\n    for factor in prime_numbers::iter().take_while(u64::is_odd)\
    \ {\n        if n < factor {\n            break;\n        }\n\n        if n %\
    \ factor == 0 {\n            i -= 1;\n            max_factor_size = factor;\n\
    \        }\n\n        if i > n / factor {\n            max_factor = 1;\n     \
    \       max_factor_size = factor;\n        }\n\n        if max_factor > n / factor\
    \ {\n            break;\n        }\n    }\n\n    assert!(\n        max_factor_size\
    \ == 1,\n        \"The largest prime factor of {} should be 1. However, the {}\
    \ prime factor is {}.\",\n        n,\n        n / max_factor_size,\n        max_factor_size\n\
    \    );\n    max_factor", "    let mut primes = vec![false; n + 1];\n    let mut\
    \ factor = 2;\n    while primes[factor] == false {\n        primes[factor] = true;\n\
    \        factor += 1;\n    }\n    factor", "    let mut i = 1\n    let mut j =\
    \ 2\n    while i * j <= n {\n        if n % i == 0 {\n            i += 1;\n  \
    \          while n % i == 0 {\n                i += 1;\n            }\n      \
    \      if i == n / i {\n                return i\n            }\n        }\n \
    \       j += 1;\n    }\n    i + 1", "    let mut prime_factor = 1;\n    for i\
    \ in 2..=n {\n        let mut i = i;\n        let mut limit = 1;\n        while\
    \ i * i <= n {\n            if n % i == 0 {\n                limit = i;\n    \
    \            break;\n            }\n            i += 1;\n        }\n        if\
    \ limit != 1 {\n            prime_factor = i;\n        }\n    }\n    prime_factor",
  "    let mut factors = vec![1; n];\n\n    factors.next_back()\n        .unwrap()\n\
    \        .rev()\n        .enumerate()\n        .for_each(|(i, factor)| {\n   \
    \         if !is_prime(&factor) {\n                factors.remove(i);\n      \
    \      }\n        });\n\n    factors.iter().max().unwrap()", '    (1..=sqrt(n
    as f64)).iter().filter(|factor| n % factor == 0).max()', "    let mut factors\
    \ = vec![1; n];\n\n    while n != 1 {\n        for &factor in factors.iter_mut()\
    \ {\n            if n % factor == 0 {\n                factors.swap(0, factor);\n\
    \                n /= factor;\n                break;\n            }\n       \
    \ }\n    }\n\n    factors.iter().max().unwrap_or(1)", '    largest_prime_factor_factors(&[2..n]).unwrap()',
  "    // Sieve of Eratosthenes to find all prime factors\n    let mut primes = vec![];\n\
    \    for (i, &c) in n.into_iter().cloned().combinations(|&x| *x == 0) {\n    \
    \    if !(i%c) {\n            primes.push(i);\n        }\n    }\n\n    // Sieve\
    \ of Atkin's algorithm to find the largest prime\n    primes.iter().max().unwrap_or(1)",
  '    factors::largest_prime_factor(n)', "    let mut factor = 1;\n    while n %\
    \ factor == 0 {\n        factor *= 2;\n    }\n    while n > 1 {\n        factor\
    \ *= 2;\n        if n % factor == 0 {\n            break;\n        }\n       \
    \ n /= factor;\n    }\n    n", "    fn is_prime(p: isize) -> bool {\n        let\
    \ mut i = 2;\n        while i * i <= p { i += 2; }\n        i <= p / 2 && p %\
    \ i == 0\n    }\n    let mut max = 2;\n    while max < n {\n        if is_prime(max)\
    \ {\n            max += 1;\n        }\n        else {\n            max = max *\
    \ 2;\n        }\n    }\n    max", "    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            return i;\n        }\n        i += 1;\n\
    \    }\n    n // i", '    largest_prime_factors(&n)[0].clone()', "    n.checked_div(2).expect(\"\
    n must be positive\")\n        .checked_gcd(&n).expect(\"n must be positive\"\
    )\n        .unwrap_or(n - 1)", '    (1..n).find(|x| n % x == 0).unwrap()', " \
    \   debug_assert!(n > 1);\n    debug_assert!(n % 2 == 0);\n\n    for i in 2..n\
    \ {\n        if n % i == 0 {\n            return i;\n        }\n    }\n\n    n",
  '    large_prime_factor(n, n)', "    let mut i = 2; // 2 will be prime and only\
    \ needs to be tested once\n    let mut max = prime_factors(&mut i, n);\n    let\
    \ mut factor = max;\n    while factor != 1 {\n        if n % factor == 0 {\n \
    \           max += 1;\n        }\n        factor += 1;\n    }\n    max", "   \
    \ let mut i: isize = n;\n    while i > 1 {\n        i = i / 2;\n        if n %\
    \ i == 0 {\n            i = i + 1;\n        }\n    }\n    i", "    let mut i =\
    \ 2;\n    while i * i <= n {\n        if n % i == 0 {\n            return i;\n\
    \        }\n        i += 1;\n    }\n    i", "    let mut max_divisor = 1;\n  \
    \  let mut next_divisor = 2;\n    let mut prime_divisor = 1;\n\n    for _ in 0..n\
    \ / 2 {\n        if n % next_divisor == 0 {\n            prime_divisor = next_divisor;\n\
    \            next_divisor += 1;\n        } else {\n            max_divisor = next_divisor;\n\
    \            next_divisor += 1;\n        }\n    }\n\n    max_divisor", "    let\
    \ mut n = n as isize;\n    fn isPrime(n: isize) -> bool {\n        n <= 1\n  \
    \  }\n    let mut i = 2;\n    while i * i < n && isPrime(i) {\n        i += 1;\n\
    \    }\n    i", "    let mut f = 1;\n    let mut p = 2;\n    while p * p <= n\
    \ {\n        if n % p == 0 {\n            f *= p;\n        }\n        p *= 3;\n\
    \    }\n    f", "    let mut factor: isize = 1;\n    while n % factor == 0 {\n\
    \        factor *= 2;\n    }\n    factor", "    if n < 2 {\n        return n;\n\
    \    }\n    let mut max_num = n::max_value();\n    for i in 2..max_num {\n   \
    \     if n % i == 0 {\n            return i;\n        }\n    }\n    return n;",
  "    let mut i = 2;\n    let mut prime_factor = 1;\n    loop {\n        if n % i\
    \ == 0 {\n            prime_factor = i;\n            i += 2;\n        } else if\
    \ i == n / prime_factor {\n            return prime_factor;\n        } else {\n\
    \            i += 1;\n        }\n    }", "    let mut i = 2;\n    let mut j =\
    \ 2;\n    while i * j <= n {\n        if n % i == 0 {\n            i += 1;\n \
    \       } else if n % j == 0 {\n            j += 1;\n        } else {\n      \
    \      break;\n        }\n    }\n    if i * j <= n {\n        i * j\n    } else\
    \ {\n        i\n    }", "    let mut i = 2;\n    let mut max = 1;\n\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            max = i;\n            i +=\
    \ 1;\n        }\n        i += 1;\n    }\n\n    if max == 1 {\n        0\n    }\
    \ else {\n        max\n    }", "    let mut prime: isize = 0;\n    let mut divisor:\
    \ isize = 1;\n    while n > 1 {\n        if n % divisor == 0 {\n            divisor\
    \ *= 2;\n            prime += 1;\n        } else {\n            divisor += 1;\n\
    \        }\n        n /= 2;\n    }\n    prime", "    let mut f = 0usize;\n   \
    \ let mut m = 0usize;\n    let mut p = 1usize;\n    let mut q = 2usize;\n    while\
    \ p * p <= n {\n        if n % p == 0 {\n            n /= p;\n            f +=\
    \ 1;\n        } else {\n            if p * p > n {\n                break;\n \
    \           }\n            if n % q == 0 {\n                n /= q;\n        \
    \        m += 1;\n            } else {\n                if q * q > n {\n     \
    \               break;\n                }\n                if q * q == n {\n \
    \                   q /= q;\n                    p += 1;\n                } else\
    \ {\n                    if q * q > n {\n                        break;\n    \
    \                }\n                    q /= q;\n                    m += 1;\n\
    \                }\n            }\n        }\n    }\n    f as isize * m", "  \
    \  // TODO: find a better way of doing this\n    if n <= 1 {\n        return 1;\n\
    \    }\n\n    let mut prime = n - 1;\n    let mut i = 2;\n\n    while i <= sqrt(n)\
    \ {\n        if n % i == 0 {\n            prime -= 1;\n            n /= i;\n \
    \       } else {\n            i += 1;\n        }\n    }\n    prime", "    let\
    \ mut f = 2; // Starting at 2, since 1 is not a prime number.\n    while f * f\
    \ <= n {\n        if n % f == 0 {\n            n = n / f;\n        } else {\n\
    \            f = f + 2;\n        }\n    }\n    if n > 2 {\n        largest_prime_factor(n\
    \ - 1)\n    } else {\n        n\n    }", "    let mut prime_factors = HashSet::new();\n\
    \    let mut i = 2; // i is always greater than 1.\n    while i <= n {\n     \
    \   if prime_factors.contains(&i) {\n            i += 2;\n        } else if n\
    \ % i == 0 {\n            prime_factors.insert(i);\n            i += 1;\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    prime_factors.len()",
  "    if n == 1 { return 1; }\n    if n % 2 == 0 { return 2; }\n    \n    let mut\
    \ candidate = 3; // Prime factor: 3\n    \n    // Start by testing primes\n  \
    \  loop {\n        if n % candidate == 0 { return candidate; }\n        candidate\
    \ += 2;\n    }", "    // First guess is 2, then increment by 2 to get the next\
    \ guess. We have\n    // a chance that we can break out of that loop quickly on\
    \ large numbers.\n    let mut factors = vec![2];\n    let mut i = 0;\n    while\
    \ i < n {\n        if n % i == 0 {\n            factors.push(i);\n           \
    \ i += 2;\n        } else {\n            i += 1;\n        }\n    }\n    factors.max()",
  "    let mut m = n;\n    let mut i = 2;\n    while i * i <= m {\n        if m %\
    \ i == 0 {\n            m = m / i;\n            i = 2;\n        }\n        else\
    \ {\n            i += 1;\n        }\n    }\n    i", "    use std::cmp::Ordering;\n\
    \    let mut m = n as isize;\n    loop {\n        m /= 2;\n        if m > 1 {\n\
    \            break;\n        }\n        // TODO: use sieve for bigger numbers\n\
    \        let c = primes::<isize>[m];\n        if Ordering::cmp(&c, &1) == Ordering::Greater\
    \ {\n            return m;\n        }\n    }\n    n", "    let mut factors = vec![];\n\
    \    for (i, &k) in factorization(n).iter().enumerate() {\n        if *k <= n\
    \ {\n            return *k;\n        }\n        for factor in factors.iter().rev()\
    \ {\n            if factor % n == 0 {\n                return *factor;\n     \
    \       }\n        }\n        factors.push(k);\n    }\n    factors.iter().max().unwrap_or(1)",
  "    factors::factorize(n)\n        .max()\n        .unwrap_or(n)", "    if n %\
    \ 2 == 0 {\n        2\n    } else if n % 3 == 0 {\n        3\n    } else {\n \
    \       // Start at 3 and move only odd numbers up\n        let mut i = 3;\n \
    \       while i * i <= n && n % i == 0 {\n            i += 2;\n        }\n   \
    \     i\n    }", "    let mut largest = n;\n    let mut i: isize = 1;\n\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            largest = i;\n        }\n\
    \n        i += 1;\n    }\n\n    if largest <= n {\n        largest\n    } else\
    \ {\n        largest\n    }", "    let mut result = 1;\n    while result <= n\
    \ {\n        let mut i = result;\n        let mut j = 1;\n        while j * i\
    \ <= n {\n            i += 1;\n            j *= i;\n        }\n        result\
    \ = i;\n    }\n    result", "    let mut i = 2;\n    let mut prime_factor: isize\
    \ = 1;\n    while i * prime_factor <= n && n >= 2 {\n        if n % i == 0 {\n\
    \            i += 1;\n        } else {\n            prime_factor *= i;\n     \
    \   }\n        i += 1;\n    }\n    prime_factor", "    if n < 2 { return 2 }\n\
    \n    let mut factors = vec![2..=n];\n\n    for &factor in &factors {\n      \
    \  if n % factor == 0 {\n            factors.remove(factor);\n            break;\n\
    \        }\n    }\n\n    factors.last().unwrap_or(1)", "    if n <= 1 {\n    \
    \    n\n    } else {\n        let mut i = 1u64;\n        while i * i <= n {\n\
    \            if n % i == 0 {\n                return i;\n            }\n     \
    \       i += 1;\n        }\n        n\n    }", "    let mut factors = vec![0;\
    \ n as usize];\n    let mut prime_divisor = 1;\n    let mut prime_factor = 0;\n\
    \    while prime_divisor <= n {\n        if n % prime_divisor == 0 {\n       \
    \     factors[prime_factor] = prime_divisor;\n            if n == prime_divisor\
    \ * prime_divisor {\n                // Odd divisor\n                if prime_divisor\
    \ == 2 {\n                    // Even divisor of a prime\n                   \
    \ factors[0] = prime_divisor;\n                } else {\n                    //\
    \ Not a prime\n                    return 0;\n                }\n            }\n\
    \        } else {\n            prime_divisor *= 2;\n        }\n    }\n    for\
    \ &factor in factors.iter() {\n        if factor > n {\n            break;\n \
    \       }\n    }\n    return factors[factors.len() - 1];", "    let mut prime_factors\
    \ = vec![0; n + 1];\n    let mut prime_factor = 1;\n    while n % prime_factor\
    \ == 0 {\n        prime_factors[prime_factors as usize + 1] += 1;\n        n /=\
    \ prime_factor;\n        prime_factor *= prime_factors;\n    }\n    prime_factors[prime_factors\
    \ as usize + 1]", "    loop {\n        if n % 2 == 0 {\n            n /= 2;\n\
    \            continue;\n        }\n\n        let mut i = 3;\n        while i *\
    \ i <= n {\n            if n % i == 0 {\n                n /= i;\n           \
    \     continue;\n            }\n            i += 1;\n        }\n\n        if n\
    \ == 1 {\n            return n;\n        }\n    }", "    let mut factors = vec![];\n\
    \    let mut prime = true;\n    while n != 1 {\n        if n % 2 == 1 {\n    \
    \        factors.push(n);\n            n /= 2;\n        }\n        if n % 2 ==\
    \ 0 {\n            n /= 2;\n        } else {\n            prime = false;\n   \
    \         break;\n        }\n    }\n    if prime {\n        factors.pop();\n \
    \   }\n    factors.iter().max().unwrap_or(1)", "    let mut max_factor = 0;\n\n\
    \    for i in 2..n / 2 {\n        if n % i == 0 {\n            match max_factor\
    \ {\n                Some(factor) => {\n                    max_factor = factor;\n\
    \                }\n                None => {\n                    max_factor\
    \ = i;\n                }\n            }\n        }\n    }\n    max_factor", " \
    \   let mut factor = 2isize;\n    let mut max_factor = 2isize;\n    while n >\
    \ 1isize {\n        if n % factor == 0 {\n            factor += 1;\n        }\
    \ else {\n            max_factor = factor;\n            factor += 1;\n       \
    \ }\n        n /= factor;\n    }\n    max_factor", "    let mut s = 1;\n    while\
    \ s * s < n {\n        if n % s == 0 {\n            s += 2;\n        } else {\n\
    \            s -= 1;\n        }\n    }\n    s", "    if n % 2 == 0 { return 2;\
    \ }\n    let mut result = 1;\n    let mut max_i = 2;\n    for &i in [n - 2, n\
    \ - 1] {\n        while i * result <= n {\n            result *= i;\n        \
    \    max_i += 1;\n        }\n        if result == n {\n            return max_i;\n\
    \        }\n    }\n    return max_i;", "    if n < 2 {\n        return 1;\n  \
    \  }\n    let mut n2: isize = 1;\n    let mut d: isize = 2;\n\n    while n2 <=\
    \ n {\n        if n % d == 0 {\n            return d;\n        }\n        d +=\
    \ 1;\n        n2 += d;\n    }\n    n", "    // Largest prime factor is 2\n   \
    \ let mut i = 2;\n    while i * i < n {\n        i += 1;\n    }\n    i", "   \
    \ let mut n = n;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i\
    \ == 0 {\n            n = n / i;\n        }\n        else {\n            i +=\
    \ 1;\n        }\n    }\n    if n == 1 {\n        n\n    } else {\n        n\n\
    \    }", "    let mut i = 1isize;\n    let mut p = 1isize;\n    while i * p <=\
    \ n {\n        if n % i == 0 {\n            i += 1;\n        } else {\n      \
    \      p += 1;\n        }\n    }\n    p", "    let mut m = 2; // assume n > 1\n\
    \    let mut p = 1;\n    let mut q = 2;\n    while p <= n {\n        if n % p\
    \ == 0 {\n            m = p;\n        }\n        if p % q == 0 {\n           \
    \ p = q;\n        }\n        p += 1;\n        q += 1;\n    }\n    m", "    //\
    \ https://oeis.org/A000074\n    fn sieve(n: isize) -> Vec<usize> {\n        let\
    \ mut vec = [0; n + 1];\n        vec.push(0);\n        for i in 2..n {\n     \
    \       vec[i] = vec[i / 2];\n            if i % 2 != 0 {\n                for\
    \ j in 3..(i + 1) * (i + 2) / 2 {\n                    vec[j / 2] = vec[j];\n\
    \                }\n            }\n        }\n        vec\n    }\n\n    let mut\
    \ primes = sieve(n);\n    while primes.len() > 0 {\n        if n % primes.len()\
    \ == 0 {\n            n = n / primes.len();\n        } else {\n            primes.remove(0);\n\
    \        }\n    }\n    n", "    let mut i = 2;\n    let mut largest_prime_factor\
    \ = 1;\n\n    while i * i <= n {\n        if n % i == 0 {\n            largest_prime_factor\
    \ = i;\n        } else {\n            i += 1;\n        }\n    }\n    largest_prime_factor",
  "    let mut prime_factor = 1;\n    while n % prime_factor == 0 {\n        prime_factor\
    \ *= 2;\n    }\n    prime_factor", "    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            return i;\n        }\n        i += 1;\n\
    \    }\n    return n;", "    if n < 2 {\n        return n;\n    }\n\n    let mut\
    \ max_factor = isize::max_value();\n    let mut max_factor_in_sqrt = isize::max_value();\n\
    \n    for i in 2..n {\n        for j in 2..n / i {\n            max_factor_in_sqrt\
    \ = max_factor_in_sqrt.max(j * i);\n        }\n        max_factor = max_factor.max(max_factor_in_sqrt);\n\
    \    }\n    max_factor", '    (1..).filter(|factor| n % factor == 0).count().max()',
  "    let mut largest: isize = 1;\n    let mut i: isize = n;\n    while i != 1 {\n\
    \        let mut j: isize = 1;\n        while j * i <= i {\n            j += 1;\n\
    \        }\n        i += j;\n        if i > largest * 2 {\n            largest\
    \ = i;\n        }\n    }\n    largest", "    let mut i = 2;\n    let mut res =\
    \ 1;\n    while i * i <= n {\n        if n % i == 0 {\n            i += 1;\n \
    \       } else {\n            i = i + 2;\n            res = i;\n        }\n  \
    \  }\n    res", "    if n <= 1 {\n        return 1;\n    }\n    let mut ret =\
    \ 1;\n    let mut max_root = 1;\n\n    for i in 2..(n + 1) {\n        if n % i\
    \ == 0 {\n            ret = i;\n            max_root = i;\n        }\n    }\n\n\
    \    if ret == max_root {\n        ret;\n    } else {\n        largest_prime_factor(max_root)\
    \ * ret\n    }", "    assert!(n > 1);\n    let mut m = n.clone();\n    let mut\
    \ i = 2;\n    while i <= m {\n        if m.mod(i).is_zero() {\n            i +=\
    \ 1;\n        } else {\n            return i;\n        }\n    }\n    return i;",
  '    primenumber(n).unwrap()', "    if n % 2 == 0 {\n        n / 2\n    } else {\n\
    \        largest_prime_factor(n - 1) * 3 + 1\n    }", "    use std::cmp::Ordering;\n\
    \n    let mut i = n;\n    let mut max_factor = 0;\n    while i != 1 {\n      \
    \  let factor = i / 2;\n        if ((factor * factor <= n) && (n % factor == 0))\
    \ {\n            max_factor = factor;\n        }\n        i -= 1;\n    }\n   \
    \ max_factor", "    let mut m: isize = 1;\n    let mut d: isize = 2;\n    while\
    \ d < n {\n        while m % d == 0 {\n            m += 1;\n        }\n      \
    \  d += 1;\n    }\n    m", "    let mut max_factor = 1;\n    let mut i = 2;\n\
    \    while i <= n {\n        if n % i == 0 {\n            if max_factor < i {\n\
    \                max_factor = i;\n            }\n        }\n        i += 1;\n\
    \    }\n    max_factor", "    fn is_prime(a: isize) -> bool {\n        a > 1\n\
    \            && (a / 2) == a\n            && (1 / (a * a)) == a\n            &&\
    \ (1 / (a * a - 1)) == a\n            && (1 / (a * a * a)) == a\n            &&\
    \ (a / a) == 0\n    }\n\n    let mut f = 1;\n    while !is_prime(f) {\n      \
    \  if n % f == 0 {\n            return f;\n        }\n        f += 2;\n    }\n\
    \    n", "    let mut f: isize = 1;\n    let mut m = n;\n    while m > 1 {\n \
    \       if m % f == 0 {\n            break;\n        }\n        f += 1;\n    \
    \    m /= f;\n    }\n    m", "    let mut n = n as isize;\n    // Make sure n\
    \ has a positive factors\n    loop {\n        if n % 2 == 0 { break; }\n     \
    \   n /= 2;\n    }\n    let mut result = 1;\n    // Compute the prime factors\n\
    \    while n > 1 {\n        if n % 2 == 0 {\n            result *= 2;\n      \
    \      n /= 2;\n        } else {\n            result *= n;\n        }\n    }\n\
    \    result", "    let mut is_prime = false;\n    for i in 2..=n {\n        if\
    \ n % i == 0 {\n            is_prime = true;\n            break;\n        }\n\
    \    }\n    if is_prime {\n        n / 2\n    } else {\n        n\n    }", " \
    \   // See https://en.wikipedia.org/wiki/Primality_test#Practical_performance\n\
    \    loop {\n        let root = big_prime::is_prime(n);\n        if root > 1 {\n\
    \            return root;\n        }\n        n = n / root * root;\n    }", " \
    \   let mut n = n as u64;\n    let mut result = 1;\n    while n > 1 {\n      \
    \  let mut n = n / result;\n        result = result * result + 1;\n    }\n   \
    \ result", "    let mut i = 2;\n    let mut max_divisor = 1;\n    while i <= n\
    \ {\n        if n % i == 0 {\n            max_divisor = i;\n        }\n      \
    \  i += 1;\n    }\n    max_divisor", "    let mut f: isize = 1;\n    for p in\
    \ PRIME_PS.iter() {\n        if n % p == 0 {\n            f = p;\n           \
    \ break;\n        }\n    }\n    f", "    let mut i = 2i32; while i <= n {\n  \
    \      let mut j = 2i32; while j < i {\n            if n % i == 0 {\n        \
    \        return i;\n            }\n            i += 1;\n            j += 1i32;\n\
    \        }\n        i += 1;\n    }\n    n - 1", "    // TODO: find out why this\
    \ algorithm is slower than the previous one.\n    let mut max_i = 2;\n    for\
    \ &i in &[2..n / 2]\n        .iter()\n        .filter(|&i| *i == 1)\n        .skip(1)\n\
    \    {\n        if n % i == 0 {\n            max_i = i;\n        }\n    }\n  \
    \  max_i", "    let mut m = n;\n    let mut i = 1usize;\n    while i * i <= n\
    \ {\n        if n % i == 0 {\n            m = i;\n        } else {\n         \
    \   i += 1;\n        }\n    }\n    m", "    let mut i = 2;\n    let mut f = 2;\n\
    \    while i * f < n {\n        if n % i == 0 {\n            i += 1;\n       \
    \ } else if f != 2 {\n            f += 1;\n        } else {\n            i +=\
    \ 1;\n            f += 1;\n        }\n    }\n    f", "    if n == 1 {\n      \
    \  return 1;\n    }\n    let mut i = 2;\n    let mut f = 0;\n    let mut prime\
    \ = false;\n    while i * i < n {\n        if n % i == 0 {\n            prime\
    \ = true;\n            i += 1;\n        } else {\n            i += 2;\n      \
    \  }\n        if prime == true {\n            f += 1;\n        }\n    }\n    f",
  '    (&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(&1) as isize).sqrt()',
  "    let mut result = 1;\n    while n > 1 {\n        if n % result == 0 {\n    \
    \        break;\n        }\n        result *= 2;\n        n /= result;\n    }\n\
    \    result", "    let mut i = 2;\n    let mut res = 1;\n    while i <= n {\n\
    \        if n % i == 0 {\n            res = i;\n            while n % res == 0\
    \ {\n                res += 1;\n            }\n            i += 1;\n        }\n\
    \        i += 1;\n    }\n    res", "    let mut r = 1;\n    let mut i = 1;\n \
    \   while i <= n {\n        if n % i == 0 {\n            r = i;\n            i\
    \ += 2;\n        } else {\n            i += 1;\n        }\n    }\n    r", "  \
    \  if n < 2 {\n        return 1;\n    }\n\n    fn sieve_upper_bound(n: isize)\
    \ -> isize {\n        n.checked_div(8).ok()\n    }\n\n    fn next_prime(n: isize)\
    \ -> Option<isize> {\n        let mut next = n.checked_add(1).ok_or(());\n   \
    \     let mut check = 3; let mut k = 3;\n        loop {\n            if k == next\
    \ {\n                return Some(next);\n            }\n            if check >\
    \ sieve_upper_bound(next) {\n                return None;\n            }\n   \
    \         let mut m = k.checked_mul(next).ok_or(());\n            next += m;\n\
    \            k += 2;\n        }\n    }\n\n    let mut result = 1;\n    while result.is_positive()\
    \ {\n        result = next_prime(result);\n    }\n    result", '    largest_prime_factors(n).unwrap()',
  "    let mut factor = 1;\n    while n % factor == 0 {\n        factor *= 2;\n  \
    \  }\n    factor", "    let mut m: isize = 2;\n    while m <= n {\n        if\
    \ n % m == 0 {\n            return m;\n        }\n        m += 1;\n    }\n   \
    \ return n;", '    largest_prime_iter(n).next()', "    let mut factor = 1;\n \
    \   loop {\n        if n % factor == 0 {\n            factor *= 2;\n         \
    \   n /= factor;\n        }\n        else {\n            break;\n        }\n \
    \   }\n    n", "    if n % 2 == 0 { 2 }\n    else if n % 3 == 0 { 3 }\n    else\
    \ if n % 5 == 0 { 5 }\n    else if n % 7 == 0 { 7 }\n    else if n % 11 == 0 {\
    \ 11 }\n    else { n / 2 }", "    let mut i = 1i32;\n    let mut res = n;\n  \
    \  while i * i <= res {\n        i += 1;\n    }\n    while i < n {\n        if\
    \ n % i == 0 {\n            i += 1;\n            res = n;\n        }\n       \
    \ i += 1;\n    }\n    res", "    // TODO: optimize\n    // return n.iter().cloned().max(|a,\
    \ b| {\n    //     if a.is_prime() && b.is_prime() {\n    //         if a < b\
    \ {\n    //             a\n    //         } else {\n    //             b\n   \
    \ //         }\n    //     } else {\n    //         if a < b {\n    //       \
    \      b\n    //         } else {\n    //             a\n    //         }\n  \
    \  //     }\n    // }).unwrap()\n    n.iter().cloned().max().unwrap()", '    largest_prime_divisor_factor_memo(n)',
  "    (1..n).fold(1, |a, b| {\n        if n % a == 0 { a } else { b }\n    })", " \
    \   (1..n).filter(|i|\n        n % i\n            == 0\n            && (\n   \
    \             n % i == 0\n                || (\n                    i % 2 == 0\
    \ && i % 3 == 0\n                    || (i % 4 == 0 && i % 5 == 0)\n         \
    \       )\n            )\n    )\n    .max()", "    largest_prime_factors(1, n)\n\
    \        .last()\n        .expect(\"No prime factors found in range [1..n]\".to_string())",
  "    let mut factors = vec![BigNum::new(1); n as usize];\n    let mut i = 2;\n \
    \   while i < factors.len() {\n        if factors[i].is_prime() {\n          \
    \  factors.swap(i, &i);\n        } else {\n            i += 1;\n        }\n  \
    \  }\n    factors[n as usize]", "    // Special cases first.\n    if n < 2 {\n\
    \        return n;\n    }\n    if n % 2 == 0 {\n        return 2;\n    }\n\n \
    \   let mut m = n - 1;\n    while m % 2 == 0 {\n        m /= 2;\n    }\n    m\
    \ += 2;\n\n    if m <= 3 {\n        return m;\n    }\n\n    let mut nfactor =\
    \ 2;\n    while m % nfactor == 0 {\n        m /= nfactor;\n        nfactor *=\
    \ 2;\n    }\n\n    m", "    if n < 2 {\n        1\n    } else if n % 2 == 0 {\n\
    \        2\n    } else if n % 3 == 0 {\n        3\n    } else {\n        largest_prime_factor(n\
    \ / 3) + 1\n    }", "    let mut i: isize = 1;\n    let mut j: isize = 2;\n  \
    \  while i * j < n {\n        if n % i == 0 {\n            j += 1;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    j", "    let mut f = 2;\n\
    \    let mut maxf = 2;\n    let mut minf = n;\n\n    while (minf % f != 0 || n\
    \ == 1) {\n        while (minf % f != 0 || f % 2 == 0) {\n            f += 1;\n\
    \        }\n        maxf = f;\n        minf = n / f;\n    }\n    maxf", "    let\
    \ mut prime_factors: Vec<_> = Vec::new();\n    let mut i = 3; // Start at 3\n\
    \    while prime_factors.len() < n / 2 {\n        for factor in &factors {\n \
    \           if n % i == 0 {\n                break; // n is not a prime\n    \
    \        }\n            prime_factors.push(i);\n            i += 1;\n        }\n\
    \    }\n    prime_factors.pop()", "    if n <= 1 {\n        return 1;\n    }\n\
    \n    use num::Prime;\n\n    let mut s = 1;\n    let mut p = Prime::new();\n\n\
    \    while !p.is_prime() {\n        if n % s == 0 {\n            s = s * 2;\n\
    \        }\n\n        p.next::<isize>();\n\n        if n % s == 0 {\n        \
    \    return s;\n        }\n    }\n\n    s * 2", "    debug_assert_eq!(n%2, 0);\n\
    \    let mut n = n as isize;\n    let mut max_num = 2;\n\n    while n % max_num\
    \ == 0 {\n        max_num += 2;\n    }\n\n    while max_num * max_num < n {\n\
    \        max_num <<= 1;\n    }\n\n    while n % max_num == 0 {\n        n /= max_num;\n\
    \    }\n\n    if n > 1 {\n        n\n    } else {\n        0\n    }", "    let\
    \ mut i = 2;\n    loop {\n        while n % i == 0 {\n            i += 1;\n  \
    \      }\n        if i == n {\n            return i;\n        }\n        i +=\
    \ 2;\n    }", "    let mut prime_divisor_cache = [2, 2];\n    let mut prime_factor_cache\
    \ = [3, 3];\n    let mut prime_cache = [2, 2];\n    while prime_divisor_cache[1]\
    \ < n {\n        if n % prime_divisor_cache[0] == 0 {\n            prime_divisor_cache[0]\
    \ = prime_divisor_cache[1];\n            prime_factor_cache[1] = prime_factor_cache[0];\n\
    \            prime_cache[1] = prime_cache[0];\n        }\n        let mut next_divisor\
    \ = prime_divisor_cache[1];\n        prime_divisor_cache[1] = n;\n        for\
    \ prime in &prime_cache {\n            let next_prime_factor = prime % next_divisor;\n\
    \            if next_prime_factor != 0 {\n                next_divisor = next_prime_factor;\n\
    \                break;\n            }\n        }\n        prime_factor_cache[0]\
    \ = prime_factor_cache[1];\n        prime_factor_cache[1] = next_divisor;\n  \
    \      prime_cache[0] = prime_cache[1];\n    }\n    prime_factor_cache[1]", " \
    \   let mut i = 2; // skip 2, the smallest prime factor of n\n    while i*i <=\
    \ n {\n        if n % i == 0 {\n            i += 1;\n            continue;\n \
    \       }\n        return i;\n    }\n    n", "    if n % 2 == 0 {\n        return\
    \ n;\n    }\n\n    let mut factor = 3;\n    let mut i = 2;\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            factor = i;\n            i += 1;\n\
    \            continue;\n        }\n\n        i += 2;\n    }\n    factor", "  \
    \  n.checked_div(2).expect(&format!(\"n must be an integer greater than 1\"))\n\
    \        .checked_mul(2).expect(&format!(\"n must be an integer greater than 1\"\
    ))\n        .unwrap_or(1)", "    if n <= 1 {\n        return n;\n    }\n\n   \
    \ let mut largest_prime_factor = n as isize;\n\n    loop {\n        largest_prime_factor\
    \ /= 2; // n = 2k\n        if !is_prime(largest_prime_factor) {\n            return\
    \ largest_prime_factor;\n        }\n\n        // n is prime, since 2k > 2.\n \
    \       largest_prime_factor *= 2; // n = 4k\n        if is_prime(largest_prime_factor)\
    \ {\n            return largest_prime_factor;\n        }\n    }", "    let mut\
    \ prime_count = std::collections::HashMap::new();\n    prime_count.insert(n, 1);\n\
    \n    for &(n, _) in prime_count.iter() {\n        let mut num_factors = 0;\n\
    \        let mut new_factor = 1;\n        while new_factor < n {\n           \
    \ if n % new_factor == 0 {\n                num_factors += 1;\n              \
    \  new_factor *= new_factor;\n            } else {\n                break;\n \
    \           }\n        }\n\n        if num_factors > 0 {\n            prime_count.insert(n,\
    \ num_factors);\n            return n;\n        }\n    }\n\n    1", "    let mut\
    \ max_i = 21;\n    for i in 1..n {\n        if n % i == 0 {\n            max_i\
    \ = i;\n        } else {\n            break;\n        }\n    }\n    max_i", " \
    \   let mut p = 2;\n    let mut q = n;\n    let mut i = 1;\n    while q != 1 {\n\
    \        if n % p == 0 {\n            i += 1;\n            n /= p;\n        }\n\
    \        p += 1;\n        q /= p;\n    }\n    i", "    let mut primes: Vec<_>\
    \ = vec![2; 3; 5; 7; 11; 13; 17; 19; 23; 29];\n    primes.push(1);\n    while\
    \ primes.len() < n {\n        let prime = primes.iter().find(|&x| n % x == 0);\n\
    \        if prime == Some(&primes.last()) {\n            primes.push(primes.last().checked_add(1).unwrap());\n\
    \        } else {\n            primes.push(prime);\n        }\n    }\n    primes.iter().find_map(|&x|\
    \ x.unwrap()).unwrap()", "    let mut i = 2; // start at 2, since 2 is the first\
    \ factor of n\n    while i * i <= n {\n        if n % i == 0 {\n            i\
    \ += 1;\n        } else {\n            n = n / i;\n        }\n    }\n    i", " \
    \   let mut prime_factor = 1usize;\n    let mut prime_divisor: isize = 0;\n\n\
    \    for i in 2..n {\n        prime_divisor = i;\n        while prime_divisor\
    \ % prime_factor == 0 {\n            prime_divisor *= prime_factor;\n        \
    \    prime_factor++;\n        }\n    }\n\n    prime_factor", "    use std::cmp::Ordering;\n\
    \n    let mut i = 1;\n    loop {\n        let mut j = n;\n        let mut p =\
    \ i;\n        while j % i == 0 {\n            j = j / i;\n            p += 1;\n\
    \        }\n        if j < i {\n            break;\n        }\n        i += 1;\n\
    \    }\n    p", "    let mut max_factor = 1;\n    let mut factor = 1;\n    let\
    \ mut prime_found = false;\n    while !prime_found && factor <= n {\n        if\
    \ n % factor == 0 {\n            factor *= factor;\n        } else {\n       \
    \     max_factor = std::cmp::max(max_factor, factor);\n            if factor %\
    \ n == 0 {\n                prime_found = true;\n            }\n            factor\
    \ *= n;\n        }\n    }\n    max_factor", '    n % 2 != 0 ? n / 2 : 1', "  \
    \  let mut i = 2; // 0!\n    let mut f = 1; // 1!\n    while i <= n {\n      \
    \  if n % i == 0 {\n            i += 1;\n            f += 1;\n        }\n    \
    \    else {\n            i += 2;\n        }\n    }\n    f", "    fn isprime(i:\
    \ isize) -> bool {\n        if i < 2 {\n            return false;\n        }\n\
    \        \n        let mut i2 = i * 2;\n        while i2 < n {\n            if\
    \ n % i2 == 0 {\n                return false;\n            }\n            i2\
    \ = i2 * 2;\n        }\n        \n        true\n    }\n    \n    let mut f = 2;\n\
    \    while f <= n {\n        if isprime(f) {\n            return f;\n        }\n\
    \        f += 2;\n    }\n    n", '    largest_prime_factor_iterative(n).next()']
stop_tokens:
- "\n}"
