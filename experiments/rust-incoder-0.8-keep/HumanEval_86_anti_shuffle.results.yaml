name: HumanEval_86_anti_shuffle
language: rust
results:
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    iterate_words(s).collect::<String>().sort_by(|a, b| a.cmp(b))\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `iterate_words` in this scope\n  -->\
    \ /tmp/tmpkdc3r4nl.rs:11:5\n   |\n11 |     iterate_words(s).collect::<String>().sort_by(|a,\
    \ b| a.cmp(b))\n   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut output = String::new();\n    let mut words = s.splitn(\" \", s.len());\n\
    \    for word in words {\n        output.push_str(word.chars().enumerate().filter(|&(c,\
    \ _)| c < 128).\n            map(|(_, c)| {\n                let mut d = c.to_ascii_lowercase().as_byte();\n\
    \                d[0] = (d[0]).wrapping_add(1);\n                d.to_owned()\n\
    \            }).\n            collect());\n        output.push_str(\" \");\n \
    \   }\n    output.push_str(\"\\n\");\n    output\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdee5setb.rs:12:30\n   |\n\
    12 |     let mut words = s.splitn(\" \", s.len());\n   |                     \
    \         ^^^ expected `usize`, found `&str`\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `usize`\n    --> /tmp/tmpdee5setb.rs:12:23\n     |\n12   |  \
    \   let mut words = s.splitn(\" \", s.len());\n     |                       ^^^^^^\
    \ expected an `FnMut<(char,)>` closure, found `usize`\n     |\n     = help: the\
    \ trait `FnMut<(char,)>` is not implemented for `usize`\n     = help: the following\
    \ other types implement trait `Pattern<'a>`:\n               &'b String\n    \
    \           &'b [char; N]\n               &'b [char]\n               &'b str\n\
    \               &'c &'b str\n               [char; N]\n               char\n \
    \              pattern::MultiCharEqPattern<C>\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `usize`\nnote: required by\
    \ a bound in `core::str::<impl str>::splitn`\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `usize`\n   --> /tmp/tmpdee5setb.rs:13:17\n    |\n13  |     for\
    \ word in words {\n    |                 ^^^^^ expected an `FnMut<(char,)>` closure,\
    \ found `usize`\n    |\n    = help: the trait `FnMut<(char,)>` is not implemented\
    \ for `usize`\n    = help: the following other types implement trait `Pattern<'a>`:\n\
    \              &'b String\n              &'b [char; N]\n              &'b [char]\n\
    \              &'b str\n              &'c &'b str\n              [char; N]\n \
    \             char\n              pattern::MultiCharEqPattern<C>\n    = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `usize`\n\
    note: required by a bound in `std::str::SplitN`\n    = note: this error originates\
    \ in the macro `generate_pattern_iterators` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0599]: no method named `as_byte` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpdee5setb.rs:16:52\n   |\n16 |          \
    \       let mut d = c.to_ascii_lowercase().as_byte();\n   |                  \
    \                                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut result: String = String::new();\n    let mut\
    \ words: Vec<&str> = s.split_whitespace();\n    let mut word_count: i64 = 0;\n\
    \    let mut new_char: char;\n    let mut last_char: char;\n\n    while word_count\
    \ < words.len() {\n        let mut i = 0;\n        let mut j = word_count + 1;\n\
    \        let mut c = words[word_count].chars();\n        if c.len() > 0 {\n  \
    \          while i < c.len() {\n                let mut new_char: char = c.next().unwrap();\n\
    \                while j > 0 && words[j].chars().any(|x| x == new_char) {\n  \
    \                  new_char += words[j].chars().next().unwrap();\n           \
    \         j--;\n                }\n                result.push_str(&new_char);\n\
    \                i += 1;\n            }\n        } else {\n            result.push_str(&words[word_count]);\n\
    \            i += 1;\n        }\n        word_count += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpnij8tnn4.rs:27:24\n\
    \   |\n27 |                     j--;\n   |                        ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnij8tnn4.rs:13:32\n   |\n13 |\
    \     let mut words: Vec<&str> = s.split_whitespace();\n   |                 \
    \   ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `SplitWhitespace`\n\
    \   |                    |\n   |                    expected due to this\n   |\n\
    \   = note: expected struct `Vec<&str>`\n              found struct `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnij8tnn4.rs:18:24\n   |\n18 |\
    \     while word_count < words.len() {\n   |                        ^^^^^^^^^^^\
    \ expected `i64`, found `usize`\n   |\nhelp: you can convert a `usize` to an `i64`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     while word_count\
    \ < words.len().try_into().unwrap() {\n   |                                  \
    \ ++++++++++++++++++++\n\nerror[E0277]: the type `[&str]` cannot be indexed by\
    \ `i64`\n  --> /tmp/tmpnij8tnn4.rs:21:21\n   |\n21 |         let mut c = words[word_count].chars();\n\
    \   |                     ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>` is not\
    \ implemented for `i64`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<i64>` for `Vec<&str>`\n\nerror[E0277]: the type `[&str]` cannot be indexed\
    \ by `i64`\n  --> /tmp/tmpnij8tnn4.rs:25:32\n   |\n25 |                 while\
    \ j > 0 && words[j].chars().any(|x| x == new_char) {\n   |                   \
    \             ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented for `i64`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<i64>` for `Vec<&str>`\n\
    \nerror[E0277]: the type `[&str]` cannot be indexed by `i64`\n  --> /tmp/tmpnij8tnn4.rs:26:33\n\
    \   |\n26"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write your code here\n    let mut chars = s.chars();\n    let mut sorted_s\
    \ = s.chars();\n    let mut num_spaces = 0;\n    while chars.next() != Some(s.len())\
    \ {\n        if chars.next().unwrap() != ' ' {\n            sorted_s.next();\n\
    \            continue;\n        }\n        chars.next();\n        num_spaces++;\n\
    \    }\n    if num_spaces > 1 {\n        sorted_s.reverse();\n    }\n    let mut\
    \ i = 0;\n    let mut sorted_chars = s.chars();\n    while i < chars.len() {\n\
    \        if chars.next() != Some(s.len()) {\n            sorted_chars.next();\n\
    \            i += 1;\n        }\n        else {\n            sorted_chars.next();\n\
    \            i += 1;\n            chars.next();\n        }\n    }\n    sorted_s.to_string()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpzu29yidu.rs:21:19\n\
    \   |\n21 |         num_spaces++;\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n21 |         { let tmp = num_spaces;\
    \ num_spaces += 1; tmp };\n   |         +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    21 -         num_spaces++;\n21 +         num_spaces += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzu29yidu.rs:15:32\n   |\n15 |     while chars.next()\
    \ != Some(s.len()) {\n   |                                ^^^^^^^ expected `char`,\
    \ found `usize`\n\nerror[E0599]: no method named `reverse` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpzu29yidu.rs:24:18\n   |\n24 |         sorted_s.reverse();\n\
    \   |                  ^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpzu29yidu.rs:28:21\n\
    \   |\n28 |     while i < chars.len() {\n   |                     ^^^ method not\
    \ found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzu29yidu.rs:29:33\n\
    \   |\n29 |         if chars.next() != Some(s.len()) {\n   |                 \
    \                ^^^^^^^ expected `char`, found `usize`\n\nerror[E0599]: the method\
    \ `to_string` exists for struct `Chars<'_>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpzu29yidu.rs:39:14\n   |\n39 |       sorted_s.to_string()\n   |\
    \                ^^^^^^^^^ method cannot be called on `Chars<'_>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Chars<'_>: std::fmt::Display`\n           which is required by `Chars<'_>:\
    \ ToString`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut new_string = \"\";\n    for c in s.chars() {\n        if c != ' '\
    \ {\n            new_string += c;\n        } else {\n            let mut new_word\
    \ = new_string.to_string();\n            let mut pos = 0;\n            for (i,\
    \ char) in new_string.chars().enumerate() {\n                if char != ' ' {\n\
    \                    new_word.insert(pos, char);\n                    pos += 1;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            new_string.push_str(new_word);\n        }\n    }\n  \
    \  new_string\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmp8x44mliz.rs:14:13\n   |\n14 |             new_string +=\
    \ c;\n   |             ----------^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `&str`\n\nerror[E0599]: no method named `push_str` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmp8x44mliz.rs:26:24\n   |\n\
    26 |             new_string.push_str(new_word);\n   |                        ^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8x44mliz.rs:29:5\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \          ------ expected `String` because of return type\n...\n29 |     new_string\n\
    \   |     ^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    if s.is_empty() {\n        return String::new();\n    }\n\n    let mut new_str\
    \ = String::from(s);\n    let mut new_slice = String::from(s);\n\n    let mut\
    \ ascii_order = Vec::new();\n    for ch in new_str {\n        ascii_order.push(char2ascii(ch));\n\
    \    }\n\n    new_str = new_str.replace(ascii_order, ascii_order.iter().cloned().collect::<Vec<_>>());\n\
    \n    new_str = new_str.replace(new_str.split_whitespace().collect(), new_str.split_whitespace().iter().cloned().collect::<Vec<_>>());\n\
    \n    new_str = new_str.replace(new_str.chars().filter(|c| *c != ' ').collect(),\
    \ new_str.chars().filter(|c| *c == ' ').collect());\n\n    new_str = new_str.replace(new_str.chars().filter(|c|\
    \ *c != ' ').collect(), new_str.chars().filter(|c| *c == ' ').collect());\n\n\
    \    new_str = new_str.trim().to_string();\n\n    new_str\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char2ascii` in this scope\n  --> /tmp/tmpybs2isqd.rs:20:26\n\
    \   |\n20 |         ascii_order.push(char2ascii(ch));\n   |                  \
    \        ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmpybs2isqd.rs:19:15\n   |\n19 |     for ch in new_str\
    \ {\n   |               ^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `Vec<_>`\n\
    \   --> /tmp/tmpybs2isqd.rs:23:23\n    |\n23  |     new_str = new_str.replace(ascii_order,\
    \ ascii_order.iter().cloned().collect::<Vec<_>>());\n    |                   \
    \    ^^^^^^^ expected an `FnMut<(char,)>` closure, found `Vec<_>`\n    |\n   \
    \ = help: the trait `FnMut<(char,)>` is not implemented for `Vec<_>`\n    = help:\
    \ the following other types implement trait `Pattern<'a>`:\n              &'b\
    \ String\n              &'b [char; N]\n              &'b [char]\n            \
    \  &'b str\n              &'c &'b str\n              [char; N]\n             \
    \ char\n              pattern::MultiCharEqPattern<C>\n    = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `Vec<_>`\nnote: required\
    \ by a bound in `str::<impl str>::replace`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpybs2isqd.rs:23:44\n   |\n23 |     new_str = new_str.replace(ascii_order,\
    \ ascii_order.iter().cloned().collect::<Vec<_>>());\n   |                    \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found struct `Vec`\n   |\n   = note: expected reference `&str`\n   \
    \              found struct `Vec<_>`\n\nerror[E0599]: no method named `iter` found\
    \ for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpybs2isqd.rs:25:96\n\
    \   |\n25 |     new_str = new_str.replace(new_str.split_whitespace().collect(),\
    \ new_str.split_whitespace().iter().cloned().collect::<Vec<_>>());\n   |     \
    \                "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s.to_lowercase();\n    let mut result = String::new();\n    for\
    \ c in s.chars().cloned() {\n        result.push(*c);\n        result.push(c.to_ascii_lowercase());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmphrtrnyxq.rs:13:24\n     |\n13   |     for c in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmphrtrnyxq.rs:13:14\n\
    \   |\n13 |     for c in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmphrtrnyxq.rs:13:14\n   |\n13 |     for c in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = String::from(s);\n    s.sort_by_key(|&c| {\n        match c {\n\
    \            c if c.is_whitespace() => c.to_ascii_lowercase().chars().count()\
    \ as u32,\n            c if !c.is_whitespace() => c.to_ascii_lowercase().chars().count()\
    \ as u32 - c.to_ascii_lowercase().chars().count() as u32,\n            _ => panic!(\"\
    invalid character in string '{}'.\", c),\n        }\n    });\n    s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmperyo1n9f.rs:12:7\n   |\n12 |     s.sort_by_key(|&c|\
    \ {\n   |       ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut word_chars = s.chars().collect::<Vec<_>>();\n\n    let mut new_s:\
    \ String = String::new();\n    let mut ascii_map: HashMap<String, usize> = HashMap::new();\n\
    \n    for word_char in word_chars {\n        let ascii_value = word_char.code();\n\
    \n        let mut new_word_char = word_char;\n\n        let mut next_word_char:\
    \ Option<String> = None;\n\n        while next_word_char.is_none() {\n       \
    \     ascii_map.insert(\n                new_word_char.to_string(),\n        \
    \        ascii_value.clone(),\n            );\n\n            next_word_char =\
    \ ascii_map.remove(new_word_char.to_string());\n        }\n\n        new_word_char\
    \ = next_word_char.expect(\"new_word_char not found\");\n\n        if ascii_value\
    \ == ascii_map.get(&new_word_char.to_string()).unwrap() {\n            new_s +=\
    \ new_word_char;\n        } else {\n            let mut idx = ascii_map.get(&new_word_char.to_string()).unwrap();\n\
    \n            idx -= 1;\n\n            new_s += char::from_integer(idx);\n   \
    \     }\n\n        new_s += ' ';\n    }\n\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpwe5k2akg.rs:14:24\n\
    \   |\n14 |     let mut ascii_map: HashMap<String, usize> = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpwe5k2akg.rs:14:49\n\
    \   |\n14 |     let mut ascii_map: HashMap<String, usize> = HashMap::new();\n\
    \   |                                                 ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no method named `code` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpwe5k2akg.rs:17:37\n   |\n17 |         let ascii_value =\
    \ word_char.code();\n   |                                     ^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe5k2akg.rs:32:25\n\
    \   |\n19 |         let mut new_word_char = word_char;\n   |                 \
    \                --------- expected due to this value\n...\n32 |         new_word_char\
    \ = next_word_char.expect(\"new_word_char not found\");\n   |                \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe5k2akg.rs:35:22\n\
    \   |\n35 |             new_s += new_word_char;\n   |                      ^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0599]: no function or associated item\
    \ named `from_integer` found for type `char` in the current scope\n  --> /tmp/tmpwe5k2akg.rs:41:28\n\
    \   |\n41 |             new_s += char::from_integer(idx);\n   |              \
    \              ^^^^^^^^^^^^ function or associated item not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwe5k2akg.rs:44:18\n   |\n44 |  \
    \       new_s += ' ';\n   |                  ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    44 |         new_s += \" \";\n   |                  ~~~\n\nerror: abort"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    s.chars().sort_by(|a, b| a.cmp(b).unwrap()).for_each(|c|\
    \ {\n        if c != ' ' {\n            s.insert(s.chars().max().unwrap() + 1,\
    \ c);\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpbf5jvi2i.rs:12:15\n   |\n12 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b).unwrap()).for_each(|c| {\n   |               ^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror[E0369]: cannot add `{integer}` to `char`\n  -->\
    \ /tmp/tmpbf5jvi2i.rs:14:47\n   |\n14 |             s.insert(s.chars().max().unwrap()\
    \ + 1, c);\n   |                      ------------------------ ^ - {integer}\n\
    \   |                      |\n   |                      char\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Your code goes here\n    let mut s = String::from(s);\n    let mut new_s\
    \ = String::new();\n    s.split_whitespace().sort_by_key(|x|x.0).for_each(|x|\
    \ {\n        match x.to_string().chars().count(|y| y.is_ascii()) {\n         \
    \   0 => new_s.push(x),\n            1 => new_s.push('_'),\n            2 => new_s.push(x),\n\
    \            _ => {\n                let mut i = s.len();\n                for\
    \ i in s.split_whitespace().iter_mut() {\n                    if i == 0 {\n  \
    \                      *i += x;\n                    } else {\n              \
    \          if *i < *i {\n                            *i += x;\n              \
    \          } else {\n                            let mut j = s.len();\n      \
    \                      for (i, j) in s.split_whitespace().into_iter().zip(s.split_whitespace().into_iter().rev())\
    \ {\n                                if *j < *i {\n                          \
    \          *i += x;\n                                    break;\n            \
    \                    }\n                            }\n                      \
    \  }\n                    }\n                }\n            }\n        }\n   \
    \ })\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `new_s`\n  --> /tmp/tmp9firqgzk.rs:40:7\n  \
    \ |\n40 |     })\n   |       ^ help: add `;` here\n41 |     new_s\n   |     -----\
    \ unexpected token\n\nerror[E0599]: no method named `sort_by_key` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmp9firqgzk.rs:14:26\n  \
    \ |\n14 |     s.split_whitespace().sort_by_key(|x|x.0).for_each(|x| {\n   |  \
    \                        ^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `iter_mut` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp9firqgzk.rs:21:47\n   |\n21 |          \
    \       for i in s.split_whitespace().iter_mut() {\n   |                     \
    \                          ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s\n        .chars()\n        .cloned()\n        .collect::<Vec<_>>()\n\
    \        .sort_by(|a, b| a.cmp(b).reverse());\n    for c in s {\n        if !s.contains(c)\
    \ || c == ' ' {\n            s.remove(&c);\n        }\n    }\n    s.to_string()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpuwm_bhno.rs:13:10\n     |\n13   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpuwm_bhno.rs:14:10\n\
    \   |\n14 |           .collect::<Vec<_>>()\n   |            ^^^^^^^ method cannot\
    \ be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n\n    let mut new_s = String::with_capacity(s.len());\n \
    \   let mut words: Vec<String> = vec![];\n    let mut blank_space_count: usize\
    \ = 0;\n\n    // Find the end of each word\n    for c in s.chars() {\n       \
    \ if c != ' ' {\n            new_s.push_str(&*c);\n        } else {\n        \
    \    words.push(new_s);\n            new_s.push_str(\"\");\n            blank_space_count\
    \ += 1;\n        }\n    }\n\n    // Replace the word with its order in ascending\
    \ order using ascii value\n    for w in words {\n        w.insert(0, char::from_u32(*w).unwrap().to_string());\n\
    \    }\n\n    new_s.push(blank_space_count.to_string());\n\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6af5jo7a.rs:20:29\n\
    \   |\n20 |             new_s.push_str(&*c);\n   |                           \
    \  ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6af5jo7a.rs:30:36\n   |\n\
    30 |         w.insert(0, char::from_u32(*w).unwrap().to_string());\n   |     \
    \                               ^^ expected `u32`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6af5jo7a.rs:30:21\n   |\n30 |         w.insert(0,\
    \ char::from_u32(*w).unwrap().to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6af5jo7a.rs:33:16\n   |\n33 |     new_s.push(blank_space_count.to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    let mut sorted = String::new();\n\
    \    let mut new_word = \"\".to_string();\n    let mut new_words: Vec<String>\
    \ = vec![];\n    let mut space_char = false;\n    for word in words {\n      \
    \  let s = word.to_string();\n        for ch in s.chars() {\n            let ord\
    \ = ch.to_ascii();\n            if ord > 65 && ord < 90 {\n                new_word\
    \ = new_word.to_owned();\n                space_char = false;\n            } else\
    \ {\n                space_char = !space_char;\n                new_word += match\
    \ space_char {\n                    true => {' '}\n                    false =>\
    \ {ch}\n                };\n            }\n        }\n        sorted.push_str(new_word);\n\
    \        new_word = \"\".to_string();\n        new_words.push(new_word);\n   \
    \ }\n    sorted.push_str(new_word);\n    sorted.trim_end();\n    sorted.clone()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_ascii` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpud7o685f.rs:19:26\n   |\n19 |             let ord = ch.to_ascii();\n\
    \   |                          ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud7o685f.rs:26:30\n\
    \   |\n26 |                     true => {' '}\n   |                          \
    \    ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n26 |                     true => {\" \"}\n\
    \   |                              ~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpud7o685f.rs:27:31\n   |\n27 |                     false => {ch}\n  \
    \ |                               ^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpud7o685f.rs:31:25\n   |\n31 |         sorted.push_str(new_word);\n\
    \   |                         ^^^^^^^^\n   |                         |\n   | \
    \                        expected `&str`, found struct `String`\n   |        \
    \                 help: consider borrowing here: `&new_word`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpud7o685f.rs:35:21\n   |\n35 |     sorted.push_str(new_word);\n\
    \   |                     ^^^^^^^^\n   |                     |\n   |         \
    \            expected `&str`, found struct `String`\n   |                    \
    \ help: consider borrowing here: `&new_word`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().enumerate().filter_map(|(i, c)| {\n        match c {\n        \
    \    'a' => Some(c.to_ascii_lowercase()),\n            'e' => Some(c.to_ascii_lowercase()),\n\
    \            'i' => Some(c.to_ascii_lowercase()),\n            'o' => Some(c.to_ascii_lowercase()),\n\
    \            'u' => Some(c.to_ascii_lowercase()),\n            'A' => Some(c.to_ascii_uppercase()),\n\
    \            'E' => Some(c.to_ascii_uppercase()),\n            'I' => Some(c.to_ascii_uppercase()),\n\
    \            'O' => Some(c.to_ascii_uppercase()),\n            'U' => Some(c.to_ascii_uppercase()),\n\
    \            c => None,\n        }\n    })\n    .map(|(i, _)| i.to_string())\n\
    \    .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwgmzusq4.rs:26:11\n   |\n\
    26 |     .map(|(i, _)| i.to_string())\n   |           ^^^^^-\n   |           |\
    \    |\n   |           |    expected due to this\n   |           expected `char`,\
    \ found tuple\n   |\n   = note: expected type `char`\n             found tuple\
    \ `(_, _)`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s\n        .split_whitespace()\n        .map(|s| s.to_string())\n\
    \        .collect::<Vec<_>>();\n    for (i, &word) in s.iter().enumerate() {\n\
    \        s[i] = s.iter()\n            .zip(word.chars().cloned().collect::<Vec<_>>())\n\
    \            .map(|(idx, val)| (val - 32) as char).collect();\n    }\n    String::from_utf8_lossy(s).to_string()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpljtszip6.rs:17:31\n     |\n17   |             .zip(word.chars().cloned().collect::<Vec<_>>())\n\
    \     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpljtszip6.rs:17:40\n   |\n17 |               .zip(word.chars().cloned().collect::<Vec<_>>())\n\
    \   |                                          ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpljtszip6.rs:20:29\n\
    \   |\n20 |     String::from_utf8_lossy(s).to_string()\n   |                 \
    \            ^ expected `&[u8]`, found struct `Vec`\n   |\n   = note: expected\
    \ reference `&[u8]`\n                 found struct `Vec<String>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut i = 0;\n    let mut len = 0;\n    let mut j = 0;\n    let mut k =\
    \ 0;\n    let mut tmp = 0;\n    let mut temp_str = \"\";\n    let mut new_str\
    \ = \"\";\n    let mut new_str_len = 0;\n    let mut new_str_len_i = 0;\n    let\
    \ mut new_str_len_i1 = 0;\n    let mut prev_c = ' ';\n    let mut prev_c2 = '\
    \ ';\n    let mut new_word = \"\";\n    let mut new_word_len = 0;\n    let mut\
    \ new_word_len_i = 0;\n    let mut new_word_len_i1 = 0;\n    let mut is_space\
    \ = false;\n\n    while i < s.len() {\n        prev_c = s.chars().nth(i).unwrap();\n\
    \        is_space = false;\n        len = 0;\n        for (j = 1; j < s.len();\
    \ j += 1) {\n            tmp = 0;\n            prev_c2 = s.chars().nth(j).unwrap();\n\
    \            if prev_c != prev_c2 {\n                tmp += 1;\n             \
    \   prev_c = prev_c2;\n            }\n            len += 1;\n        }\n     \
    \   i += len;\n        temp_str = s.chars().nth(i).unwrap();\n        new_str_len\
    \ = 0;\n        new_str_len_i = 0;\n        new_str_len_i1 = 0;\n        new_word\
    \ = \"\";\n        new_word_len = 0;\n        new_word_len_i = 0;\n        new_word_len_i1\
    \ = 0;\n        for (j = 1; j < s.len(); j += 1) {\n            tmp = 0;\n   \
    \         prev_c2 = s.chars().nth(j).unwrap();\n            if prev_c != prev_c2\
    \ {\n                tmp += 1;\n                prev_c = prev_c2;\n          \
    \  }\n            i += 1;\n            new_str_len += 1;\n            if new_str_len\
    \ < temp_str.len() {\n                new_str_len += 1;\n                new_str_len_i\
    \ += 1;\n                if new_str_len_i < temp_str.len() {\n               \
    \     new_str_len_i += 1;\n                    new_word_len += 1;\n          \
    \      }\n            }\n        }\n        i += 1;\n        for (j = new_str_len_i1;\
    \ j < new_str_len; j += 1) {\n            tmp = 0;\n            prev_c2 = s.chars().nth(new_str_len\
    \ + j).unwrap();\n            if prev_c != prev_c2 {\n                tmp += 1;\n\
    \                prev_c = prev_c2;\n            }\n            i += 1;\n     \
    \   }\n        for (j = new_str_len; j < new_str_len_i1; j += 1) {\n         \
    \   tmp = 0;\n            prev_c2 = s.chars().nth(new_str_len + j).unwrap();\n\
    \            if prev_c != prev_c2 {\n                tmp += 1;\n             \
    \   prev_c = prev_c2;\n            }\n            i += 1;\n        }\n       \
    \ if (new_str_len == temp_str.\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpida2b8gm.rs:100:3\n\
    \    |\n10  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n29  |     while i < s.len() {\n\
    \    |                       - this delimiter might not be properly closed...\n\
    ...\n89  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n100 | }\n    |   ^\n\nerror: expected one of `)`, `,`, `@`, or `|`, found\
    \ `=`\n  --> /tmp/tmpida2b8gm.rs:33:16\n   |\n33 |         for (j = 1; j < s.len();\
    \ j += 1) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror:\
    \ missing `in` in `for` loop\n  --> /tmp/tmpida2b8gm.rs:33:15\n   |\n33 |    \
    \     for (j = 1; j < s.len(); j += 1) {\n   |               ^ help: try adding\
    \ `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpida2b8gm.rs:33:16\n\
    \   |\n33 |         for (j = 1; j < s.len(); j += 1) {\n   |                ^\
    \ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpida2b8gm.rs:88:12\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n88 |     \
    \    if (new_str_len == temp_str.\n   |            ^ unclosed delimiter\n89 |\
    \ }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpida2b8gm.rs:10:31\n   |\n10 | fn anti_shuffle(s: String) -> String\
    \ {\n   |    ------------               ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 6 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.split(\" \").sort().join(\" \")\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpwgpvew7k.rs:11:18\n   |\n11 |     s.split(\"\
    \ \").sort().join(\" \")\n   |                  ^^^^ method not found in `std::str::Split<'_,\
    \ &str>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    for c in s.chars() {\n        if c.is_whitespace() {\n\
    \            s.insert(s.start(), ' ');\n        } else {\n            let index\
    \ = s.find(|c| c.is_ascii_alphanumeric())\n                .expect(\"There should\
    \ be at least one alphanumeric character\");\n            let replacement = String::from(\"\
    X\");\n            let mut new_s = String::new();\n            for i in 0..index\
    \ {\n                new_s.push_str(&replacement);\n            }\n          \
    \  new_s.push(&*s);\n            s = new_s;\n        }\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `start` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpqb1o28jr.rs:14:24\n   |\n14 |             s.insert(s.start(),\
    \ ' ');\n   |                        ^^^^^ help: there is an associated function\
    \ with a similar name: `trim_start`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb1o28jr.rs:23:24\n\
    \   |\n23 |             new_s.push(&*s);\n   |                        ^^^ expected\
    \ `char`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut new_s: Vec<char> = vec![];\n\n    // Split s\
    \ by space\n    let mut spaces = s.split_whitespace();\n\n    // For every word\
    \ in s\n    for w in spaces {\n        // Add it to new_s according to ascii values\n\
    \        for c in w.chars() {\n            let ascii_value = c.to_ascii_lowercase();\n\
    \            new_s.push(ascii_value);\n        }\n    }\n\n    // Join new_s to\
    \ s\n    let mut new_s = new_s.join();\n\n    // Split s by space\n    let mut\
    \ spaces = s.split_whitespace();\n\n    // For every word in s\n    for w in spaces\
    \ {\n        // Add it to new_s according to ascii values\n        for c in w.chars()\
    \ {\n            let ascii_value = c.to_ascii_uppercase();\n            new_s.push(ascii_value);\n\
    \        }\n    }\n\n    // Join new_s to s\n    let mut new_s = new_s.join();\n\
    \n    // Split s by space\n    let mut spaces = s.split_whitespace();\n\n    //\
    \ For every word in s\n    for w in spaces {\n        // Add it to new_s according\
    \ to ascii values\n        for c in w.chars() {\n            let ascii_value =\
    \ c.to_ascii_lowercase();\n            new_s.push(ascii_value);\n        }\n \
    \   }\n\n    // Join new_s to s\n    let mut new_s = new_s.join();\n\n    // Split\
    \ s by space\n    let mut spaces = s.split_whitespace();\n\n    // For every word\
    \ in s\n    for w in spaces {\n        // Add it to new_s according to ascii values\n\
    \        for c in w.chars() {\n            let ascii_value = c.to_ascii_uppercase();\n\
    \            new_s.push(ascii_value);\n        }\n    }\n\n    // Join new_s to\
    \ s\n    let mut new_s = new_s.join();\n\n    // Split s by space\n    let mut\
    \ spaces = s.split_whitespace();\n\n    // For every word in s\n    for w in spaces\
    \ {\n        // Add it to new_s according to ascii values\n        for c in w.chars()\
    \ {\n            let ascii_value = c.to_ascii_lowercase();\n            new_s.push(ascii_value);\n\
    \        }\n    }\n\n    // Join new_s to s\n    let mut new_s = new_s.join();\n\
    \n    // Split s by space\n    let mut spaces = s.split_whitespace();\n\n    //\
    \ For every word in s\n    for w in spaces {\n        // Add it to new_s according\
    \ to ascii values\n        for c in w.chars() {\n            let ascii_value =\
    \ c.to_ascii_uppercase();\n            new_s.push(ascii_value);\n        }\n \
    \   }\n\n    // Join new_s to s\n    let mut new_s = new_s.join();\n\n    // Split\
    \ s by space\n    let mut spaces = s.split_whitespace();\n\n    // For every word\
    \ in s\n    for w in spaces {\n        // Add it to new_s \n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpex7m1swa.rs:121:3\n\
    \    |\n10  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n108 |     for w in spaces {\n\
    \    |                     - this delimiter might not be properly closed...\n\
    109 |         // Add it to new_s \n110 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n121 | }\n    |   ^\n\nerror[E0599]: the method\
    \ `join` exists for struct `Vec<char>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpex7m1swa.rs:27:27\n   |\n27 |     let mut new_s = new_s.join();\n\
    \   |                           ^^^^ method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `[char]: Join<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpex7m1swa.rs:10:31\n   |\n10 | fn anti_shuffle(s: String) -> String\
    \ {\n   |    ------------               ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s.chars().collect::<Vec<_>>();\n    for (i, c) in s.iter().enumerate()\
    \ {\n        if c != ' ' {\n            s[i] = c - 32;\n        }\n    }\n   \
    \ s.sort_by_key(|&x| x.as_bytes()[0]);\n    s.to_string()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpydc5nkyk.rs:13:14\n\
    \   |\n13 |         if c != ' ' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot subtract `{integer}` from `&char`\n  --> /tmp/tmpydc5nkyk.rs:14:22\n\
    \   |\n14 |             s[i] = c - 32;\n   |                    - ^ -- {integer}\n\
    \   |                    |\n   |                    &char\n\nerror[E0599]: no\
    \ method named `as_bytes` found for type `char` in the current scope\n  --> /tmp/tmpydc5nkyk.rs:17:26\n\
    \   |\n17 |     s.sort_by_key(|&x| x.as_bytes()[0]);\n   |                   \
    \       ^^^^^^^^ method not found in `char`\n\nerror[E0599]: `Vec<char>` doesn't\
    \ implement `std::fmt::Display`\n   --> /tmp/tmpydc5nkyk.rs:18:7\n    |\n18  |\
    \       s.to_string()\n    |         ^^^^^^^^^ `Vec<char>` cannot be formatted\
    \ with the default formatter\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<char>: std::fmt::Display`\n            which\
    \ is required by `Vec<char>: ToString`\n            `[char]: std::fmt::Display`\n\
    \            which is required by `[char]: ToString`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    s.iter().map(|c| c.to_ascii_lowercase()).fold(String::new(),\
    \ |mut acc, c| {\n        if acc.is_empty() {\n            return c;\n       \
    \ }\n        if acc[acc.len() - 1] != ' ' {\n            acc.push(c);\n      \
    \  }\n        acc\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp7fa4z5bp.rs:12:7\n   |\n12 |     s.iter().map(|c| c.to_ascii_lowercase()).fold(String::new(),\
    \ |mut acc, c| {\n   |       ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n12 |     s.chars().map(|c| c.to_ascii_lowercase()).fold(String::new(),\
    \ |mut acc, c| {\n   |       ~~~~~\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .filter_map(|c| c.to_ascii_lowercase().unwrap())\n   \
    \     .collect::<Vec<_>>()\n        .into_iter()\n        .filter(|&x| x != '\
    \ ')\n        .map(|x| x.to_string().chars()\n            .filter_map(|c| c.to_ascii_lowercase().unwrap())\n\
    \            .collect::<Vec<_>>()\n            .sort())\n        .flat_map(|x|\
    \ x.collect::<Vec<_>>().join(\"_\"))\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpdg837tsl.rs:12:48\n   |\n12 |         .filter_map(|c| c.to_ascii_lowercase().unwrap())\n\
    \   |                                                ^^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result: String = String::new();\n    let words = s.split_whitespace();\n\
    \    let mut buffer = String::new();\n    for word in words {\n        // Add\
    \ space to buffer to ensure buffer is greater than word before concatenating\n\
    \        buffer.push_str(\" \");\n        // Append the new word based on its\
    \ ascii value\n        buffer.push_str(*word.chars().map(|c| c.to_ascii_lowercase()).collect::<String>());\n\
    \        result.push_str(&buffer);\n        // Remove space from buffer to ensure\
    \ buffer is less than word after concatenating\n        buffer.pop_str();\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0z645e4k.rs:18:25\n   |\n\
    18 |         buffer.push_str(*word.chars().map(|c| c.to_ascii_lowercase()).collect::<String>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found `str`\n   |                         help: consider borrowing here: `&*word.chars().map(|c|\
    \ c.to_ascii_lowercase()).collect::<String>()`\n\nerror[E0599]: no method named\
    \ `pop_str` found for struct `String` in the current scope\n  --> /tmp/tmp0z645e4k.rs:21:16\n\
    \   |\n21 |         buffer.pop_str();\n   |                ^^^^^^^ method not\
    \ found in `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut result = s;\n    for i in 1..s.len() {\n    \
    \    let mut j = i;\n        while j > 0 {\n            let c = s[j];\n      \
    \      let k = j;\n            while k < s.len() {\n                if s[k] <\
    \ c {\n                    k = k + 1;\n                    continue;\n       \
    \         }\n                break;\n            }\n            if k == 0 {\n\
    \                break;\n            }\n            result[k] = c;\n         \
    \   j = k;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp295twbjv.rs:16:21\n\
    \   |\n16 |             let c = s[j];\n   |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp295twbjv.rs:19:20\n   |\n19 |                 if s[k] < c {\n \
    \  |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp295twbjv.rs:28:13\n\
    \   |\n28 |             result[k] = c;\n   |             ^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previo"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = String::new();\n    for (i, c) in s.chars().enumerate() {\n\
    \        if i > 0 {\n            words.push_str(\" \");\n        }\n        words.push_str(c.to_string());\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmy0m733k.rs:16:24\n   |\n\
    16 |         words.push_str(c.to_string());\n   |                        ^^^^^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&c.to_string()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.split(\" \").sort_by_key(|&word| word.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>()).join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp6b21ldjv.rs:11:18\n   |\n11 |     s.split(\"\
    \ \").sort_by_key(|&word| word.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>()).join(\"\
    \ \")\n   |                  ^^^^^^^^^^^ method not found in `std::str::Split<'_,\
    \ &str>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .cloned()\n        .chain(s.chars().filter(|&c| !c.is_ascii_letter()))\n\
    \        .cloned()\n        .chain(s.chars().filter(|&c| !c.is_ascii_digit()))\n\
    \        .cloned()\n        .chain(s.chars().filter(|&c| !c.is_ascii_lowercase()))\n\
    \        .cloned()\n        .chain(s.chars().filter(|&c| !c.is_ascii_uppercase()))\n\
    \        .cloned()\n        .chain(s.chars().filter(|&c| !c.is_ascii_punctuation()))\n\
    \        .cloned()\n        .chain(s.chars().filter(|&c| !c.is_ascii_whitespace()))\n\
    \        .cloned()\n        .map(|c| if c.is_ascii_letter() { c.to_ascii_lowercase()\
    \ } else { c })\n        .collect()\n        .cloned()\n        .chain(s.chars().filter(|&c|\
    \ !c.is_ascii_letter()))\n        .collect::<String>()\n}\n\nfn main() {\n   \
    \ let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpgp_62_bz.rs:12:10\n     |\n12   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `chain` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpgp_62_bz.rs:13:10\n\
    \   |\n13 |           .chain(s.chars().filter(|&c| !c.is_ascii_letter()))\n  \
    \ |            ^^^^^ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Chars<'_> as Iterator>::Item = &_`\n           which is required\
    \ by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n\
    \           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpgp_62_bz.rs:13:41\n   |\n13 |         .chain(s.chars().filter(|&c|\
    \ !c.is_ascii_letter()))\n   |                                         ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpgp_62_bz.rs:28:41\n   |\n28 |         .chain(s.chars().filter(|&c|\
    \ !c.is_ascii_letter()))\n   |                                         ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Split the input string into tokens\n    let mut tokens = s.split_whitespace();\n\
    \    // Sort each token\n    tokens.sort_by(|a, b| a.cmp(b));\n    // Join all\
    \ tokens again\n    tokens.join().to_string()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpmiv9hx7a.rs:14:12\n   |\n14 |     tokens.sort_by(|a,\
    \ b| a.cmp(b));\n   |            ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `join` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpmiv9hx7a.rs:16:12\n   |\n16 |     tokens.join().to_string()\n\
    \   |            ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s.to_string();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < s.len() {\n        let mut tmp = s[i];\n        if tmp == ' ' {\n      \
    \      if j > i {\n                s[i] = s[j];\n                s[j] = 'z';\n\
    \            }\n            i += 1;\n            j += 1;\n        } else {\n \
    \           if j > i {\n                s[j] = tmp;\n            }\n         \
    \   i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7jbhmfyn.rs:15:23\n\
    \   |\n15 |         let mut tmp = s[i];\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7jbhmfyn.rs:18:17\n   |\n18 |                 s[i] = s[j];\n  \
    \ |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7jbhmfyn.rs:18:24\n   |\n18 |                 s[i] = s[j];\n  \
    \ |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut chars = s;\n    let mut result = s;\n    let mut newchars = s;\n\
    \    while newchars.len() != 0 {\n        let mut char = newchars.remove(0);\n\
    \        let mut newchar = newchars.remove(0);\n        while newchar != char\
    \ {\n            chars.remove(0);\n            newchars.remove(0);\n        }\n\
    \        result.push(char);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbvkzsbzg.rs:15:13\n\
    \   |\n15 |         let mut char = newchars.remove(0);\n   |             ----^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmpbvkzsbzg.rs:16:13\n   |\n16 |         let mut newchar\
    \ = newchars.remove(0);\n   |             ----^^^^^^^\n   |             |\n  \
    \ |             help: remove this `mut`\n\nerror[E0382]: use of moved value: `s`\n\
    \  --> /tmp/tmpbvkzsbzg.rs:12:22\n   |\n10 | fn anti_shuffle(s: String) -> String\
    \ {\n   |                 - move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n11 |     let mut chars = s;\n   |          \
    \           - value moved here\n12 |     let mut result = s;\n   |           \
    \           ^ value used here after move\n\nerror[E0382]: use of moved value:\
    \ `s`\n  --> /tmp/tmpbvkzsbzg.rs:13:24\n   |\n10 | fn anti_shuffle(s: String)\
    \ -> String {\n   |                 - move occurs because `s` has type `String`,\
    \ which does not implement the `Copy` trait\n11 |     let mut chars = s;\n12 |\
    \     let mut result = s;\n   |                      - value moved here\n13 |\
    \     let mut newchars = s;\n   |                        ^ value used here after\
    \ move\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().group_by(|&x| x).collect::<Vec<_>>().into_iter().map(|x| {\n  \
    \      let mut x = x.clone();\n        x.sort_by_key(|&x| x.to_ascii_lowercase().unwrap());\n\
    \        x\n    }).collect::<Vec<_>>().join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpczxrmffn.rs:11:15\n   |\n11 |     s.chars().group_by(|&x|\
    \ x).collect::<Vec<_>>().into_iter().map(|x| {\n   |               ^^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().filter(|x| *x != ' ').collect::<Vec<_>>().sort_unstable().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpvhb26836.rs:11:73\n\
    \   |\n11 |     s.chars().filter(|x| *x != ' ').collect::<Vec<_>>().sort_unstable().collect::<String>()\n\
    \   |                                                                        \
    \ ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // TODO: Your code here\n    let mut l = s.chars();\n    let mut d = String::new();\n\
    \n    for (i, _) in l.enumerate() {\n        for j in (i..s.len()).rev() {\n \
    \           if s[j].is_ascii_lowercase() {\n                d.push((s[j]).to_string());\n\
    \                s.insert(j + 1, \" \");\n                break;\n           \
    \ }\n        }\n    }\n    l.sort_by(|a, b| a.cmp(b));\n    d.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoyku9cvj.rs:17:16\n\
    \   |\n17 |             if s[j].is_ascii_lowercase() {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpoyku9cvj.rs:18:24\n   |\n18 |                 d.push((s[j]).to_string());\n\
    \   |                        ^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoyku9cvj.rs:19:33\n\
    \   |\n19 |                 s.insert(j + 1, \" \");\n   |                    \
    \             ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write\
    \ a `char` literal, use single quotes\n   |\n19 |                 s.insert(j +\
    \ 1, ' ');\n   |                                 ~~~\n\nerror[E0599]: no method\
    \ named `sort_by` found for struct `Chars` in the current scope\n  --> /tmp/tmpoyku9cvj.rs:24:7\n\
    \   |\n24 |     l.sort_by(|a, b| a.cmp(b));\n   |       ^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: the method `into_iter` exists for struct `String`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    words.sort_by(|a, b| a.cmp(b));\n\
    \    let mut result = String::new();\n    for word in words {\n        result.push_str(word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmppvfthqst.rs:12:11\n   |\n12 |     words.sort_by(|a,\
    \ b| a.cmp(b));\n   |           ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result = String::new();\n    for word in s.split_whitespace() {\n\
    \        let mut new_word = String::new();\n        let mut new_word_ord = String::new();\n\
    \        let mut idx = 0;\n        for c in word.chars() {\n            if c <\
    \ 'A' || c > 'Z' {\n                new_word.push(c);\n            } else if idx\
    \ != 0 {\n                new_word_ord.push(c);\n                idx = 0;\n  \
    \          }\n            idx += 1;\n        }\n        let word_ord = new_word_ord.chars().fold(0,\
    \ |a, b| {\n            match a < b {\n                true => a,\n          \
    \      false => b,\n            }\n        });\n        result.push_str(&format!(\"\
    {}{}\", new_word, word_ord));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2rfx7u_9.rs:26:23\n   |\n\
    26 |             match a < b {\n   |                       ^ expected integer,\
    \ found `char`\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmp2rfx7u_9.rs:26:21\n\
    \   |\n26 |             match a < b {\n   |                     ^ no implementation\
    \ for `{integer} < char` and `{integer} > char`\n   |\n   = help: the trait `PartialOrd<char>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: `match` arms have incompatible\
    \ types\n  --> /tmp/tmp2rfx7u_9.rs:28:26\n   |\n26 | /             match a < b\
    \ {\n27 | |                 true => a,\n   | |                         - this\
    \ is found to be of type `{integer}`\n28 | |                 false => b,\n   |\
    \ |                          ^ expected integer, found `char`\n29 | |        \
    \     }\n   | |_____________- `match` arms have incompatible types\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.replace(r#\"\\s+\" => \" \"#)\n        .chars()\n        .filter(|c| *c\
    \ != ' ')\n        .fold(\"\", |mut acc, c| {\n            match c {\n       \
    \         ' ' => acc.to_ascii_lowercase(),\n                'a' => acc.to_ascii_lowercase().to_ascii_lowercase(),\n\
    \                'b' => acc.to_ascii_lowercase().to_ascii_uppercase(),\n     \
    \           'c' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'd' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase(),\n\
    \                'e' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'f' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase(),\n\
    \                'g' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'h' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'i' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'j' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'k' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'l' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'm' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'n' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'o' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'p' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_uppercase().to_ascii_lowercase(),\n\
    \                'q' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5f7uzd2n.rs:45:3\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |         .fold(\"\", |mut acc,\
    \ c| {\n   |              -                 - unclosed delimiter\n   |       \
    \       |\n   |              unclosed delimiter\n15 |             match c {\n\
    \   |                     - this delimiter might not be properly closed...\n...\n\
    34 | }\n   | - ...as it matches this but it has different indentation\n...\n45\
    \ | }\n   |   ^\n\nerror[E0061]: this function takes 2 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmp5f7uzd2n.rs:11:7\n    |\n11  |     s.replace(r#\"\
    \\s+\" => \" \"#)\n    |       ^^^^^^^ --------------- supplied 1 argument\n \
    \   |       |\n    |       expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5f7uzd2n.rs:14:15\n\
    \   |\n14 |         .fold(\"\", |mut acc, c| {\n   |               ^^- help: try\
    \ using a conversion method: `.to_string()`\n   |               |\n   |      \
    \         expected struct `String`, found `&str`\n\nerror[E0609]: no field `to_ascii_`\
    \ on type `String`\n  --> /tmp/tmp5f7uzd2n.rs:33:70\n   |\n33 |              \
    \   'q' => acc.to_ascii_lowercase().to_ascii_uppercase().to_ascii_\n   |     \
    \                                                                 ^^^^^^^^^ unknown\
    \ field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5f7uzd2n.rs:14:32\n \
    \  |\n14 |           .fold(\"\", |mut acc, c| {\n   |  ________________________________^\n\
    15 | |             match c {\n16 | |                 ' ' => acc.to_ascii_lowercase(),\n\
    17 | |                 'a' => acc.to_ascii_lowercase().to_ascii_lowercase(),\n\
    ...  |\n44 | |     assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot.\
    \ How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?...\n\
    45 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0609.\nFor more information about an error, try `rustc --"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().map(|c| *c < 'A' || *c > 'Z' || *c < 'a' || *c > 'z').collect::<Vec<char>>().iter().chain(s.split_whitespace().collect()).collect::<Vec<_>>().sort().iter().collect::<Vec<_>>().chain(s.split_whitespace().collect()).collect::<Vec<_>>().collect().to_string()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpzvsuaymm.rs:11:23\n\
    \   |\n11 |     s.chars().map(|c| *c < 'A' || *c > 'Z' || *c < 'a' || *c > 'z').collect::<Vec<char>>().iter().chain(s.split_whitespace().collect()).c...\n\
    \   |                       ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpzvsuaymm.rs:11:35\n   |\n11 |     s.chars().map(|c| *c < 'A' ||\
    \ *c > 'Z' || *c < 'a' || *c > 'z').collect::<Vec<char>>().iter().chain(s.split_whitespace().collect()).c...\n\
    \   |                                   ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmpzvsuaymm.rs:11:47\n   |\n11 |     s.chars().map(|c|\
    \ *c < 'A' || *c > 'Z' || *c < 'a' || *c > 'z').collect::<Vec<char>>().iter().chain(s.split_whitespace().collect()).c...\n\
    \   |                                               ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpzvsuaymm.rs:11:59\n   |\n11 |     s.chars().map(|c|\
    \ *c < 'A' || *c > 'Z' || *c < 'a' || *c > 'z').collect::<Vec<char>>().iter().chain(s.split_whitespace().collect()).c...\n\
    \   |                                                           ^^\n\nerror[E0277]:\
    \ a value of type `Vec<char>` cannot be built from an iterator over elements of\
    \ type `bool`\n    --> /tmp/tmpzvsuaymm.rs:11:69\n     |\n11   | ... *c < 'a'\
    \ || *c > 'z').collect::<Vec<char>>().iter().chain(s.split_whitespace().collect()).collect::<Vec<_>>().sort().iter().collect::...\n\
    \     |                           ^^^^^^^ value of type `Vec<char>` cannot be\
    \ built from `std::iter::Iterator<Item=bool>`\n     |\n     = help: the trait\
    \ `FromIterator<bool>` is not implemented for `Vec<char>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0599]: no method named `iter` found for unit type `()` in\
    \ the current scope\n  --> /tmp/tmpzvsuaymm.rs:11:164\n   |\n11 | ..._whitespace().collect()).collect::<Vec<_>>().sort().iter().collect::<Vec<_>>().chain(s.split_whitespace().collect()).collect::<Vec<_>>...\n\
    \   |                                            "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut res = String::from(s);\n    while let Some(w)\
    \ = s.split_first_word() {\n        let w = w.to_lowercase();\n        res.push_str(&w);\n\
    \        if w != \"!\" {\n            res.push_str(\"!\");\n        }\n    }\n\
    \    while let Some(mut s) = s.split_first_word() {\n        s.push('!');\n  \
    \      res.push_str(&s);\n    }\n    if let Some(mut s) = s.split_first_word()\
    \ {\n        res.push_str(\"!\");\n    }\n    res.push_str(\"!\");\n    res\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_first_word` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpux3mavzq.rs:13:27\n   |\n13 |     while\
    \ let Some(w) = s.split_first_word() {\n   |                           ^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `split_at`\n\nerror[E0277]:\
    \ can't compare `str` with `&str`\n  --> /tmp/tmpux3mavzq.rs:16:14\n   |\n16 |\
    \         if w != \"!\" {\n   |              ^^ no implementation for `str ==\
    \ &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented for `str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0599]: no method\
    \ named `split_first_word` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpux3mavzq.rs:20:31\n   |\n20 |     while let Some(mut s) = s.split_first_word()\
    \ {\n   |                               ^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror[E0599]: no method named `split_first_word`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpux3mavzq.rs:24:28\n\
    \   |\n24 |     if let Some(mut s) = s.split_first_word() {\n   |            \
    \                ^^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `split_at`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write code here\n    let mut res = s.to_string();\n    let mut new_string\
    \ = String::from(\"\");\n\n    for ch in res.chars() {\n        let index = s.find_first_of(&ch);\n\
    \        if index == Some(s.len() - 1) {\n            new_string += &ch;\n   \
    \     }\n        else {\n            let next_ch = s[index + 1].unwrap().to_ascii_lowercase();\n\
    \            if next_ch == ch.to_ascii_lowercase() {\n                new_string\
    \ += &ch;\n            }\n            else{\n                new_string += &ch.to_ascii_lowercase();\n\
    \            }\n        }\n    }\n    return new_string.to_string();\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find_first_of` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpj2qewjo8.rs:16:23\n   |\n16 |         let\
    \ index = s.find_first_of(&ch);\n   |                       ^^^^^^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj2qewjo8.rs:18:27\n\
    \   |\n18 |             new_string += &ch;\n   |                           ^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpj2qewjo8.rs:23:31\n   |\n23 |                 new_string += &ch;\n \
    \  |                               ^^^ expected `str`, found `char`\n   |\n  \
    \ = note: expected reference `&str`\n              found reference `&char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj2qewjo8.rs:26:31\n   |\n26 |  \
    \               new_string += &ch.to_ascii_lowercase();\n   |                \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.split_whitespace().collect::<Vec<_>>().sort_by(|a, b| a.cmp(b)).collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpycok3qmv.rs:11:71\n\
    \   |\n11 |     s.split_whitespace().collect::<Vec<_>>().sort_by(|a, b| a.cmp(b)).collect()\n\
    \   |                                                                       ^^^^^^^\
    \ `()` is not an iterator\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `(): Iterator`\n           which is required by `&mut\
    \ (): Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s\n        .split_whitespace()\n        .collect::<Vec<&str>>()\n\
    \        .iter()\n        .cloned()\n        .collect::<Vec<&str>>();\n    //\
    \ sort the string\n    s.sort_by_key(|&x| x.as_bytes().to_vec().iter().cloned());\n\
    \    // replace all the words\n    s.iter_mut().enumerate().for_each(|(i, x)|\
    \ {\n        if i % 2 == 0 {\n            *i = \"!\".to_string();\n        }\n\
    \    });\n    s.join(\"\").to_string()\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Cloned<std::slice::Iter<'_, u8>>: Ord` is\
    \ not satisfied\n   --> /tmp/tmpci0n06i4.rs:18:19\n    |\n18  |     s.sort_by_key(|&x|\
    \ x.as_bytes().to_vec().iter().cloned());\n    |       ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `Cloned<std::slice::Iter<'_, u8>>`\n\
    \    |       |\n    |       required by a bound introduced by this call\n    |\n\
    note: required by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpci0n06i4.rs:22:13\n   |\n\
    22 |             *i = \"!\".to_string();\n   |             ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ word_len: usize = 0;\n    let mut char_count = 0;\n    while char_count < s.len()\
    \ {\n        // find the index of first space\n        let mut index = s.find(char::whitespace);\n\
    \        if index == s.len() {\n            break;\n        }\n        let mut\
    \ next_index = index + 1;\n        // find next non space character\n        while\
    \ next_index < s.len() {\n            if s[next_index] == char::whitespace {\n\
    \                break;\n            }\n            next_index += 1;\n       \
    \ }\n        // find the end of word\n        let mut end_index = next_index;\n\
    \        while end_index < s.len() {\n            if s[end_index] == char::whitespace\
    \ {\n                break;\n            }\n            end_index += 1;\n    \
    \    }\n        let mut word = &mut s[..end_index];\n        // find the first\
    \ character not being alphabetic\n        let mut next_char = char::ascii_lowercase;\n\
    \        while next_char == char::ascii_lowercase && next_index < s.len() {\n\
    \            if s[next_index] == char::ascii_lowercase {\n                next_char\
    \ += 1;\n            }\n            next_index += 1;\n        }\n        // skip\
    \ if next character is blank\n        if next_char == char::ascii_lowercase {\n\
    \            next_char = char::ascii_lowercase;\n        }\n        // skip if\
    \ next_char is non alphabetic\n        if next_char != char::ascii_lowercase {\n\
    \            next_char = char::ascii_lowercase;\n        }\n        // skip if\
    \ previous character is alphabetic\n        let mut prev_char = char::ascii_lowercase;\n\
    \        if index > 0 {\n            prev_char = &s[index - 1];\n            if\
    \ prev_char == char::ascii_lowercase {\n                prev_char = char::ascii_lowercase;\n\
    \            }\n        }\n        // if previous char and current char are different,\
    \ swap\n        if prev_char != char::ascii_lowercase && next_char != char::ascii_lowercase\
    \ {\n            swap(&mut s[..index], &mut s[index..end_index]);\n        }\n\
    \        result.push(word);\n        word_len += 1;\n        char_count += 1;\n\
    \    }\n    result.reserve(word_len);\n    for word in result {\n        println!(\"\
    {}\", word);\n    }\n    s.to_string()\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp7885e83v.rs:64:13\n\
    \   |\n64 |             swap(&mut s[..index], &mut s[index..end_index]);\n   |\
    \             ^^^^ not found in this scope\n   |\nhelp: consider importing one\
    \ of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0599]: no function or associated item named `whitespace` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp7885e83v.rs:17:38\n   |\n\
    17 |         let mut index = s.find(char::whitespace);\n   |                 \
    \                     ^^^^^^^^^^\n   |                                      |\n\
    \   |                                      function or associated item not found\
    \ in `char`\n   |                                      help: there is an associated\
    \ function with a similar name: `is_ascii_whitespace`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7885e83v.rs:18:21\n   |\n18 |         if index == s.len()\
    \ {\n   |                     ^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n18 |         if index == Some(s.len())\
    \ {\n   |                     +++++       +\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmp7885e83v.rs:21:36\n   |\n21 |         let\
    \ mut next_index = index + 1;\n   |                              ----- ^ - {integer}\n\
    \   |                              |\n   |                              Option<usize>\n\
    \nerror[E0599]: no function or associated item named `whitespace` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp7885e83v.rs:24:39\n   |\n24 |   \
    \          if s[next_index] == char::whitespace {\n   |                      \
    \                 ^^^^^^^^^^\n   |                                       |\n \
    \  |                                       function or associated item not found\
    \ in `char`\n   |                                       help: there is an associated\
    \ function with a similar name: `is_ascii_whitespace`\n\nerror[E0599]: no function\
    \ or associated ite"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // TODO: implement the function\n    s.chars()\n        .map(|c| c.to_ascii_lowercase().to_ascii_lowercase())\n\
    \        .collect()\n        .sort_by(|a,b| a.cmp(&b))\n        .collect()\n \
    \       .join(\"_\")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpy8oqv3pf.rs:14:10\n\
    \   |\n14 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n14 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.split_whitespace().collect::<Vec<_>>().sort_by_key(|&word| {\n        let\
    \ mut counter = 0;\n        for c in word.as_str() {\n            counter += c.to_digit(10);\n\
    \        }\n        counter\n    }).collect::<Vec<_>>().join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_str` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpibwtvxcj.rs:13:23\n   |\n13 |         for c in\
    \ word.as_str() {\n   |                      -^^^^^^-- help: remove this method\
    \ call\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpibwtvxcj.rs:17:8\n\
    \   |\n17 |     }).collect::<Vec<_>>().join(\" \")\n   |        ^^^^^^^ `()` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().map(|c| {\n        if c == ' ' {\n            c.to_ascii_lowercase()\n\
    \        } else {\n            c\n        }\n    }).collect::<Vec<_>>().join(\"\
    \").to_string()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `join` exists for struct `Vec<char>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpc59kafog.rs:17:28\n   |\n17 |\
    \     }).collect::<Vec<_>>().join(\"\").to_string()\n   |                    \
    \        ^^^^ method cannot be called on `Vec<char>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `[char]: Join<_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // TODO: implement your logic here\n    s.to_string()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpyhwnttzk.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut new_s = String::with_capacity(s.len());\n   \
    \ let mut is_space = false;\n    let mut is_first_word = true;\n\n    for ch in\
    \ s.chars() {\n        if !is_space {\n            if is_first_word {\n      \
    \          is_first_word = false;\n                new_s.push_str(&ch);\n    \
    \            continue;\n            }\n\n            if let Some(i) = new_s.rfind(|c|\
    \ *c == ch && c != ' ') {\n                let mut j = i;\n                while\
    \ j > 0 && new_s[j - 1] == ' ' {\n                    j -= 1;\n              \
    \  }\n                *j = ch;\n            } else {\n                new_s.push('_');\n\
    \                new_s.push(ch);\n            }\n            is_space = true;\n\
    \        } else {\n            if let Some(i) = new_s.rfind(|c| *c == ch && c\
    \ != ' ') {\n                new_s.insert(new_s.len(), ch);\n            }\n \
    \       }\n    }\n\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl9tthsch.rs:20:32\n   |\n\
    20 |                 new_s.push_str(&ch);\n   |                              \
    \  ^^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpl9tthsch.rs:26:32\n   |\n26 |         \
    \        while j > 0 && new_s[j - 1] == ' ' {\n   |                          \
    \      ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpl9tthsch.rs:29:17\n\
    \   |\n29 |                 *j = ch;\n   |                 ^^\n   |\nhelp: parentheses\
    \ are required to parse this as an expression\n   |\n26 ~                 (while\
    \ j > 0 && new_s[j - 1] == ' ' {\n27 |                     j -= 1;\n28 ~     \
    \            })\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut r = String::with_capacity(s.size());\n    let mut m = String::with_capacity(s.size());\n\
    \    for (i, c) in s.chars().enumerate() {\n        if !m.is_empty() {\n     \
    \       r.push(*m);\n            r.push(c);\n            m.clear();\n        }\
    \ else {\n            if c.is_alphabetic() {\n                m.push(c);\n   \
    \         } else {\n                let len = c.len_utf8();\n                let\
    \ mut r = String::with_capacity(len + 1);\n                r.push(*m);\n     \
    \           r.push(c);\n                m = r;\n            }\n        }\n   \
    \ }\n    r.push(*m);\n    r\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp82na78sm.rs:11:41\n   |\n11 |     let mut r = String::with_capacity(s.size());\n\
    \   |                                         ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp82na78sm.rs:12:41\n   |\n12 |     let mut m = String::with_capacity(s.size());\n\
    \   |                                         ^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp82na78sm.rs:15:20\n   |\n15 |\
    \             r.push(*m);\n   |                    ^^ expected `char`, found `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp82na78sm.rs:24:24\n   |\n24 |\
    \                 r.push(*m);\n   |                        ^^ expected `char`,\
    \ found `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82na78sm.rs:30:12\n\
    \   |\n30 |     r.push(*m);\n   |            ^^ expected `char`, found `str`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    let mut res =\n        String::with_capacity(words[0].chars().count()\
    \ + words.len() * 2);\n    let mut new_string = \"\";\n    for word in words {\n\
    \        let mut new_word = \"\";\n        let mut new_letter_count = 1;\n   \
    \     for letter in word.chars() {\n            if new_letter_count == 1 {\n \
    \               new_word += letter;\n                new_letter_count += 1;\n\
    \                continue;\n            }\n            let mut ascii_val = letter;\n\
    \            let mut next_letter_count = 1;\n            while ascii_val != 0\
    \ {\n                ascii_val -= 0x41;\n                next_letter_count +=\
    \ 1;\n            }\n            new_word += new_letter_count.to_string();\n \
    \           new_letter_count = next_letter_count;\n        }\n        res += &new_word.to_string();\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpwmoq8yun.rs:13:31\n   |\n13 |         String::with_capacity(words[0].chars().count()\
    \ + words.len() * 2);\n   |                               ^^^^^^^^\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpwmoq8yun.rs:13:64\n   |\n13 |         String::with_capacity(words[0].chars().count()\
    \ + words.len() * 2);\n   |                                                  \
    \              ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpwmoq8yun.rs:20:17\n\
    \   |\n20 |                 new_word += letter;\n   |                 --------^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwmoq8yun.rs:26:32\n   |\n26 |\
    \             while ascii_val != 0 {\n   |                                ^ expected\
    \ `char`, found `u8`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmpwmoq8yun.rs:27:17\n   |\n27 |     \
    \            ascii_val -= 0x41;\n   |                 ---------^^^^^^^^\n   |\
    \                 |\n   |                 cannot use `-=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpwmoq8yun.rs:30:13\n\
    \   |\n30 |             new_word += new_letter_count.to_string();\n   |      \
    \       --------^--^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |        |\n\
    \   |             |        `+` cannot be used to concatenate a `&str` with a `String`\n\
    \   |             cannot use `+=` on type `&str`\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368, E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s.to_owned();\n    let mut buffer = String::new();\n    let mut\
    \ index = s.len();\n    let mut current_char = 0;\n\n    while index > 0 {\n \
    \       while index > 0 && current_char < s.len() {\n            let char = s[index\
    \ - 1];\n            let next_char = s[index];\n            if char == next_char\
    \ {\n                buffer.push_str(&s[current_char..]);\n                buffer.push_str(&s[next_char..]);\n\
    \                index -= 1;\n                index -= 1;\n                break;\n\
    \            }\n            if char == ' ' {\n                index -= 1;\n  \
    \              current_char += 1;\n            }\n        }\n        if index\
    \ == 0 {\n            buffer.push_str(&s[..]);\n            buffer.push_str(&s[..]);\n\
    \            index += 1;\n            current_char += 1;\n        }\n    }\n \
    \   buffer\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp13wxreyn.rs:18:24\n\
    \   |\n18 |             let char = s[index - 1];\n   |                       \
    \ ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp13wxreyn.rs:19:29\n   |\n19 |             let next_char = s[index];\n\
    \   |                             ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut result: String = \"\";\n    while !s.is_empty()\
    \ {\n        let mut i = 1;\n        let mut j = s.len();\n        while i <=\
    \ j {\n            if s[i].to_ascii_lowercase().cmp(&s[j].to_ascii_lowercase())\
    \ > 0 {\n                result.push_str(&s[i - 1].to_ascii_lowercase());\n  \
    \              i += 1;\n            } else {\n                result.push_str(&s[j\
    \ - 1].to_ascii_lowercase());\n                j -= 1;\n            }\n      \
    \  }\n        result.push_str(&s[i - 1].to_ascii_lowercase());\n        i += 1;\n\
    \        while i <= j {\n            result.push_str(&s[i - 1].to_ascii_lowercase());\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp7ap4o6m.rs:12:30\n   |\n\
    12 |     let mut result: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpp7ap4o6m.rs:17:16\n   |\n\
    17 |             if s[i].to_ascii_lowercase().cmp(&s[j].to_ascii_lowercase())\
    \ > 0 {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp7ap4o6m.rs:17:47\n\
    \   |\n17 |             if s[i].to_ascii_lowercase().cmp(&s[j].to_ascii_lowercase())\
    \ > 0 {\n   |                                               ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp7ap4o6m.rs:18:34\n   |\n18 |                 result.push_str(&s[i\
    \ - 1].to_ascii_lowercase());\n   |                                  ^^^^^^^^\
    \ `String` c"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut l = s.len();\n    let mut new_s = String::with_capacity(s.len());\n\
    \    let mut counter = 0;\n    while l > 0 {\n        if counter > 0 {\n     \
    \       new_s.push_str(&s[counter..(l-1)]);\n            new_s.push_str(&s[l..counter]);\n\
    \            l += counter;\n        }\n        counter += 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'begin <= end (2 <= 1) when slicing `Hi`', library/core/src/str/mod.rs:111:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Convert string to lowercase\n    let mut new_s = s.to_lowercase();\n \
    \   let mut res = String::with_capacity(new_s.len());\n    \n    // Split string\
    \ into words\n    for word in new_s.split(\" \") {\n        // Get ascii value\
    \ for word\n        let word_ascii = word\n            .chars()\n            .filter(|c|\
    \ c != '\\n')\n            .map(|c| c.to_ascii_lower())\n            .collect::<Vec<_>>();\n\
    \        \n        // Sort ascii value of word\n        word_ascii.sort();\n \
    \       \n        // Write ascii value of word to res\n        for ascii in word_ascii\
    \ {\n            res.push_str(&ascii);\n        }\n        \n        // Add space\n\
    \        res.push_str(\" \");\n    }\n    \n    // Add newline\n    res.push_str(\"\
    \\n\");\n    \n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2ogcb9mu.rs:20:27\n\
    \   |\n20 |             .filter(|c| c != '\\n')\n   |                        \
    \   ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0599]: no method named `to_ascii_lower` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp2ogcb9mu.rs:21:24\n   |\n21 |   \
    \          .map(|c| c.to_ascii_lower())\n   |                        ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp2ogcb9mu.rs:28:13\n   |\n28 |         for ascii in word_ascii\
    \ {\n   |             ^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp2ogcb9mu.rs:28:22\n    |\n28  |\
    \         for ascii in word_ascii {\n    |                      ^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Option`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp2ogcb9mu.rs:28:9\n    |\n28  | /         for ascii in word_ascii {\n\
    29  | |             res.push_str(&ascii);\n30  | |         }\n    | |_________^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `None`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp2ogcb9mu.rs:25:20\n   |\n25 |         word_ascii.sort();\n   |     \
    \               ^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemen"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words: Vec<&str> = s.split_whitespace().collect();\n    let mut rev_words:\
    \ Vec<&str> = words.reverse();\n    rev_words.sort_by(|x, y| y.cmp(&x).reverse());\n\
    \    rev_words.reverse();\n    let mut new_words: Vec<&str> = vec![];\n    for\
    \ x in rev_words.clone() {\n        if !words.contains(&x) {\n            new_words.push(&x);\n\
    \        }\n    }\n    new_words.sort_by(|x, y| y.cmp(&x).reverse());\n    new_words.reverse();\n\
    \    let mut res = String::new();\n    for x in new_words {\n        res.push_str(&x);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0o2usg8n.rs:12:36\n   |\n\
    12 |     let mut rev_words: Vec<&str> = words.reverse();\n   |               \
    \         ---------   ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \                        |\n   |                        expected due to this\n\
    \   |\n   = note: expected struct `Vec<&str>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut word_list = String::new();\n    s.split_whitespace().sort_by_key(|x|x.0).filter(|x|x.len()\
    \ > 0).forEach(|x|{\n        word_list.push_str(x);\n    });\n    word_list.push_str(\"\
    \");\n    return word_list;\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpnapbx5m5.rs:13:26\n   |\n13 |     s.split_whitespace().sort_by_key(|x|x.0).filter(|x|x.len()\
    \ > 0).forEach(|x|{\n   |                          ^^^^^^^^^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::with_capacity(s.len());\n    s.chars().enumerate().for_each(|(i,c)|\
    \ {\n        let pos = c.to_ascii_lowercase().chars().enumerate().skip(1).count();\n\
    \        let new_word = s.chars().enumerate()\n            .skip(i)\n        \
    \    .take(pos)\n            .map(|(_,c)| c)\n            .collect::<String>();\n\
    \        res += new_word;\n    });\n    res\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpmm956lhb.rs:13:42\n   |\n13 |         let pos = c.to_ascii_lowercase().chars().enumerate().skip(1).count();\n\
    \   |                                          ^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmm956lhb.rs:19:16\n   |\n19 |\
    \         res += new_word;\n   |                ^^^^^^^^\n   |               \
    \ |\n   |                expected `&str`, found struct `String`\n   |        \
    \        help: consider borrowing here: `&new_word`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    match &s[..] {\n        \" \" => \"\",\n        &_ => s,\n    }.sort_by(|a,\
    \ b| b.len_utf8() - a.len_utf8()).join(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpxdv5b7p4.rs:13:15\n\
    \   |\n11 | /     match &s[..] {\n12 | |         \" \" => \"\",\n   | |      \
    \          -- this is found to be of type `&str`\n13 | |         &_ => s,\n  \
    \ | |               ^ expected `&str`, found struct `String`\n14 | |     }.sort_by(|a,\
    \ b| b.len_utf8() - a.len_utf8()).join(\"\")\n   | |_____- `match` arms have incompatible\
    \ types\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().iter().filter_map(|c| {\n        if c.is_whitespace() {\n     \
    \       None\n        } else {\n            Some(c.to_ascii_lower())\n       \
    \ }\n    }).cloned().collect::<String>().sort_by(|a, b| a.cmp(b)).collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp8wcf0ewu.rs:11:15\n   |\n11 |     s.chars().iter().filter_map(|c|\
    \ {\n   |               ^^^^ private field, not a method\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    use std::ascii::AsciiExt;\n\n    let mut words = s.chars();\n\n    let mut\
    \ new_s = String::with_capacity(s.len());\n    let mut word: char;\n    let mut\
    \ new_word: char;\n    let mut new_word = ' ';\n    let mut index = 0;\n\n   \
    \ loop {\n        word = words.next().unwrap();\n        if index == 0 {\n   \
    \         new_s.append(&word);\n        } else {\n            new_s.append(&new_word);\n\
    \            new_s.append(&word);\n            new_s.append(&new_word);\n    \
    \    }\n\n        index = index + 1;\n\n        if word.to_ascii_lowercase().is_ascii_whitespace()\
    \ {\n            new_s.append(&new_word);\n            new_s.append(&new_word);\n\
    \            new_s.append(&new_word);\n            new_s.append(&new_word);\n\
    \            index = index + 1;\n        }\n    }\n\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated trait `std::ascii::AsciiExt`: use inherent methods\
    \ instead\n  --> /tmp/tmp1i8vzu8c.rs:11:21\n   |\n11 |     use std::ascii::AsciiExt;\n\
    \   |                     ^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1i8vzu8c.rs:24:19\n   |\n24 |          \
    \   new_s.append(&word);\n   |                   ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1i8vzu8c.rs:26:19\n   |\n26 |             new_s.append(&new_word);\n\
    \   |                   ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp1i8vzu8c.rs:27:19\n   |\n27 |             new_s.append(&word);\n   |\
    \                   ^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmp1i8vzu8c.rs:28:19\n\
    \   |\n28 |             new_s.append(&new_word);\n   |                   ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp1i8vzu8c.rs:34:19\n\
    \   |\n34 |             new_s.append(&new_word);\n   |                   ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp1i8vzu8c.rs:35:19\n\
    \   |\n35 |             new_s.append(&new_word);\n   |                   ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp1i8vzu8c.rs:36:19\n\
    \   |\n36 |             new_s.append(&new_word);\n   |                   ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp1i8vzu8c.rs:37:19\n\
    \   |\n37 |             new_s.append(&new_word);\n   |                   ^^^^^^\
    \ method not found in `String`\n\nwarning: un"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    \n    let mut result = s.to_string();\n    \n    let mut words = s.split_whitespace();\n\
    \    \n    loop {\n        \n        let mut tmp_result = String::new();\n   \
    \     \n        for word in words {\n            \n            let mut temp_result\
    \ = String::new();\n            \n            for mut c in word.chars() {\n  \
    \              \n                let temp_result = (c + temp_result).to_string();\n\
    \                \n                if temp_result.len() < c.len() {\n        \
    \            temp_result.push(0);\n                }\n            }\n        \
    \    \n            tmp_result.push((temp_result + tmp_result).to_string());\n\
    \            \n            if tmp_result.len() < word.len() {\n              \
    \  tmp_result.push(0);\n            }\n        }\n        \n        result = tmp_result\
    \ + result;\n        \n        let mut tmp_words = tmp_result.split_whitespace();\n\
    \        \n        if tmp_words.length != words.length {\n            break;\n\
    \        }\n        \n        words = tmp_words;\n    }\n    \n    result\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `String` to `char`\n  --> /tmp/tmpikkvyccc.rs:26:38\n\
    \   |\n26 |                 let temp_result = (c + temp_result).to_string();\n\
    \   |                                    - ^ ----------- String\n   |        \
    \                            |\n   |                                    char\n\
    \nerror[E0599]: no method named `len` found for type `char` in the current scope\n\
    \  --> /tmp/tmpikkvyccc.rs:28:42\n   |\n28 |                 if temp_result.len()\
    \ < c.len() {\n   |                                          ^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpikkvyccc.rs:33:44\n\
    \   |\n33 |             tmp_result.push((temp_result + tmp_result).to_string());\n\
    \   |                                            ^^^^^^^^^^\n   |            \
    \                                |\n   |                                     \
    \       expected `&str`, found struct `String`\n   |                         \
    \                   help: consider borrowing here: `&tmp_result`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpikkvyccc.rs:33:29\n   |\n33 |             tmp_result.push((temp_result\
    \ + tmp_result).to_string());\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpikkvyccc.rs:36:33\n   |\n36 |                 tmp_result.push(0);\n\
    \   |                                 ^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpikkvyccc.rs:40:31\n   |\n40 |         result\
    \ = tmp_result + result;\n   |                               ^^^^^^\n   |    \
    \                           |\n   |                               expected `&str`,\
    \ found struct `String`\n   |                               help: consider borrowing\
    \ here: `&result`\n\nerror[E0609]: no field `length` on type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpikkvyccc.rs:44:22\n   |\n44 |         if tmp_words.length != words.length\
    \ {\n   |                      ^^^^^^ unknown field\n\nerror[E0609]: no field\
    \ `length` on type `SplitWhitespace<'_>`\n  --> /tmp/tmpikkvyccc.rs:44:38\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::from(s);\n    let mut alphabet_order = vec!['A'..'Z'];\n\
    \    let mut vowel_order = vec!['A'..'E'];\n    let mut consonant_order = vec!['A'..'Z',\
    \ 'a'..'z'];\n    let mut spaces = vec![' ', '\\t', '\\n'];\n\n    res.replace(\"\
    !\", \"!A\", 1);\n    res.replace(\"?\", \"?A\", 1);\n    res.replace(\".\", \"\
    .A\", 1);\n    res.replace(\",\", \",A\", 1);\n    res.replace(\":\", \":A\",\
    \ 1);\n    res.replace(\";\", \";A\", 1);\n    res.replace(\"'\", \"'A\", 1);\n\
    \    res.replace(\"(\", \"(A\", 1);\n    res.replace(\")\", \"(A\", 1);\n\n  \
    \  while let Some(mut c) = res.find(' ') {\n        let mut new_char = c;\n  \
    \      if alphabet_order.contains(&c) ^ vowel_order.contains(&c) ^ consonant_order.contains(&c)\
    \ {\n            new_char += consonant_order.iter().find(|c| *c == c).unwrap().unwrap();\n\
    \        } else {\n            new_char += alphabet_order.iter().find(|c| *c ==\
    \ c).unwrap().unwrap();\n        }\n        *new_char = *c;\n        res.replace(new_char.to_string(),\
    \ new_char.to_string(), 1);\n    }\n\n    while let Some(mut c) = res.find('\\\
    t') {\n        let mut new_char = c;\n        if alphabet_order.contains(&c) ^\
    \ vowel_order.contains(&c) ^ consonant_order.contains(&c) {\n            new_char\
    \ += consonant_order.iter().find(|c| *c == c).unwrap().unwrap();\n        } else\
    \ {\n            new_char += alphabet_order.iter().find(|c| *c == c).unwrap().unwrap();\n\
    \        }\n        *new_char = *c;\n        res.replace(new_char.to_string(),\
    \ new_char.to_string(), 1);\n    }\n\n    while let Some(mut c) = res.find('\\\
    n') {\n        let mut new_char = c;\n        if alphabet_order.contains(&c) ^\
    \ vowel_order.contains(&c) ^ consonant_order.contains(&c) {\n            new_char\
    \ += consonant_order.iter().find(|c| *c == c).unwrap().unwrap();\n        } else\
    \ {\n            new_char += alphabet_order.iter().find(|c| *c == c).unwrap().unwrap();\n\
    \        }\n        *new_char = *c;\n        res.replace(new_char.to_string(),\
    \ new_char.to_string(), 1);\n    }\n\n    while let Some(mut c) = res.\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp_xtu78j1.rs:61:1\n   |\n61\
    \ | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp_xtu78j1.rs:61:1\n\
    \   |\n60 |     while let Some(mut c) = res.\n   |     ----- ---------------------\
    \ this `while` condition successfully parsed\n   |     |\n   |     while parsing\
    \ the body of this `while` expression\n61 | }\n   | ^ expected `{`\n\nerror[E0061]:\
    \ this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp_xtu78j1.rs:17:9\n\
    \    |\n17  |     res.replace(\"!\", \"!A\", 1);\n    |         ^^^^^^^ ---  ----\
    \  - supplied 3 arguments\n    |         |\n    |         expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp_xtu78j1.rs:18:9\n\
    \    |\n18  |     res.replace(\"?\", \"?A\", 1);\n    |         ^^^^^^^ ---  ----\
    \  - supplied 3 arguments\n    |         |\n    |         expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp_xtu78j1.rs:19:9\n\
    \    |\n19  |     res.replace(\".\", \".A\", 1);\n    |         ^^^^^^^ ---  ----\
    \  - supplied 3 arguments\n    |         |\n    |         expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp_xtu78j1.rs:20:9\n\
    \    |\n20  |     res.replace(\",\", \",A\", 1);\n    |         ^^^^^^^ ---  ----\
    \  - supplied 3 arguments\n    |         |\n    |         expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp_xtu78j1.rs:21:9\n\
    \    |\n21  |     res.replace(\":\", \":A\", 1);\n    |         ^^^^^^^ ---  ----\
    \  - supplied 3 arguments\n    |         |\n    |         expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp_xtu78j1.rs:22:9\n\
    \    |\n22  |     res.replace(\";\", \";A\", 1);\n    |         "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Your code here\n    let mut res = String::new();\n    let mut last_letter\
    \ = String::new();\n    for c in s.chars() {\n        if c.is_whitespace() {\n\
    \            if !res.is_empty() {\n                res += '\\0';\n           \
    \ }\n            continue;\n        }\n        if !res.is_empty() {\n        \
    \    res += '\\0';\n        }\n        let c_ord = c.ascii();\n        if c_ord\
    \ < last_letter.ascii() {\n            res += '\\0';\n        }\n        last_letter\
    \ = c;\n        res += c;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplbrabxcz.rs:17:24\n   |\n\
    17 |                 res += '\\0';\n   |                        ^^^^ expected\
    \ `&str`, found `char`\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n17 |                 res += \"\\0\";\n   |            \
    \            ~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplbrabxcz.rs:22:20\n\
    \   |\n22 |             res += '\\0';\n   |                    ^^^^ expected `&str`,\
    \ found `char`\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n22 |             res += \"\\0\";\n   |                    ~~~~\n\
    \nerror[E0599]: no method named `ascii` found for type `char` in the current scope\n\
    \  --> /tmp/tmplbrabxcz.rs:24:23\n   |\n24 |         let c_ord = c.ascii();\n\
    \   |                       ^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii`\n\nerror[E0599]: no method named `ascii` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmplbrabxcz.rs:25:32\n   |\n\
    25 |         if c_ord < last_letter.ascii() {\n   |                          \
    \      ^^^^^ help: there is an associated function with a similar name: `is_ascii`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplbrabxcz.rs:26:20\n   |\n26 |\
    \             res += '\\0';\n   |                    ^^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n26 |             res += \"\\0\";\n   |                    ~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplbrabxcz.rs:28:23\n   |\n13 |     let mut last_letter\
    \ = String::new();\n   |                           ------------- expected due\
    \ to this value\n...\n28 |         last_letter = c;\n   |                    \
    \   ^- help: try using a conversion method: `.to_string()`\n   |             \
    \          |\n   |                       expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplbrabxcz.rs:29:16\n   |\n29 |\
    \         res += c;\n   |                ^ expected `&str`, found `char`\n\nerror:\
    \ aborting due to 7 previous errors\n\nSome errors have detailed explanations:"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut buffer = String::new();\n    let mut len = s.len();\n    let mut\
    \ char_to_replace = char::MIN;\n    let mut replace_chars = String::new();\n \
    \   let mut char_ascii_to_replace = String::new();\n\n    // Iterate over chars\
    \ of string\n    // and append them into buffer\n    while len > 0 {\n       \
    \ let mut new_char = s[len - 1];\n        let mut new_char_ascii = char::MIN;\n\
    \        loop {\n            if new_char == ' ' {\n                break;\n  \
    \          }\n            if char_to_replace == char::MIN {\n                if\
    \ s[len - 1] < char::MIN {\n                    char_to_replace = s[len - 1];\n\
    \                }\n                new_char_ascii = char_ascii_to_replace[len\
    \ - 1];\n            }\n            new_char = s[len - 2] as char;\n         \
    \   if new_char > char::MIN {\n                new_char_ascii = char_ascii_to_replace[len\
    \ - 2];\n                break;\n            }\n            len -= 1;\n      \
    \  }\n        buffer += new_char;\n        char_ascii_to_replace += String::from(\"\
    &%c\");\n    }\n\n    // Now get words and replace them with orderd characters\n\
    \    // using ascii values\n    while buffer.len() > 0 {\n        let mut first_chars\
    \ = String::new();\n        let mut first_char_asciis = String::new();\n     \
    \   let mut second_chars = String::new();\n        let mut second_char_asciis\
    \ = String::new();\n        // Separate chars before and after blank space\n \
    \       // and store them into respective arrays\n        let mut first_char_pos\
    \ = 0;\n        while first_char_pos + 1 < buffer.len() {\n            let mut\
    \ first_char = String::new();\n            let mut second_char = String::new();\n\
    \            let mut first_char_ascii = char::MIN;\n            let mut second_char_ascii\
    \ = char::MIN;\n            loop {\n                let new_char_pos = first_char_pos\
    \ + 1;\n                if new_char_pos > buffer.len() {\n                   \
    \ break;\n                }\n                first_char += buffer[first_char_pos];\n\
    \                second_char += buffer[new_char_pos];\n                if first_char\
    \ == ' ' {\n                    break;\n                }\n                first_char_ascii\
    \ = char_ascii_to_replace[first_char_pos];\n                second_char_ascii\
    \ = char_ascii_to_replace[new_char_pos];\n                if first_char_ascii\
    \ == char::MIN {\n                    if buffer[new_char_pos] < char::MIN {\n\
    \                        first_char_ascii = char_ascii_to_replace[new_char_pos];\n\
    \                    }\n                    first_char = String::from(\"\");\n\
    \                    break;\n                }\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp32i4xzwk.rs:88:3\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n45 |     while buffer.len() > 0 {\n\
    \   |                            - unclosed delimiter\n...\n53 |         while\
    \ first_char_pos + 1 < buffer.len() {\n   |                                  \
    \               - unclosed delimiter\n...\n58 |             loop {\n   |     \
    \             - this delimiter might not be properly closed...\n...\n77 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n88 | }\n\
    \   |   ^\n\nerror[E0599]: no associated item named `MIN` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp32i4xzwk.rs:13:37\n   |\n13 |     let mut\
    \ char_to_replace = char::MIN;\n   |                                     ^^^ associated\
    \ item not found in `char`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp32i4xzwk.rs:20:28\n   |\n20 |         let mut new_char\
    \ = s[len - 1];\n   |                            ^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no associated item named `MIN` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp32i4xzwk.rs:21:40\n   |\n21 |         let\
    \ mut new_char_ascii = char::MIN;\n   |                                      \
    \  ^^^ associated item not found in `char`\n\nerror[E0599]: no associated item\
    \ named `MIN` found for type `char` in the current scope\n  --> /tmp/tmp32i4xzwk.rs:26:41\n\
    \   |\n26 |             if char_to_replace == char::MIN {\n   |              \
    \                           ^^^ assoc"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.to_lowercase()\n        .split_whitespace()\n        .iter()\n        .map(|word|\
    \ word.chars().enumerate().map(|(i, char)| char.ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(s.chars().enumerate().map(|(i, _)| char::ascii_lowercase(i + 1).to_string()).collect())\n\
    \        .chain(\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpaocbyjfw.rs:33:15\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n33 |     \
    \    .chain(\n   |               ^ unclosed delimiter\n34 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpaocbyjfw.rs:13:10\n   |\n13 |         .iter()\n\
    \   |          ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no function or associated item named `ascii_lowercase` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpaocbyjfw.rs:15:57\n   |\n15 |         .chain(s.chars().enumerate().map(|(i,\
    \ _)| char::ascii_lowercase(i + 1).to_string()).collect())\n   |             \
    \                                            ^^^^^^^^^^^^^^^\n   |           \
    \                                              |\n   |                       \
    \                                  function or associated item not found in `char`\n\
    \   |                                                         help: there is an\
    \ associated function with a similar name: `is_ascii_lowercase`\n\nerror[E0599]:\
    \ no function or associated item named `ascii_lowercase` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpaocbyjfw.rs:16:57\n   |\n16 |         .chain(s.chars().enumerate().map(|(i,\
    \ _)| char::ascii_lowercase(i + 1).to_string()).collect())\n   |             \
    \                                            ^^^^^^^^^^^^^^^\n   |           \
    \                                              |\n   |                       \
    \                                  function or associated item not found in `char`\n\
    \   |                                                         help: there is an\
    \ associated function with a similar name: `is_ascii_lowercase`\n\nerror[E0599]:\
    \ no function or associated item named `ascii_lowercase` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpaocbyjfw.rs:17:57\n   |\n17 |         .chain(s.chars().enumerate().map(|(i,\
    \ _)| char::ascii_lowerc"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut buffer = s.chars().map(|c| c as char).collect();\n    buffer.sort_by(|a,\
    \ b| *a > *b).collect::<String>()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpgt1p6yho.rs:12:5\n\
    \   |\n11 |     let mut buffer = s.chars().map(|c| c as char).collect();\n   |\
    \         ---------- consider giving `buffer` a type\n12 |     buffer.sort_by(|a,\
    \ b| *a > *b).collect::<String>()\n   |     ^^^^^^ cannot infer type\n   |\n \
    \  = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    use std::ascii::AsciiExt;\n    let mut result = String::from(s);\n    for\
    \ &c in result.chars() {\n        match c {\n            ' ' => {\n          \
    \      let mut iter = result.char_indices().rev();\n                iter.next();\n\
    \                let mut start = iter.next();\n                while start !=\
    \ result.char_indices() {\n                    let end = iter.next();\n      \
    \              let s = result\n                        .chars()\n            \
    \            .skip(start.0)\n                        .take(end.0)\n          \
    \              .collect::<Vec<_>>()\n                        .join('');\n    \
    \                start = end;\n                    result.replace(start.0, end.0,\
    \ s);\n                }\n            }\n            _ => (),\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpkn1j88cq.rs:26:32\n   |\n\
    26 |                         .join('');\n   |                                ^\
    \ empty character literal\n\nwarning: unused import: `std::ascii::AsciiExt`\n\
    \  --> /tmp/tmpkn1j88cq.rs:11:9\n   |\n11 |     use std::ascii::AsciiExt;\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on\
    \ by default\n\nwarning: use of deprecated trait `std::ascii::AsciiExt`: use inherent\
    \ methods instead\n  --> /tmp/tmpkn1j88cq.rs:11:21\n   |\n11 |     use std::ascii::AsciiExt;\n\
    \   |                     ^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkn1j88cq.rs:13:9\n\
    \   |\n13 |     for &c in result.chars() {\n   |         ^^    --------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkn1j88cq.rs:19:32\n  \
    \ |\n19 |                 while start != result.char_indices() {\n   |       \
    \                         ^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ struct `CharIndices`\n   |\n   = note: expected enum `Option<(usize, char)>`\n\
    \            found struct `CharIndices<'_>`\n\nerror[E0609]: no field `0` on type\
    \ `Option<(usize, char)>`\n  --> /tmp/tmpkn1j88cq.rs:23:37\n   |\n23 |       \
    \                  .skip(start.0)\n   |                                     ^\n\
    \nerror[E0609]: no field `0` on type `Option<(usize, char)>`\n  --> /tmp/tmpkn1j88cq.rs:24:35\n\
    \   |\n24 |                         .take(end.0)\n   |                       \
    \            ^\n\nerror[E0599]: the method `join` exists for struct `Vec<char>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpkn1j88cq.rs:26:26\n \
    \  |\n26 |                         .join('');\n   |                          ^^^^\
    \ method cannot be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfie"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // TODO: Implement your code\n    println!(\"{:?}\", s)\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_min10r_.rs:12:5\n   |\n\
    12 |     println!(\"{:?}\", s)\n   |     ^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\n   = note: this error originates in the macro `println` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write your solution here\n    let mut rev = s.chars().map(|c| {\n    \
    \    match c {\n            'A'..='Z' => {\n                if s.len() < 2 {\n\
    \                    c\n                } else {\n                    match s.chars().next().unwrap()\
    \ {\n                        'A'..='Z' => ('A' as u32)..('Z' as u32),\n      \
    \                  'a' => {\n                            if s.len() < 2 {\n  \
    \                              ('A' as u32)..('Z' as u32)\n                  \
    \          } else {\n                                ('a' as u32)..('z' as u32)\n\
    \                            }\n                        },\n                 \
    \       _ => c,\n                    }\n                }\n            }\n   \
    \         'a' => {\n                if s.len() < 2 {\n                    ('a'\
    \ as u32)..('z' as u32)\n                } else {\n                    ('a' as\
    \ u32)..('z' as u32)\n                }\n            }\n            _ => c,\n\
    \        }\n    }).collect::<Vec<_>>();\n    rev.sort_unstable();\n    rev.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpef3pytyy.rs:27:30\n\
    \   |\n18 |                       match s.chars().next().unwrap() {\n   |    \
    \                   ------------------------------- `match` arms have incompatible\
    \ types\n19 |                           'A'..='Z' => ('A' as u32)..('Z' as u32),\n\
    \   |                                        -------------------------- this is\
    \ found to be of type `std::ops::Range<u32>`\n20 |                           'a'\
    \ => {\n21 | /                             if s.len() < 2 {\n22 | |          \
    \                       ('A' as u32)..('Z' as u32)\n23 | |                   \
    \          } else {\n24 | |                                 ('a' as u32)..('z'\
    \ as u32)\n25 | |                             }\n   | |_____________________________-\
    \ this is found to be of type `std::ops::Range<u32>`\n26 |                   \
    \        },\n27 |                           _ => c,\n   |                    \
    \            ^ expected struct `std::ops::Range`, found `char`\n   |\n   = note:\
    \ expected struct `std::ops::Range<u32>`\n                found type `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n\n    let mut new_words = Vec::new();\n\
    \    let mut new_word_starts = Vec::new();\n\n    for (i, w) in words.iter().enumerate()\
    \ {\n        let mut chars = w.chars();\n        let mut new_chars = Vec::new();\n\
    \n        while let Some(mut c) = chars.pop() {\n            c.to_ascii_lowercase();\n\
    \            new_chars.push(c);\n        }\n\n        new_word_starts.push(new_chars.len());\n\
    \n        for c in new_chars {\n            if c != ' ' {\n                new_words.push(c.to_string());\n\
    \            } else {\n                new_words.push(w);\n            }\n   \
    \     }\n    }\n\n    let mut new_s = new_words.iter().map(|s| &s[..]).collect::<String>();\n\
    \    new_s.push(&\"\");\n    new_s.extend(new_word_starts);\n\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpsqlxfgo3.rs:16:25\n   |\n16 |     for (i,\
    \ w) in words.iter().enumerate() {\n   |                         ^^^^ method not\
    \ found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .filter(|c| !c.is_whitespace())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .cloned()\n        .sort_by(|a, b| a.cmp(&b))\n    \
    \    .collect::<String>()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmp0gxtv534.rs:16:10\n   |\n16 |         .sort_by(|a,\
    \ b| a.cmp(&b))\n   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ char>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s[..s.len()].chars()\n        .filter(|c| c.is_alphanumeric())\n        .sort_by(|a,\
    \ b| a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase()))\n        .collect()\n\
    \        .cloned()\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Filter` in the\
    \ current scope\n  --> /tmp/tmp62c1rdxo.rs:13:10\n   |\n13 |         .sort_by(|a,\
    \ b| a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase()))\n   |          ^^^^^^^\
    \ method not found in `Filter<Chars<'_>, [closure@/tmp/tmp62c1rdxo.rs:12:17: 12:40]>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().enumerate().map(|(i, c)| {\n        let new_ord = c.to_ascii_lowercase().cmp(&s.chars().nth(i\
    \ + 1).to_ascii_lowercase());\n        (new_ord, i)\n    }).sort_by(|(_, a), (_,\
    \ b)| a).fold(s.to_string(), |mut acc, (e, i) => acc.insert_slice(i, &*e));\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `,` or `:`, found `=>`\n  --> /tmp/tmpxa9bnhj9.rs:14:73\n\
    \   |\n14 |     }).sort_by(|(_, a), (_, b)| a).fold(s.to_string(), |mut acc, (e,\
    \ i) => acc.insert_slice(i, &*e));\n   |                                     \
    \                                    ^^ expected one of `,` or `:`\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().filter_map(|c| c.to_ascii_lower()).collect()\n        .iter()\n\
    \        .zip(s.chars().filter_map(|c| c.to_ascii_lower()).collect())\n      \
    \  .filter_map(|(w1, w2)| {\n            if w1 < w2 {\n                (w1, w2)\n\
    \            } else {\n                (w2, w1)\n            }\n        }).collect()\n\
    \        .iter()\n        .map(|(w, c)| {\n            if c == ' ' || c == '\\\
    n' {\n                w\n            } else {\n                c.to_string()\n\
    \            }\n        }).collect()\n        .to_string()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_ascii_lower` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpdahd1juo.rs:11:32\n   |\n11 |     s.chars().filter_map(|c|\
    \ c.to_ascii_lower()).collect()\n   |                                ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `to_ascii_lower` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpdahd1juo.rs:13:41\n   |\n13 |         .zip(s.chars().filter_map(|c|\
    \ c.to_ascii_lower()).collect())\n   |                                       \
    \  ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut ord = vec![String::new(); s.len()];\n    for\
    \ word in s.split_whitespace() {\n        for c in word.chars() {\n          \
    \  ord[ord.len()] += String::from(c);\n        }\n    }\n    for (ix, c) in ord.iter_mut().enumerate()\
    \ {\n        ord[ix] = String::from(c);\n    }\n    let mut res = String::new();\n\
    \    for (cx, cxc) in ord.iter().cloned().zip(ord.iter().cloned()) {\n       \
    \ res.push_str(&(cxc as u32).to_string());\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwku0apro.rs:15:31\n   |\n\
    15 |             ord[ord.len()] += String::from(c);\n   |                    \
    \           ^^^^^^^^^^^^^^^\n   |                               |\n   |      \
    \                         expected `&str`, found struct `String`\n   |       \
    \                        help: consider borrowing here: `&String::from(c)`\n\n\
    error[E0277]: the trait bound `String: From<&mut String>` is not satisfied\n \
    \ --> /tmp/tmpwku0apro.rs:19:32\n   |\n19 |         ord[ix] = String::from(c);\n\
    \   |                   ------------ ^ expected an implementor of trait `From<&mut\
    \ String>`\n   |                   |\n   |                   required by a bound\
    \ introduced by this call\n   |\nhelp: consider mutably borrowing here\n   |\n\
    19 |         ord[ix] = String::from(&mut c);\n   |                           \
    \     ++++\n\nerror[E0605]: non-primitive cast: `String` as `u32`\n  --> /tmp/tmpwku0apro.rs:23:23\n\
    \   |\n23 |         res.push_str(&(cxc as u32).to_string());\n   |           \
    \            ^^^^^^^^^^^^ an `as` expression can only be used to convert between\
    \ primitive types or to coerce to a specific trait object\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0605.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.chars().collect::<Vec<_>>();\n    let mut result = String::new();\n\
    \    words.sort_by(|a, b| {\n        let a_size = a.chars().count();\n       \
    \ let b_size = b.chars().count();\n        a.chars().iter().fold(0usize, |i, c|\
    \ i + (c.to_ascii_lowercase().cmp(&c.to_ascii_uppercase()) as usize));\n     \
    \   b.chars().iter().fold(0usize, |i, c| i + (c.to_ascii_lowercase().cmp(&c.to_ascii_uppercase())\
    \ as usize))\n    });\n    let mut i = 0;\n    words.iter().for_each(|c| {\n \
    \       let j = i;\n        i += 1;\n        if c.to_ascii_lowercase().is_uppercase()\
    \ {\n            result.push(c);\n            result.push(&words[j]);\n      \
    \  } else {\n            result.push(&c.to_ascii_lowercase());\n            result.push(&words[j]);\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpk2rfzegp.rs:14:24\n   |\n14 |         let a_size\
    \ = a.chars().count();\n   |                        ^^^^^ method not found in\
    \ `&char`\n\nerror[E0599]: no method named `chars` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpk2rfzegp.rs:15:24\n   |\n15 |         let\
    \ b_size = b.chars().count();\n   |                        ^^^^^ method not found\
    \ in `&char`\n\nerror[E0599]: no method named `chars` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpk2rfzegp.rs:16:11\n   |\n16 |         a.chars().iter().fold(0usize,\
    \ |i, c| i + (c.to_ascii_lowercase().cmp(&c.to_ascii_uppercase()) as usize));\n\
    \   |           ^^^^^ method not found in `&char`\n\nerror[E0599]: no method named\
    \ `chars` found for reference `&char` in the current scope\n  --> /tmp/tmpk2rfzegp.rs:17:11\n\
    \   |\n17 |         b.chars().iter().fold(0usize, |i, c| i + (c.to_ascii_lowercase().cmp(&c.to_ascii_uppercase())\
    \ as usize))\n   |           ^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk2rfzegp.rs:24:25\n   |\n24 |             result.push(c);\n\
    \   |                         ^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |             result.push(*c);\n   |    \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk2rfzegp.rs:25:25\n\
    \   |\n25 |             result.push(&words[j]);\n   |                        \
    \ ^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n25 -             result.push(&words[j]);\n25 +             result.push(words[j]);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk2rfzegp.rs:27:25\n  \
    \ |\n27 |             result.push(&c.to_ascii_lowercase());\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n27 -             result.push(&c.to_ascii_lowercase());\n\
    27 +             result.push(c.to_ascii_lowercase());\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result: String = String::new();\n    for i in s.chars().cloned().skip_while(|c|\
    \ c.is_whitespace()) {\n        match i {\n            c if c.is_ascii(|c| c <\
    \ ' ') => {\n                result.push(i);\n            }\n            _ =>\
    \ {\n                result.push('_');\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpi6xf_6zs.rs:12:24\n     |\n12   |     for i in s.chars().cloned().skip_while(|c|\
    \ c.is_whitespace()) {\n     |                        ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `skip_while` exists for struct `Cloned<Chars<'_>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpi6xf_6zs.rs:12:33\n   |\n12 |     \
    \  for i in s.chars().cloned().skip_while(|c| c.is_whitespace()) {\n   |     \
    \                              ^^^^^^^^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    let mut res = String::new();\n\
    \    let mut counter = 0;\n    for word in words {\n        if !counter.is_zero()\
    \ {\n            res.push_str(&counter.to_string());\n            res.push_str(\"\
    \ \");\n        }\n        res.push_str(word);\n        counter = counter + word.len();\n\
    \    }\n    if !counter.is_zero() {\n        res.push_str(&counter.to_string());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `is_zero` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpouetfsq8.rs:15:21\n   |\n15 |         if !counter.is_zero() {\n\
    \   |                     ^^^^^^^\n   |\nhelp: you must specify a type for this\
    \ binding, like `i32`\n   |\n13 |     let mut counter: i32 = 0;\n   |        \
    \ ~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_zero` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpouetfsq8.rs:22:17\n   |\n22 |     if !counter.is_zero()\
    \ {\n   |                 ^^^^^^^ method not found in `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0689.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::new();\n    let mut last_seen: u8 = 0;\n    for (i,\
    \ c) in s.chars().enumerate() {\n        if c == ' ' {\n            // skip spaces\n\
    \            continue;\n        }\n        if last_seen > ord(c) && ord(c) < last_seen\
    \ {\n            // no alphabet between last seen character and the current one\n\
    \            res.push_str(&format!(\"{}-\", last_seen));\n        }\n        res.push_str(&format!(\"\
    {}\", c));\n        last_seen = ord(c);\n    }\n    res.push_str(&format!(\"-{}\"\
    , last_seen));\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ord` in this scope\n  --> /tmp/tmpgtafm1l_.rs:18:24\n\
    \   |\n18 |         if last_seen > ord(c) && ord(c) < last_seen {\n   |      \
    \                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `ord` in this scope\n  --> /tmp/tmpgtafm1l_.rs:18:34\n   |\n18 |         if\
    \ last_seen > ord(c) && ord(c) < last_seen {\n   |                           \
    \       ^^^ not found in this scope\n\nerror[E0425]: cannot find function `ord`\
    \ in this scope\n  --> /tmp/tmpgtafm1l_.rs:23:21\n   |\n23 |         last_seen\
    \ = ord(c);\n   |                     ^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut l = s.chars().collect::<Vec<_>>();\n    l.sort();\n    let mut s\
    \ = String::new();\n    for (i, &c) in l.iter().enumerate() {\n        if i !=\
    \ 0 {\n            s.push_str(&' ');\n        }\n        s.push(c);\n    }\n \
    \   s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp319ne_mf.rs:16:24\n   |\n\
    16 |             s.push_str(&' ');\n   |                        ^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Your code here\n    let mut s: String = s.to_string();\n    let mut i\
    \ = 0;\n    let mut result = '';\n\n    while i < s.len() {\n        let c = s.chars()\n\
    \            .skip(i)\n            .nth(0)\n            .unwrap();\n        //\
    \ println!(\"{}\", &c);\n        let new_c = if c < 'a' {\n            if c >\
    \ 'z' {\n                'a' - 10\n            } else {\n                'a' -\
    \ c as i32\n            }\n        } else if c > 'z' {\n            if c < 'A'\
    \ {\n                'z' - 10\n            } else {\n                'z' - c as\
    \ i32\n            }\n        } else {\n            if c < '0' {\n           \
    \     '9' - 10\n            } else {\n                '9' - c as i32\n       \
    \     }\n        };\n        result += &s[i as usize];\n        result += &new_c;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmp3ydnd3_z.rs:14:23\n   |\n\
    14 |     let mut result = '';\n   |                       ^ empty character literal\n\
    \nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmp3ydnd3_z.rs:24:21\n\
    \   |\n24 |                 'a' - 10\n   |                 --- ^ -- {integer}\n\
    \   |                 |\n   |                 char\n\nerror[E0369]: cannot subtract\
    \ `i32` from `char`\n  --> /tmp/tmp3ydnd3_z.rs:26:21\n   |\n26 |             \
    \    'a' - c as i32\n   |                 --- ^ -------- i32\n   |           \
    \      |\n   |                 char\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `char`\n  --> /tmp/tmp3ydnd3_z.rs:30:21\n   |\n30 |                 'z'\
    \ - 10\n   |                 --- ^ -- {integer}\n   |                 |\n   |\
    \                 char\n\nerror[E0369]: cannot subtract `i32` from `char`\n  -->\
    \ /tmp/tmp3ydnd3_z.rs:32:21\n   |\n32 |                 'z' - c as i32\n   | \
    \                --- ^ -------- i32\n   |                 |\n   |            \
    \     char\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmp3ydnd3_z.rs:36:21\n\
    \   |\n36 |                 '9' - 10\n   |                 --- ^ -- {integer}\n\
    \   |                 |\n   |                 char\n\nerror[E0369]: cannot subtract\
    \ `i32` from `char`\n  --> /tmp/tmp3ydnd3_z.rs:38:21\n   |\n38 |             \
    \    '9' - c as i32\n   |                 --- ^ -------- i32\n   |           \
    \      |\n   |                 char\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp3ydnd3_z.rs:41:20\n   |\n41 |         result\
    \ += &s[i as usize];\n   |                    ^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut buf: Vec<String> = vec![];\n    let mut word: String = s.to_string();\n\
    \    let mut len: usize = word.length;\n    let mut last_char: u8 = 0;\n    let\
    \ mut is_whitespace = false;\n    let mut cnt: usize = 0;\n    while cnt < len\
    \ {\n        if buf[cnt - 1].chars().nth(1).unwrap() > last_char {\n         \
    \   buf.push(word.chars().skip(1).take(len - cnt).collect());\n            last_char\
    \ = buf[cnt - 1].chars().nth(1).unwrap();\n            is_whitespace = false;\n\
    \            cnt = 0;\n            len = 0;\n        } else {\n            if\
    \ is_whitespace {\n                let is_next = false;\n                while\
    \ cnt < len && buf[cnt - 1].chars().nth(1).unwrap() == is_next {\n           \
    \         cnt += 1;\n                }\n                buf.push(word.chars().skip(1).take(len\
    \ - cnt).collect());\n                is_whitespace = false;\n            } else\
    \ {\n                cnt += 1;\n            }\n        }\n        len += 1;\n\
    \        if buf[len - 1] == ' ' {\n            is_whitespace = true;\n       \
    \ }\n    }\n    buf.push(word.chars().skip(1).take(len - 1).collect());\n    String::from_utf8(buf).unwrap()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmpcrfdi6bh.rs:13:31\n\
    \   |\n13 |     let mut len: usize = word.length;\n   |                      \
    \         ^^^^^^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcrfdi6bh.rs:18:51\n\
    \   |\n18 |         if buf[cnt - 1].chars().nth(1).unwrap() > last_char {\n  \
    \ |                                                   ^^^^^^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcrfdi6bh.rs:20:25\n\
    \   |\n14 |     let mut last_char: u8 = 0;\n   |                        -- expected\
    \ due to this type\n...\n20 |             last_char = buf[cnt - 1].chars().nth(1).unwrap();\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcrfdi6bh.rs:27:76\n\
    \   |\n27 |                 while cnt < len && buf[cnt - 1].chars().nth(1).unwrap()\
    \ == is_next {\n   |                                                         \
    \                   ^^^^^^^ expected `char`, found `bool`\n\nerror[E0277]: can't\
    \ compare `String` with `char`\n  --> /tmp/tmpcrfdi6bh.rs:37:25\n   |\n37 |  \
    \       if buf[len - 1] == ' ' {\n   |                         ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcrfdi6bh.rs:42:23\n   |\n42 |     String::from_utf8(buf).unwrap()\n\
    \   |                       ^^^ expected `u8`, found struct `String`\n   |\n \
    \  = note: expected struct `Vec<u8>`\n              found struct `Vec<String>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut chars_sorted_by_ascii = s.chars().map(|c| *c).collect::<Vec<char>>();\n\
    \    chars_sorted_by_ascii\n        .iter()\n        .cloned()\n        .sort_by(|a,b|\
    \ a.cmp(b).reverse());\n    chars_sorted_by_ascii.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpidy48dth.rs:12:55\n\
    \   |\n12 |     let mut chars_sorted_by_ascii = s.chars().map(|c| *c).collect::<Vec<char>>();\n\
    \   |                                                       ^^\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `Cloned` in the current scope\n \
    \ --> /tmp/tmpidy48dth.rs:16:10\n   |\n16 |         .sort_by(|a,b| a.cmp(b).reverse());\n\
    \   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, char>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    iter::repeat(s).take_while(|&x| *x != ' ')\n        .collect::<Vec<_>>()\n\
    \        .sort();\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `iter`\n\
    \  --> /tmp/tmpgpzp4w75.rs:11:5\n   |\n11 |     iter::repeat(s).take_while(|&x|\
    \ *x != ' ')\n   |     ^^^^ use of undeclared crate or module `iter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgpzp4w75.rs:10:31\n   |\n10 | fn anti_shuffle(s:\
    \ String) -> String {\n   |    ------------               ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .filter(|c| !c.is_whitespace())\n        .group_by(|c|\
    \ c.to_ascii_uppercase())\n        .map(|(_, items)| items.join())\n        .collect::<Vec<_>>()\n\
    \        .join::<String>(\"\".to_owned())\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `Filter` in the\
    \ current scope\n  --> /tmp/tmp4uoa2mlw.rs:13:10\n   |\n13 |         .group_by(|c|\
    \ c.to_ascii_uppercase())\n   |          ^^^^^^^^ method not found in `Filter<Chars<'_>,\
    \ [closure@/tmp/tmp4uoa2mlw.rs:12:17: 12:39]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Your code here\n    let mut s = s.chars();\n    let mut rs = s.clone();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut len = 0;\n    let mut word\
    \ = String::new();\n    while i < rs.len() {\n        len = rs.len();\n      \
    \  if rs.len() == 0 {\n            break;\n        }\n        let mut index =\
    \ i;\n        let mut temp: Char = Char::new();\n        let mut char_count =\
    \ Char::new();\n        for c in rs {\n            if c.to_ascii_lowercase() >\
    \ temp.to_ascii_lowercase() {\n                index = i;\n                temp\
    \ = c;\n            }\n            i += 1;\n            char_count.set_val(c.to_ascii_lowercase());\n\
    \        }\n        rs[index] = temp;\n        word.push_str(&char_count);\n \
    \       for c in rs {\n            rs.remove(&c);\n        }\n    }\n    s.push_str(&word);\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmp7wzfwefh.rs:24:30\n\
    \   |\n24 |         let mut temp: Char = Char::new();\n   |                  \
    \            ^^^^ use of undeclared type `Char`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Char`\n  --> /tmp/tmp7wzfwefh.rs:25:30\n   |\n25 | \
    \        let mut char_count = Char::new();\n   |                             \
    \ ^^^^ use of undeclared type `Char`\n\nerror[E0412]: cannot find type `Char`\
    \ in this scope\n  --> /tmp/tmp7wzfwefh.rs:24:23\n   |\n24 |         let mut temp:\
    \ Char = Char::new();\n   |                       ^^^^ help: a builtin type with\
    \ a similar name exists (notice the capitalization): `char`\n\nerror[E0599]: no\
    \ method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmp7wzfwefh.rs:18:18\n\
    \   |\n18 |     while i < rs.len() {\n   |                  ^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: no method named `len` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmp7wzfwefh.rs:19:18\n   |\n19 |         len\
    \ = rs.len();\n   |                  ^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmp7wzfwefh.rs:20:15\n\
    \   |\n20 |         if rs.len() == 0 {\n   |               ^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmp7wzfwefh.rs:34:9\n   |\n34 |         rs[index] = temp;\n   |  \
    \       ^^^^^^^^^\n\nerror[E0599]: no method named `remove` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmp7wzfwefh.rs:37:16\n   |\n37 |          \
    \   rs.remove(&c);\n   |                ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `push_str` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp7wzfwefh.rs:40:7\n   |\n40 |     s.push_str(&word);\n \
    \  |       ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `as_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7wzfwefh.rs:41:5\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    words\n        .iter()\n        .cloned()\n        .map(|word| word.chars().enumerate().map(|(idx,\
    \ char)| char.ascii_upper().collect::<Vec<_>>()))\n        .flatten()\n      \
    \  .sort_by(|a, b| a.iter().max().cmp(&b.iter().max()))\n        .collect::<Vec<_>>()\n\
    \        .into_iter()\n        .map(|char| char.collect::<String>().join())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `words` in this scope\n  --> /tmp/tmp7ad3e3yu.rs:11:5\n\
    \   |\n11 |     words\n   |     ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    s.replace_blank_space_by_one_space();\n    s.sort_ascii_based_on_length();\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `replace_blank_space_by_one_space` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp9ims7c8e.rs:12:7\n \
    \  |\n12 |     s.replace_blank_space_by_one_space();\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `sort_ascii_based_on_length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp9ims7c8e.rs:13:7\n\
    \   |\n13 |     s.sort_ascii_based_on_length();\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result = s.to_string();\n    for i in 0..s.len() {\n        let mut\
    \ j = 0;\n        for c in &s[i..] {\n            if let Some(j) = (j + 1..s.len()).find(|&b|\
    \ b == c) where j < i {\n                j = j + c.len_utf8();\n             \
    \   continue;\n            }\n            result.insert(i, c);\n            j\
    \ += c.len_utf8();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `where`\n  --> /tmp/tmpknwue4a8.rs:15:65\n\
    \   |\n15 |             if let Some(j) = (j + 1..s.len()).find(|&b| b == c) where\
    \ j < i {\n   |             --                                               \
    \   ^^^^^ expected `{`\n   |             |\n   |             this `if` expression\
    \ has a condition, but no block\n\nerror[E0277]: `&str` is not an iterator\n \
    \ --> /tmp/tmpknwue4a8.rs:14:18\n   |\n14 |         for c in &s[i..] {\n   | \
    \                 ^^^^^^^ `&str` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `&str`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut map = String::with_capacity(s.len());\n    for ch in s.chars() {\n\
    \        let key = ch.to_ascii_lowercase().unwrap();\n        match map.get(&key)\
    \ {\n            Some(x) => {\n                map.insert(key, x.to_string().to_ascii_lowercase().unwrap());\n\
    \                map.insert(ch as u8, ch as u8);\n            }\n            None\
    \ => {\n                map.insert(key, ch);\n            }\n        }\n    }\n\
    \    map\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvb72zduu.rs:13:43\n   |\n13 |         let key = ch.to_ascii_lowercase().unwrap();\n\
    \   |                                           ^^^^^^ method not found in `char`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `&_`\n   --> /tmp/tmpvb72zduu.rs:14:23\n\
    \    |\n14  |         match map.get(&key) {\n    |                   --- -^^^\n\
    \    |                   |   |\n    |                   |   string indices are\
    \ ranges of `usize`\n    |                   |   help: consider removing the leading\
    \ `&`-reference\n    |                   required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for\
    \ `&_`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvb72zduu.rs:17:28\n   |\n17 |              \
    \   map.insert(ch as u8, ch as u8);\n   |                            ^^^^^^^^\
    \ expected `usize`, found `u8`\n   |\nhelp: you can convert a `u8` to a `usize`\n\
    \   |\n17 |                 map.insert((ch as u8).into(), ch as u8);\n   |   \
    \                         +        ++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvb72zduu.rs:17:38\n   |\n17 |                 map.insert(ch as\
    \ u8, ch as u8);\n   |                                      ^^^^^^^^ expected\
    \ `char`, found `u8`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    s.sort_by_key(|&b| b.chars().count());\n    s.split_whitespace().sort_by_key(|&b|\
    \ b.chars().count());\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpdpq9ucd8.rs:12:7\n   |\n12 |     s.sort_by_key(|&b|\
    \ b.chars().count());\n   |       ^^^^^^^^^^^ method not found in `String`\n\n\
    error[E0599]: no method named `sort_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpdpq9ucd8.rs:13:26\n   |\n13 |     s.split_whitespace().sort_by_key(|&b|\
    \ b.chars().count());\n   |                          ^^^^^^^^^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut new_s = String::from(s);\n    new_s.sort_unstable();\n\n    new_s.replace(\"\
    \  \", \" \");\n\n    new_s.replace(\"!\", \" !\");\n    new_s.replace(\"?\",\
    \ \" ? \");\n\n    new_s.replace(\"_\", \" _\");\n    new_s.replace(\"__\", \"\
    \ __ \");\n\n    new_s.replace(\"|\", \" |  \");\n    new_s.replace(\"\\|\", \"\
    \ \\|\");\n\n    new_s.replace(\"&\", \" &  \");\n    new_s.replace(\"&&\", \"\
    \ &&\");\n\n    new_s.replace(\"(\", \"  (\");\n    new_s.replace(\")\", \" )\
    \ \");\n    new_s.replace(\"[\", \" [  \");\n    new_s.replace(\"]\", \" ]  \"\
    );\n\n    new_s.replace(\"{\", \"  { \");\n    new_s.replace(\"}\", \" } \");\n\
    \n    new_s.replace(\"(\", \" (\");\n    new_s.replace(\")\", \" ) \");\n    new_s.replace(\"\
    {\", \" { \");\n    new_s.replace(\"}\", \" } \");\n\n    new_s.replace(\"<\"\
    , \" < \");\n    new_s.replace(\">\", \" > \");\n    new_s.replace(\"+\", \" +\
    \ \");\n    new_s.replace(\"-\", \" - \");\n    new_s.replace(\"=\", \" = \");\n\
    \n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: unknown character escape: `|`\n  --> /tmp/tmp9_ue2nak.rs:23:21\n\
    \   |\n23 |     new_s.replace(\"\\|\", \" \\|\");\n   |                     ^\
    \ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n23 |     new_s.replace(r\"\
    \\|\", \" \\|\");\n   |                   ~~~~~\n\nerror: unknown character escape:\
    \ `|`\n  --> /tmp/tmp9_ue2nak.rs:23:28\n   |\n23 |     new_s.replace(\"\\|\",\
    \ \" \\|\");\n   |                            ^ unknown character escape\n   |\n\
    \   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n23 |     new_s.replace(\"\\\
    |\", r\" \\|\");\n   |                         ~~~~~~\n\nerror[E0599]: no method\
    \ named `sort_unstable` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp9_ue2nak.rs:12:11\n   |\n12 |     new_s.sort_unstable();\n   |     \
    \      ^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut out = String::with_capacity(s.len());\n    let mut word_list = s.split_whitespace();\n\
    \    let mut words_with_new_order = vec![];\n    let mut current_word = 0;\n\n\
    \    for word in word_list {\n        let mut word_with_new_order = word;\n  \
    \      let mut current_char = 0;\n        while current_char < word.len() {\n\
    \            let ascii_val = word[current_char].ascii();\n            if ascii_val\
    \ < ascii_val {\n                let mut new_chars = vec![];\n               \
    \ let mut prev_char = current_char;\n                while prev_char < word.len()\
    \ && ascii_val < word[prev_char].ascii() {\n                    new_chars.push(prev_char);\n\
    \                    prev_char += 1;\n                }\n                word_with_new_order\
    \ += new_chars.join(\"\") + word[prev_char..current_char];\n                current_char\
    \ += 1;\n            } else {\n                current_char += 1\n           \
    \ }\n        }\n\n        words_with_new_order.push(word_with_new_order);\n  \
    \  }\n\n    let mut last_space_len = 0;\n    for word in words_with_new_order\
    \ {\n        let mut space_len = word.len() - word.trim_end_matches(' ').len();\n\
    \        if space_len > last_space_len {\n            last_space_len = space_len;\n\
    \        }\n        out += word;\n    }\n    out += &s[s.len() - last_space_len..];\n\
    \    out\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpeuqs2kmk.rs:20:29\n\
    \   |\n20 |             let ascii_val = word[current_char].ascii();\n   |    \
    \                         ^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpeuqs2kmk.rs:24:61\n\
    \   |\n24 |                 while prev_char < word.len() && ascii_val < word[prev_char].ascii()\
    \ {\n   |                                                             ^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0599]: the method `join` exists for struct\
    \ `Vec<usize>`, but its trait bounds were not satisfied\n  --> /tmp/tmpeuqs2kmk.rs:28:50\n\
    \   |\n28 |                 word_with_new_order += new_chars.join(\"\") + word[prev_char..current_char];\n\
    \   |                                                  ^^^^ method cannot be called\
    \ on `Vec<usize>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[usize]: Join<_>`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpeuqs2kmk.rs:28:59\n   |\n28 |                 word_with_new_order +=\
    \ new_chars.join(\"\") + word[prev_char..current_char];\n   |                \
    \                                           ^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    words\n        .iter()\n        .map(|s| s.to_ascii_lowercase().chars().collect::<Vec<char>>())\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| {\n         \
    \   let mut new: String = c.clone();\n            new.sort();\n            new\n\
    \        })\n        .collect()\n        .fold(s, |a, s| {\n            s.to_ascii_lowercase()\n\
    \                .chars()\n                .filter(|&c| !a.contains(c))\n    \
    \            .collect::<Vec<char>>()\n                .iter()\n              \
    \  .map(|c| {\n                    let mut new: String = a.clone();\n        \
    \            new.push(*c);\n                    a\n                })\n      \
    \          .collect()\n        })\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `words` in this scope\n  --> /tmp/tmpxm9r2u5w.rs:11:5\n\
    \   |\n11 |     words\n   |     ^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `sort` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpxm9r2u5w.rs:18:17\n   |\n18 |             new.sort();\n   |        \
    \         ^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().map(|c| c.to_ascii_lower()).collect()\n        .sort_by(|a, b|\
    \ b.cmp(a)).collect::<Vec<_>>()\n        .iter()\n        .map(|c| if c.is_whitespace()\
    \ { c } else { c.to_ascii_lower() })\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_ascii_lower` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp2s0h5k5s.rs:11:25\n   |\n11 |     s.chars().map(|c|\
    \ c.to_ascii_lower()).collect()\n   |                         ^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_ascii_lowercase`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .filter(|c| *c < 32 && c >= 0)\n        .cloned()\n  \
    \      .collect::<Vec<_>>()\n        .sort_by(|a, b| a.cmp(b)).collect()\n   \
    \     .iter()\n        .map(|c| match c {\n            ' ' => &'_ ',\n       \
    \     _ => c,\n        })\n        .collect::<String>()\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpq32krzrn.rs:18:24\n\
    \   |\n18 |             ' ' => &'_ ',\n   |                        ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().filter_map(|c| *c as u32).chain(s.split_whitespace())\n       \
    \ .chain(s.chars().cloned().chain(s.chars().enumerate().map(|(i, c)|\n       \
    \     i as u32 + c.ascii_value().unwrap() as u32).collect()))\n        .chain(s.chars().cloned().chain(s.chars().enumerate().map(|(i,\
    \ c)|\n            i as u32 + c.ascii_value().unwrap() + 10 as u32).collect()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpw0g5bniv.rs:11:30\n\
    \   |\n11 |     s.chars().filter_map(|c| *c as u32).chain(s.split_whitespace())\n\
    \   |                              ^^\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpw0g5bniv.rs:12:26\n \
    \    |\n12   |         .chain(s.chars().cloned().chain(s.chars().enumerate().map(|(i,\
    \ c)|\n     |                          ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `chain`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpw0g5bniv.rs:12:35\n   |\n12 |           .chain(s.chars().cloned().chain(s.chars().enumerate().map(|(i,\
    \ c)|\n   |                                     ^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0599]: no method named `ascii_value` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpw0g5bniv.rs:13:26\n   |\n13 |          \
    \   i as u32 + c.ascii_value().unwrap() as u32).collect()))\n   |            \
    \              ^^^^^^^^^^^ method not found in `char`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpw0g5bniv.rs:14:26\n\
    \     |\n14   |         .chain(s.chars().cloned().chain(s.chars().enumerate().map(|(i,\
    \ c)|\n     |                          ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `chain`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpw0g5bniv.rs:14:35\n   |\n14 |      "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().sort_by(|a, b| a.cmp(b).reverse()).collect::<Vec<_>>().join(\"\"\
    ).to_string()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpwsn7zbo4.rs:11:15\n   |\n11 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b).reverse()).collect::<Vec<_>>().join(\"\").to_string()\n   |    \
    \           ^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut ans = String::with_capacity(s.len());\n    let mut pos = 0;\n\n \
    \   for ch in s.chars() {\n        let num = ch.to_ascii_lowercase().unwrap();\n\
    \n        // check if num is in the range [33, 126]\n        if num >= 33 && num\
    \ <= 126 {\n            let char = char::from_ascii_lowercase(num).unwrap();\n\
    \            ans.push_str(&char);\n        } else {\n            // num is less\
    \ than 33, so just add it to the string.\n            ans.push(*ch);\n       \
    \ }\n\n        // increment position\n        pos += 1;\n    }\n\n    // trim\
    \ off the extra chars.\n    ans.trim_end();\n    ans\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp5fo9buco.rs:15:43\n   |\n15 |         let num = ch.to_ascii_lowercase().unwrap();\n\
    \   |                                           ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no function or associated item named `from_ascii_lowercase` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp5fo9buco.rs:19:30\n   |\n\
    19 |             let char = char::from_ascii_lowercase(num).unwrap();\n   |  \
    \                            ^^^^^^^^^^^^^^^^^^^^\n   |                      \
    \        |\n   |                              function or associated item not\
    \ found in `char`\n   |                              help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp5fo9buco.rs:23:22\n   |\n23 |        \
    \     ans.push(*ch);\n   |                      ^^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Your code goes here\n    s.split_whitespace().sort_unstable_by_key(|&x|\
    \ x.chars().enumerate().map(|(i, c)| (c.to_ascii_digit(), i)).max().unwrap()).collect::<Vec<_>>().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_unstable_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp_7e_uf7_.rs:12:26\n   |\n12 |     s.split_whitespace().sort_unstable_by_key(|&x|\
    \ x.chars().enumerate().map(|(i, c)| (c.to_ascii_digit(), i)).max().unwrap()).collect::<...\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .map(|c| c.to_ascii_lowercase())\n        .collect()\n\
    \        .iter()\n        .collect::<Vec<_>>()\n        .sort_by(|a, b| a.cmp(b).reverse())\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp33z6i0zh.rs:13:10\n\
    \   |\n13 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n13 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .filter_map(|c| c.to_ascii_lowercase().unwrap())\n   \
    \     .enumerate()\n        .map(|(idx, c)| (c, idx))\n        .sort_by(|(_, idx)|\
    \ idx)\n        .map(|(c, n)| c.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"_\")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpm7rcas_r.rs:12:48\n   |\n12 |         .filter_map(|c| c.to_ascii_lowercase().unwrap())\n\
    \   |                                                ^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `sort_by` found for struct `Map` in\
    \ the current scope\n  --> /tmp/tmpm7rcas_r.rs:15:10\n   |\n15 |         .sort_by(|(_,\
    \ idx)| idx)\n   |          ^^^^^^^ method not found in `Map<Enumerate<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmpm7rcas_r.rs:12:21: 12:56]>>, [closure@/tmp/tmpm7rcas_r.rs:14:14:\
    \ 14:33]>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s.to_owned();\n    let mut words = s.split_whitespace();\n  \
    \  while !words.is_empty() {\n        let mut new_word = \"\";\n        words.sort_by_key(|x|\
    \ x.cmp(&x.chars().min().unwrap()).unwrap());\n        words.for_each(|x| {\n\
    \            if !new_word.is_empty() {\n                new_word.push(x);\n  \
    \          } else {\n                new_word.push(x);\n            }\n      \
    \  });\n        words.clear();\n        words.push_str(&new_word);\n    }\n  \
    \  s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_empty` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpyvbk7pih.rs:13:18\n   |\n13 |     while\
    \ !words.is_empty() {\n   |                  ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpyvbk7pih.rs:15:15\n   |\n15 |         words.sort_by_key(|x|\
    \ x.cmp(&x.chars().min().unwrap()).unwrap());\n   |               ^^^^^^^^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `push`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpyvbk7pih.rs:18:26\n\
    \   |\n18 |                 new_word.push(x);\n   |                          ^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `push` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpyvbk7pih.rs:20:26\n   |\n\
    20 |                 new_word.push(x);\n   |                          ^^^^ method\
    \ not found in `&str`\n\nerror[E0599]: no method named `clear` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpyvbk7pih.rs:23:15\n  \
    \ |\n23 |         words.clear();\n   |               ^^^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `push_str` found for\
    \ struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpyvbk7pih.rs:24:15\n\
    \   |\n24 |         words.push_str(&new_word);\n   |               ^^^^^^^^ help:\
    \ there is an associated function with a similar name: `as_str`\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result: Vec<String> = s.chars().map( |c| {\n        let ord = c.to_ascii_lowercase().unwrap();\n\
    \        String::from(ord)\n    } ).collect();\n    let mut current_ord = 0;\n\
    \    let mut new_ord = ord::MAX;\n    let mut i = 0;\n    while i < result.len()\
    \ {\n        if current_ord < new_ord {\n            result[i] = result[i] + &mut\
    \ current_ord;\n            current_ord += ord::MAX;\n        }\n        else\
    \ {\n            current_ord -= new_ord;\n            new_ord = ord::MAX;\n  \
    \      }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `ord`\n\
    \  --> /tmp/tmpe45_nwij.rs:16:23\n   |\n16 |     let mut new_ord = ord::MAX;\n\
    \   |                       ^^^ use of undeclared crate or module `ord`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `ord`\n  --> /tmp/tmpe45_nwij.rs:21:28\n\
    \   |\n21 |             current_ord += ord::MAX;\n   |                       \
    \     ^^^ use of undeclared crate or module `ord`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `ord`\n  --> /tmp/tmpe45_nwij.rs:25:23\n \
    \  |\n25 |             new_ord = ord::MAX;\n   |                       ^^^ use\
    \ of undeclared crate or module `ord`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpe45_nwij.rs:12:42\n\
    \   |\n12 |         let ord = c.to_ascii_lowercase().unwrap();\n   |         \
    \                                 ^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe45_nwij.rs:20:37\n   |\n20 |             result[i]\
    \ = result[i] + &mut current_ord;\n   |                                     ^^^^^^^^^^^^^^^^\
    \ expected `str`, found integer\n   |\n   = note:      expected reference `&str`\n\
    \           found mutable reference `&mut {integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe45_nwij.rs:29:5\n   |\n10 | fn anti_shuffle(s: String)\
    \ -> String {\n   |                               ------ expected `String` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.to_string()\n        .split_whitespace()\n        .sort_by(|a, b| a.cmp(b))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpoqf6yde4.rs:13:10\n   |\n13 |         .sort_by(|a,\
    \ b| a.cmp(b))\n   |          ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut counter = 0;\n    let mut word_count = s.chars().count();\n    let\
    \ mut new_word = \"\";\n    let mut word_array = vec![];\n    for char in s.chars()\
    \ {\n        if char == ' ' {\n            let word_len = word_array.len();\n\
    \            for i in 0..word_len {\n                new_word += word_array[i].to_string();\n\
    \            }\n            word_array.clear();\n            word_count -= 1;\n\
    \        }\n        word_array.push(char);\n        counter += 1;\n    }\n   \
    \ let word_len = word_array.len();\n    for i in 0..word_len {\n        new_word\
    \ += word_array[i].to_string();\n    }\n    new_word\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpl5bbumke.rs:19:29\n\
    \   |\n14 |     let mut word_array = vec![];\n   |         -------------- consider\
    \ giving `word_array` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n19 |                 new_word += word_array[i].to_string();\n   |       \
    \                      ^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type\
    \ must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl5bbumke.rs:31:5\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \          ------ expected `String` because of return type\n...\n31 |     new_word\n\
    \   |     ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    if s.is_empty() {\n        return s\n    }\n    let mut new_s = s.chars();\n\
    \    new_s.sort();\n    let mut new_s_chars = vec![];\n    for (i, c) in new_s.into_iter().enumerate()\
    \ {\n        if c.is_whitespace() {\n            if i == 0 {\n               \
    \ new_s_chars.push(' ');\n            }\n            if i < new_s.len() - 1 {\n\
    \                new_s_chars.push(' ');\n            }\n        } else {\n   \
    \         new_s_chars.push(c);\n        }\n    }\n    new_s_chars\n        .iter()\n\
    \        .map(|c| c.to_string().chars().map(|b| b + 97).collect::<Vec<u8>>())\n\
    \        .fold(String::new(), |mut acc, iter| {\n            acc.push_str(iter.fold(\"\
    \".to_string(), |mut acc, x| {\n                acc.push(x);\n               \
    \ acc\n            }));\n            acc\n        })\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpp2r7aj43.rs:15:11\n   |\n15 |     new_s.sort();\n   | \
    \          ^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpp2r7aj43.rs:22:26\n\
    \   |\n22 |             if i < new_s.len() - 1 {\n   |                       \
    \   ^^^ method not found in `Chars<'_>`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmpp2r7aj43.rs:31:50\n   |\n31 |         .map(|c| c.to_string().chars().map(|b|\
    \ b + 97).collect::<Vec<u8>>())\n   |                                        \
    \        - ^ -- {integer}\n   |                                              \
    \  |\n   |                                                char\n\nerror[E0599]:\
    \ `Vec<u8>` is not an iterator\n   --> /tmp/tmpp2r7aj43.rs:33:31\n    |\n33  |\
    \               acc.push_str(iter.fold(\"\".to_string(), |mut acc, x| {\n    |\
    \                                 ^^^^ `Vec<u8>` is not an iterator\n    |\n \
    \   = note: the following trait bounds were not satisfied:\n            `Vec<u8>:\
    \ Iterator`\n            which is required by `&mut Vec<u8>: Iterator`\n     \
    \       `[u8]: Iterator`\n            which is required by `&mut [u8]: Iterator`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // code goes here\n    let mut result = String::new();\n    for word in s.split_whitespace()\
    \ {\n        let mut new_word = word;\n        for c in new_word.chars() {\n \
    \           match c.value() {\n                65..90 ? c.value() - 26 : c.value()\
    \ - 65,\n                _ => continue,\n            }\n            new_word +=\
    \ c.to_digits(10).to_string();\n        }\n        result += new_word + \" \"\
    ;\n    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `if`, or `|`, found `?`\n  --> /tmp/tmpy7cl5svo.rs:17:24\n\
    \   |\n17 |                 65..90 ? c.value() - 26 : c.value() - 65,\n   |  \
    \                      ^ expected one of `=>`, `if`, or `|`\n\nerror[E0599]: no\
    \ method named `value` found for type `char` in the current scope\n  --> /tmp/tmpy7cl5svo.rs:16:21\n\
    \   |\n16 |             match c.value() {\n   |                     ^^^^^ method\
    \ not found in `char`\n\nwarning: unreachable statement\n  --> /tmp/tmpy7cl5svo.rs:20:13\n\
    \   |\n16 | /             match c.value() {\n17 | |                 65..90 ? c.value()\
    \ - 26 : c.value() - 65,\n18 | |                 _ => continue,\n19 | |      \
    \       }\n   | |_____________- any code following this expression is unreachable\n\
    20 |               new_word += c.to_digits(10).to_string();\n   |            \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement\n   |\n   =\
    \ note: `#[warn(unreachable_code)]` on by default\n\nerror[E0599]: no method named\
    \ `to_digits` found for type `char` in the current scope\n  --> /tmp/tmpy7cl5svo.rs:20:27\n\
    \   |\n20 |             new_word += c.to_digits(10).to_string();\n   |       \
    \                    ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_digit`\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpy7cl5svo.rs:22:28\n\
    \   |\n22 |         result += new_word + \" \";\n   |                   --------\
    \ ^ --- &str\n   |                   |        |\n   |                   |    \
    \    `+` cannot be used to concatenate two `&str` strings\n   |              \
    \     &str\n   |\n   = note: string concatenation requires an owned `String` on\
    \ the left\nhelp: create an owned `String` from a string reference\n   |\n22 |\
    \         result += new_word.to_owned() + \" \";\n   |                       \
    \    +++++++++++\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s: String = s;\n    let mut chars = s.chars().enumerate().collect::<Vec<_>>();\n\
    \    let mut word_to_ord: HashSet<&'static str> = HashSet::new();\n    let mut\
    \ new_string: String = String::new();\n\n    for (i, c) in chars {\n        if\
    \ !word_to_ord.contains(&c.to_string()) {\n            word_to_ord.insert(c.to_string());\n\
    \            new_string.push_str(c.to_string());\n        }\n    }\n\n    for\
    \ i in 0..s.len() - 1 {\n        chars[i].unwrap()\n            .to_string()\n\
    \            .replace(b'a', b'z')\n            .replace(b'A', b'Z')\n        \
    \    .replace(b'e', b'z')\n            .replace(b'E', b'Z')\n            .replace(b'i',\
    \ b'z')\n            .replace(b'I', b'Z')\n            .replace(b'o', b'z')\n\
    \            .replace(b'O', b'Z')\n            .replace(b'u', b'z')\n        \
    \    .replace(b'U', b'Z')\n            .replace(b'c', b'a')\n            .replace(b'C',\
    \ b'A')\n            .replace(b'n', b'n')\n            .replace(b'N', b'N')\n\
    \            .replace(b's', b's')\n            .replace(b'S', b'S')\n        \
    \    .replace(b'p', b'p')\n            .replace(b'P', b'P')\n            .replace(b't',\
    \ b't')\n            .replace(b'T', b'T')\n            .replace(b'd', b'd')\n\
    \            .replace(b'D', b'D')\n            .replace(b'g', b'g')\n        \
    \    .replace(b'G', b'G')\n            .replace(b'h', b'h')\n            .replace(b'H',\
    \ b'H')\n            .replace(b'y', b'y')\n            .replace(b'Y', b'Y')\n\
    \            .replace(b'z', b'z')\n            .replace(b'Z', b'Z');\n    }\n\n\
    \    new_string.push_str(s);\n    new_string\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpi64mkjeh.rs:13:26\n\
    \   |\n13 |     let mut word_to_ord: HashSet<&'static str> = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi64mkjeh.rs:13:50\n\
    \   |\n13 |     let mut word_to_ord: HashSet<&'static str> = HashSet::new();\n\
    \   |                                                  ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi64mkjeh.rs:19:33\n   |\n\
    19 |             new_string.push_str(c.to_string());\n   |                   \
    \              ^^^^^^^^^^^^^\n   |                                 |\n   |   \
    \                              expected `&str`, found struct `String`\n   |  \
    \                               help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0599]: no method named `unwrap` found for tuple `(usize, char)` in the\
    \ current scope\n  --> /tmp/tmpi64mkjeh.rs:24:18\n   |\n24 |         chars[i].unwrap()\n\
    \   |                  ^^^^^^ method not found in `(usize, char)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi64mkjeh.rs:58:25\n   |\n58 |     new_string.push_str(s);\n\
    \   |                         ^\n   |                         |\n   |        \
    \                 expected `&str`, found struct `String`\n   |               \
    \          help: consider borrowing here: `&s`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().map( |c| c.to_ascii_lowercase().unwrap() ).collect::<Vec<_>>().sort_by(|a,\
    \ b| a.cmp(&b)).iter().map(|c| c + '\\0').collect::<String>().to_string()\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpcxa6s2e0.rs:11:47\n   |\n11 |     s.chars().map( |c| c.to_ascii_lowercase().unwrap()\
    \ ).collect::<Vec<_>>().sort_by(|a, b| a.cmp(&b)).iter().map(|c| c + '\\0').collect::...\n\
    \   |                                               ^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `iter` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpcxa6s2e0.rs:11:104\n   |\n11 |     s.chars().map(\
    \ |c| c.to_ascii_lowercase().unwrap() ).collect::<Vec<_>>().sort_by(|a, b| a.cmp(&b)).iter().map(|c|\
    \ c + '\\0').collect::...\n   |                                              \
    \                                                          ^^^^ method not found\
    \ in `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Complete this function\n    let mut result = s.to_string();\n    let mut\
    \ map = String::new();\n\n    map.push(\"a\".to_string());\n    map.push(\"b\"\
    .to_string());\n    map.push(\"c\".to_string());\n    map.push(\"d\".to_string());\n\
    \    map.push(\"e\".to_string());\n    map.push(\"f\".to_string());\n    map.push(\"\
    g\".to_string());\n    map.push(\"h\".to_string());\n    map.push(\"i\".to_string());\n\
    \    map.push(\"j\".to_string());\n    map.push(\"k\".to_string());\n    map.push(\"\
    l\".to_string());\n    map.push(\"m\".to_string());\n    map.push(\"n\".to_string());\n\
    \    map.push(\"o\".to_string());\n    map.push(\"p\".to_string());\n    map.push(\"\
    q\".to_string());\n    map.push(\"r\".to_string());\n    map.push(\"s\".to_string());\n\
    \    map.push(\"t\".to_string());\n    map.push(\"u\".to_string());\n    map.push(\"\
    v\".to_string());\n    map.push(\"w\".to_string());\n    map.push(\"x\".to_string());\n\
    \    map.push(\"y\".to_string());\n    map.push(\"z\".to_string());\n\n    map.push(\"\
    A\".to_string());\n    map.push(\"B\".to_string());\n    map.push(\"C\".to_string());\n\
    \    map.push(\"D\".to_string());\n    map.push(\"E\".to_string());\n    map.push(\"\
    F\".to_string());\n    map.push(\"G\".to_string());\n    map.push(\"H\".to_string());\n\
    \    map.push(\"I\".to_string());\n    map.push(\"J\".to_string());\n    map.push(\"\
    K\".to_string());\n    map.push(\"L\".to_string());\n    map.push(\"M\".to_string());\n\
    \    map.push(\"N\".to_string());\n    map.push(\"O\".to_string());\n    map.push(\"\
    P\".to_string());\n    map.push(\"Q\".to_string());\n    map.push(\"R\".to_string());\n\
    \    map.push(\"S\".to_string());\n    map.push(\"T\".to_string());\n    map.push(\"\
    U\".to_string());\n    map.push(\"V\".to_string());\n    map.push(\"W\".to_string());\n\
    \    map.push(\"X\".to_string());\n    map.push(\"Y\".to_string());\n    map.push(\"\
    Z\".to_string());\n\n    map.push(\"0\".to_string());\n    map.push(\"1\".to_string());\n\
    \    map.push\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaxhnicc_.rs:15:14\n   |\n\
    15 |     map.push(\"a\".to_string());\n   |              ^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxhnicc_.rs:16:14\n\
    \   |\n16 |     map.push(\"b\".to_string());\n   |              ^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpaxhnicc_.rs:17:14\n   |\n17 |     map.push(\"c\".to_string());\n\
    \   |              ^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpaxhnicc_.rs:18:14\n   |\n18 |  \
    \   map.push(\"d\".to_string());\n   |              ^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxhnicc_.rs:19:14\n\
    \   |\n19 |     map.push(\"e\".to_string());\n   |              ^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpaxhnicc_.rs:20:14\n   |\n20 |     map.push(\"f\".to_string());\n\
    \   |              ^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpaxhnicc_.rs:21:14\n   |\n21 |  \
    \   map.push(\"g\".to_string());\n   |              ^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxhnicc_.rs:22:14\n\
    \   |\n22 |     map.push(\"h\".to_string());\n   |              ^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpaxhnicc_.rs:23:14\n   |\n23 |     map.push(\"i\".to_string());\n\
    \   |              ^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpaxhnicc_.rs:24:14\n   |\n24 |  \
    \   map.push(\"j\".to_string());\n   |              ^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxhnicc_.rs:25:14\n\
    \   |\n25 |     map.push(\"k\".to_string());\n   |              ^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpaxhnicc_.rs:26:14\n   |\n26 |     map.push(\"l\"."
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result = s;\n    let mut words = s.split_whitespace();\n    let mut\
    \ new_words = Vec::new();\n    for w in words {\n        let mut new_w = w.to_string();\n\
    \        let mut letters = new_w.chars();\n        letters.sort();\n        new_w\
    \ = String::from_iter(letters);\n        new_words.push(new_w);\n    }\n    result\
    \ = new_words.join(\" \");\n    result\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp8yst6g_w.rs:17:17\n   |\n17 |         letters.sort();\n\
    \   |                 ^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no\
    \ function or associated item named `from_iter` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp8yst6g_w.rs:18:25\n   |\n18 |         new_w = String::from_iter(letters);\n\
    \   |                         ^^^^^^^^^ function or associated item not found\
    \ in `String`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there\
    \ is an associated function with a similar name\n   |\n18 |         new_w = String::from_utf8(letters);\n\
    \   |                         ~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Your code here\n    let mut s = s; // make a copy to preserve original\
    \ string\n    s.split(\" \").sort(|a, b| a.cmp(b)).join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpztq2xrks.rs:13:18\n   |\n13 |     s.split(\"\
    \ \").sort(|a, b| a.cmp(b)).join(\" \")\n   |                  ^^^^ method not\
    \ found in `std::str::Split<'_, &str>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut rev = String::new();\n    let mut new_word = \"\";\n    for (i, c)\
    \ in s.chars().enumerate() {\n        if c == ' ' {\n            new_word += &s[i\
    \ - 1..i];\n            new_word.push_str(\" \");\n        } else {\n        \
    \    new_word.push_str(&ascii_to_string(c));\n        }\n        rev.push_str(&new_word);\n\
    \        new_word = \"\";\n    }\n    rev\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ascii_to_string` in this scope\n  -->\
    \ /tmp/tmpmfnzdtax.rs:18:32\n   |\n18 |             new_word.push_str(&ascii_to_string(c));\n\
    \   |                                ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmpmfnzdtax.rs:15:13\n   |\n15 |             new_word += &s[i - 1..i];\n\
    \   |             --------^^^^^^^^^^^^^^^^\n   |             |\n   |         \
    \    cannot use `+=` on type `&str`\n\nerror[E0599]: no method named `push_str`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpmfnzdtax.rs:16:22\n\
    \   |\n16 |             new_word.push_str(\" \");\n   |                      ^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `push_str` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpmfnzdtax.rs:18:22\n\
    \   |\n18 |             new_word.push_str(&ascii_to_string(c));\n   |        \
    \              ^^^^^^^^ method not found in `&str`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0368, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().map(|c| c.to_string()).collect::<Vec<_>>().sort_by(|a, b| b.cmp(a)).collect()\n\
    \        .iter().map(|x| x.to_string()).collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp9farb30a.rs:11:83\n\
    \   |\n11 |     s.chars().map(|c| c.to_string()).collect::<Vec<_>>().sort_by(|a,\
    \ b| b.cmp(a)).collect()\n   |                                               \
    \                                    ^^^^^^^ `()` is not an iterator\n   |\n \
    \  = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.to_string().replace(\"_\", \"\")\n        .replace(\" \", \" \")\n    \
    \    .to_string()\n        .to_string()\n        .sort_by_key(|x| *x.as_bytes())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpa784m_te.rs:15:10\n   |\n15 |         .sort_by_key(|x|\
    \ *x.as_bytes())\n   |          ^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    use std::cmp::Ordering;\n\n    let mut s = s.to_owned();\n    while let Some(c)\
    \ = s.chars().next() {\n        let replacement = if c.is_ascii_lowercase() &&\
    \ !c.is_ascii_uppercase() {\n            'o'\n        } else if c.is_ascii_uppercase()\
    \ && c.is_ascii_lowercase() {\n            'O'\n        } else if c.is_ascii_lowercase()\
    \ && !c.is_ascii_uppercase() {\n            'a'\n        } else if c.is_ascii_uppercase()\
    \ && c.is_ascii_lowercase() {\n            'A'\n        } else {\n           \
    \ c\n        };\n        s.replace(s.find(c), c.len_utf8(), replacement);\n  \
    \  }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpn9tmyizn.rs:11:9\n\
    \   |\n11 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpn9tmyizn.rs:26:11\n\
    \    |\n26  |         s.replace(s.find(c), c.len_utf8(), replacement);\n    |\
    \           ^^^^^^^ ---------  ------------  ----------- supplied 3 arguments\n\
    \    |           |\n    |           expected 2 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut new_s: String = String::new();\n    let mut i:\
    \ usize = 0;\n    let mut j: usize = 0;\n    while i < s.len() {\n        if s.as_bytes()[i]\
    \ >= 65 && s.as_bytes()[i] <= 90 {\n            i += 1;\n            continue;\n\
    \        }\n        while j >= 0 && s.as_bytes()[j] >= 90 && s.as_bytes()[j] <=\
    \ 122 {\n            new_s.push_str(&s[..j]);\n            j -= 1;\n        }\n\
    \        new_s.push_str(&s[..i]);\n        j = 0;\n        i += 1;\n    }\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"H\"`,\n right: `\"Hi\"`', /tmp/tmpjagqmz8h.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write your code in Rust here\n    \n    let mut s = String::from(s);\n\
    \    for &mut char in s.chars() {\n        if char == ' ' {\n            continue;\n\
    \        }\n        let char = char.to_ascii_lowercase();\n        \n        //\
    \ get all occurences of this char\n        let mut i = s.char_indices()\n    \
    \        .filter(|&x| x == char)\n            .collect::<Vec<_>>();\n        \n\
    \        let mut new_char: char = char;\n        let mut cnt: usize = 0;\n   \
    \     \n        // find min index\n        i.sort_by(|a, b| a.cmp(b));\n     \
    \   for i in i {\n            if cnt == 0 {\n                new_char = char;\n\
    \                cnt = 1;\n            } else if cnt == 2 {\n                if\
    \ i as u8 == 255 {\n                    new_char = char;\n                   \
    \ break;\n                }\n                new_char = char + char;\n       \
    \         cnt += 1;\n            } else {\n                new_char = char + char;\n\
    \                cnt += 1;\n            }\n        }\n        s = s.replace(\"\
    \\&\\&\\&\".to_string(), &new_char).to_string();\n    }\n    \n    s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: unknown character escape: `&`\n  --> /tmp/tmpb82hn8rq.rs:46:25\n\
    \   |\n46 |         s = s.replace(\"\\&\\&\\&\".to_string(), &new_char).to_string();\n\
    \   |                         ^ unknown character escape\n   |\n   = help: for\
    \ more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n46 |         s = s.replace(r\"\
    \\&\\&\\&\".to_string(), &new_char).to_string();\n   |                       ~~~~~~~~~\n\
    \nerror: unknown character escape: `&`\n  --> /tmp/tmpb82hn8rq.rs:46:27\n   |\n\
    46 |         s = s.replace(\"\\&\\&\\&\".to_string(), &new_char).to_string();\n\
    \   |                           ^ unknown character escape\n   |\n   = help: for\
    \ more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n46 |         s = s.replace(r\"\
    \\&\\&\\&\".to_string(), &new_char).to_string();\n   |                       ~~~~~~~~~\n\
    \nerror: unknown character escape: `&`\n  --> /tmp/tmpb82hn8rq.rs:46:29\n   |\n\
    46 |         s = s.replace(\"\\&\\&\\&\".to_string(), &new_char).to_string();\n\
    \   |                             ^ unknown character escape\n   |\n   = help:\
    \ for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n46 |         s = s.replace(r\"\
    \\&\\&\\&\".to_string(), &new_char).to_string();\n   |                       ~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb82hn8rq.rs:14:9\n   |\n14 | \
    \    for &mut char in s.chars() {\n   |         ^^^^^^^^^    --------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ `&mut _`\n   |         help: you can probably remove the explicit borrow: `char`\n\
    \   |\n   = note:           expected type `char`\n           found mutable re"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    let mut letters = vec![String::new();\
    \ words.size() as usize];\n    letters.clone_from_slice(words[0].chars());\n \
    \   for word in &words[1..] {\n        letters.clone_from_slice(word.chars().iter().cloned());\n\
    \    }\n\n    let mut new_letters = vec![String::new(); letters.len()];\n    let\
    \ mut new_letters_len = vec![0; letters.len()];\n\n    let mut prev_letter = 0;\n\
    \    let mut prev_letter_len = Vec::new();\n    for &letter in letters {\n   \
    \     let mut letter_len = letters.iter().filter(|c| *c == letter).count();\n\
    \        prev_letter_len.push(letter_len);\n        if letter_len > prev_letter_len[0]\
    \ {\n            prev_letter = letter_len;\n        }\n    }\n    prev_letter_len\
    \ = prev_letter_len.iter().cloned().collect::<Vec<_>>();\n\n    for &letter in\
    \ letters {\n        for mut letter_len = letters.iter().filter(|c| *c == letter).count()\
    \ {\n            if letter_len == prev_letter_len.iter().min() {\n           \
    \     new_letters[prev_letter_len.iter().max().unwrap()] += letter;\n        \
    \    }\n        }\n    }\n\n    let mut result = String::new();\n    new_letters.iter().for_each(|&letter|\
    \ {\n        result.push_str(&letter);\n    });\n    result\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmp0_ba04uz.rs:33:27\n  \
    \ |\n33 |         for mut letter_len = letters.iter().filter(|c| *c == letter).count()\
    \ {\n   |                           ^ help: try adding `in` here\n\nerror: expected\
    \ expression, found `=`\n  --> /tmp/tmp0_ba04uz.rs:33:28\n   |\n33 |         for\
    \ mut letter_len = letters.iter().filter(|c| *c == letter).count() {\n   |   \
    \                         ^ expected expression\n\nerror[E0599]: no method named\
    \ `size` found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmp0_ba04uz.rs:12:49\n\
    \   |\n12 |     let mut letters = vec![String::new(); words.size() as usize];\n\
    \   |                                                 ^^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp0_ba04uz.rs:13:30\n   |\n13 |     letters.clone_from_slice(words[0].chars());\n\
    \   |                              ^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp0_ba04uz.rs:14:18\n   |\n\
    14 |     for word in &words[1..] {\n   |                  ^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0_ba04uz.rs:23:9\n   |\n23 |     for &letter\
    \ in letters {\n   |         ^^^^^^^    ------- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `letter`\n   |\n\
    \   = note: expected struct `String`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0_ba04uz.rs:32:9\n   |\n32 |     for &letter\
    \ in letters {\n   |         ^^^^^^^    ------- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `letter`\n   |\n\
    \   = note: expected struct `String`\n           found reference `&_`\n\nerror:\
    \ aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0608.\nFor more information about an error, try `rustc -"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::from(s);\n    let mut s = String::from(s);\n\n    let\
    \ mut new_s = String::new();\n    let mut new_words = Vec::new();\n\n    while\
    \ !s.is_empty() {\n        let mut new_word = String::new();\n        let mut\
    \ first_char = 0;\n        let mut last_char = 0;\n        while s.len() != 0\
    \ {\n            let c = s.chars().nth(0);\n            let pos = c.position();\n\
    \            first_char = pos;\n            last_char = pos;\n            new_word\
    \ = s.clone().trim_start_matches(\"_\");\n            s.truncate(last_char);\n\
    \            new_word.truncate(first_char);\n            new_word.insert(0, c);\n\
    \            new_words.push(new_word);\n            s = new_word.clone();\n  \
    \      }\n        new_s.extend_from_slice(new_words[0]);\n        for word in\
    \ new_words.iter().skip(1) {\n            new_s.extend_from_slice(word);\n   \
    \     }\n    }\n\n    return res;\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `position` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmptu3rhosv.rs:23:25\n   |\n23 |             let pos\
    \ = c.position();\n   |                         ^^^^^^^^ method not found in `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptu3rhosv.rs:26:24\n   |\n18 |\
    \         let mut new_word = String::new();\n   |                            -------------\
    \ expected due to this value\n...\n26 |             new_word = s.clone().trim_start_matches(\"\
    _\");\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptu3rhosv.rs:29:32\n   |\n29 |             new_word.insert(0,\
    \ c);\n   |                                ^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0599]: no method named `extend_from_slice` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmptu3rhosv.rs:33:15\n   |\n33 |         new_s.extend_from_slice(new_words[0]);\n\
    \   |               ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `extend_from_slice` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmptu3rhosv.rs:35:19\n   |\n35 |             new_s.extend_from_slice(word);\n\
    \   |                   ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write your code here\n    let mut words: Vec<String> = s.chars().collect();\n\
    \    words.sort_by(|&a| a.to_ascii_lowercase());\n    return words.join(\"\");\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpgx56gmdr.rs:12:44\n     |\n12\
    \   |     let mut words: Vec<String> = s.chars().collect();\n     |          \
    \                                  ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0593]: closure is expected to take 2 arguments, but it\
    \ takes 1 argument\n  --> /tmp/tmpgx56gmdr.rs:13:11\n   |\n13 |     words.sort_by(|&a|\
    \ a.to_ascii_lowercase());\n   |           ^^^^^^^ ---- takes 1 argument\n   |\
    \           |\n   |           expected closure that takes 2 arguments\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0593.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().collect::<Vec<_>>().sort_by(|a, b| a.to_ascii_lowercase().cmp(b.to_ascii_lowercase()));\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpea3wmshr.rs:11:77\n   |\n\
    11 |     s.chars().collect::<Vec<_>>().sort_by(|a, b| a.to_ascii_lowercase().cmp(b.to_ascii_lowercase()));\n\
    \   |                                                                        \
    \     ^^^^^^^^^^^^^^^^^^^^^^\n   |                                           \
    \                                  |\n   |                                   \
    \                                          expected `&char`, found `char`\n  \
    \ |                                                                          \
    \   help: consider borrowing here: `&b.to_ascii_lowercase()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpea3wmshr.rs:10:31\n   |\n10 | fn anti_shuffle(s:\
    \ String) -> String {\n   |    ------------               ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = String::from(s);\n    for (i, c) in s.chars().enumerate() {\n\
    \        match c.to_ascii_lowercase().cmp(&b'a' - b'a') {\n            Ordering::Less\
    \ => s.insert(i, ' '),\n            Ordering::Greater => break,\n            Ordering::Equal\
    \ => {\n                let mut idx = i;\n                for (j, c) in s.chars().enumerate()\
    \ {\n                    let a = c.to_ascii_lowercase();\n                   \
    \ if a == c {\n                        break;\n                    }\n       \
    \             idx = j;\n                }\n                s.swap(i, idx);\n \
    \           }\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpvumo965x.rs:14:13\n   |\n14 |             Ordering::Less => s.insert(i,\
    \ ' '),\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpvumo965x.rs:15:13\n\
    \   |\n15 |             Ordering::Greater => break,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpvumo965x.rs:16:13\n   |\n16 |    \
    \         Ordering::Equal => {\n   |             ^^^^^^^^ use of undeclared type\
    \ `Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvumo965x.rs:13:42\n\
    \   |\n13 |         match c.to_ascii_lowercase().cmp(&b'a' - b'a') {\n   |   \
    \                                       ^^^^^^^^^^^^ expected `&char`, found `u8`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpvumo965x.rs:25:19\n   |\n25 |                 s.swap(i,\
    \ idx);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0433,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .filter(|c| c != ' ').collect::<Vec<_>>()\n        .sort_by(|x,\
    \ y| x.cmp(y))\n        .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2zsb_7bd.rs:12:23\n\
    \   |\n12 |         .filter(|c| c != ' ').collect::<Vec<_>>()\n   |          \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmp2zsb_7bd.rs:14:10\n\
    \   |\n14 |         .collect()\n   |          ^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut word_iter: WordIt = s.split_whitespace().iter();\n    let mut buf\
    \ = [0u8; s.len()];\n    let mut ascii_buf = [0u8; s.len()];\n    let mut prev_ascii\
    \ = 0;\n    let mut word_len = 0;\n    let mut new_word: [u8; MAX_SIZE] = [0u8;\
    \ MAX_SIZE];\n    loop {\n        let mut next_ascii = 0;\n        let mut new_word\
    \ = [0u8; MAX_SIZE];\n        for (i, word) in word_iter.next() {\n          \
    \  prev_ascii = ascii_buf[i as usize];\n            next_ascii = word[0].to_ascii_lowercase();\n\
    \            new_word[0] = next_ascii;\n            ascii_buf[i] = next_ascii;\n\
    \            new_word[1] = word[1];\n            ascii_buf[i + 2] = ascii_buf[i\
    \ as usize + 1];\n            new_word[2 + word_len] = prev_ascii;\n         \
    \   word_len += 1;\n        }\n        if word_len < s.len() {\n            buf[word_len\
    \ as usize] = '\\0';\n            buf[word_len as usize + 1] = '\\0';\n      \
    \  } else {\n            break;\n        }\n        word_iter.reset();\n    }\n\
    \    buf[word_len as usize + 1] = '\\0';\n    String::from_utf8_lossy(buf).unwrap()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpxokmlr4h.rs:12:25\n   |\n10 | fn anti_shuffle(s: String) -> String {\n\
    \   |                 - this would need to be a `const`\n11 |     let mut word_iter:\
    \ WordIt = s.split_whitespace().iter();\n12 |     let mut buf = [0u8; s.len()];\n\
    \   |                         ^\n\nerror[E0435]: attempt to use a non-constant\
    \ value in a constant\n  --> /tmp/tmpxokmlr4h.rs:13:31\n   |\n10 | fn anti_shuffle(s:\
    \ String) -> String {\n   |                 - this would need to be a `const`\n\
    ...\n13 |     let mut ascii_buf = [0u8; s.len()];\n   |                      \
    \         ^\n\nerror[E0412]: cannot find type `WordIt` in this scope\n  --> /tmp/tmpxokmlr4h.rs:11:24\n\
    \   |\n11 |     let mut word_iter: WordIt = s.split_whitespace().iter();\n   |\
    \                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `MAX_SIZE` in this scope\n  --> /tmp/tmpxokmlr4h.rs:16:28\n   |\n\
    16 |     let mut new_word: [u8; MAX_SIZE] = [0u8; MAX_SIZE];\n   |           \
    \                 ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `MAX_SIZE` in this scope\n  --> /tmp/tmpxokmlr4h.rs:16:46\n   |\n16 |\
    \     let mut new_word: [u8; MAX_SIZE] = [0u8; MAX_SIZE];\n   |              \
    \                                ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_SIZE` in this scope\n  --> /tmp/tmpxokmlr4h.rs:19:34\n\
    \   |\n19 |         let mut new_word = [0u8; MAX_SIZE];\n   |                \
    \                  ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `iter` found for struct `SplitWhitespace` in the current scope\n  -->\
    \ /tmp/tmpxokmlr4h.rs:11:54\n   |\n11 |     let mut word_iter: WordIt = s.split_whitespace().iter();\n\
    \   |                                                      ^^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `unwrap` found for\
    \ enum `Cow<'_, str>` in the current scope\n  --> /tmp/tmpxokmlr4h.rs:39:34\n\
    \   |\n39 |     String::from_utf8_lossy(buf).unwrap()\n   |                  \
    \                ^^^^^^ method not "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n\n    let mut w = String::new();\n    let mut new_w = String::new();\n\
    \    let mut new_s = String::new();\n\n    while !s.is_empty() {\n        new_w\
    \ = w.to_owned() + s.chars().collect()\n            .sort_by(|x, y| x.cmp(&y))\n\
    \            .collect::<Vec<_>>()\n            .join(' ');\n        new_s = s\
    \ + new_w.to_string();\n        s = new_s;\n    }\n\n    s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpq0bp64ks.rs:18:42\n\
    \   |\n18 |         new_w = w.to_owned() + s.chars().collect()\n   |         \
    \                                 ^^^^^^^ cannot infer type for type parameter\
    \ `B` declared on the associated function `collect`\n   |\n   = note: type must\
    \ be known at this point\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n18 |         new_w = w.to_owned() + s.chars().collect::<B>()\n \
    \  |                                                 +++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq0bp64ks.rs:22:21\n   |\n22 |         new_s = s + new_w.to_string();\n\
    \   |                     ^^^^^^^^^^^^^^^^^\n   |                     |\n   |\
    \                     expected `&str`, found struct `String`\n   |           \
    \          help: consider borrowing here: `&new_w.to_string()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    match s.chars().order() {\n        Ordering::Less => {\n            let mut\
    \ result = String::with_capacity(s.len());\n            let mut buffer = String::with_capacity(s.len());\n\
    \            for (index, ch) in s.chars().enumerate() {\n                if ch\
    \ != ' ' {\n                    buffer.push(ch);\n                } else {\n \
    \                   let index2 = index;\n                    while index2 < buffer.len()\
    \ {\n                        buffer.swap(index2, index2);\n                  \
    \      index2 += 1;\n                    }\n                    buffer.push('\
    \ ');\n                }\n            }\n            result.push_str(&buffer);\n\
    \            result\n        }\n        Ordering::Greater => {\n            let\
    \ mut result = String::with_capacity(s.len());\n            let mut buffer = String::with_capacity(s.len());\n\
    \            let mut words: Vec<_> = s.splitn(2, \" \").collect();\n         \
    \   for (index, ch) in s.chars().enumerate() {\n                if ch != ' ' {\n\
    \                    buffer.push(ch);\n                } else {\n            \
    \        if index == 0 {\n                        result.push_str(&words[0]);\n\
    \                        words.shift();\n                    } else {\n      \
    \                  let index2 = index;\n                        while index2 <\
    \ buffer.len() {\n                            buffer.swap(index2, index2);\n \
    \                           index2 += 1;\n                        }\n        \
    \                buffer.push(' ');\n                        result.push_str(&buffer);\n\
    \                        buffer.push(' ');\n                        words.shift();\n\
    \                    }\n                }\n            }\n            result.push_str(&buffer);\n\
    \            result\n        }\n        Ordering::Equal => {\n            let\
    \ mut result = String::with_capacity(s.len());\n            let mut buffer = String::with_capacity(s.len());\n\
    \            for (index, ch) in s.chars().enumerate() {\n                if ch\
    \ != ' ' {\n                    buffer.push(ch);\n                } else {\n \
    \                   let index2 = index;\n                    while index2 < buffer.len()\
    \ {\n                        buffer.swap(index2, index2);\n                  \
    \      index2 += 1;\n                    }\n                    buffer.push('\
    \ ');\n                }\n            }\n            result.push_str(&buffer);\n\
    \            result\n        }\n    }\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpk1l9r0wm.rs:12:9\n   |\n12 |         Ordering::Less => {\n   |     \
    \    ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpk1l9r0wm.rs:30:9\n   |\n30\
    \ |         Ordering::Greater => {\n   |         ^^^^^^^^ use of undeclared type\
    \ `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpk1l9r0wm.rs:57:9\n   |\n57 |         Ordering::Equal => {\n   |\
    \         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]: no method\
    \ named `order` found for struct `Chars` in the current scope\n  --> /tmp/tmpk1l9r0wm.rs:11:21\n\
    \   |\n11 |     match s.chars().order() {\n   |                     ^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `swap` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpk1l9r0wm.rs:21:32\n   |\n21 | \
    \                        buffer.swap(index2, index2);\n   |                  \
    \              ^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `shift` found for struct `Vec<&str>` in the current scope\n  --> /tmp/tmpk1l9r0wm.rs:40:31\n\
    \   |\n40 |                         words.shift();\n   |                     \
    \          ^^^^^ method not found in `Vec<&str>`\n\nerror[E0599]: no method named\
    \ `swap` found for struct `String` in the current scope\n  --> /tmp/tmpk1l9r0wm.rs:44:36\n\
    \   |\n44 | ...                   buffer.swap(index2, index2);\n   |         \
    \                     ^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `shift` found for struct `Vec<&str>` in the current scope\n  --> /tmp/tmpk1l9r0wm.rs:50:31\n\
    \   |\n50 |                         words.shift();\n   |                     \
    \          ^^^^^ method not found in `Vec<&str>`\n\nerror[E0599]: no method named\
    \ `swap` found for struct `String` in the current scope\n  --> /tmp/tmpk1l9r0wm.rs:66:32\n\
    \   |\n66 |                         buffer.swap(index2, index2);\n   |       \
    \                         ^^^^ method not found in `String`\n\nerror: aborti"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut new_s = s.chars().fold(String::new(), |mut acc, &c|\n        if c.is_alphabetic()\
    \ {\n            acc.push_str(&c.to_ascii_lowercase());\n        } else {\n  \
    \          acc.push_str(&c.to_ascii_uppercase());\n        }\n    );\n    new_s.push_str(\"\
    !\");\n    new_s.push_str(&s.chars().filter(|c| c.is_alphabetic()).collect::<Vec<_>>());\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgl4s8y7_.rs:11:61\n   |\n\
    11 |     let mut new_s = s.chars().fold(String::new(), |mut acc, &c|\n   |   \
    \                                                          ^--\n   |         \
    \                                                    ||\n   |                \
    \                                             |expected due to this\n   |    \
    \                                                         expected `char`, found\
    \ reference\n   |                                                            \
    \ help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgl4s8y7_.rs:12:30\n\
    \   |\n12 |           if c.is_alphabetic() {\n   |  ______________________________^\n\
    13 | |             acc.push_str(&c.to_ascii_lowercase());\n14 | |         } else\
    \ {\n   | |_________^ expected struct `String`, found `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgl4s8y7_.rs:14:16\n   |\n14 |           } else {\n   |\
    \  ________________^\n15 | |             acc.push_str(&c.to_ascii_uppercase());\n\
    16 | |         }\n   | |_________^ expected struct `String`, found `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgl4s8y7_.rs:19:20\n   |\n19 |     new_s.push_str(&s.chars().filter(|c|\
    \ c.is_alphabetic()).collect::<Vec<_>>());\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `Vec`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&Vec<char>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write code here\n    let mut words = s.split_whitespace().collect::<Vec<String>>();\n\
    \    let mut chars_map = Vec::new();\n\n    for (i, &c) in words.iter().enumerate()\
    \ {\n        let value = c.to_ascii_lowercase();\n        if !chars_map.contains(&value)\
    \ {\n            chars_map.push(String::new());\n        }\n        chars_map.get(&value).unwrap().push(i);\n\
    \    }\n\n    let mut s = String::new();\n    for (c, chars) in chars_map.iter()\
    \ {\n        chars.sort();\n        for (i, j) in chars.iter().rev() {\n     \
    \       s.push_str(&s[*j..*i]);\n        }\n        s.push_str(&c);\n    }\n \
    \   s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpofvtjecd.rs:12:42\n     |\n12\
    \   |     let mut words = s.split_whitespace().collect::<Vec<String>>();\n   \
    \  |                                          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the type `[String]` cannot be indexed\
    \ by `&String`\n   --> /tmp/tmpofvtjecd.rs:20:23\n    |\n20  |         chars_map.get(&value).unwrap().push(i);\n\
    \    |                   --- ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n    |                   |\n    |                   required by a\
    \ bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `&String`\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpofvtjecd.rs:24:9\n\
    \   |\n24 |     for (c, chars) in chars_map.iter() {\n   |         ^^^^^^^^^^\
    \    ---------------- this expression has type `Option<&String>`\n   |       \
    \  |\n   |         expected struct `String`, found tuple\n   |\n   = note: expected\
    \ struct `String`\n               found tuple `(_, _)`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut new_s = s.to_owned();\n    let mut ascii_char_map = HashMap::new();\n\
    \    ascii_char_map.insert(b'a', 0);\n    ascii_char_map.insert(b'b', 1);\n  \
    \  ascii_char_map.insert(b'c', 2);\n    ascii_char_map.insert(b'd', 3);\n    ascii_char_map.insert(b'e',\
    \ 4);\n    ascii_char_map.insert(b'f', 5);\n    ascii_char_map.insert(b'g', 6);\n\
    \    ascii_char_map.insert(b'h', 7);\n    ascii_char_map.insert(b'i', 8);\n  \
    \  ascii_char_map.insert(b'j', 9);\n    ascii_char_map.insert(b'k', 10);\n   \
    \ ascii_char_map.insert(b'l', 11);\n    ascii_char_map.insert(b'm', 12);\n   \
    \ ascii_char_map.insert(b'n', 13);\n    ascii_char_map.insert(b'o', 14);\n   \
    \ ascii_char_map.insert(b'p', 15);\n    ascii_char_map.insert(b'q', 16);\n   \
    \ ascii_char_map.insert(b'r', 17);\n    ascii_char_map.insert(b's', 18);\n   \
    \ ascii_char_map.insert(b't', 19);\n    ascii_char_map.insert(b'u', 20);\n   \
    \ ascii_char_map.insert(b'v', 21);\n    ascii_char_map.insert(b'w', 22);\n   \
    \ ascii_char_map.insert(b'x', 23);\n    ascii_char_map.insert(b'y', 24);\n   \
    \ ascii_char_map.insert(b'z', 25);\n    ascii_char_map.insert(b' ', 26);\n\n \
    \   // first we start from the beginning and work towards the end\n    new_s.reverse();\n\
    \    let mut new_new_s = new_s.to_owned();\n    new_new_s.reverse();\n\n    //\
    \ we start from the end of the first word and work towards the beginning of the\
    \ second\n    let mut ascii_new_new_s = new_new_s.to_owned();\n    ascii_new_new_s.reverse();\n\
    \n    // we start from the beginning of the second and work towards the end of\
    \ the first\n    let mut ascii_ascii_new_s = ascii_new_new_s.to_owned();\n   \
    \ ascii_ascii_new_s.reverse();\n\n    for i in 0..ascii_ascii_new_s.len() {\n\
    \        if ascii_ascii_new_s[i] > ascii_ascii_new_new_s[i] {\n            ascii_new_new_s[i]\
    \ = ascii_ascii_new_s[i - ascii_ascii_new_new_s.len()];\n        }\n    }\n  \
    \  new_new_s.reverse();\n\n    new_new_s.join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp1y72ry_y.rs:12:30\n   |\n12 |     let mut ascii_char_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `ascii_ascii_new_new_s` in this scope\n\
    \  --> /tmp/tmp1y72ry_y.rs:55:35\n   |\n55 |         if ascii_ascii_new_s[i] >\
    \ ascii_ascii_new_new_s[i] {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `ascii_ascii_new_s`\n\nerror[E0425]:\
    \ cannot find value `ascii_ascii_new_new_s` in this scope\n  --> /tmp/tmp1y72ry_y.rs:56:56\n\
    \   |\n56 |             ascii_new_new_s[i] = ascii_ascii_new_s[i - ascii_ascii_new_new_s.len()];\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `ascii_ascii_new_s`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp1y72ry_y.rs:42:11\n   |\n42 |     new_s.reverse();\n   |       \
    \    ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1y72ry_y.rs:44:15\n   |\n44 |     new_new_s.reverse();\n\
    \   |               ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp1y72ry_y.rs:48:21\n   |\n48 | \
    \    ascii_new_new_s.reverse();\n   |                     ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp1y72ry_y.rs:52:23\n   |\n52 |     ascii_ascii_new_s.reverse();\n   |\
    \                       ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0277]: the type `String` cannot be indexed by `usize"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut buf = [0; s.len() * 6 + 1];\n\n    let mut i:\
    \ usize = 0;\n    let mut j: usize = 0;\n\n    for i in s.chars().enumerate()\
    \ {\n        let c = i.0[0];\n        let k = i.1;\n\n        if c.is_whitespace()\
    \ {\n            buf[i as usize + 4] &= !0x20;\n        } else {\n           \
    \ buf[i as usize + 5] = buf[i as usize + 5] | c;\n            buf[i as usize +\
    \ 4] &= 0x1f;\n            buf[i as usize + 5] |= k as char;\n        }\n\n  \
    \      if i == s.chars().count() - 1 {\n            buf[i as usize + 5] &= !0x1f;\n\
    \        }\n\n        if i == 0 {\n            buf[i as usize + 5] &= !0x20;\n\
    \        }\n\n        if i == s.chars().count() - 1 {\n            buf[i as usize\
    \ + 5] |= 0x20;\n        }\n\n        i += 1;\n        j += 1;\n    }\n\n    s[0..(s.len()\
    \ - j)] = &buf[..j];\n\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmplindzcc5.rs:12:23\n   |\n11 |     let mut s = s;\n   |     ---------\
    \ help: consider using `const` instead of `let`: `const s`\n12 |     let mut buf\
    \ = [0; s.len() * 6 + 1];\n   |                       ^ non-constant value\n\n\
    error[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmplindzcc5.rs:18:17\n\
    \   |\n18 |         let c = i.0[0];\n   |                 ^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplindzcc5.rs:29:17\n   |\n29 |         if i ==\
    \ s.chars().count() - 1 {\n   |                 ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found `usize`\n   |\n   = note: expected tuple `(usize, char)`\n    \
    \           found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplindzcc5.rs:33:17\n\
    \   |\n33 |         if i == 0 {\n   |                 ^ expected tuple, found\
    \ integer\n   |\n   = note: expected tuple `(usize, char)`\n               found\
    \ type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplindzcc5.rs:37:17\n\
    \   |\n37 |         if i == s.chars().count() - 1 {\n   |                 ^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `usize`\n   |\n   = note: expected tuple `(usize, char)`\n\
    \               found type `usize`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `(usize, char)`\n  --> /tmp/tmplindzcc5.rs:41:9\n\
    \   |\n41 |         i += 1;\n   |         -^^^^^\n   |         |\n   |       \
    \  cannot use `+=` on type `(usize, char)`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmplindzcc5.rs:45:5\n\
    \   |\n45 |     s[0..(s.len() - j)] = &buf[..j];\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: the left-hand-side of an assignment\
    \ must have a statically known size\n\nerror[E0605]: non-primitive cast: `(usize,\
    \ char)` as `usize`\n  --> /tmp/tmplindzcc5.rs:22:17\n   |\n22 |             buf[i\
    \ as usize + 4] &= !0x20;\n   |                 ^^^^^^^^^^ an `as` expression\
    \ can only be used to conve"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s.to_string();\n    let mut buffer = String::with_capacity(s.len()\
    \ * 2);\n\n    buffer.push_str(\"\\0\".to_string());\n    buffer.push_str(\"\\\
    0\".to_string());\n\n    let mut offset = 0;\n\n    while offset < s.len() {\n\
    \        let mut last = 0;\n        while last < s.len() {\n            let mut\
    \ current = s[last..].chars().enumerate().rev().find(|&(i, c)| c.is_whitespace());\n\
    \            let mut word = s[last..current].to_string();\n            let mut\
    \ replacement = 0;\n            while current != 0 {\n                let mut\
    \ current = s[current..].chars().enumerate().rev().find(|&(i, c)| c.is_ascii_letter());\n\
    \                if current != 0 {\n                    replacement = i;\n   \
    \                 break;\n                }\n                current = s.len()\
    \ as i32;\n            }\n\n            if current == 0 {\n                current\
    \ += 2;\n            }\n\n            buffer.push_str(&s[last..current]);\n  \
    \          buffer.push_str(&s[last..replacement]);\n\n            last += 2;\n\
    \            offset = current;\n        }\n    }\n\n    buffer.to_string()\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp6gvb0s2_.rs:28:35\n\
    \   |\n28 |                     replacement = i;\n   |                       \
    \            ^ help: a local variable with a similar name exists: `s`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6gvb0s2_.rs:14:21\n   |\n14 |     buffer.push_str(\"\
    \\0\".to_string());\n   |                     ^^^^^^^^^^^^^^^^\n   |         \
    \            |\n   |                     expected `&str`, found struct `String`\n\
    \   |                     help: consider borrowing here: `&\"\\0\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6gvb0s2_.rs:15:21\n   |\n15 |\
    \     buffer.push_str(\"\\0\".to_string());\n   |                     ^^^^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&\"\\0\"\
    .to_string()`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n    --> /tmp/tmp6gvb0s2_.rs:22:61\n     |\n22   |        \
    \     let mut current = s[last..].chars().enumerate().rev().find(|&(i, c)| c.is_whitespace());\n\
    \     |                                                             ^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     = help:\
    \ the following other types implement trait `ExactSizeIterator`:\n           \
    \    &mut I\n               Args\n               ArgsOs\n               ArrayChunks<'_,\
    \ T, N>\n               ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_,\
    \ T, N>\n               Box<I, A>\n               Chunks<'_, T>\n            \
    \ and 109 others\n     = note: required because of the requirements on the impl\
    \ of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required by a bound\
    \ in `rev`\n\nerror[E0599]: the method `find` exists for struct `Rev<Enumerate<Chars<'_>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp6gvb0s2_.rs:22:67\n \
    \  |\n22 |               let mut current = s[last..].chars().enumerate().rev().find(|&(i,\
    \ c)| c.is_whitespace());\n   |                                              \
    \       "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::from(s);\n    for c in s.chars() {\n        if !(res.contains(&c.to_ascii_lowercase())\
    \ && !res.contains(&c.to_ascii_uppercase())) {\n            res = res.insert(c.to_ascii_lowercase(),\
    \ c.to_ascii_uppercase());\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpmuy5gy5l.rs:13:27\n\
    \     |\n13   |         if !(res.contains(&c.to_ascii_lowercase()) && !res.contains(&c.to_ascii_uppercase()))\
    \ {\n     |                  -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                  |\n     |                  required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing\
    \ here\n     |\n13   |         if !(res.contains(*&c.to_ascii_lowercase()) &&\
    \ !res.contains(&c.to_ascii_uppercase())) {\n     |                          \
    \ +\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpmuy5gy5l.rs:13:69\n\
    \     |\n13   |         if !(res.contains(&c.to_ascii_lowercase()) && !res.contains(&c.to_ascii_uppercase()))\
    \ {\n     |                                                            --------\
    \ ^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n  \
    \   |                                                            |\n     |   \
    \                                                         required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Fn<(char,)>` is not\
    \ implemented for `char`\n     = note: required because of the requirements on\
    \ the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required by\
    \ a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing here\n\
    \     |\n13   |         if !(res.contains(&c.to_ascii_lowercase()) && !res.contains(*&c.to_ascii_uppercase()))\
    \ {\n     |                                                                  \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmuy5gy5l.rs:14:30\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    use std::ascii::AsciiExt;\n\n    let mut s = s\n        .chars()\n      \
    \  .map(|c| (c, AsciiExt::ordinal(c)))\n        .collect::<Vec<_>>()\n       \
    \ .iter()\n        .sort_by_key(|(_, c_index)| c_index)\n        .map(|(_, c)|\
    \ c)\n        .collect::<String>()\n        .replace(\"_\", \" \")\n        .replace(\"\
    !\", \".\")\n        .replace(\"h\", \"i\")\n        .replace(\"o\", \"u\")\n\
    \        .replace(\"l\", \"n\")\n        .replace(\"w\", \"l\")\n        .replace(\"\
    d\", \"e\");\n    for ch in s.chars().filter(|c| c.is_whitespace()) {\n      \
    \  s = s.insert(s.chars().position(|c| c == ch).unwrap_or(0), ch);\n    }\n  \
    \  s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated trait `std::ascii::AsciiExt`: use inherent methods\
    \ instead\n  --> /tmp/tmpw1pjbzij.rs:15:22\n   |\n15 |         .map(|c| (c, AsciiExt::ordinal(c)))\n\
    \   |                      ^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nwarning: use of deprecated trait `std::ascii::AsciiExt`: use inherent\
    \ methods instead\n  --> /tmp/tmpw1pjbzij.rs:11:21\n   |\n11 |     use std::ascii::AsciiExt;\n\
    \   |                     ^^^^^^^^\n\nwarning: trait objects without an explicit\
    \ `dyn` are deprecated\n  --> /tmp/tmpw1pjbzij.rs:15:22\n   |\n15 |         .map(|c|\
    \ (c, AsciiExt::ordinal(c)))\n   |                      ^^^^^^^^\n   |\n   = note:\
    \ `#[warn(bare_trait_objects)]` on by default\n   = warning: this is accepted\
    \ in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note:\
    \ for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n   |\n15 |         .map(|c| (c, <dyn AsciiExt>::ordinal(c)))\n\
    \   |                      ++++         +\n\nerror[E0191]: the value of the associated\
    \ type `Owned` (from trait `AsciiExt`) must be specified\n  --> /tmp/tmpw1pjbzij.rs:15:22\n\
    \   |\n15 |         .map(|c| (c, AsciiExt::ordinal(c)))\n   |                \
    \      ^^^^^^^^ help: specify the associated type: `AsciiExt<Owned = Type>`\n\n\
    error[E0599]: no function or associated item named `ordinal` found for trait object\
    \ `dyn AsciiExt` in the current scope\n  --> /tmp/tmpw1pjbzij.rs:15:32\n   |\n\
    15 |         .map(|c| (c, AsciiExt::ordinal(c)))\n   |                       \
    \         ^^^^^^^ function or associated item not found in `dyn AsciiExt`\n\n\
    error[E0599]: no method named `sort_by_key` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpw1pjbzij.rs:18:10\n   |\n18 |         .sort_by_key(|(_,\
    \ c_index)| c_index)\n   |          ^^^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ _>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome\
    \ errors have detailed explanations: E0191, E0599.\nFor more information about\
    \ an error, try"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    let mut result = words.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < result.len() {\n        if i == 0 {\n     \
    \       result[i] = result[i].to_lowercase();\n            continue;\n       \
    \ }\n        let current_char = result[i].chars().next().unwrap();\n        let\
    \ next_char = result[i + 1].chars().next().unwrap();\n        let mut j = i;\n\
    \        while j > 0 && result[j - 1].chars().next().unwrap().cmp(&current_char)\
    \ < 0 {\n            result[j - 1] = result[j - 1].chars().next().unwrap();\n\
    \            j -= 1;\n        }\n        result[j] = current_char.to_lowercase();\n\
    \        if i == result.len() - 1 {\n            break;\n        }\n        let\
    \ next_char_val = next_char.value();\n        let next_char_char_code = next_char.char_code();\n\
    \        let mut j = 0;\n        while j < result.len() && result[j].chars().next().unwrap().cmp(&next_char_char_code)\
    \ < 0 {\n            result[j + 1] = result[j + 1].chars().next().unwrap();\n\
    \            j += 1;\n        }\n        result[j] = next_char_val;\n        i\
    \ += 1;\n    }\n    result\n        .into_iter()\n        .chain(words.iter().cloned())\n\
    \        .collect::<Vec<_>>()\n        .join(' ')\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpwvnt6aco.rs:12:28\n   |\n12 |     let mut\
    \ result = words.iter().cloned().collect::<Vec<_>>();\n   |                  \
    \          ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no\
    \ method named `iter` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpwvnt6aco.rs:42:22\n   |\n42 |         .chain(words.iter().cloned())\n\
    \   |                      ^^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    words.sort_by(|a, b| a.cmp(b));\n\
    \    String::from_utf8_lossy(words)\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpa2jdtall.rs:12:11\n   |\n12 |     words.sort_by(|a,\
    \ b| a.cmp(b));\n   |           ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa2jdtall.rs:13:29\n   |\n13 |\
    \     String::from_utf8_lossy(words)\n   |                             ^^^^^ expected\
    \ `&[u8]`, found struct `SplitWhitespace`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa2jdtall.rs:13:5\n   |\n10 | fn anti_shuffle(s: String) -> String\
    \ {\n   |                               ------ expected `String` because of return\
    \ type\n...\n13 |     String::from_utf8_lossy(words)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found enum `Cow`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Cow<'_, str>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write code here\n    let mut sorted_string = s.to_string();\n    let mut\
    \ last_char_index = 0;\n    let mut current_char_index = 0;\n    let mut current_char:\
    \ char;\n    let mut temp_str = \"\";\n    let mut word_length = s.len() / 2;\n\
    \    let mut last_char_word_length: usize = 0;\n    let mut first_char_word_length:\
    \ usize = 0;\n    while current_char_index < word_length {\n        last_char_index\
    \ = current_char_index;\n        current_char = sorted_string[current_char_index];\n\
    \        while current_char_index < word_length {\n            let next_char =\
    \ sorted_string[current_char_index + 1];\n            if current_char == next_char\
    \ {\n                current_char_index += 1;\n            } else {\n        \
    \        break;\n            }\n            last_char_index = current_char_index;\n\
    \            current_char = sorted_string[current_char_index];\n        }\n  \
    \      temp_str += sorted_string[last_char_index];\n        sorted_string = sorted_string.replace(last_char_index,\
    \ current_char_index, \"\");\n    }\n    while first_char_word_length < word_length\
    \ {\n        last_char_index = current_char_index;\n        current_char = sorted_string[first_char_word_length];\n\
    \        while current_char_index < word_length {\n            let next_char =\
    \ sorted_string[current_char_index + 1];\n            if current_char == next_char\
    \ {\n                current_char_index += 1;\n            } else {\n        \
    \        break;\n            }\n            last_char_index = current_char_index;\n\
    \            current_char = sorted_string[current_char_index];\n        }\n  \
    \      temp_str += sorted_string[last_char_index];\n        sorted_string = sorted_string.replace(last_char_index,\
    \ current_char_index, \"\");\n        first_char_word_length += 1;\n    }\n  \
    \  while last_char_word_length < word_length {\n        last_char_index = current_char_index;\n\
    \        current_char = sorted_string[last_char_word_length];\n        while current_char_index\
    \ < word_length {\n            let next_char = sorted_string[current_char_index\
    \ + 1];\n            if current_char == next_char {\n                current_char_index\
    \ += 1;\n            } else {\n                break;\n            }\n       \
    \     last_char_index = current_char_index;\n            current_char = sorted_string[current_char_index];\n\
    \        }\n        temp_str += sorted_string[last_char_index];\n        sorted_string\
    \ = sorted_string.replace(last_char_index, current_char_index, \"\");\n      \
    \  last_char_word_length += 1;\n    }\n    temp_str + sorted_string\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7l5egeyb.rs:22:24\n\
    \   |\n22 |         current_char = sorted_string[current_char_index];\n   |  \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7l5egeyb.rs:24:29\n   |\n24 |             let next_char = sorted_string[current_char_index\
    \ + 1];\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7l5egeyb.rs:31:28\n   |\n31 |             current_char = sorted_string[current_char_index];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n    "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut words = s.split_whitespace();\n    let mut sorted_words\
    \ = words.clone();\n    sorted_words.sort();\n    sorted_words.sort_by_key(|x|\n\
    \        match x.as_bytes()[..] {\n            b\"a'\" => 1,\n            b\"\
    b\"  => 2,\n            b\"c\"  => 3,\n            b\"d'\" => 4,\n           \
    \ b\"e'\" => 5,\n            b\"f'\" => 6,\n            b\"g'\" => 7,\n      \
    \      b\"h'\" => 8,\n            b\"i'\" => 9,\n            b\"j'\" => 10,\n\
    \            b\"k'\" => 11,\n            b\"l'\" => 12,\n            b\"m'\" =>\
    \ 13,\n            b\"n'\" => 14,\n            b\"o'\" => 15,\n            b\"\
    p'\" => 16,\n            b\"q'\" => 17,\n            b\"r'\" => 18,\n        \
    \    b\"s'\" => 19,\n            b\"t'\" => 20,\n            b\"u'\" => 21,\n\
    \            b\"v'\" => 22,\n            b\"w'\" => 23,\n            b\"x'\" =>\
    \ 24,\n            b\"y'\" => 25,\n            b\"z'\" => 26,\n            _ =>\
    \ -1,\n        }\n    );\n    words.clear();\n    for (i, elem) in sorted_words.iter().enumerate()\
    \ {\n        words.push((elem[0] + elem[1] + elem[2] + elem[3] + elem[4]).to_string());\n\
    \    }\n    let mut result = String::new();\n    for word in words {\n       \
    \ result.push_str(&word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp6davyq3k.rs:14:18\n   |\n14 |     sorted_words.sort();\n\
    \   |                  ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for struct `SplitWhitespace` in the current\
    \ scope\n  --> /tmp/tmp6davyq3k.rs:15:18\n   |\n15 |     sorted_words.sort_by_key(|x|\n\
    \   |                  ^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `clear` found for struct `SplitWhitespace` in\
    \ the current scope\n  --> /tmp/tmp6davyq3k.rs:46:11\n   |\n46 |     words.clear();\n\
    \   |           ^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmp6davyq3k.rs:47:35\n   |\n47 |     for (i, elem) in sorted_words.iter().enumerate()\
    \ {\n   |                                   ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `push` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmp6davyq3k.rs:48:15\n   |\n48 |         words.push((elem[0]\
    \ + elem[1] + elem[2] + elem[3] + elem[4]).to_string());\n   |               ^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::new();\n    for i in s.chars().cloned().collect::<Vec<char>>()\
    \ {\n        if let Some(' ') = i {\n            res.push_str(&format!(\"{} \"\
    , i));\n        } else {\n            res.push_str(&format!(\"{}\", i));\n   \
    \     }\n    }\n    for i in s.chars().cloned().collect::<Vec<char>>() {\n   \
    \     if let Some(' ') = i {\n            res.push_str(&format!(\"{} \", i));\n\
    \        } else {\n            res.push_str(&format!(\"{}\", i));\n        }\n\
    \    }\n    res.chars().cloned().collect::<Vec<_>>().sort();\n    let mut i =\
    \ res.chars().cloned().collect::<Vec<_>>();\n    while i != res.chars().cloned().collect::<Vec<_>>()\
    \ {\n        if i.len() <= 2 {\n            i += res.chars().cloned().collect::<Vec<_>>();\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpds0s44k1.rs:12:24\n     |\n12   |     for i in s.chars().cloned().collect::<Vec<char>>()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpds0s44k1.rs:12:33\n   |\n12 |       for i in s.chars().cloned().collect::<Vec<char>>()\
    \ {\n   |                                   ^^^^^^^ method cannot be called on\
    \ `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0277]: `Option<char>` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmpds0s44k1.rs:14:42\n   |\n14 |             res.push_str(&format!(\"\
    {} \", i));\n   |                                          ^ `Option<char>` cannot\
    \ be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `Option<char>`\n   = note: in format strings you may\
    \ be able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error\
    \ originates in the macro `$crate::__export::format_args` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0277]: `Option<char>` doesn't\
    \ implement `std::fmt::Display`\n  --> /tmp/tmpds0s44k1.rs:16:41\n   |\n16 | \
    \            res.push_str(&format!(\"{}\", i));\n   |                        \
    \                 ^ `Option<char>` cannot be formatted with the default formatter\n\
    \   |\n   = help: the trait `std::fmt::Display` is not implemented for `Option<char>`\n\
    \   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error or"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // split into words by space\n    let words = s.chars().collect::<Vec<_>>();\n\
    \n    // replace each character with its ascii value\n    let new_s = words.iter().map(|c|\
    \ c.to_ascii()).collect::<Vec<_>>();\n\n    // convert back to String\n    new_s.iter().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_ascii` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpgtx8813t.rs:15:40\n   |\n15 |     let new_s\
    \ = words.iter().map(|c| c.to_ascii()).collect::<Vec<_>>();\n   |            \
    \                            ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // write your code here\n    let mut s = String::from(s);\n    \n    for\
    \ i in s.chars(){\n        let c = i;\n        let i = if c > 96 && c < 123 {\n\
    \            c - 96\n        } else {\n            c + 32\n        };\n      \
    \  s = s.replace(str::from_utf8(&s[0..i]).unwrap(), str::from_utf8(&s[(i+1..s.len())]).unwrap());\n\
    \    }\n    \n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgj8scek0.rs:16:24\n   |\n\
    16 |         let i = if c > 96 && c < 123 {\n   |                        ^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgj8scek0.rs:16:34\n\
    \   |\n16 |         let i = if c > 96 && c < 123 {\n   |                     \
    \             ^^^ expected `char`, found `u8`\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `char`\n  --> /tmp/tmpgj8scek0.rs:17:15\n   |\n17 |       \
    \      c - 96\n   |             - ^ -- {integer}\n   |             |\n   |   \
    \          char\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpgj8scek0.rs:19:15\n\
    \   |\n19 |             c + 32\n   |             - ^ -- {integer}\n   |      \
    \       |\n   |             char\n\nerror[E0599]: no function or associated item\
    \ named `from_utf8` found for type `str` in the current scope\n  --> /tmp/tmpgj8scek0.rs:21:28\n\
    \   |\n21 |         s = s.replace(str::from_utf8(&s[0..i]).unwrap(), str::from_utf8(&s[(i+1..s.len())]).unwrap());\n\
    \   |                            ^^^^^^^^^ function or associated item not found\
    \ in `str`\n   |\nhelp: you are looking for the module in `std`, not the primitive\
    \ type\n   |\n21 |         s = s.replace(std::str::from_utf8(&s[0..i]).unwrap(),\
    \ str::from_utf8(&s[(i+1..s.len())]).unwrap());\n   |                       ~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0599]: no function or associated item named `from_utf8` found for type\
    \ `str` in the current scope\n  --> /tmp/tmpgj8scek0.rs:21:63\n   |\n21 |    \
    \     s = s.replace(str::from_utf8(&s[0..i]).unwrap(), str::from_utf8(&s[(i+1..s.len())]).unwrap());\n\
    \   |                                                               ^^^^^^^^^\
    \ function or associated item not found in `str`\n   |\nhelp: you are looking\
    \ for the module in `std`, not the primitive type\n   |\n21 |         s = s.replace(str::from_utf8(&s[0..i]).unwrap(),\
    \ std::str::from_utf8(&s[(i+1..s.len())]).unwrap());\n   |                   \
    \                                       ~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308,"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut word = s.to_lowercase();\n    let mut order = vec![' ', ',', '.',\
    \ '?', '!', ';', ':', '!', '!'];\n    let mut res = Vec::new();\n    for c in\
    \ word.chars() {\n        if order.contains(&c) {\n            res.push_str(&order);\n\
    \        } else {\n            res.push_str(&c);\n            order.push(&c);\n\
    \        }\n    }\n    res.push_str(&order);\n    res.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push_str` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmpido41roa.rs:16:17\n   |\n16 |             res.push_str(&order);\n\
    \   |                 ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `push`\n\nerror[E0599]: no method named `push_str` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmpido41roa.rs:18:17\n   |\n18 |          \
    \   res.push_str(&c);\n   |                 ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `push`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpido41roa.rs:19:24\n   |\n19 |             order.push(&c);\n   |    \
    \                    ^^ expected `char`, found `&char`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n19 -             order.push(&c);\n19 +             order.push(c);\n\
    \   | \n\nerror[E0599]: no method named `push_str` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmpido41roa.rs:22:9\n   |\n22 |     res.push_str(&order);\n\
    \   |         ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpido41roa.rs:23:5\n \
    \  |\n10 | fn anti_shuffle(s: String) -> String {\n   |                      \
    \         ------ expected `String` because of return type\n...\n23 |     res.to_owned()\n\
    \   |     ^^^^^^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n\
    \   = note: expected struct `String`\n              found struct `Vec<_>`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut string_to_be_replaced = s.to_string();\n    let mut ordered_string_to_be_replaced\
    \ = String::new();\n\n    for word in string_to_be_replaced.split_whitespace()\
    \ {\n        ordered_string_to_be_replaced.push_str(\" \");\n        let mut temp_word:\
    \ String = word.to_string();\n        let mut ascii_code = 0;\n        let mut\
    \ ascii_code_next = 0;\n\n        for character in temp_word.chars().cloned()\
    \ {\n            ascii_code = ascii_code + character.chars().count();\n      \
    \      ascii_code_next = ascii_code + 1;\n            ordered_string_to_be_replaced.push_str(&(ascii_code_next).to_string());\n\
    \        }\n\n        if let Ok(last) = ordered_string_to_be_replaced.split_last()\
    \ {\n            ordered_string_to_be_replaced.push_str(&last.0);\n        }\n\
    \    }\n    ordered_string_to_be_replaced\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpg19t7ixh.rs:20:44\n     |\n20   |         for character\
    \ in temp_word.chars().cloned() {\n     |                                    \
    \        ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpg19t7ixh.rs:20:26\n   |\n20 |         for character in\
    \ temp_word.chars().cloned() {\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpg19t7ixh.rs:20:26\n   |\n20 |         for character in temp_word.chars().cloned()\
    \ {\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0599]: no method named `split_last` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpg19t7ixh.rs:26:57\n\
    \   |\n26 |         if let Ok(last) = ordered_string_to_be_replaced.split_last()\
    \ {\n   |                                                         ^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `split`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut w = s.chars();\n    w.sort_by(|a, b| b.cmp(&a));\n\
    \    w = w.collect();\n    let mut a = w.len();\n    while a > 0 {\n        s\
    \ += w[a - 1].to_string();\n        a--;\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmplnerecv8.rs:18:12\n\
    \   |\n18 |         a--;\n   |            ^ expected expression\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmplnerecv8.rs:13:7\n   |\n13 |     w.sort_by(|a, b| b.cmp(&a));\n   |\
    \       ^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `len` found for struct `Chars` in the current scope\n  --> /tmp/tmplnerecv8.rs:15:19\n\
    \   |\n15 |     let mut a = w.len();\n   |                   ^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0277]: a value of type `Chars<'_>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmplnerecv8.rs:14:11\n\
    \     |\n14   |     w = w.collect();\n     |           ^^^^^^^ value of type `Chars<'_>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Chars<'_>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmplnerecv8.rs:17:14\n   |\n17 |         s += w[a - 1].to_string();\n\
    \   |              ^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words: Vec<String> = s.chars().collect();\n    words.sort_unstable();\n\
    \    let mut new_word = \"\";\n    let mut index = 0;\n    while index < words.len()\
    \ {\n        if index == 0 {\n            new_word += &words[index];\n       \
    \ }\n        else {\n            new_word += &words[index][1..];\n        }\n\
    \        index += 1;\n    }\n    new_word\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmppcn597tu.rs:11:44\n     |\n11\
    \   |     let mut words: Vec<String> = s.chars().collect();\n     |          \
    \                                  ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmppcn597tu.rs:17:13\n   |\n17 |             new_word\
    \ += &words[index];\n   |             --------^^^^^^^^^^^^^^^^^\n   |        \
    \     |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmppcn597tu.rs:20:13\n\
    \   |\n20 |             new_word += &words[index][1..];\n   |             --------^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppcn597tu.rs:24:5\n   |\n10 | fn anti_shuffle(s:\
    \ String) -> String {\n   |                               ------ expected `String`\
    \ because of return type\n...\n24 |     new_word\n   |     ^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |     |\n   |     expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .filter_map(|c| match c {\n            ' ' => '_',\n \
    \           'a' => a,\n            'e' => a,\n            'i' => a,\n        \
    \    'o' => a,\n            'u' => a,\n            'y' => y,\n            'A'\
    \ => y,\n            'E' => y,\n            'I' => y,\n            'O' => y,\n\
    \            'U' => y,\n            'Y' => y,\n            _ => c,\n        })\n\
    \        .collect::<String>()\n        .into_iter()\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmparcjfzxm.rs:14:20\n\
    \   |\n14 |             'a' => a,\n   |                    ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0425]: cannot find value `a` in this\
    \ scope\n  --> /tmp/tmparcjfzxm.rs:15:20\n   |\n15 |             'e' => a,\n \
    \  |                    ^ help: a local variable with a similar name exists: `c`\n\
    \nerror[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmparcjfzxm.rs:16:20\n\
    \   |\n16 |             'i' => a,\n   |                    ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0425]: cannot find value `a` in this\
    \ scope\n  --> /tmp/tmparcjfzxm.rs:17:20\n   |\n17 |             'o' => a,\n \
    \  |                    ^ help: a local variable with a similar name exists: `c`\n\
    \nerror[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmparcjfzxm.rs:18:20\n\
    \   |\n18 |             'u' => a,\n   |                    ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0425]: cannot find value `y` in this\
    \ scope\n  --> /tmp/tmparcjfzxm.rs:19:20\n   |\n19 |             'y' => y,\n \
    \  |                    ^ help: a local variable with a similar name exists: `c`\n\
    \nerror[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmparcjfzxm.rs:20:20\n\
    \   |\n20 |             'A' => y,\n   |                    ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0425]: cannot find value `y` in this\
    \ scope\n  --> /tmp/tmparcjfzxm.rs:21:20\n   |\n21 |             'E' => y,\n \
    \  |                    ^ help: a local variable with a similar name exists: `c`\n\
    \nerror[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmparcjfzxm.rs:22:20\n\
    \   |\n22 |             'I' => y,\n   |                    ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0425]: cannot find value `y` in this\
    \ scope\n  --> /tmp/tmparcjfzxm.rs:23:20\n   |\n23 |             'O' => y,\n \
    \  |                    ^ help: a local variable with a similar name exists: `c`\n\
    \nerror[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmparcjfzxm.rs:24:20\n\
    \   |\n2"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write code here\n    let mut words = s.split_whitespace();\n    words.sort_by_key(|x|\
    \ x.to_ascii_lowercase());\n    let mut result: String = s.clone();\n    for (i,\
    \ word) in words.iter().enumerate() {\n        if i > 0 {\n            let start\
    \ = i - 1;\n            let end = i;\n            result.push_str(&word);\n  \
    \          result.push_str(&s[start..end]);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp28wfudc3.rs:13:11\n   |\n13 |     words.sort_by_key(|x|\
    \ x.to_ascii_lowercase());\n   |           ^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `iter` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmp28wfudc3.rs:15:28\n   |\n15 |     for (i, word)\
    \ in words.iter().enumerate() {\n   |                            ^^^^ method not\
    \ found in `SplitWhitespace<'_>`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmp28wfudc3.rs:15:13\n\
    \   |\n15 |     for (i, word) in words.iter().enumerate() {\n   |            \
    \ ^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp28wfudc3.rs:15:22\n    |\n15  |     for (i, word) in words.iter().enumerate()\
    \ {\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n    |\n    = help: within `(_, str)`, the trait `Sized` is\
    \ not implemented for `str`\n    = note: required because it appears within the\
    \ type `(_, str)`\nnote: required by a bound in `Option`\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmp28wfudc3.rs:15:5\n\
    \    |\n15  | /     for (i, word) in words.iter().enumerate() {\n16  | |     \
    \    if i > 0 {\n17  | |             let start = i - 1;\n18  | |             let\
    \ end = i;\n...   |\n21  | |         }\n22  | |     }\n    | |_____^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: within `(_, str)`, the trait\
    \ `Sized` is not implemented for `str`\n    = note: required because it appears\
    \ within the type `(_, str)`\nnote: required by a bound in `None`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explan"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().enumerate().filter(|(idx, _)| idx > 0 && s[idx] == ' ').fold(s,\
    \ |mut s, (_, idx)| {\n        s.push(char::to_ascii_lowercase(idx));\n      \
    \  &mut s\n    })\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg6nidkd4.rs:11:51\n   |\n\
    11 |     s.chars().enumerate().filter(|(idx, _)| idx > 0 && s[idx] == ' ').fold(s,\
    \ |mut s, (_, idx)| {\n   |                                                  \
    \ ^\n   |                                                   |\n   |          \
    \                                         expected `&usize`, found integer\n \
    \  |                                                   help: consider borrowing\
    \ here: `&0`\n\nerror[E0277]: the type `String` cannot be indexed by `&usize`\n\
    \  --> /tmp/tmpg6nidkd4.rs:11:56\n   |\n11 |     s.chars().enumerate().filter(|(idx,\
    \ _)| idx > 0 && s[idx] == ' ').fold(s, |mut s, (_, idx)| {\n   |            \
    \                                            ^^^^^^ `String` cannot be indexed\
    \ by `&usize`\n   |\n   = help: the trait `Index<&usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg6nidkd4.rs:12:41\n\
    \   |\n12 |         s.push(char::to_ascii_lowercase(idx));\n   |             \
    \                            ^^^\n   |                                       \
    \  |\n   |                                         expected `&char`, found `char`\n\
    \   |                                         help: consider borrowing here: `&idx`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg6nidkd4.rs:13:9\n   |\n13 | \
    \        &mut s\n   |         ^^^^^^ expected struct `String`, found `&mut String`\n\
    \   |\nhelp: consider removing the borrow\n   |\n13 -         &mut s\n13 +   \
    \      s\n   | \n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s.chars();\n    let mut w: Vec<&str> = vec![];\n\n    for ch\
    \ in s {\n        if ch != ' ' {\n            w.push(&ch.to_string());\n     \
    \   }\n    }\n\n    let mut new_string = \"\";\n\n    for ch in w {\n        new_string\
    \ = new_string.chars().collect();\n        new_string.push(&*ch.to_string());\n\
    \    }\n\n    new_string.pop();\n    new_string.sort_unstable();\n    new_string.to_owned()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpz1t_1j27.rs:24:20\n   |\n24 |         new_string.push(&*ch.to_string());\n\
    \   |                    ^^^^ method not found in `&str`\n\nerror[E0277]: a value\
    \ of type `&str` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpz1t_1j27.rs:23:41\n     |\n23   |         new_string = new_string.chars().collect();\n\
    \     |                                         ^^^^^^^ value of type `&str` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `&str`\n     = help: the following\
    \ other types implement trait `FromIterator<A>`:\n               <String as FromIterator<&'a\
    \ char>>\n               <String as FromIterator<&'a str>>\n               <String\
    \ as FromIterator<Box<str>>>\n               <String as FromIterator<Cow<'a, str>>>\n\
    \               <String as FromIterator<String>>\n               <String as FromIterator<char>>\n\
    note: required by a bound in `collect`\n\nerror[E0599]: no method named `pop`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpz1t_1j27.rs:27:16\n\
    \   |\n27 |     new_string.pop();\n   |                ^^^ method not found in\
    \ `&str`\n\nerror[E0599]: no method named `sort_unstable` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpz1t_1j27.rs:28:16\n   |\n28 |   \
    \  new_string.sort_unstable();\n   |                ^^^^^^^^^^^^^ method not found\
    \ in `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    let mut new_s = String::with_capacity(s.len());\n\
    \    let mut map = HashMap::new();\n    for word in words {\n        map.insert(word.to_ascii_lowercase(),\
    \ word);\n    }\n    for e in map.iter() {\n        new_s.push_str(e.get());\n\
    \    }\n    return new_s;\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphdkz6601.rs:13:19\n   |\n13 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut ordered_s = s.chars().fold(String::new(), |s, c| {\n        match\
    \ c {\n            ' ' => s.push_str(\"\".to_string()),\n            '\\n' =>\
    \ s.push_str(\"\".to_string()),\n            _ => {\n                let a = s.len();\n\
    \                let b = s.chars().skip(a).fold(String::new(), |s, c| {\n    \
    \                match c {\n                        ' ' => s.push_str(\"_\".to_string()),\n\
    \                        '\\n' => s.push_str(\"_\".to_string()),\n           \
    \             _ => s.push_str(&c.to_string()),\n                    }\n      \
    \          });\n                s.push_str(&b[..a])\n            }\n        }\n\
    \    });\n    let mut words = ordered_s.split_whitespace();\n    let mut last_char\
    \ = String::new();\n    for (i, word) in words.iter().enumerate() {\n        let\
    \ mut new_word = String::new();\n        last_char = String::new();\n        for\
    \ c in word.chars() {\n            if c == ' ' {\n                new_word.push_str(last_char);\n\
    \                new_word.push_str(&c.to_string());\n            } else {\n  \
    \              new_word.push_str(&c.to_string());\n            }\n           \
    \ last_char = c\n        }\n        words[i] = new_word;\n    }\n    ordered_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2c4_0cwx.rs:13:31\n   |\n\
    13 |             ' ' => s.push_str(\"\".to_string()),\n   |                  \
    \             ^^^^^^^^^^^^^^\n   |                               |\n   |     \
    \                          expected `&str`, found struct `String`\n   |      \
    \                         help: consider borrowing here: `&\"\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2c4_0cwx.rs:13:20\n   |\n13 |\
    \             ' ' => s.push_str(\"\".to_string()),\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmp2c4_0cwx.rs:13:22\n   |\n13 |         \
    \    ' ' => s.push_str(\"\".to_string()),\n   |                    - ^^^^^^^^\
    \ this call modifies `s` in-place\n   |                    |\n   |           \
    \         you probably want to use this value after calling the method...\n  \
    \ = note: ...instead of the `()` output of method `push_str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2c4_0cwx.rs:14:32\n   |\n14 |             '\\\
    n' => s.push_str(\"\".to_string()),\n   |                                ^^^^^^^^^^^^^^\n\
    \   |                                |\n   |                                expected\
    \ `&str`, found struct `String`\n   |                                help: consider\
    \ borrowing here: `&\"\".to_string()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2c4_0cwx.rs:19:43\n   |\n19 |                         ' ' => s.push_str(\"\
    _\".to_string()),\n   |                                           ^^^^^^^^^^^^^^^\n\
    \   |                                           |\n   |                      \
    \                     expected `&str`, found struct `String`\n   |           \
    \                                help: consider borrowing here: `&\"_\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2c4_0cwx.rs:19:32\n   |\n19 |\
    \                         ' ' => s.push_str(\"_\".to_string()),\n   |        \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its recei"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut new_s = String::with_capacity(s.len() * 2);\n    let mut new_s_len\
    \ = String::with_capacity(s.len() * 2);\n    for c in s.chars() {\n        let\
    \ char_code = c.code();\n        match char_code {\n            char_code::A ...\
    \ char_code::z => {\n                let new_char = c.into();\n              \
    \  new_s.push_str(&new_char);\n                new_s_len.push_str(&new_char.len());\n\
    \            }\n            _ => {\n                new_s.push_str(&c.to_string());\n\
    \                new_s_len.push_str(&c.len());\n            }\n        }\n   \
    \ }\n    new_s.push_str(&new_s_len);\n    new_s_len.push_str(&new_s.len());\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `char_code`\n\
    \  --> /tmp/tmp895mz44i.rs:16:13\n   |\n16 |             char_code::A ... char_code::z\
    \ => {\n   |             ^^^^^^^^^ use of undeclared crate or module `char_code`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `char_code`\n\
    \  --> /tmp/tmp895mz44i.rs:16:30\n   |\n16 |             char_code::A ... char_code::z\
    \ => {\n   |                              ^^^^^^^^^ use of undeclared crate or\
    \ module `char_code`\n\nwarning: `...` range patterns are deprecated\n  --> /tmp/tmp895mz44i.rs:16:26\n\
    \   |\n16 |             char_code::A ... char_code::z => {\n   |             \
    \             ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0599]: no method named `code` found for type `char` in the current scope\n\
    \  --> /tmp/tmp895mz44i.rs:14:27\n   |\n14 |         let char_code = c.code();\n\
    \   |                           ^^^^ method not found in `char`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp895mz44i.rs:17:21\n   |\n17 |                 let new_char = c.into();\n\
    \   |                     ^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the trait bound `str: From<char>`\
    \ is not satisfied\n  --> /tmp/tmp895mz44i.rs:17:34\n   |\n17 |              \
    \   let new_char = c.into();\n   |                                  ^^^^ the trait\
    \ `From<char>` is not implemented for `str`\n   |\n   = help: the following other\
    \ types implement trait `From<T>`:\n             <String as From<&String>>\n \
    \            <String as From<&mut"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    str.split_whitespace()\n        .into_iter()\n        .map(|s| s.to_ascii_lowercase())\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|a, b| b.cmp(a))\n        .iter()\n\
    \        .map(|s| s.to_ascii_lowercase())\n        .collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `str`\n  --> /tmp/tmpz0tsdc_c.rs:11:5\n\
    \   |\n11 |     str.split_whitespace()\n   |     ^^^ not a value\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = String::from(\"_\");\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < s.len() {\n        j = j + 1;\n        while j < s.len() {\n  \
    \          s.insert(i, s[j].chars().min().unwrap());\n            j = j + 1;\n\
    \        }\n        i = i + 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuusyn46n.rs:17:25\n\
    \   |\n17 |             s.insert(i, s[j].chars().min().unwrap());\n   |      \
    \                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        let ascii_code\
    \ = c.as_bytes().iter().map(|b| b as u8).collect::<Vec<_>>().max().unwrap();\n\
    \        let c = if ascii_code < 32 { c.to_ascii_lowercase().to_string() } else\
    \ { c.to_string() };\n        result.push(c);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprvyfpckb.rs:13:28\n   |\n13 |         let ascii_code =\
    \ c.as_bytes().iter().map(|b| b as u8).collect::<Vec<_>>().max().unwrap();\n \
    \  |                            ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprvyfpckb.rs:15:21\n   |\n15 |         result.push(c);\n\
    \   |                     ^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result = String::new();\n\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if i > 0 {\n            result.push(c);\n        }\n\n        if\
    \ i > 0 && c == ' ' {\n            result.push(c);\n        }\n\n        if i\
    \ == s.len() - 1 && c == ' ' {\n            result.push(c);\n        }\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"Hi\"`', /tmp/tmp8xe6hcys.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::from(\"_\");\n    for c in s.chars() {\n        res.push_str(&(c.to_ascii_lowercase()));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4pi1cf44.rs:13:22\n   |\n\
    13 |         res.push_str(&(c.to_ascii_lowercase()));\n   |                  \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = String::from(\"anti_shuffle(\");\n    for word in s.split_whitespace().filter(|&word|\
    \ !word.is_empty()) {\n        let mut new_word = String::from(word);\n      \
    \  for c in new_word {\n            s.push_str(&c.to_ascii_lowercase());\n   \
    \     }\n        s.push(' ');\n    }\n    s.push(')');\n    s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpvyb2nms0.rs:14:18\n\
    \   |\n14 |         for c in new_word {\n   |                  ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::from(s);\n    for w in s.split(' ').collect::<Vec<String>>()\
    \ {\n        res.insert(\n            0..length(),\n            w.chars()\n  \
    \              .map(|c| c as char).collect::<Vec<char>>()\n                .iter()\n\
    \                .cloned()\n                .chain(Vec::new())\n             \
    \   .collect::<Vec<char>>(),\n        );\n        res.insert(\n            0..length(),\n\
    \            w.chars()\n                .filter(|c| c.is_alphabetic())\n     \
    \           .cloned()\n                .chain(Vec::new())\n                .collect::<Vec<char>>(),\n\
    \        );\n        res.insert(\n            0..length(),\n            w.chars()\n\
    \                .filter(|c| !c.is_alphabetic())\n                .cloned()\n\
    \                .chain(Vec::new())\n                .collect::<Vec<char>>(),\n\
    \        );\n        res.insert(\n            0..length(),\n            w.chars()\n\
    \                .filter(|c| !c.is_alphabetic())\n                .filter(|c|\
    \ !c.is_numeric())\n                .cloned()\n                .chain(Vec::new())\n\
    \                .collect::<Vec<char>>(),\n        );\n        res.insert(\n \
    \           0..length(),\n            w.chars()\n                .filter(|c| !c.is_alphabetic())\n\
    \                .filter(|c| !c.is_numeric())\n                .filter(|c| !c.is_space())\n\
    \                .filter(|c| !c.is_punct())\n                .cloned()\n     \
    \           .chain(Vec::new())\n                .collect::<Vec<char>>(),\n   \
    \     );\n        res.insert(\n            0..length(),\n            w.chars()\n\
    \                .filter(|c| !c.is_alphabetic())\n                .filter(|c|\
    \ !c.is_numeric())\n                .filter(|c| !c.is_space())\n             \
    \   .filter(|c| !c.is_punct())\n                .filter(|c| !c.is_alnum())\n \
    \               .cloned()\n                .chain(Vec::new())\n              \
    \  .collect::<Vec<char>>(),\n        );\n        res.insert(\n            0..length(),\n\
    \            w.chars()\n                .filter(|c| !c.is_alphabetic())\n    \
    \            .filter(|c| !c.is_numeric())\n                .filter(|c| !c.is_space())\n\
    \                .filter(|c| !c.is_punct())\n                .filter(|c| !c.is_alnum())\n\
    \                .filter(|c| c.is_digit())\n                .filter(|c| c.is_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp39qan_qg.rs:91:3\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n11 |     let mut res = String::from(s);\n\
    12 |     for w in s.split(' ').collect::<Vec<String>>() {\n   |              \
    \                                      - this delimiter might not be properly\
    \ closed...\n...\n80 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n91 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp39qan_qg.rs:79:24\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n79 |     \
    \            .filter(|c| c.is_\n   |                        ^ unclosed delimiter\n\
    80 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find function\
    \ `length` in this scope\n  --> /tmp/tmp39qan_qg.rs:14:16\n   |\n14 |        \
    \     0..length(),\n   |                ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `length` in this scope\n  --> /tmp/tmp39qan_qg.rs:23:16\n\
    \   |\n23 |             0..length(),\n   |                ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `length` in this scope\n  -->\
    \ /tmp/tmp39qan_qg.rs:31:16\n   |\n31 |             0..length(),\n   |       \
    \         ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `length` in this scope\n  --> /tmp/tmp39qan_qg.rs:39:16\n   |\n39 |        \
    \     0..length(),\n   |                ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `length` in this scope\n  --> /tmp/tmp39qan_qg.rs:48:16\n\
    \   |\n48 |             0..length(),\n   |                ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `length` in this scope\n  -->\
    \ /tmp/tmp39qan_qg.rs:59:16\n   |\n59 |             0..length(),\n   |       \
    \         ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `length` in this scope\n  --> /tmp/tmp39qan_qg.rs:71:16\n   |\n71 |        \
    \     0..length(),\n   |                ^^^^^^ no"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::new();\n    let mut order = [String::new(), String::new(),\
    \ String::new()];\n    let mut spaces = [String::new(), String::new(), String::new()];\n\
    \n    for letter in s.chars() {\n        match letter {\n            ' ' => {\n\
    \                spaces[0] += letter;\n            }\n            '\\n' => {\n\
    \                order[0] = letter;\n            }\n            ' ' => spaces[1]\
    \ += letter,\n            '\\n' => order[1] = letter,\n            _ => order[2]\
    \ += letter,\n        }\n    }\n    order = order.iter().enumerate().collect();\n\
    \n    for n in 0..order.len() {\n        res += spaces[n % 3];\n        res +=\
    \ order[n];\n        res += spaces[(n + 1) % 3];\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx29_2tot.rs:18:30\n   |\n\
    18 |                 spaces[0] += letter;\n   |                              ^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx29_2tot.rs:21:28\n\
    \   |\n21 |                 order[0] = letter;\n   |                 --------\
    \   ^^^^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \         |          |\n   |                 |          expected struct `String`,\
    \ found `char`\n   |                 expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx29_2tot.rs:23:33\n   |\n23 |\
    \             ' ' => spaces[1] += letter,\n   |                              \
    \   ^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpx29_2tot.rs:24:32\n   |\n24 |             '\\n' => order[1] = letter,\n\
    \   |                     --------   ^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                     |          |\n   |                \
    \     |          expected struct `String`, found `char`\n   |                \
    \     expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx29_2tot.rs:25:30\n   |\n25 |             _ => order[2] += letter,\n\
    \   |                              ^^^^^^ expected `&str`, found `char`\n\nerror[E0277]:\
    \ a value of type `[String; 3]` cannot be built from an iterator over elements\
    \ of type `(usize, &String)`\n    --> /tmp/tmpx29_2tot.rs:28:38\n     |\n28  \
    \ |     order = order.iter().enumerate().collect();\n     |                  \
    \                    ^^^^^^^ value of type `[String; 3]` cannot be built from\
    \ `std::iter::Iterator<Item=(usize, &String)>`\n     |\n     = help: the trait\
    \ `FromIterator<(usize, &String)>` is not implemented for `[String; 3]`\nnote:\
    \ required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx29_2tot.rs:31:16\n\
    \   |\n31 |         res += spaces[n % 3];\n   |                ^^^^^^^^^^^^^\n\
    \   |                |\n   |                expected `&str`, found struct `String`\n\
    \   |                he"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result = String::new();\n    for i in s.chars().cloned() {\n    \
    \    let c = i.to_ascii_lowercase();\n        if !c.is_alphanumeric() {\n    \
    \        result += c;\n        } else {\n            if c.len() > 2 {\n      \
    \          result += &format!(\"{}{}\", c, c.to_ascii_lowercase()[1..]);\n   \
    \         } else {\n                result += \"_\";\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpg19nrewx.rs:12:24\n     |\n12   |     for i in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpg19nrewx.rs:12:14\n\
    \   |\n12 |     for i in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpg19nrewx.rs:12:14\n   |\n12 |     for i in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    s.iter().for_each(|&x| {\n        if x.is_whitespace()\
    \ {\n            s = s.to_string();\n        }\n        assert!(x.is_ascii_lower());\n\
    \        let mut x = x.to_string();\n        x.set_ascii_order(x.ascii_order()\
    \ - 1);\n        s.push(&x);\n    });\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp299msbqv.rs:12:7\n   |\n12 |     s.iter().for_each(|&x|\
    \ {\n   |       ^^^^ method not found in `String`\n   |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n   |\n12 |     s.chars().for_each(|&x| {\n   |\
    \       ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    match s.chars().fold(\"\".to_string(), |mut acc, c| {\n        if !acc.is_empty()\
    \ {\n            acc.push_ascii_lowercase();\n        }\n        acc.push_ascii_lowercase();\n\
    \        acc.push(c);\n        acc\n    });\n    match s.chars().fold(\"\".to_string(),\
    \ |mut acc, c| {\n        if !acc.is_empty() {\n            acc.push_ascii_uppercase();\n\
    \        }\n        acc.push_ascii_uppercase();\n        acc.push(c);\n      \
    \  acc\n    });\n    s.to_string()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `?`, `{`, or an operator, found `;`\n  -->\
    \ /tmp/tmpyg038twt.rs:18:7\n   |\n11 |     match s.chars().fold(\"\".to_string(),\
    \ |mut acc, c| {\n   |     -----\n   |     |\n   |     while parsing this `match`\
    \ expression\n   |     help: try removing this `match`\n...\n18 |     });\n  \
    \ |       ^ expected one of `.`, `?`, `{`, or an operator\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut chars = s.chars();\n    let mut new_s = String::new();\n    new_s.push_str(\"\
    \");\n    let mut word = \"\";\n    while let Some(item) = chars.next() {\n  \
    \      if item == ' ' || item == '\\t' {\n            new_s.push_str(word);\n\
    \            word = \"\";\n        } else {\n            let ascii = chars.get_mut().unwrap().unwrap().to_ascii_uppercase();\n\
    \            let mut char_ascii = chars.get_mut().unwrap().unwrap().to_ascii_lowercase();\n\
    \            if char_ascii < ascii {\n                char_ascii += 1;\n     \
    \           chars.set_mut(&char_ascii);\n            } else {\n              \
    \  word += chars.get_mut().unwrap().unwrap().to_ascii_lowercase();\n         \
    \       chars.set_mut(&ascii);\n            }\n        }\n    }\n    new_s.push_str(word)\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `get_mut` found for struct `Chars` in the\
    \ current scope\n   --> /tmp/tmp7_qkjoi2.rs:20:31\n    |\n20  |             let\
    \ ascii = chars.get_mut().unwrap().unwrap().to_ascii_uppercase();\n    |     \
    \                          ^^^^^^^ method not found in `Chars<'_>`\n    |\nhelp:\
    \ consider wrapping the receiver expression with the appropriate type\n    |\n\
    20  |             let ascii = Pin::new(&mut chars).get_mut().unwrap().unwrap().to_ascii_uppercase();\n\
    \    |                         +++++++++++++      +\n\nerror[E0599]: no method\
    \ named `get_mut` found for struct `Chars` in the current scope\n   --> /tmp/tmp7_qkjoi2.rs:21:40\n\
    \    |\n21  |             let mut char_ascii = chars.get_mut().unwrap().unwrap().to_ascii_lowercase();\n\
    \    |                                        ^^^^^^^ method not found in `Chars<'_>`\n\
    \    |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n21  |             let mut char_ascii = Pin::new(&mut chars).get_mut().unwrap().unwrap().to_ascii_lowercase();\n\
    \    |                                  +++++++++++++      +\n\nerror[E0599]:\
    \ no method named `set_mut` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmp7_qkjoi2.rs:24:23\n   |\n24 |                 chars.set_mut(&char_ascii);\n\
    \   |                       ^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `get_mut` found for struct `Chars` in the current scope\n  \
    \ --> /tmp/tmp7_qkjoi2.rs:26:31\n    |\n26  |                 word += chars.get_mut().unwrap().unwrap().to_ascii_lowercase();\n\
    \    |                               ^^^^^^^ method not found in `Chars<'_>`\n\
    \    |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n26  |                 word += Pin::new(&mut chars).get_mut().unwrap().unwrap().to_ascii_lowercase();\n\
    \    |                         +++++++++++++      +\n\nerror[E0599]: no method\
    \ named `set_mut` found for struct `Chars` in the current scope\n  --> /tmp/tmp7_qkjoi2.rs:27:23\n\
    \   |\n27 |                 chars.set_mut(&ascii);\n   |                     \
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::with_capacity(s.len());\n    let mut i = 0;\n    for\
    \ c in s.chars() {\n        if c == '_' || c == ' ' {\n            res.push_str(&s[i\
    \ .. (i + c.len())]);\n            res.push(c);\n            i += c.len();\n \
    \       } else {\n            res.push(c);\n            i += 1;\n        }\n \
    \   }\n    res.push_str(&s[i ..]);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp95twg_k6.rs:15:41\n   |\n15 |             res.push_str(&s[i\
    \ .. (i + c.len())]);\n   |                                         ^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `len` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp95twg_k6.rs:17:20\n   |\n17 |          \
    \   i += c.len();\n   |                    ^^^ method not found in `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut buf = String::new();\n    let mut i = 0;\n  \
    \  loop {\n        if buf.len() == 0 {\n            if i < s.len() {\n       \
    \         buf += &s[i..i];\n                i += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        let c = s.chars().nth(i);\n\
    \        let b = buf.chars().nth(i) as char;\n        if c < b {\n           \
    \ buf += &s[i - 1..i];\n            i += 1;\n        } else {\n            buf\
    \ += &s[i..i + 1];\n            i += 1;\n        }\n    }\n    buf\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8aorfizh.rs:25:16\n   |\n\
    25 |         if c < b {\n   |                ^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    help: try wrapping the expression in `Some`\n   |\n25 |         if c < Some(b)\
    \ {\n   |                +++++ +\n\nerror[E0605]: non-primitive cast: `Option<char>`\
    \ as `char`\n  --> /tmp/tmp8aorfizh.rs:24:17\n   |\n24 |         let b = buf.chars().nth(i)\
    \ as char;\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression\
    \ can only be used to convert between primitive types or to coerce to a specific\
    \ trait object\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0605.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut result = String::new();\n    let mut alphabet = [1u8; 256];\n   \
    \ for c in s.chars() {\n        alphabet[c as usize] = alphabet[c as usize] -\
    \ 1;\n    }\n    for c in s.chars() {\n        if alphabet[c as usize] == -1 {\n\
    \            result.push(c);\n        } else {\n            result.push(c + alphabet[c\
    \ as usize]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `u8`\n  --> /tmp/tmpjnq00r3i.rs:17:36\n\
    \   |\n17 |         if alphabet[c as usize] == -1 {\n   |                    \
    \                ^^\n   |                                    |\n   |         \
    \                           cannot apply unary operator `-`\n   |            \
    \                        help: you may have meant the maximum value of `u8`: `u8::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0369]: cannot add\
    \ `u8` to `char`\n  --> /tmp/tmpjnq00r3i.rs:20:27\n   |\n20 |             result.push(c\
    \ + alphabet[c as usize]);\n   |                         - ^ --------------------\
    \ u8\n   |                         |\n   |                         char\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0600.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::new();\n    for word in s.split(\" \") {\n        res\
    \ += *word.chars().sort(|a, b| a.cmp(&b)).collect::<String>().to_string();\n \
    \       res += \" \";\n    }\n    res.trim_end();\n    return res\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpmfp7rp05.rs:13:30\n   |\n13 |         res += *word.chars().sort(|a,\
    \ b| a.cmp(&b)).collect::<String>().to_string();\n   |                       \
    \       ^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::with_capacity(s.len());\n    let mut w = s.split_whitespace();\n\
    \    for (i, c) in w.iter().enumerate() {\n        match c {\n            'a'\
    \ => {\n                let r = w.next_back().unwrap().to_ascii_lowercase();\n\
    \                res.push_str(&r);\n            }\n            'e' => {\n    \
    \            let r = w.next_back().unwrap().to_ascii_uppercase();\n          \
    \      res.push_str(&r);\n            }\n            'i' => {\n              \
    \  let r = w.next_back().unwrap().to_ascii_lowercase();\n                res.push_str(&r);\n\
    \            }\n            'o' => {\n                let r = w.next_back().unwrap().to_ascii_uppercase();\n\
    \                res.push_str(&r);\n            }\n            ' ' => res.push_str(&c.to_string()),\n\
    \            _ => res.push_str(&c),\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpxl0sfq0y.rs:13:21\n   |\n13 |     for (i,\
    \ c) in w.iter().enumerate() {\n   |                     ^^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxl0sfq0y.rs:32:31\n\
    \   |\n32 |             _ => res.push_str(&c),\n   |                         \
    \      ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::new();\n    for i in s.split_whitespace() {\n     \
    \   if !i.remove() {\n            res.push(i);\n        }\n    }\n    return res;\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `remove` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp862fjt6l.rs:13:15\n   |\n13 |         if !i.remove()\
    \ {\n   |               ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp862fjt6l.rs:14:22\n   |\n14 |             res.push(i);\n\
    \   |                      ^ expected `char`, found `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s.to_string();\n    let mut res = \"\";\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let j = s.len();\n        while i +1 != j {\n\
    \            if s[i] == s[j] {\n                res += &s[i +1 ..];\n        \
    \        i += 1;\n            } else {\n                j -= 1;\n            }\n\
    \        }\n        res += &s[i];\n        i += 1;\n    }\n    res.to_string()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpci_1qbdu.rs:17:16\n\
    \   |\n17 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpci_1qbdu.rs:17:24\n   |\n17 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpci_1qbdu.rs:18:17\n\
    \   |\n18 |                 res += &s[i +1 ..];\n   |                 ---^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpci_1qbdu.rs:24:17\n\
    \   |\n24 |         res += &s[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \    "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    // Write your function here.\n    // Print the original sentence\n    println!(\"\
    {:?}\", s);\n    let mut new_s = String::new();\n    let mut index = 0;\n    let\
    \ mut char_value = 0;\n    let mut word_value: String = \"hello\".to_string();\n\
    \    for i in s.chars().filter(|&c| c == ' ') {\n        if index == 0 {\n   \
    \         char_value += 1;\n        } else {\n            char_value += 2;\n \
    \       }\n        new_s.append(word_value[char_value]);\n        index += 1;\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpt1jv9emp.rs:24:15\n   |\n24 |         new_s.append(word_value[char_value]);\n\
    \   |               ^^^^^^ method not found in `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpt1jv9emp.rs:24:22\n\
    \   |\n24 |         new_s.append(word_value[char_value]);\n   |              \
    \        ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n  \
    \ |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut re = Regex::new(\"\\\\s\").unwrap();\n    re.captures_iter(&s).for_each(|c|\
    \ c.as_str().sort_by(|a, b| a.cmp(b)));\n    re.captures(&s).unwrap().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpyettjc7p.rs:11:18\n   |\n11 |     let mut re = Regex::new(\"\\\\s\"\
    ).unwrap();\n   |                  ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = String::from(s);\n    s.sort_by(|a,b| a.to_ascii_lowercase()\
    \ < b.to_ascii_lowercase());\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp47icbc5z.rs:12:7\n   |\n12 |     s.sort_by(|a,b|\
    \ a.to_ascii_lowercase() < b.to_ascii_lowercase());\n   |       ^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.split_whitespace().sort_by(|a, b| a.cmp(&b)).join(\"_\")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpdidfrrch.rs:11:26\n   |\n11 |     s.split_whitespace().sort_by(|a,\
    \ b| a.cmp(&b)).join(\"_\")\n   |                          ^^^^^^^ method not\
    \ found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.lines()\n        .map(|w| w.chars().enumerate().collect::<Vec<_>>())\n\
    \        .map(|(a, b)| {\n            if a.1.is_none() {\n                b.1.to_owned()\n\
    \            } else {\n                let (left, right) = a.1.unwrap().clone(),\
    \ b.1.unwrap().clone();\n                if left.is_ascii_uppercase() {\n    \
    \                right.to_owned()\n                } else {\n                \
    \    left.to_owned()\n                }\n            }\n        })\n        .collect::<Vec<_>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n\
    \  --> /tmp/tmpcjxislx1.rs:17:57\n   |\n17 |                 let (left, right)\
    \ = a.1.unwrap().clone(), b.1.unwrap().clone();\n   |                        \
    \                                 ^ expected one of `.`, `;`, `?`, `else`, or\
    \ an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcjxislx1.rs:13:15\n\
    \   |\n13 |         .map(|(a, b)| {\n   |               ^^^^^-\n   |         \
    \      |    |\n   |               |    expected due to this\n   |            \
    \   expected struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(usize,\
    \ char)>`\n               found tuple `(_, _)`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut result = \"\";\n    let mut char_val = 0;\n \
    \   let mut word_val = s.chars().count() as usize;\n    let mut prev_char_val\
    \ = 0;\n    let mut prev_word_val = s.chars().count() as usize;\n\n    while word_val\
    \ > 0 {\n        let mut new_word_val = word_val;\n        let mut new_char_val\
    \ = 0;\n\n        for c in s.chars() {\n            char_val = c.value();\n  \
    \          if char_val < prev_char_val {\n                new_word_val += 1;\n\
    \                new_char_val += char_val - prev_char_val;\n            } else\
    \ {\n                new_char_val += char_val - prev_char_val;\n            }\n\
    \            prev_char_val = char_val;\n            prev_word_val = new_word_val;\n\
    \        }\n\n        result = result.push_str(&s[new_word_val..new_word_val +\
    \ new_char_val])\n            .expect(\"String concatenation failed\");\n    \
    \    s = &s[new_word_val + new_char_val..s.len()];\n        word_val = s.chars().count()\
    \ as usize;\n    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `value` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpfkiuth2j.rs:23:26\n   |\n23 |             char_val = c.value();\n\
    \   |                          ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpfkiuth2j.rs:34:25\n   |\n34 |         result = result.push_str(&s[new_word_val..new_word_val\
    \ + new_char_val])\n   |                         ^^^^^^^^ method not found in\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfkiuth2j.rs:36:13\n\
    \   |\n11 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n36 |         s = &s[new_word_val + new_char_val..s.len()];\n   |        \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n36 |         s = (&s[new_word_val\
    \ + new_char_val..s.len()]).to_string();\n   |             +                 \
    \                       +++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfkiuth2j.rs:39:5\n   |\n10 | fn anti_shuffle(s: String) -> String {\n\
    \   |                               ------ expected `String` because of return\
    \ type\n...\n39 |     result\n   |     ^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |     |\n   |     expected struct `String`, found `&str`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.split(\" \").sort_by(|a, b| a.cmp(b)).join(\" \")\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp01srjouj.rs:11:18\n   |\n11 |     s.split(\"\
    \ \").sort_by(|a, b| a.cmp(b)).join(\" \")\n   |                  ^^^^^^^ method\
    \ not found in `std::str::Split<'_, &str>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut new_string: Vec<Char> = s.chars().collect();\n    new_string.sort_by_key(|&c|\
    \ c.ascii_val());\n\n    let mut result = String::with_capacity(new_string.len());\n\
    \    new_string.iter().for_each(|c| {\n        if c.ascii_val() < 97 {\n     \
    \       result.push('a');\n        } else if c.ascii_val() < 123 {\n         \
    \   result.push('b');\n        } else {\n            result.push('c');\n     \
    \   }\n    });\n\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpjcix9f1r.rs:11:29\n\
    \   |\n11 |     let mut new_string: Vec<Char> = s.chars().collect();\n   |   \
    \                          ^^^^\n   |\nhelp: a builtin type with a similar name\
    \ exists\n   |\n11 |     let mut new_string: Vec<char> = s.chars().collect();\n\
    \   |                             ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n10 | fn anti_shuffle<Char>(s: String) -> String {\n   |               \
    \ ++++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::with_capacity(s.len());\n    for word in s.split('\
    \ ') {\n        res.extend(word.chars().enumerate().filter(|(_, c)| c != '\\0').collect::<Vec<_>>());\n\
    \    }\n    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmju6_onm.rs:13:63\n\
    \   |\n13 |         res.extend(word.chars().enumerate().filter(|(_, c)| c != '\\\
    0').collect::<Vec<_>>());\n   |                                              \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: the trait bound `String:\
    \ Extend<(usize, char)>` is not satisfied\n  --> /tmp/tmpmju6_onm.rs:13:13\n \
    \  |\n13 |         res.extend(word.chars().enumerate().filter(|(_, c)| c != '\\\
    0').collect::<Vec<_>>());\n   |             ^^^^^^ the trait `Extend<(usize, char)>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `Extend<A>`:\n             <String as Extend<&'a char>>\n  \
    \           <String as Extend<&'a str>>\n             <String as Extend<Box<str>>>\n\
    \             <String as Extend<Cow<'a, str>>>\n             <String as Extend<String>>\n\
    \             <String as Extend<char>>\n\nerror[E0599]: no method named `sort`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpmju6_onm.rs:15:9\n\
    \   |\n15 |     res.sort();\n   |         ^^^^ method not found in `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut out = String::with_capacity(s.len());\n    let mut current_word =\
    \ String::with_capacity(s.len());\n    for (i, c) in s.chars().enumerate() {\n\
    \        if c.is_ascii() {\n            *current_word += c.to_uppercase();\n \
    \       } else {\n            *current_word += c.to_lowercase();\n        }\n\
    \        if i != s.len() - 1 {\n            *out += &current_word;\n         \
    \   current_word.clear();\n        }\n    }\n    *out += current_word;\n    out\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `str`\n  --> /tmp/tmp6qlk9lgm.rs:15:13\n   |\n15 |             *current_word\
    \ += c.to_uppercase();\n   |             -------------^^^^^^^^^^^^^^^^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `str`\n  --> /tmp/tmp6qlk9lgm.rs:17:13\n\
    \   |\n17 |             *current_word += c.to_lowercase();\n   |             -------------^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `str`\n  --> /tmp/tmp6qlk9lgm.rs:20:13\n\
    \   |\n20 |             *out += &current_word;\n   |             ----^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `str`\n  --> /tmp/tmp6qlk9lgm.rs:24:5\n\
    \   |\n24 |     *out += current_word;\n   |     ----^^^^^^^^^^^^^^^^\n   |   \
    \  |\n   |     cannot use `+=` on type `str`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.lines()\n        .map(|x| x.chars().chain(Ord::Ord))\n        .flat_map(|x|\
    \ x.collect())\n        .chain(Ord::Ord)\n        .collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "warning: trait objects without an explicit `dyn` are deprecated\n  -->\
    \ /tmp/tmp559azco8.rs:12:34\n   |\n12 |         .map(|x| x.chars().chain(Ord::Ord))\n\
    \   |                                  ^^^\n   |\n   = note: `#[warn(bare_trait_objects)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n   |\n12 |         .map(|x| x.chars().chain(<dyn Ord>::Ord))\n\
    \   |                                  ++++    +\n\nerror[E0038]: the trait `Ord`\
    \ cannot be made into an object\n   --> /tmp/tmp559azco8.rs:12:34\n    |\n12 \
    \ |         .map(|x| x.chars().chain(Ord::Ord))\n    |                       \
    \           ^^^ `Ord` cannot be made into an object\n    |\nnote: for a trait\
    \ to be \"object safe\" it needs to allow building a vtable to allow the call\
    \ to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n\
    \nwarning: trait objects without an explicit `dyn` are deprecated\n  --> /tmp/tmp559azco8.rs:14:16\n\
    \   |\n14 |         .chain(Ord::Ord)\n   |                ^^^\n   |\n   = warning:\
    \ this is accepted in the current edition (Rust 2015) but is a hard error in Rust\
    \ 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n   |\n14 |         .chain(<dyn Ord>::Ord)\n   |             \
    \   ++++    +\n\nerror[E0038]: the trait `Ord` cannot be made into an object\n\
    \   --> /tmp/tmp559azco8.rs:14:16\n    |\n14  |         .chain(Ord::Ord)\n   \
    \ |                ^^^ `Ord` cannot be made into an object\n    |\nnote: for a\
    \ trait to be \"object safe\" it needs to allow building a vtable to allow the\
    \ call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n\
    \nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    s.replace(' ', |c| {\n        match c {\n           \
    \ ' ' => c.to_string().reverse(),\n            '!' => c.to_string().reverse(),\n\
    \            '?' => c.to_string().reverse(),\n            ' ' => c.to_string().reverse(),\n\
    \            _ => c,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp6ao_l7vz.rs:14:34\n   |\n14 |             ' ' =>\
    \ c.to_string().reverse(),\n   |                                  ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp6ao_l7vz.rs:15:34\n   |\n15 |             '!' => c.to_string().reverse(),\n\
    \   |                                  ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp6ao_l7vz.rs:16:34\n\
    \   |\n16 |             '?' => c.to_string().reverse(),\n   |                \
    \                  ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp6ao_l7vz.rs:17:34\n   |\n17 | \
    \            ' ' => c.to_string().reverse(),\n   |                           \
    \       ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut res = String::new();\n    s.split_whitespace().sort_by(|a, b| a.cmp(b).unwrap()).for_each(|word|\
    \ {\n        if !word.chars().any(|c| !ascii_tok.is_alphanumeric(c)) {\n     \
    \       res.push_str(word.chars().collect::<String>());\n        } else {\n  \
    \          res.push('1');\n        }\n    });\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ascii_tok` in this scope\n  --> /tmp/tmpwvoxtck5.rs:13:35\n\
    \   |\n13 |         if !word.chars().any(|c| !ascii_tok.is_alphanumeric(c)) {\n\
    \   |                                   ^^^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `sort_by` found for struct `SplitWhitespace` in\
    \ the current scope\n  --> /tmp/tmpwvoxtck5.rs:12:26\n   |\n12 |     s.split_whitespace().sort_by(|a,\
    \ b| a.cmp(b).unwrap()).for_each(|word| {\n   |                          ^^^^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut r = String::with_capacity(s.size());\n    for ch in s.chars() {\n\
    \        if !r.is_empty() {\n            r.push('_');\n        }\n        r.push(ch\
    \ as char);\n    }\n    r\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp394q82fh.rs:11:41\n   |\n11 |     let mut r = String::with_capacity(s.size());\n\
    \   |                                         ^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut new_s: String = String::with_capacity(s.len());\n    let mut alphabet:\
    \ Vec<u8> = vec![32, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\
    \ 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    for c in s.chars() {\n       \
    \ let index = alphabet.iter().position(|x| *x == c).unwrap();\n        new_s.push_str(&s.chars().nth(index).unwrap().to_string());\n\
    \        alphabet.swap(index, alphabet.iter().position(|x| *x == c).unwrap() +\
    \ 1);\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq2kofx60.rs:14:56\n   |\n\
    14 |         let index = alphabet.iter().position(|x| *x == c).unwrap();\n   |\
    \                                                        ^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq2kofx60.rs:16:65\n\
    \   |\n16 |         alphabet.swap(index, alphabet.iter().position(|x| *x == c).unwrap()\
    \ + 1);\n   |                                                                \
    \ ^ expected `u8`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n    let mut new_s = String::new();\n    let mut counter =\
    \ 0;\n    for c in s.chars() {\n        if let Some(c) = c {\n            counter\
    \ += c.as_byte().unwrap() * (256.0 + (counter%10));\n            if counter >\
    \ 255 { counter = 255; }\n        }\n    }\n    while counter > 0 {\n        if\
    \ counter % 2 == 0 {\n            new_s.push_str(\"!!\");\n        } else {\n\
    \            new_s.push_str(\"!!\");\n            new_s.push_str(\"!\");\n   \
    \     }\n        counter /= 2;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmporj8kojv.rs:15:16\n   |\n\
    15 |         if let Some(c) = c {\n   |                ^^^^^^^   - this expression\
    \ has type `char`\n   |                |\n   |                expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<_>`\n\nerror[E0277]: cannot add an integer to a float\n  --> /tmp/tmporj8kojv.rs:16:54\n\
    \   |\n16 |             counter += c.as_byte().unwrap() * (256.0 + (counter%10));\n\
    \   |                                                      ^ no implementation\
    \ for `{float} + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not\
    \ implemented for `{float}`\n   = help: the following other types implement trait\
    \ `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n\
    \             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n  \
    \           <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n      \
    \       <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n        \
    \   and 48 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut output = String::new();\n    for word in s.split_whitespace() {\n\
    \        let mut new_word = String::new();\n        for c in word {\n        \
    \    new_word.push(c as char);\n        }\n        for i in 0..new_word.len()\
    \ {\n            for j in new_word.chars().position(|c| *c == i as char) {\n \
    \               new_word[j] = '!' as char;\n            }\n        }\n       \
    \ new_word = new_word.split_ascii_lowercase()\n            .collect::<Vec<_>>()\n\
    \            .join(\"\");\n        output += new_word + \" \";\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmp82q8etxn.rs:14:18\n\
    \   |\n14 |         for c in word {\n   |                  ^^^^ `&str` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&str`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmp82q8etxn.rs:18:52\n   |\n18 | \
    \            for j in new_word.chars().position(|c| *c == i as char) {\n   | \
    \                                                   ^^\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp82q8etxn.rs:19:17\n   |\n\
    19 |                 new_word[j] = '!' as char;\n   |                 ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `split_ascii_lowercase` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp82q8etxn.rs:22:29\n   |\n\
    22 |         new_word = new_word.split_ascii_lowercase()\n   |               \
    \              ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_ascii_lowercase`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp82q8etxn.rs:25:19\n   |\n25 |         output += new_word + \" \";\n\
    \   |                   ^^^^^^^^^^^^^^\n   |                   |\n   |       \
    \            expected `&str`, found struct `String`\n   |                   help:\
    \ consider borrowing here: `&(new_word + \" \")`\n\nerror[E0604]: only `u8` can\
    \ be cast as `char`, not `usize`\n  --> /tmp/tmp82q8etxn.rs:18:58\n   |\n18 |\
    \             for j in new_word.chars().posi"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut ordered_s = String::new();\n    s.split(\" \").sort();\n    for c\
    \ in s.chars() {\n        ordered_s.push_str(match c {\n            ' ' => \"\
    -\",\n            'a' => \"z\",\n            'z' => \"a\",\n            'A' =>\
    \ \"Z\",\n            'Z' => \"A\",\n            c => c.to_string(),\n       \
    \ });\n    }\n    return ordered_s;\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpaym_vvwy.rs:12:18\n   |\n12 |     s.split(\"\
    \ \").sort();\n   |                  ^^^^ method not found in `std::str::Split<'_,\
    \ &str>`\n\nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpaym_vvwy.rs:20:18\n\
    \   |\n14 |           ordered_s.push_str(match c {\n   |  ____________________________-\n\
    15 | |             ' ' => \"-\",\n16 | |             'a' => \"z\",\n17 | |   \
    \          'z' => \"a\",\n18 | |             'A' => \"Z\",\n19 | |           \
    \  'Z' => \"A\",\n   | |                    --- this and all prior arms are found\
    \ to be of type `&str`\n20 | |             c => c.to_string(),\n   | |       \
    \           ^^^^^^^^^^^^^\n   | |                  |\n   | |                 \
    \ expected `&str`, found struct `String`\n   | |                  help: consider\
    \ borrowing here: `&c.to_string()`\n21 | |         });\n   | |_________- `match`\
    \ arms have incompatible types\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().map(|c|\n        let mut c1 = c;\n        if c1 >= 128 {\n    \
    \        c1 = 0\n        }\n        c + c1\n    ).collect::<String>()\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: closure bodies that contain statements must be surrounded by braces\n\
    \  --> /tmp/tmpojdowbrh.rs:11:21\n   |\n11 |     s.chars().map(|c|\n   |     \
    \                ^\n...\n16 |         c + c1\n   |         ^\n   |\nnote: statement\
    \ found outside of a block\n  --> /tmp/tmpojdowbrh.rs:12:23\n   |\n12 |      \
    \   let mut c1 = c;\n   |         --------------^ this `;` turns the preceding\
    \ closure into a statement\n   |         |\n   |         this expression is a\
    \ statement because of the trailing semicolon\nnote: the closure body may be incorrectly\
    \ delimited\n  --> /tmp/tmpojdowbrh.rs:11:19\n   |\n11 |       s.chars().map(|c|\n\
    \   |  ___________________^\n12 | |         let mut c1 = c;\n   | |______________________^\
    \ this is the parsed closure...\n...\n16 |           c + c1\n   |           -\
    \ ...but likely you meant the closure to end here\nhelp: try adding braces\n \
    \  |\n11 ~     s.chars().map(|c| {\n12 |         let mut c1 = c;\n13 |       \
    \  if c1 >= 128 {\n14 |             c1 = 0\n15 |         }\n16 ~         }c +\
    \ c1\n   |\n\nerror: expected `;`, found `c`\n  --> /tmp/tmpojdowbrh.rs:15:10\n\
    \   |\n15 |         }\n   |          ^ help: add `;` here\n16 |         c + c1\n\
    \   |         - unexpected token\n\nerror: expected one of `!`, `.`, `::`, `;`,\
    \ `?`, `{`, `}`, or an operator, found `)`\n  --> /tmp/tmpojdowbrh.rs:17:5\n \
    \  |\n16 |         c + c1\n   |               - expected one of 8 possible tokens\n\
    17 |     ).collect::<String>()\n   |     ^ unexpected token\n\nerror[E0658]: `let`\
    \ expressions in this position are unstable\n  --> /tmp/tmpojdowbrh.rs:12:9\n\
    \   |\n12 |         let mut c1 = c;\n   |         ^^^^^^^^^^^^^^\n   |\n   = note:\
    \ see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpojdowbrh.rs:11:5\n   |\n11 | /\
    \     s.chars().map(|c|\n12 | |         let mut c1 = c;\n13 | |         if c1\
    \ >= 128 {\n14 | |             c1 = 0\n15 | |         }\n   | |         ^- help:\
    \ consider using a semicolon here\n   | |_________|\n   |           expected `()`,\
    \ found struct `Map`\n   |\n   = note: expected unit type `()`"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut w = s.chars();\n    let mut buf = String::new();\n    let mut next_word\
    \ = String::new();\n    let mut last_word_idx = 0;\n    let mut in_word = String::new();\n\
    \n    while w.next() != Some(String::new()) {\n        let word_len = w.as_slice().len();\n\
    \        let mut cur_word = String::with_capacity(word_len);\n\n        cur_word.push_str(&w.as_slice());\n\
    \n        if cur_word.is_empty() {\n            continue;\n        }\n\n     \
    \   if cur_word[0] == ' ' {\n            next_word.push_str(&cur_word);\n    \
    \        continue;\n        }\n\n        if cur_word[cur_word.len() - 1] == '\
    \ ' {\n            cur_word.pop_back();\n            next_word.push_str(&cur_word);\n\
    \            continue;\n        }\n\n        // we found a non-word character\n\
    \        // get rid of it and put it into next_word\n        next_word.push_str(&cur_word);\n\
    \        cur_word.clear();\n\n        // remove the last word\n        if cur_word.is_empty()\
    \ {\n            last_word_idx = cur_word.len() - 1;\n            continue;\n\
    \        }\n\n        // remove the next word from the cur_word\n        cur_word.pop_back();\n\
    \n        // now we need to check the next word\n        // if it's an empty string,\
    \ put it into the in_word\n        if cur_word.is_empty() {\n            in_word.push_str(&cur_word);\n\
    \            continue;\n        }\n\n        // otherwise, we need to find out\
    \ what is the next word\n        // and put the word into the in_word (if it's\
    \ empty\n        // we don't care about the next word)\n        let next_word_len\
    \ = next_word.len() - 1;\n        let mut in_word_len = cur_word.len() - 1;\n\
    \        while in_word_len > 0 && (cur_word[in_word_len] == ' ' || cur_word[in_word_len]\
    \ == '.') {\n            in_word_len--;\n        }\n\n        in_word.push_str(&cur_word[in_word_len..]);\n\
    \n        // if the in_word is not empty, push the in_word into the buf\n    \
    \    // and put all chars from the in_word into the buf\n        if in_word.is_empty()\
    \ {\n            buf.push_str(&next_word);\n            next_word.clear();\n \
    \           continue;\n        }\n\n        // if the in_word is not empty, we\
    \ need to check whether it is the\n        // next word. if it's not, put it in\
    \ the buf and put all chars from\n        // the next word into the in_word\n\
    \        if next_word.len() > 0 {\n            buf.push_str(&next_word);\n   \
    \         next_word.clear();\n            continue;\n        }\n\n        // if\
    \ the in_word is empty but the cur_word is not empty\n        // put all the chars\
    \ from the cur_word into the in_word\n        if in_word.is_empty\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqvrdjz80.rs:101:3\n\
    \    |\n10  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n17  |     while w.next() != Some(String::new())\
    \ {\n    |                                           - this delimiter might not\
    \ be properly closed...\n...\n90  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n101 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmpqvrdjz80.rs:90:1\n   |\n89 |         if in_word.is_empty\n\
    \   |         -- this `if` expression has a condition, but no block\n90 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvrdjz80.rs:17:28\n\
    \   |\n17 |     while w.next() != Some(String::new()) {\n   |                \
    \            ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0599]:\
    \ no method named `as_slice` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmpqvrdjz80.rs:18:26\n   |\n18 |         let word_len = w.as_slice().len();\n\
    \   |                          ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `as_slice` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmpqvrdjz80.rs:21:30\n   |\n21 |         cur_word.push_str(&w.as_slice());\n\
    \   |                              ^^^^^^^^ method not found in `Chars<'_>`\n\n\
    error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpqvrdjz80.rs:27:12\n\
    \   |\n27 |         if cur_word[0] == ' ' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `St"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut s = s;\n\n    // Create a map that stores ascii value\n    // of\
    \ every character in the string\n    let mut char_map = HashMap::new();\n    for\
    \ c in s.chars() {\n        let mut value = c as usize;\n        char_map.insert(c.to_string(),\
    \ value);\n    }\n\n    // Create a map that stores the index of every character\
    \ in the string\n    // and it's ascii value\n    let mut index_map = HashMap::new();\n\
    \    for (i, c) in s.chars().enumerate() {\n        let mut value = c as usize;\n\
    \        index_map.insert(c.to_string(), i);\n    }\n\n    // Now go through each\
    \ word in the sentence and replace each character by\n    // an index in the map\
    \ that corresponds to the ascii value.\n    // Example:\n    // hi => 1 2 3 4\n\
    \    // ello = 5 6 7 8\n    // ello => 1 2 5 7\n    for word in s.split_whitespace()\
    \ {\n        // Create a vector that stores indexes of every character in the\
    \ word\n        let mut indexes = Vec::new();\n        for (index, c) in word.chars().enumerate()\
    \ {\n            match char_map.get(c.to_string()) {\n                Some(index)\
    \ => indexes.push(index),\n                None => panic!(\"invalid char: {},\
    \ not in map\", c),\n            }\n        }\n\n        // Reorder the indexes\
    \ so that characters arranged in ascending order\n        let mut sort_indexes\
    \ = Vec::new();\n        for i in 0..(indexes.len() - 1) {\n            if index_map.contains_key(indexes.swap(i).to_string())\
    \ {\n                sort_indexes.push(index_map.get(indexes.swap(i).to_string()).unwrap());\n\
    \            }\n        }\n\n        let mut new_word = String::new();\n     \
    \   for index in sort_indexes {\n            new_word.push((&s[index]).to_string());\n\
    \        }\n\n        s = new_word;\n    }\n\n    s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpytdu6h64.rs:15:24\n   |\n15 |     let mut char_map = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpytdu6h64.rs:23:25\n\
    \   |\n23 |     let mut index_map = HashMap::new();\n   |                    \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0061]: this function\
    \ takes 2 arguments but 1 argument was supplied\n   --> /tmp/tmpytdu6h64.rs:48:47\n\
    \    |\n48  |             if index_map.contains_key(indexes.swap(i).to_string())\
    \ {\n    |                                               ^^^^ - supplied 1 argument\n\
    \    |                                               |\n    |                \
    \                               expected 2 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0599]: `()` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmpytdu6h64.rs:48:55\n   |\n48 |             if index_map.contains_key(indexes.swap(i).to_string())\
    \ {\n   |                                                       ^^^^^^^^^ `()`\
    \ cannot be formatted with the default formatter\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): std::fmt::Display`\n     \
    \      which is required by `(): ToString`\n\nerror[E0061]: this function takes\
    \ 2 arguments but 1 argument was supplied\n   --> /tmp/tmpytdu6h64.rs:49:57\n\
    \    |\n49  |                 sort_indexes.push(index_map.get(indexes.swap(i).to_string()).unwrap());\n\
    \    |                                                         ^^^^ - supplied\
    \ 1 argument\n    |                                                         |\n\
    \    |                                                         expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0599]: `()` doesn't implement\
    \ `std::fmt::Display`\n  --> /tmp/tmpytdu6h64.rs:49:65\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut words = s.split_whitespace();\n    let mut chars_sorted_by_value\
    \ = Vec::new();\n    let mut chars_sorted_by_ascii = Vec::new();\n    for word\
    \ in words {\n        let mut s = word;\n        let mut i = s.len() - 1;\n  \
    \      for c in s.chars() {\n            match c {\n                '!' => s.insert(i,\
    \ '2'),\n                '@' => s.insert(i, '3'),\n                '#' => s.insert(i,\
    \ '4'),\n                '$' => s.insert(i, '5'),\n                '%' => s.insert(i,\
    \ '6'),\n                '^' => s.insert(i, '7'),\n                '&' => s.insert(i,\
    \ '8'),\n                '*' => s.insert(i, '9'),\n                '(' | ')' =>\
    \ s.insert(i, '0'),\n                '_' => s.insert(i, '1'),\n              \
    \  '-' => s.insert(i, '-'),\n                '=' => s.insert(i, '+'),\n      \
    \          '~' => s.insert(i, 'a'),\n                '<' => s.insert(i, 'b'),\n\
    \                '>' => s.insert(i, 'c'),\n                '_' => s.insert(i,\
    \ 'd'),\n                '|' => s.insert(i, 'e'),\n                '.' => s.insert(i,\
    \ 'f'),\n                '?' => s.insert(i, 'g'),\n                ';' => s.insert(i,\
    \ 'h'),\n                ':' => s.insert(i, 'i'),\n                '/' => s.insert(i,\
    \ 'j'),\n                '[' | ']' => s.insert(i, 'k'),\n                '\\\\\
    ' => s.insert(i, 'l'),\n                ']' => s.insert(i, 'm'),\n           \
    \     '{' => s.insert(i, 'n'),\n                '}' => s.insert(i, 'o'),\n   \
    \             '_' => s.insert(i, 'p'),\n                '|' => s.insert(i, 'q'),\n\
    \                '\"' => s.insert(i, 'r'),\n                '<' => s.insert(i,\
    \ 's'),\n                '>' => s.insert(i, 't'),\n                '\\'' => s.insert(i,\
    \ 'u'),\n                '(' | ')' => s.insert(i, 'v'),\n                ',' =>\
    \ s.insert(i, 'w'),\n                '.' => s.insert(i, 'x'),\n              \
    \  '/' => s.insert(i, 'y'),\n                '-' => s.insert(i, 'z'),\n      \
    \          '_' => s.insert(i, 'A'),\n                '=' => s.insert(i, 'B'),\n\
    \                '|' => s.insert(i, 'C'),\n                ';' => s.insert(i,\
    \ 'D'),\n                '>' => s.insert(i, 'E'),\n                '<' => s.insert(i,\
    \ 'F'),\n                '\\\\' => s.\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpb17vaffj.rs:75:3\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for word in words {\n  \
    \ |                       - unclosed delimiter\n...\n17 |         for c in s.chars()\
    \ {\n   |                            - unclosed delimiter\n18 |             match\
    \ c {\n   |                     - this delimiter might not be properly closed...\n\
    ...\n64 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    75 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpb17vaffj.rs:64:1\n\
    \   |\n64 | }\n   | ^\n\nerror[E0599]: no method named `insert` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpb17vaffj.rs:19:26\n   |\n19 |   \
    \              '!' => s.insert(i, '2'),\n   |                          ^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `insert` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpb17vaffj.rs:20:26\n   |\n\
    20 |                 '@' => s.insert(i, '3'),\n   |                          ^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `insert` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpb17vaffj.rs:21:26\n   |\n\
    21 |                 '#' => s.insert(i, '4'),\n   |                          ^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `insert` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpb17vaffj.rs:22:26\n   |\n\
    22 |                 '$' => s.insert(i, '5'),\n   |                          ^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `insert` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpb17vaffj.rs:23:26\n   |\n\
    23 |                 '%' => s.insert(i, '6'),\n   |                          ^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `insert` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpb17vaffj.rs:24:26\n   |\n\
    24 |                 '^' => s.insert(i, '7'),\n   |                          ^^^^^^\
    \ method not found in `&str`\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().map(|c|\n        match c {\n            ' ' => c,\n           \
    \ _ => c,\n        }\n    ).collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpsypb2x75.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars()\n        .cloned()\n        .filter(|x| *x > ' ')\n        .map(|x|\
    \ *x < *' ' || *x < *'?')\n        .collect()\n        .sort_by(|a, b| a.cmp(b))\n\
    \        .collect()\n        .iter()\n        .map(|x| x.to_string())\n      \
    \  .collect()\n        .join(\"\\n\")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmph7jsyibv.rs:12:10\n     |\n12   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `filter` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmph7jsyibv.rs:13:10\n\
    \   |\n13 |           .filter(|x| *x > ' ')\n   |            ^^^^^^ method cannot\
    \ be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmph7jsyibv.rs:14:23\n   |\n14 |         .map(|x| *x\
    \ < *' ' || *x < *'?')\n   |                       ^^^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmph7jsyibv.rs:14:36\n   |\n14 | \
    \        .map(|x| *x < *' ' || *x < *'?')\n   |                              \
    \      ^^^^\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut map = HashMap::new();\n    let mut s = String::from(s);\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let j = i + 1;\n        while j\
    \ < s.len() {\n            if s[i].as_bytes()[0] < s[j].as_bytes()[0] {\n    \
    \            s.swap(i, j);\n            }\n            j += 1;\n        }\n  \
    \      i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmps6h5mq92.rs:11:19\n   |\n11 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps6h5mq92.rs:17:16\n\
    \   |\n17 |             if s[i].as_bytes()[0] < s[j].as_bytes()[0] {\n   |   \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps6h5mq92.rs:17:37\n   |\n17 |             if s[i].as_bytes()[0]\
    \ < s[j].as_bytes()[0] {\n   |                                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmps6h5mq92.rs:18:19\n   |\n18 |          \
    \       s.swap(i, j);\n   |                   ^^^^ method not found in `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433, E0599.\nFor more information about a"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    let mut r = String::new();\n    s.chars().for_each(|c| {\n        if c <\
    \ 0x20 || (c > 0x7f && c != ' ') {\n            r.push(c);\n        } else {\n\
    \            let mut i = r[r.len() - 1];\n            for i in 0..r.len() {\n\
    \                if r[i] == c {\n                    r[i] = '_';\n           \
    \         break;\n                }\n            }\n        }\n    });\n    r\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfx86muhw.rs:13:16\n   |\n\
    13 |         if c < 0x20 || (c > 0x7f && c != ' ') {\n   |                ^^^^\
    \ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfx86muhw.rs:13:29\n\
    \   |\n13 |         if c < 0x20 || (c > 0x7f && c != ' ') {\n   |            \
    \                 ^^^^ expected `char`, found `u8`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpfx86muhw.rs:16:25\n   |\n16 |  \
    \           let mut i = r[r.len() - 1];\n   |                         ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfx86muhw.rs:18:20\n   |\n18 |                 if r[i] == c {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfx86muhw.rs:19:21\n\
    \   |\n19 |                     r[i] = '_';\n   |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other ty"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    s.chars().filter_map(|c| match c {\n        ' ' => None,\n        '\\n' =>\
    \ None,\n        _ => Some(c.to_ascii_lowercase())),\n    }.collect()\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp6dljw3eq.rs:16:1\n\
    \   |\n10 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - this opening brace...\n...\n15 |     }.collect()\n   |   \
    \  - ...matches this closing brace\n16 | }\n   | ^ unexpected closing delimiter\n\
    \nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp6dljw3eq.rs:11:38\n\
    \   |\n11 |     s.chars().filter_map(|c| match c {\n   |                     \
    \                 ^ unclosed delimiter\n...\n14 |         _ => Some(c.to_ascii_lowercase())),\n\
    \   |                                          ^ mismatched closing delimiter\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// anti_shuffle('Hi')\
    \ returns 'Hi'\n/// anti_shuffle('hello') returns 'ehllo'\n/// anti_shuffle('Hello\
    \ World!!!') returns 'Hello !!!Wdlor'\nfn anti_shuffle(s: String) -> String {\n\
    \    \n    let mut word_idx = 0;\n    let mut current_word_idx = 0;\n    let mut\
    \ current_word_len = s.len();\n    let mut new_word_len = s.len();\n    let mut\
    \ current_new_word_len = 0;\n    \n    let mut new_word_list: Vec<String> = vec![];\n\
    \    while current_word_len > 0 {\n        let mut cur_word_len = current_word_len;\n\
    \        if current_new_word_len > 0 {\n            cur_word_len = cur_word_len\
    \ + current_new_word_len;\n        }\n        \n        if cur_word_len >= new_word_len\
    \ {\n            new_word_len = cur_word_len;\n            new_word_list = new_word_list.push(s.chars().skip(word_idx).take(cur_word_len).collect());\n\
    \            current_word_len = 0;\n            current_new_word_len = 0;\n  \
    \          word_idx += cur_word_len\n        } else {\n            current_new_word_len\
    \ = cur_word_len;\n            word_idx += cur_word_len\n        }\n    }\n  \
    \  \n    new_word_list.push(s.chars().skip(word_idx).take(current_word_len).collect());\n\
    \    new_word_list\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdxzrddcq.rs:27:29\n   |\n\
    18 |     let mut new_word_list: Vec<String> = vec![];\n   |                  \
    \          ----------- expected due to this type\n...\n27 |             new_word_list\
    \ = new_word_list.push(s.chars().skip(word_idx).take(cur_word_len).collect());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\nnote: method `push` modifies its receiver in-place\n\
    \  --> /tmp/tmpdxzrddcq.rs:27:43\n   |\n27 |             new_word_list = new_word_list.push(s.chars().skip(word_idx).take(cur_word_len).collect());\n\
    \   |                             ------------- ^^^^ this call modifies `new_word_list`\
    \ in-place\n   |                             |\n   |                         \
    \    you probably want to use this value after calling the method...\n   = note:\
    \ ...instead of the `()` output of method `push`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdxzrddcq.rs:38:5\n   |\n10 | fn anti_shuffle(s: String) -> String\
    \ {\n   |                               ------ expected `String` because of return\
    \ type\n...\n38 |     new_word_list\n   |     ^^^^^^^^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
