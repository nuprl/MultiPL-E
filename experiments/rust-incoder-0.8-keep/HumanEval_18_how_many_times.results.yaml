name: HumanEval_18_how_many_times
language: rust
results:
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(string.chars().skip(string.len()))\n        .filter(|&(c1, _)| c1\
    \ == substring)\n        .count();\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplm6t5f2g.rs:11:34\n   |\n\
    11 |         .filter(|&(c1, _)| c1 == substring)\n   |                       \
    \           ^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmplm6t5f2g.rs:8:57\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |    --------------               \
    \                        ^^^^^ expected `isize`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsyckzf46.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count() + 1).try_into().unwrap()\n  |     +                    \
    \                                                     +++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    for s in string.chars() {\n        let found = substring.contains(&s);\n\
    \        if found {\n            counter += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpgxzfusqh.rs:11:40\n\
    \     |\n11   |         let found = substring.contains(&s);\n     |          \
    \                     -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                               |\n     |                              \
    \ required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n11   |         let found = substring.contains(*&s);\n\
    \     |                                        +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ substring.contains(&c)).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp_dknaz71.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp_dknaz71.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .enumerate()\n        .filter(|(_, c)| c.contains(substring))\n     \
    \   .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpxcwmp31_.rs:11:28\n   |\n11 |         .filter(|(_,\
    \ c)| c.contains(substring))\n   |                            ^^^^^^^^ method\
    \ not found in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxcwmp31_.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars()\n10 | |         .enumerate()\n\
    11 | |         .filter(|(_, c)| c.contains(substring))\n12 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n12 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ This code uses `memchr` which is not available on all platforms, but we can\
    \ work around that.\n    let mut string_bytes = string.as_bytes();\n    let mut\
    \ substring_len = substring.len();\n    let mut i = 0;\n    while i < substring_len\
    \ && i < string_bytes.len() {\n        if substring_len == 0 {\n            return\
    \ i;\n        }\n        if string_bytes[i] == substring_len {\n            substring_len\
    \ -= 1;\n            i += 1;\n        } else if string_bytes[i] == 0 {\n     \
    \       i += 1;\n        } else {\n            substring_len -= 1;\n         \
    \   i += 1;\n        }\n    }\n    0\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0cvpip24.rs:15:20\n   |\n\
    15 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n15 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0cvpip24.rs:17:31\n   |\n17 |         if string_bytes[i] == substring_len\
    \ {\n   |                               ^^^^^^^^^^^^^ expected `u8`, found `usize`\n\
    \   |\nhelp: you can convert `string_bytes[i]` from `u8` to `usize`, matching\
    \ the type of `substring_len`\n   |\n17 |         if usize::from(string_bytes[i])\
    \ == substring_len {\n   |            ++++++++++++               +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = String::new();\n    let mut s = String::from(string);\n    let mut\
    \ sub = String::from(substring);\n\n    while !s.is_empty() {\n        let index\
    \ = sub.find(s);\n        if index != Some(sub.length()) {\n            count\
    \ += 1;\n            s = String::from_utf8(s.split_off(index).collect());\n  \
    \      }\n        else {\n            return count;\n        }\n    }\n\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpraxu9ei_.rs:14:30\n     |\n14   |         let index = sub.find(s);\n\
    \     |                         ---- ^ expected an implementor of trait `Pattern<'_>`\n\
    \     |                         |\n     |                         required by\
    \ a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n14   |         let index\
    \ = sub.find(&s);\n     |                              +\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpraxu9ei_.rs:15:30\n\
    \   |\n15 |         if index != Some(sub.length()) {\n   |                   \
    \           ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpraxu9ei_.rs:16:22\n \
    \  |\n16 |             count += 1;\n   |                      ^ expected `&str`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpraxu9ei_.rs:17:47\n\
    \   |\n17 |             s = String::from_utf8(s.split_off(index).collect());\n\
    \   |                                               ^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<usize>`\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpraxu9ei_.rs:17:54\n\
    \    |\n17  |               s = String::from_utf8(s.split_off(index).collect());\n\
    \    |                                                        ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpraxu9ei_.rs:17:17\n   |\n10 |     let mut s = Strin"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices().map(|i|\
    \ (substring, i)).count(|&(sub, i), _| sub == substring)\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmptx78nud4.rs:9:51\n    |\n9   |     string.char_indices().map(|i|\
    \ (substring, i)).count(|&(sub, i), _| sub == substring)\n    |              \
    \                                     ^^^^^ ------------------------------- supplied\
    \ 1 argument\n    |                                                   |\n    |\
    \                                                   expected 0 arguments\n   \
    \ |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmptx78nud4.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.char_indices().map(|i|\
    \ (substring, i)).count(|&(sub, i), _| sub == substring)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.char_indices().map(|i|\
    \ (substring, i)).count(|&(sub, i), _| sub == substring).try_into().unwrap()\n\
    \  |                                                                         \
    \                ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0; // count how many substrings match\n    let mut last_end = 0;\
    \ // last substring end\n    for index in string.char_indices().rev() {\n    \
    \    let start = index.0;\n        let end = index.1;\n        if last_end < start\
    \ {\n            break // nothing matched\n        }\n        if last_end >= end\
    \ {\n            break // reached end of string\n        }\n        let index\
    \ = string.char_offset(start); // start of substring match\n        if string[index..].contains(&substring)\
    \ {\n            count += 1;\n        }\n        last_end = end;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprtvzjuw2.rs:17:24\n   |\n\
    17 |         if last_end >= end {\n   |                        ^^^ expected `usize`,\
    \ found `char`\n\nerror[E0599]: no method named `char_offset` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmprtvzjuw2.rs:20:28\n   |\n20 | \
    \        let index = string.char_offset(start); // start of substring match\n\
    \   |                            ^^^^^^^^^^^ method not found in `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprtvzjuw2.rs:24:20\n   |\n10 |  \
    \   let mut last_end = 0; // last substring end\n   |                        -\
    \ expected due to this value\n...\n24 |         last_end = end;\n   |        \
    \            ^^^ expected `usize`, found `char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for index in string.char_indices() {\n        if let Some(index)\
    \ = substring.find(string.chars()[index]) {\n            count += 1;\n       \
    \ }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpcjmm3d80.rs:11:45\n\
    \   |\n11 |         if let Some(index) = substring.find(string.chars()[index])\
    \ {\n   |                                             ^^^^^^^^^^^^^^^^^^^^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Start with 0, because substring starts with substring\n    let mut cnt = 0;\n\
    \    let mut last = 0;\n    let mut i = string.find(&substring);\n    while i\
    \ != String::npos {\n        if i == last {\n            cnt += 1;\n         \
    \   last = i + 1;\n        } else {\n            cnt = 0;\n        }\n       \
    \ i = string.find(&substring, last);\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpmd3g6u67.rs:13:24\n   |\n13 | \
    \    while i != String::npos {\n   |                        ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmd3g6u67.rs:14:17\n\
    \   |\n14 |         if i == last {\n   |                 ^^^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    14 |         if i == Some(last) {\n   |                 +++++    +\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpmd3g6u67.rs:16:22\n\
    \   |\n16 |             last = i + 1;\n   |                    - ^ - {integer}\n\
    \   |                    |\n   |                    Option<usize>\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpmd3g6u67.rs:20:20\n\
    \     |\n20   |         i = string.find(&substring, last);\n     |           \
    \         ^^^^ ----------  ---- supplied 2 arguments\n     |                 \
    \   |\n     |                    expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ *c == substring).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp04kzfsnu.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|c| *c == substring).count()\n  |                \
    \                     ^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp04kzfsnu.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| *c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ *c == substring).count().try_into().unwrap()\n  |                          \
    \                             ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ substring.contains(c)).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpbl8v703f.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count() +\
    \ 1\n     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count() + 1\n     |                                \
    \                  +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpbl8v703f.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\
    \ + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ substring.contains(c)).count() + 1).try_into().unwrap()\n  |     +         \
    \                                                   +++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut last = 0;\n    for c in string.chars() {\n       \
    \ if c.to_ascii_lowercase().contains(substring) {\n            cnt += 1;\n   \
    \     }\n        if substring[last..].to_ascii_lowercase().contains(c) {\n   \
    \         cnt += 1;\n        }\n        last = c.len_utf8();\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmptmf9yudp.rs:12:35\n   |\n12 |         if c.to_ascii_lowercase().contains(substring)\
    \ {\n   |                                   ^^^^^^^^ method not found in `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n     \
    \   if string.starts_with(substring, pos) {\n            count += 1;\n       \
    \ }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpekv5q1xw.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    for ch in string.chars() {\n        if ch.contains(&substring)\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4olf23zs.rs:11:15\n   |\n11 |         if ch.contains(&substring)\
    \ {\n   |               ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv98r8ygu.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() {\n        return 0;\n    }\n\n    let mut i = 1;\n    let\
    \ mut pos = 0;\n    let mut found = false;\n    loop {\n        found = pos ==\
    \ string.len() || string.chars().any(|c| c == string[pos]);\n        if found\
    \ {\n            return i;\n        }\n        i += 1;\n        pos += 1;\n  \
    \  }\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3b5mjpbt.rs:17:68\n\
    \   |\n17 |         found = pos == string.len() || string.chars().any(|c| c ==\
    \ string[pos]);\n   |                                                        \
    \            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = Vec::new();\n    for _i in 0..string.len() {\n        for _j in\
    \ string.chars().skip_while(|&&c| c != substring[..]) {\n            count.push(0);\n\
    \        }\n        let start = _i;\n        let end = string.len() - substring.length();\n\
    \        let start = if start < 0 { 0 } else { start };\n        let end = if\
    \ end < 0 { 0 } else { end };\n        for _i in start..end {\n            let\
    \ mut pos = _i;\n            let c = string.chars().skip_while(|&&c| c != substring[..]).take(substring.length());\n\
    \            pos += c.len();\n            let found = !count.contains(&pos);\n\
    \            count.push(found as isize);\n        }\n    }\n    count.iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplukc8092.rs:11:47\n   |\n\
    11 |         for _j in string.chars().skip_while(|&&c| c != substring[..]) {\n\
    \   |                                               ^-\n   |                 \
    \                              ||\n   |                                      \
    \         |expected due to this\n   |                                        \
    \       expected `char`, found reference\n   |                               \
    \                help: you can probably remove the explicit borrow: `c`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmplukc8092.rs:15:44\n   |\n15 |         let end = string.len() - substring.length();\n\
    \   |                                            ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplukc8092.rs:20:49\n   |\n20 |             let c = string.chars().skip_while(|&&c|\
    \ c != substring[..]).take(substring.length());\n   |                        \
    \                         ^-\n   |                                           \
    \      ||\n   |                                                 |expected due\
    \ to this\n   |                                                 expected `char`,\
    \ found reference\n   |                                                 help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `length` found for struct `String` in the current scope\n  --> /tmp/tmplukc8092.rs:20:88\n\
    \   |\n20 |             let c = string.chars().skip_while(|&&c| c != substring[..]).take(substring.length());\n\
    \   |                                                                        \
    \                ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0599]: the method `len` exists for struct `std::iter::Take<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmplukc8092.rs:20:47: 20:71]>>`, but its t"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.iter().filter_map(|c|\
    \ {\n        let index = string.find(substring);\n        Some(index as isize)\n\
    \    }).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp7sskfufo.rs:9:12\n  |\n9 |     string.iter().filter_map(|c|\
    \ {\n  |            ^^^^ method not found in `String`\n  |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n  |\n9 |     string.chars().filter_map(|c| {\n\
    \  |            ~~~~~\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found\
    \ `String`\n    --> /tmp/tmp7sskfufo.rs:10:33\n     |\n10   |         let index\
    \ = string.find(substring);\n     |                            ---- ^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \       |\n     |                            required by a bound introduced by\
    \ this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl str>::find`\n\
    help: consider borrowing here\n     |\n10   |         let index = string.find(&substring);\n\
    \     |                                 +\n\nerror[E0605]: non-primitive cast:\
    \ `Option<usize>` as `isize`\n  --> /tmp/tmp7sskfufo.rs:11:14\n   |\n11 |    \
    \     Some(index as isize)\n   |              ^^^^^^^^^^^^^^ an `as` expression\
    \ can only be used to convert between primitive types or to coerce to a specific\
    \ trait object\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599, E0605.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().take_while(|c|\
    \ c.unwrap() == substring).count() + 1\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for reference `&char` in the\
    \ current scope\n --> /tmp/tmpht7i_x1d.rs:9:37\n  |\n9 |     string.chars().take_while(|c|\
    \ c.unwrap() == substring).count() + 1\n  |                                  \
    \   ^^^^^^ method not found in `&char`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpht7i_x1d.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().take_while(|c|\
    \ c.unwrap() == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().take_while(|c|\
    \ c.unwrap() == substring).count() + 1).try_into().unwrap()\n  |     +       \
    \                                                           +++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = string.find(substring);\n    while index\
    \ != String::npos {\n        count = count + 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp3si43nwu.rs:10:33\n     |\n10   |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n10   |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp3si43nwu.rs:11:28\n\
    \   |\n11 |     while index != String::npos {\n   |                          \
    \  ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmp3si43nwu.rs:13:46\n   |\n\
    13 |         index = string.find(substring, index + 1);\n   |                \
    \                        ----- ^ - {integer}\n   |                           \
    \             |\n   |                                        Option<usize>\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmp3si43nwu.rs:13:24\n     |\n13   |         index = string.find(substring,\
    \ index + 1);\n     |                        ^^^^ ---------  --------- supplied\
    \ 2 arguments\n     |                        |\n     |                       \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut count\
    \ = 0;\n    let mut start_index = 0;\n    let mut end_index = string.len() - substring.len();\n\
    \    let mut found = false;\n    while !found {\n        while start_index < end_index\
    \ {\n            if string.chars()[start_index] == substring.chars()[start_index]\
    \ {\n                start_index += 1;\n                count += 1;\n        \
    \    } else {\n                break;\n            }\n        }\n\n        if\
    \ start_index >= end_index {\n            found = true;\n        } else {\n  \
    \          end_index -= 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpoxvw9szk.rs:19:16\n\
    \   |\n19 |             if string.chars()[start_index] == substring.chars()[start_index]\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmpoxvw9szk.rs:19:47\n   |\n19\
    \ |             if string.chars()[start_index] == substring.chars()[start_index]\
    \ {\n   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .map(|(char1, char2)| (char1 as u8 ==\
    \ char2 as u8) as isize)\n        .sum()\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9ua86lu0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| a == b)\n        .count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_1qn5861.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a, b)| a == b)\n12 | |         .count() + 1\n   | |____________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n9  ~     (string.chars()\n\
    10 |         .zip(substring.chars())\n11 |         .filter(|(a, b)| a == b)\n\
    12 ~         .count() + 1).try_into().unwrap()\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.count(substring)\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpu94omfq2.rs:9:12\n\
    \    |\n9   |       string.count(substring)\n    |              ^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut last_substring_pos = 0;\n    while let Some(pos)\
    \ = string.find(substring, last_substring_pos) {\n        last_substring_pos =\
    \ pos + 1;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp5n5etjg4.rs:11:34\n     |\n11   |     while let Some(pos) = string.find(substring,\
    \ last_substring_pos) {\n     |                                  ^^^^ ---------\
    \  ------------------ supplied 2 arguments\n     |                           \
    \       |\n     |                                  expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut substr_len = substring.len();\n    let mut count = 0;\n    let mut pos =\
    \ 0;\n    while pos < string.len() {\n        let mut found = string[pos].find(&substring[..substr_len]);\n\
    \        count = if found != String::npos {\n            found + substr_len\n\
    \        } else {\n            count\n        };\n        pos = pos + 1;\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwxhd8htb.rs:13:25\n\
    \   |\n13 |         let mut found = string[pos].find(&substring[..substr_len]);\n\
    \   |                         ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no function or associated item named `npos` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpwxhd8htb.rs:14:37\n\
    \   |\n14 |         count = if found != String::npos {\n   |                 \
    \                    ^^^^ function or associated item not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .filter(|c| substring.contains(&c.to_string()))\n        .count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd0uftt5t.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .filter(|c|\
    \ substring.contains(&c.to_string()))\n11 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut pos = 0;\n    for c in string.chars() {\n    \
    \    if pos == 0 && c.is_ascii() {\n            pos = string.find(substring, pos);\n\
    \            continue;\n        }\n        if pos == 0 {\n            pos = string.find(substring,\
    \ pos + 1);\n            continue;\n        }\n        if pos == string.len()\
    \ - 1 {\n            pos = string.find(substring, 0);\n            continue;\n\
    \        }\n        let mut i = 0;\n        for b in &string[pos - 1..pos] {\n\
    \            if i == 0 && b.is_ascii() {\n                i = 1;\n           \
    \     continue;\n            }\n            if i == 1 && b.is_ascii() {\n    \
    \            i = 2;\n                continue;\n            }\n            if\
    \ i == 2 && b.is_ascii() {\n                i = 3;\n                continue;\n\
    \            }\n            break;\n        }\n        counter += i;\n       \
    \ pos += i;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpfh9qbwhb.rs:13:26\n     |\n13   |             pos = string.find(substring,\
    \ pos);\n     |                          ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                          |\n     |                          expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfh9qbwhb.rs:13:19\n   |\n10 |     let mut pos = 0;\n  \
    \ |                   - expected due to this value\n...\n13 |             pos\
    \ = string.find(substring, pos);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpfh9qbwhb.rs:17:26\n\
    \     |\n17   |             pos = string.find(substring, pos + 1);\n     |   \
    \                       ^^^^ ---------  ------- supplied 2 arguments\n     | \
    \                         |\n     |                          expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfh9qbwhb.rs:17:19\n   |\n10 |     let mut pos = 0;\n   |      \
    \             - expected due to this value\n...\n17 |             pos = string.find(substring,\
    \ pos + 1);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<usize>`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmpfh9qbwhb.rs:21:26\n     |\n21\
    \   |             pos = string.find(substring, 0);\n     |                   \
    \       ^^^^ ---------  - supplied 2 arguments\n     |                       \
    \   |\n     |                          expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfh9qbwhb.rs:21:19\n\
    \   |\n10 |     let mut pos = 0;\n   |                   - expected due to this\
    \ value\n...\n21 |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n    let\
    \ mut result = 1;\n    let mut string_ptr = string.as_bytes();\n    let mut substring_ptr\
    \ = substring.as_bytes();\n    let len = min(string_ptr.len(), substring_ptr.len());\n\
    \    for _ in 0..len {\n        if string_ptr[string_ptr.len() - substring_ptr.len()..string_ptr.len()].iter()\n\
    \            .zip(substring_ptr.iter())\n            .any(|e| e[0] == e[1])\n\
    \        {\n            result *= 2;\n        }\n        result *= 2;\n      \
    \  string_ptr = string_ptr.offset(1);\n        substring_ptr = substring_ptr.offset(1);\n\
    \    }\n    result * 2\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpx9da9dsc.rs:15:15\n\
    \   |\n15 |     let len = min(string_ptr.len(), substring_ptr.len());\n   |  \
    \             ^^^\n...\n30 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    15 |     let len = main(string_ptr.len(), substring_ptr.len());\n   |        \
    \       ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0608]: cannot index into a value of type `(&u8, &u8)`\n  --> /tmp/tmpx9da9dsc.rs:19:22\n\
    \   |\n19 |             .any(|e| e[0] == e[1])\n   |                      ^^^^\
    \ help: to access tuple elements, use: `e.0`\n\nerror[E0608]: cannot index into\
    \ a value of type `(&u8, &u8)`\n  --> /tmp/tmpx9da9dsc.rs:19:30\n   |\n19 |  \
    \           .any(|e| e[0] == e[1])\n   |                              ^^^^ help:\
    \ to access tuple elements, use: `e.1`\n\nerror[E0599]: no method named `offset`\
    \ found for reference `&[u8]` in the current scope\n  --> /tmp/tmpx9da9dsc.rs:24:33\n\
    \   |\n24 |         string_ptr = string_ptr.offset(1);\n   |                 \
    \                ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method\
    \ named `offset` found for reference `&[u8]` in the current scope\n  --> /tmp/tmpx9da9dsc.rs:25:39\n\
    \   |\n25 |         substring_ptr = substring_ptr.offset(1);\n   |           \
    \                            ^^^^^^ method not found in `&[u8]`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .chars()\n        .zip(substring.chars())\n        .filter(|(a, b)| a\
    \ == b)\n        .count();\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8t56vr76.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.contains(&substring) {\n        string.count(substring)\n    } else {\n\
    \        0\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp2y32x2kk.rs:10:16\n\
    \    |\n10  |           string.count(substring)\n    |                  ^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ *c == *substring).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbhu1l7hc.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|c| *c == *substring).count() + 1\n  |           \
    \                          ^^^^^^^^^^ expected `char`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpbhu1l7hc.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| *c == *substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ *c == *substring).count() + 1).try_into().unwrap()\n  |     +              \
    \                                         +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut substr_len = substring.length();\n    let mut count = 0;\n    let mut i\
    \ = 0;\n    while i < string.length() && count < substr_len {\n        if string[i]\
    \ == substring[0] {\n            i += 1;\n            count += 1;\n          \
    \  if i == string.length() || string[i] != substring[1] {\n                return\
    \ count;\n            }\n            while i + 1 < string.length() && count <\
    \ substr_len {\n                if string[i + 1] == substring[0] {\n         \
    \           i += 2;\n                    count += 1;\n                    if i\
    \ == string.length() || string[i] != substring[1] {\n                        return\
    \ count;\n                    }\n                } else {\n                  \
    \  i += 1;\n                }\n            }\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpq5hm2in9.rs:9:36\n  |\n9 |     let mut substr_len\
    \ = substring.length();\n  |                                    ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpq5hm2in9.rs:12:22\n\
    \   |\n12 |     while i < string.length() && count < substr_len {\n   |      \
    \                ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpq5hm2in9.rs:13:12\n   |\n13 |         if string[i] == substring[0]\
    \ {\n   |            ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpq5hm2in9.rs:13:25\n   |\n13 |         if string[i] == substring[0]\
    \ {\n   |                         ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scop"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    for (i, c) in string.chars().enumerate() {\n        if\
    \ c == substring {\n            counter += 1;\n            if i >= string.len()\
    \ - substring.len() {\n                break;\n            }\n            if i\
    \ >= string.len() - substring.len() - 1 && string.chars()[i + substring.len()..].all(|c|\
    \ c != c) {\n                break;\n            }\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgeof_hca.rs:11:17\n   |\n\
    11 |         if c == substring {\n   |                 ^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmpgeof_hca.rs:16:59\n   |\n16 |             if i >= string.len()\
    \ - substring.len() - 1 && string.chars()[i + substring.len()..].all(|c| c !=\
    \ c) {\n   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| {\n            b.cmp(a)\
    \ == Ordering::Less\n        })\n        .fold(0, |acc, (a, b)| acc + (b == a\
    \ ? 1 : 0))\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `1`\n\
    \  --> /tmp/tmpn0odhgwf.rs:14:48\n   |\n14 |         .fold(0, |acc, (a, b)| acc\
    \ + (b == a ? 1 : 0))\n   |                                                ^ expected\
    \ one of `)`, `,`, `.`, `?`, or an operator\n\nerror: expected one of `!`, `&&`,\
    \ `&`, `(`, `)`, `*`, `,`, `...`, `.`, `<`, `?`, `[`, `_`, `async`, `const`, `dyn`,\
    \ `extern`, `fn`, `for`, `impl`, `unsafe`, `~`, an operator, lifetime, or path,\
    \ found `0`\n  --> /tmp/tmpn0odhgwf.rs:14:52\n   |\n14 |         .fold(0, |acc,\
    \ (a, b)| acc + (b == a ? 1 : 0))\n   |                                      \
    \             -^ expected one of 25 possible tokens\n   |                    \
    \                               |\n   |                                      \
    \             help: missing `,`\n\nerror: expected one of `.`, `;`, `?`, `}`,\
    \ or an operator, found `)`\n  --> /tmp/tmpn0odhgwf.rs:14:54\n   |\n14 |     \
    \    .fold(0, |acc, (a, b)| acc + (b == a ? 1 : 0))\n   |                    \
    \                                  ^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut idx = string.find(substring);\n    while idx !=\
    \ std::str::npos {\n        count += 1;\n        idx = string.find(substring,\
    \ idx + 1);\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `npos` in module `std::str`\n  --> /tmp/tmpsv50b6ne.rs:11:28\n\
    \   |\n11 |     while idx != std::str::npos {\n   |                          \
    \  ^^^^ not found in `std::str`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure,\
    \ found `String`\n    --> /tmp/tmpsv50b6ne.rs:10:31\n     |\n10   |     let mut\
    \ idx = string.find(substring);\n     |                          ---- ^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \     |\n     |                          required by a bound introduced by this\
    \ call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n10   |     let mut idx = string.find(&substring);\n\
    \     |                               +\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpsv50b6ne.rs:13:42\n   |\n13 |         idx\
    \ = string.find(substring, idx + 1);\n   |                                   \
    \   --- ^ - {integer}\n   |                                      |\n   |     \
    \                                 Option<usize>\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpsv50b6ne.rs:13:22\n\
    \     |\n13   |         idx = string.find(substring, idx + 1);\n     |       \
    \               ^^^^ ---------  ------- supplied 2 arguments\n     |         \
    \             |\n     |                      expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277, E0369, E0425.\nFor more\
    \ information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.find(substring).is_none() {\n        return 0;\n    }\n\n    let mut\
    \ i = 0;\n    for pos in string.find(substring) {\n        if pos == 0 {\n   \
    \         continue;\n        }\n\n        if string.chars().skip(pos).take(substring).count()\
    \ > 1 {\n            i += 1;\n        }\n    }\n\n    i + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpe1rwxjta.rs:9:20\n     |\n9    |     if string.find(substring).is_none()\
    \ {\n     |               ---- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |               |\n     |               required by a bound introduced by\
    \ this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl str>::find`\n\
    help: consider borrowing here\n     |\n9    |     if string.find(&substring).is_none()\
    \ {\n     |                    +\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n    --> /tmp/tmpe1rwxjta.rs:14:28\n     |\n14   | \
    \    for pos in string.find(substring) {\n     |                       ---- ^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \  |\n     |                       required by a bound introduced by this call\n\
    \     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n14   |     for pos in string.find(&substring)\
    \ {\n     |                            +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpe1rwxjta.rs:19:42\n   |\n19 |         if string.chars().skip(pos).take(substring).count()\
    \ > 1 {\n   |                                          ^^^^^^^^^ expected `usize`,\
    \ found struct `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .chars()\n        .zip(string.chars())\n        .filter(|(a, b)| a ==\
    \ b)\n        .filter(|(a, b)| a.to_ascii_lowercase().contains(substring))\n \
    \       .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp5w0193ba.rs:13:49\n   |\n13 |         .filter(|(a, b)|\
    \ a.to_ascii_lowercase().contains(substring))\n   |                          \
    \                       ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5w0193ba.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string\n10 | |         .chars()\n11 | |         .zip(string.chars())\n\
    12 | |         .filter(|(a, b)| a == b)\n13 | |         .filter(|(a, b)| a.to_ascii_lowercase().contains(substring))\n\
    14 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ O(n)\n    let mut count = 0; // This is an extra level of indirection that is\
    \ unnecessary but saves ~80% of run-time when profiling\n    for ch in string.chars()\
    \ {\n        if ch == substring {\n            count += 1;\n        }\n      \
    \  if ch.is_ascii_uppercase() {\n            count += 1;\n        }\n        if\
    \ ch.is_ascii_lowercase() {\n            count += 1;\n        }\n        if ch.is_digit()\
    \ {\n            count += 1;\n        }\n        if ch.is_punctuation() {\n  \
    \          count += 1;\n        }\n        if ch.is_whitespace() {\n         \
    \   count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjs4d_cvv.rs:12:18\n   |\n\
    12 |         if ch == substring {\n   |                  ^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n   --> /tmp/tmpjs4d_cvv.rs:21:15\n    |\n21  |    \
    \     if ch.is_digit() {\n    |               ^^^^^^^^- supplied 0 arguments\n\
    \    |               |\n    |               expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0599]: no method named `is_punctuation`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpjs4d_cvv.rs:24:15\n\
    \   |\n24 |         if ch.is_punctuation() {\n   |               ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii_punctuation`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count() + how_many_times(substring, substring)\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpby1vw811.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + how_many_times(substring,\
    \ substring)\n  |                                 ^^ no implementation for `&char\
    \ == String`\n  |\n  = help: the trait `PartialEq<String>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpby1vw811.rs:9:57\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + how_many_times(substring, substring)\n  |        \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpby1vw811.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| c == substring).count()\
    \ + how_many_times(substring, substring)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + how_many_times(substring, substring)).try_into().unwrap()\n\
    \  |     +                                                                   \
    \                     +++++++++++++++++++++\n\nerror[E0277]: cannot add `isize`\
    \ to `usize`\n --> /tmp/tmpby1vw811.rs:9:55\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + how_many_times(substring, substring)\n  |        \
    \                                               ^ no implementation for `usize\
    \ + isize`\n  |\n  = help: the trait `Add<isize>` is not implemented for `usize`\n\
    \  = help: the following other types implement trait `Add<Rhs>`:\n           \
    \ <&'a f32 as Add<f32>>\n            <&'a f64 as Add<f64>>\n            <&'a i128\
    \ as Add<i128>>\n            <&'a i16 as Add<i16>>\n            <&'a "
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(sub_char, sub_len)| sub_char\
    \ == sub_len)\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_5bmkd8r.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(sub_char, sub_len)| sub_char == sub_len)\n12 | |    \
    \     .count()\n   | |________________^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n   |         \
    \        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.contains(&substring) {\n        string.count(substring)\n    } else {\n\
    \        string.length()\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp485lqppt.rs:10:16\n\
    \    |\n10  |           string.count(substring)\n    |                  ^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp485lqppt.rs:12:16\n   |\n12 |         string.length()\n\
    \   |                ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut len = 0;\n    let mut pos = 0;\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        pos = string.find(substring, pos);\n        if pos < i {\n      \
    \      len += 1;\n        } else {\n            len += pos - i;\n        }\n \
    \       i += 1;\n    }\n    len\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp_wvn7v46.rs:13:22\n     |\n13   |         pos = string.find(substring,\
    \ pos);\n     |                      ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                      |\n     |                      expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_wvn7v46.rs:13:15\n   |\n10 |     let mut pos = 0;\n   |      \
    \             - expected due to this value\n...\n13 |         pos = string.find(substring,\
    \ pos);\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found\
    \ enum `Option`\n   |\n   = note: expected type `{integer}`\n              found\
    \ enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_wvn7v46.rs:21:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n21 |     len\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |     len.try_into().unwrap()\n   |  \
    \      ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 {\n        return 0\n    }\n    if substring.len() == 0 {\n\
    \        return 1\n    }\n    \n    let mut current_offset = 0;\n    let mut sub_offset\
    \ = 0;\n    \n    while current_offset < string.len() {\n        let mut match\
    \ = false;\n        for c in string.chars() {\n            if c == 'a' {\n   \
    \             current_offset += 1;\n                sub_offset = current_offset;\n\
    \                match = true;\n                break;\n            }\n      \
    \  }\n        \n        if match {\n            if string.chars().position(|c|\
    \ c == substring[sub_offset]).is_some() {\n                return string.chars().position(|c|\
    \ c == substring[sub_offset]).unwrap() + 1;\n            }\n        }\n      \
    \  \n        current_offset += 1;\n    }\n    \n    0\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `match`\n  --> /tmp/tmpszydyerp.rs:20:17\n\
    \   |\n20 |         let mut match = false;\n   |                 ^^^^^ expected\
    \ identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n\
    \   |\n20 |         let mut r#match = false;\n   |                 ++\n\nerror:\
    \ expected expression, found `=`\n  --> /tmp/tmpszydyerp.rs:25:23\n   |\n25 |\
    \                 match = true;\n   |                 ----- ^ expected expression\n\
    \   |                 |\n   |                 while parsing this `match` expression\n\
    \nerror: expected one of `.`, `?`, `{`, or an operator, found `current_offset`\n\
    \  --> /tmp/tmpszydyerp.rs:36:9\n   |\n30 |         if match {\n   |         \
    \   ----- while parsing this `match` expression\n...\n34 |         }\n   |   \
    \       - expected one of `.`, `?`, `{`, or an operator\n35 |         \n36 | \
    \        current_offset += 1;\n   |         ^^^^^^^^^^^^^^ unexpected token\n\n\
    error: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < string.len() && j < substring.len()\
    \ {\n        if string[i] == substring[j] {\n            i += 1;\n           \
    \ j += 1;\n        } else {\n            j += 1;\n        }\n    }\n    j\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptlqcuo7i.rs:12:12\n\
    \   |\n12 |         if string[i] == substring[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptlqcuo7i.rs:12:25\n   |\n12 |         if string[i] == substring[j]\
    \ {\n   |                         ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptlqcuo7i.rs:19:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n19 |     j\n   |     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |     j.try_into().unwrap()\n   |    \
    \  ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Check substring against both strings at the same time, then do an overlaps check\
    \ between them.\n    // This way the result is the same as simply counting the\
    \ number of occurrences of substring in string\n    string.chars().zip(string.chars()).count(|(start,\
    \ end), &_| {\n        start >= substring.len() || end >= substring.len() || substring[start..end]\
    \ == &substring[start..end]\n    })\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmplv8mped9.rs:12:85\n\
    \   |\n12 |         start >= substring.len() || end >= substring.len() || substring[start..end]\
    \ == &substring[start..end]\n   |                                            \
    \                                         ^^ no implementation for `str == &str`\n\
    \   |\n   = help: the trait `PartialEq<&str>` is not implemented for `str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmplv8mped9.rs:11:40\n\
    \    |\n11  |       string.chars().zip(string.chars()).count(|(start, end), &_|\
    \ {\n    |  ________________________________________^^^^^_-\n    | |         \
    \                               |\n    | |                                   \
    \     expected 0 arguments\n12  | |         start >= substring.len() || end >=\
    \ substring.len() || substring[start..end] == &substring[start..end]\n13  | |\
    \     })\n    | |_____- supplied 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplv8mped9.rs:11:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n...\n11 | /     string.chars().zip(string.chars()).count(|(start,\
    \ end), &_| {\n12 | |         start >= substring.len() || end >= substring.len()\
    \ || substring[start..end] == &substring[start..end]\n13 | |     })\n   | |______^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |     }).try_into().un"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter: isize = 0;\n    let mut start = 0;\n    let mut end = string.len();\n\
    \    let mut found = false;\n    while start < end {\n        if found {\n   \
    \         break;\n        }\n        if string.to_lowercase()[start] == substring.to_lowercase()[start\
    \ as usize] {\n            counter += 1;\n            start += 1;\n          \
    \  found = true;\n        } else if string.to_lowercase()[end as usize] == substring.to_lowercase()[end\
    \ as usize] {\n            counter += 1;\n            end -= 1;\n        } else\
    \ {\n            found = false;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpikdm5_kq.rs:17:12\n\
    \   |\n17 |         if string.to_lowercase()[start] == substring.to_lowercase()[start\
    \ as usize] {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpikdm5_kq.rs:17:44\n   |\n17 |         if string.to_lowercase()[start]\
    \ == substring.to_lowercase()[start as usize] {\n   |                        \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpikdm5_kq.rs:21:19\n   |\n21 |         } else if string.to_lowercase()[end\
    \ as usize] == substring.to_lowercase()[end as usize] {\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0\n\n    for c in string.chars() {\n        counter += !string.chars().any(|&c|\
    \ c == c);\n        counter += !substring.chars().any(|&c| c == c);\n    }\n\n\
    \    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpcqpmsh7m.rs:9:24\n\
    \   |\n9  |     let mut counter = 0\n   |                        ^ help: add `;`\
    \ here\n10 | \n11 |     for c in string.chars() {\n   |     --- unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcqpmsh7m.rs:12:41\n   |\n12 |\
    \         counter += !string.chars().any(|&c| c == c);\n   |                 \
    \                        ^--\n   |                                         ||\n\
    \   |                                         |expected due to this\n   |    \
    \                                     expected `char`, found reference\n   | \
    \                                        help: did you mean `c`: `&char`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0277]:\
    \ cannot add-assign `bool` to `{integer}`\n  --> /tmp/tmpcqpmsh7m.rs:12:17\n \
    \  |\n12 |         counter += !string.chars().any(|&c| c == c);\n   |        \
    \         ^^ no implementation for `{integer} += bool`\n   |\n   = help: the trait\
    \ `AddAssign<bool>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcqpmsh7m.rs:13:44\n   |\n13 |         counter += !substring.chars().any(|&c|\
    \ c == c);\n   |                                            ^--\n   |        \
    \                                    ||\n   |                                \
    \            |expected due to this\n   |                                     \
    \       expected `char`, found reference\n   |                               \
    \             help: did you mean `c`: `&char`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror[E0277]: cannot add-assign `bool`\
    \ to `{integer}`\n  --> /tmp/tmpcqpmsh7m.rs:13:17\n   |\n13 |"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ *c == substring).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0fxt9es4.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|c| *c == substring).count() + 1\n  |            \
    \                         ^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp0fxt9es4.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| *c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ *c == substring).count() + 1).try_into().unwrap()\n  |     +               \
    \                                       +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ *c == substring).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphu5zyu02.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|c| *c == substring).count()\n  |                \
    \                     ^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmphu5zyu02.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| *c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ *c == substring).count().try_into().unwrap()\n  |                          \
    \                             ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ TODO: Fix this so it doesnt have to copy the string\n    let mut found_at =\
    \ -1;\n    for (i, c) in string.chars().enumerate() {\n        if c == 'a' {\n\
    \            if found_at == -1 || i - (found_at + 1) <= substring.len() {\n  \
    \              found_at = i;\n            }\n        }\n    }\n    if found_at\
    \ == -1 {\n        return 0\n    }\n    substring.chars().filter(|c| *c == 'a').count()\
    \ - found_at\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpwa2ndd1g.rs:10:24\n\
    \   |\n10 |     let mut found_at = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpwa2ndd1g.rs:13:28\n   |\n13 | \
    \            if found_at == -1 || i - (found_at + 1) <= substring.len() {\n  \
    \ |                            ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpwa2ndd1g.rs:18:20\n   |\n18 |     if found_at == -1 {\n   |   \
    \                 ^^\n   |                    |\n   |                    cannot\
    \ apply unary operator `-`\n   |                    help: you may have meant the\
    \ maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot\
    \ be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwa2ndd1g.rs:21:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n21 |     substring.chars().filter(|c| *c == 'a').count()\
    \ - found_at\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n21 |     (substring.chars().filter(|c|\
    \ *c == 'a').count() - found_at).try_into().unwrap()\n   |     +             \
    \                                             +++++++++++++++++++++\n\nerror:\
    \ aborting due to 4 previous e"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for c in string.chars() {\n        if substring.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp8rqynv2r.rs:11:31\n\
    \     |\n11   |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ !string.contains(substring) {\n        return 0;\n    }\n    if let index =\
    \ string.find(substring, 0) {\n        if index + substring.length() == string.length()\
    \ {\n            return 1;\n        }\n        return 2;\n    }\n    0;\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmph1_nglsg.rs:9:25\n     |\n9    |     if !string.contains(substring)\
    \ {\n     |                -------- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                |\n     |                required by a\
    \ bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider borrowing here\n     |\n9    |     if !string.contains(&substring)\
    \ {\n     |                         +\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmph1_nglsg.rs:12:27\n     |\n12\
    \   |     if let index = string.find(substring, 0) {\n     |                 \
    \          ^^^^ ---------  - supplied 2 arguments\n     |                    \
    \       |\n     |                           expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0599]: no method named `length` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmph1_nglsg.rs:13:30\n\
    \   |\n13 |         if index + substring.length() == string.length() {\n   | \
    \                             ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmph1_nglsg.rs:13:49\n   |\n13 | \
    \        if index + substring.length() == string.length() {\n   |            \
    \                                     ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph1_nglsg.rs:8:57\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |    --------------                                       ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n18 |     0;\n   |      - help: remove this semicolon\n\
    \nerror: abort"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|&c|\
    \ c == substring).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7i8snja8.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|&c| c == substring).count()\n  |                \
    \                     ^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp7i8snja8.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|&c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|&c|\
    \ c == substring).count().try_into().unwrap()\n  |                           \
    \                            ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ TODO: Optimize algorithm\n\n    // Calculate total overlap with substring\n\
    \    let mut substring = substring.to_lowercase();\n    let mut total_overlap\
    \ = 0;\n    for (index, character) in string.chars().enumerate() {\n        if\
    \ character == substring {\n            total_overlap += 1;\n            if total_overlap\
    \ > substring.length {\n                return total_overlap;\n            }\n\
    \        } else {\n            total_overlap = 0;\n        }\n    }\n\n    //\
    \ If we reach the end of the string, return substring's length\n    if string[string.len()...]\
    \ == substring {\n        return substring.length;\n    }\n\n    // If substring\
    \ doesn't exist at all, return original string\n    substring.length\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmp019x64aj.rs:26:27\n   |\n\
    26 |     if string[string.len()...] == substring {\n   |                     \
    \      ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n26 |     if string[string.len()..]\
    \ == substring {\n   |                           ~~\nhelp: or `..=` for an inclusive\
    \ range\n   |\n26 |     if string[string.len()..=] == substring {\n   |      \
    \                     ~~~\n\nerror[E0586]: inclusive range with no end\n  -->\
    \ /tmp/tmp019x64aj.rs:26:27\n   |\n26 |     if string[string.len()...] == substring\
    \ {\n   |                           ^^^ help: use `..` instead\n   |\n   = note:\
    \ inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp019x64aj.rs:15:25\n   |\n15 |         if character\
    \ == substring {\n   |                         ^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp019x64aj.rs:17:42\n\
    \   |\n17 |             if total_overlap > substring.length {\n   |          \
    \                                ^^^^^^ unknown field\n\nerror[E0609]: no field\
    \ `length` on type `String`\n  --> /tmp/tmp019x64aj.rs:27:26\n   |\n27 |     \
    \    return substring.length;\n   |                          ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp019x64aj.rs:31:15\n\
    \   |\n31 |     substring.length\n   |               ^^^^^^ unknown field\n\n\
    error: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0586, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ If substring does not occur in string, return 0\n    string.count(substring).map(|c|\
    \ c as isize)\n        .unwrap_or(0)\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpi7bv6xy_.rs:10:12\n\
    \    |\n10  |       string.count(substring).map(|c| c as isize)\n    |       \
    \       ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.find(substring).map(|i|\
    \ string.as_bytes()[i..].iter().filter(|c| c == c).count() + 1)\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpy_fce9qt.rs:9:17\n     |\n9    |     string.find(substring).map(|i|\
    \ string.as_bytes()[i..].iter().filter(|c| c == c).count() + 1)\n     |      \
    \      ---- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n     | \
    \           |\n     |            required by a bound introduced by this call\n\
    \     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n9    |     string.find(&substring).map(|i|\
    \ string.as_bytes()[i..].iter().filter(|c| c == c).count() + 1)\n     |      \
    \           +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpy_fce9qt.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.find(substring).map(|i| string.as_bytes()[i..].iter().filter(|c|\
    \ c == c).count() + 1)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n  |\n  = note: expected type `isize`\n\
    \             found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0\n\n    for _ in string.chars() {\n        if let Some(pos) =\
    \ string.find(substring) {\n            counter += 1;\n            string = string.replace(pos,\
    \ substring.len(), \"\").to_string();\n        }\n    }\n\n    counter\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpe_fkyqxe.rs:9:24\n\
    \   |\n9  |     let mut counter = 0\n   |                        ^ help: add `;`\
    \ here\n10 | \n11 |     for _ in string.chars() {\n   |     --- unexpected token\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmpe_fkyqxe.rs:12:40\n\
    \     |\n12   |         if let Some(pos) = string.find(substring) {\n     |  \
    \                                 ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                                   |\n     |          \
    \                         required by a bound introduced by this call\n     |\n\
    \     = note: the trait bound `String: Pattern<'_>` is not satisfied\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n12   |         if let Some(pos) = string.find(&substring) {\n\
    \     |                                        +\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpe_fkyqxe.rs:14:29\n\
    \    |\n14  |             string = string.replace(pos, substring.len(), \"\").to_string();\n\
    \    |                             ^^^^^^^ ---  ---------------  -- supplied 3\
    \ arguments\n    |                             |\n    |                      \
    \       expected 2 arguments\n    |\nnote: associated function defined here\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().enumerate()\n\
    \        .filter(|(_, c)| c == substring[0])\n        .count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpv4sa8508.rs:10:31\n   |\n10 |         .filter(|(_, c)| c == substring[0])\n\
    \   |                               ^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv4sa8508.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars().enumerate()\n10 |\
    \ |         .filter(|(_, c)| c == substring[0])\n11 | |         .count()\n   |\
    \ |________________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    11 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    substring.chars().filter(|c|\
    \ string.contains(&c)).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpgv642t9m.rs:9:50\n\
    \     |\n9    |     substring.chars().filter(|c| string.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpgv642t9m.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   substring.chars().filter(|c| string.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     substring.chars().filter(|c|\
    \ string.contains(&c)).count().try_into().unwrap()\n  |                      \
    \                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .filter(|c| c.contains(&substring))\n        .count() as isize\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpytcawb4c.rs:10:23\n   |\n10 |         .filter(|c|\
    \ c.contains(&substring))\n   |                       ^^^^^^^^ method not found\
    \ in `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n    let mut start\
    \ = 0;\n    while start < string.len() && substring[start..].contains(&string[start..])\
    \ {\n        start += 1;\n    }\n    start\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoeqzqcwo.rs:16:5\n   |\n\
    8  | fn how_many_times(string: String, substring: String) -> isize {\n   |   \
    \                                                      ----- expected `isize`\
    \ because of return type\n...\n16 |     start\n   |     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n16 |     start.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| a == b)\n        .fold(0,\
    \ |acc, &(a, b)| acc + 1)\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdbi0gl9.rs:12:24\n   |\n\
    12 |         .fold(0, |acc, &(a, b)| acc + 1)\n   |                        ^^^^^^-\n\
    \   |                        |     |\n   |                        |     expected\
    \ due to this\n   |                        expected tuple, found reference\n \
    \  |\n   = note:  expected tuple `(char, char)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i <= string.len() && j <= substring.len()\
    \ {\n        if string[i] != substring[j] {\n            i += 1;\n           \
    \ j = 0;\n        } else {\n            j += 1;\n        }\n    }\n    return\
    \ if substring[j..].len() == 0 {\n        0\n    } else {\n        i + 1\n   \
    \ };\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnsh9lji9.rs:15:12\n\
    \   |\n15 |         if string[i] != substring[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnsh9lji9.rs:15:25\n   |\n15 |         if string[i] != substring[j]\
    \ {\n   |                         ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsh9lji9.rs:25:9\n\
    \   |\n25 |         i + 1\n   |         ^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         (i + 1).try_into().unwrap()\n   |    \
    \     +     +++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < string.len() && j < substring.len()\
    \ {\n        if string[i] == substring[j] {\n            i += 1;\n           \
    \ j += 1;\n        } else {\n            j += 1;\n        }\n    }\n    i + (j\
    \ - 1)\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiae0t48t.rs:12:12\n\
    \   |\n12 |         if string[i] == substring[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpiae0t48t.rs:12:25\n   |\n12 |         if string[i] == substring[j]\
    \ {\n   |                         ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiae0t48t.rs:19:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n19 |     i + (j - 1)\n   |     ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     (i + (j - 1)).try_into().unwrap()\n\
    \   |     +           +++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`."
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c != substring[0] && c != substring[1]).count() as isize\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpnuojrlbn.rs:9:36\n  |\n9 |     string.chars().filter(|c| c != substring[0]\
    \ && c != substring[1]).count() as isize\n  |                                \
    \    ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n  |\n  = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n --> /tmp/tmpnuojrlbn.rs:9:57\n\
    \  |\n9 |     string.chars().filter(|c| c != substring[0] && c != substring[1]).count()\
    \ as isize\n  |                                                         ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().count(|c|\
    \ string.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpqpresdos.rs:9:20\n    |\n9   |     string.chars().count(|c| string.chars().any(|c|\
    \ c == c))\n    |                    ^^^^^ ----------------------------------\
    \ supplied 1 argument\n    |                    |\n    |                    expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqpresdos.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().count(|c| string.chars().any(|c| c == c))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ string.chars().any(|c| c == c)).try_into().unwrap()\n  |                   \
    \                                          ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(char, substring)| char ==\
    \ substring)\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7vny5aht.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(char, substring)| char == substring)\n12 | |        \
    \ .count()\n   | |________________^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n12 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = HashMap::new();\n    for pos in string.char_indices() {\n      \
    \  let pos = pos.0 as usize;\n        let len = substring.length();\n        if\
    \ len > 0 && substring[0..len].contains(&string[pos]) {\n            count +=\
    \ 1;\n        }\n    }\n    count.len()\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp7ymbrh17.rs:9:21\n  |\n9 |     let mut count = HashMap::new();\n  |\
    \                     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0599]: no\
    \ method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp7ymbrh17.rs:12:29\n   |\n12 |         let len = substring.length();\n\
    \   |                             ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp7ymbrh17.rs:13:51\n   |\n13 |         if len > 0 &&\
    \ substring[0..len].contains(&string[pos]) {\n   |                           \
    \                        ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(first, second)| first == second)\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqc36zr8b.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(first, second)| first == second)\n12 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n12 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter(|(i, char)| substring.contains(char))\n        .count()\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp_er5ifk1.rs:10:48\n\
    \     |\n10   |         .filter(|(i, char)| substring.contains(char))\n     |\
    \                                       -------- ^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                       |\n    \
    \ |                                       required by a bound introduced by this\
    \ call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n10   |         .filter(|(i, char)|\
    \ substring.contains(*char))\n     |                                         \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_er5ifk1.rs:9:5\n \
    \  |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.char_indices()\n10 | |   \
    \      .filter(|(i, char)| substring.contains(char))\n11 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n11 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut cnt = 0;\n    for i in string.rindex() {\n        if string.contains(&substring)\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rindex` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp9tviewnh.rs:10:21\n   |\n10 |     for i in string.rindex()\
    \ {\n   |                     ^^^^^^ help: there is an associated function with\
    \ a similar name: `find`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut cnt = 0;\n    for substr in string.split() {\n        if substr == substring\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpdxzsya65.rs:10:26\n     |\n10   |     for substr in string.split()\
    \ {\n     |                          ^^^^^- supplied 0 arguments\n     |     \
    \                     |\n     |                          expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut n = 0;\n    for c in string.chars() {\n        if c == substring {\n   \
    \         n += 1;\n        }\n        if c.is_ascii_alphanumeric() {\n       \
    \     n += 1;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplg4ef7gn.rs:11:17\n   |\n\
    11 |         if c == substring {\n   |                 ^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| (a == b) || (a < b)\
    \ || (a > b))\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbef7cz9s.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a, b)| (a == b) || (a < b) || (a > b))\n12 | |      \
    \   .count()\n   | |________________^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n   |         \
    \        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars())\n\
    \        .filter(|(c1, c2)| c1 == c2)\n        .filter(|(c1, c2)| c1 < c2)\n \
    \       .count();\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpthw8k6s1.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpexa87312.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpexa87312.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index_to_search = 0;\n    while index_to_search\
    \ < string.len() {\n        let index_to_start = index_to_search;\n        let\
    \ index_to_end = string.find(substring, index_to_search);\n        if index_to_end\
    \ == -1 {\n            count = count + 1;\n            index_to_search = index_to_start;\n\
    \        } else {\n            count = count + index_to_end - index_to_start;\n\
    \            index_to_search = index_to_end;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp4lmx_0ag.rs:13:35\n     |\n13   |         let index_to_end =\
    \ string.find(substring, index_to_search);\n     |                           \
    \        ^^^^ ---------  --------------- supplied 2 arguments\n     |        \
    \                           |\n     |                                   expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4lmx_0ag.rs:14:28\n   |\n14 |         if index_to_end\
    \ == -1 {\n   |                            ^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n14 |         if index_to_end\
    \ == Some(-1) {\n   |                            +++++  +\n\nerror[E0277]: cannot\
    \ add `Option<usize>` to `{integer}`\n  --> /tmp/tmp4lmx_0ag.rs:18:27\n   |\n\
    18 |             count = count + index_to_end - index_to_start;\n   |        \
    \                   ^ no implementation for `{integer} + Option<usize>`\n   |\n\
    \   = help: the trait `Add<Option<usize>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4lmx_0ag.rs:19:31\n   |\n10 |     let mut index_to_search\
    \ = 0;\n   |                               - expected due to this value\n...\n\
    19 |             index_to_search = index_to_end;\n   |                       \
    \        ^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note:\
    \ expected type `usize`\n              found enum `Option<usize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0308.\nFor more information about a"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for s in string.iter() {\n        if s.contains(substring)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpxhivul5m.rs:10:21\n   |\n10 |     for s in string.iter()\
    \ {\n   |                     ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n10 |     for s in string.chars()\
    \ {\n   |                     ~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count() + how_many_times_without_overlap(string, substring)\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `how_many_times_without_overlap` in\
    \ this scope\n --> /tmp/tmpd3k1hvd1.rs:9:57\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + how_many_times_without_overlap(string, substring)\n\
    \  |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: can't compare `&char` with `String`\n\
    \ --> /tmp/tmpd3k1hvd1.rs:9:33\n  |\n9 |     string.chars().filter(|c| c == substring).count()\
    \ + how_many_times_without_overlap(string, substring)\n  |                   \
    \              ^^ no implementation for `&char == String`\n  |\n  = help: the\
    \ trait `PartialEq<String>` is not implemented for `&char`\n  = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpd3k1hvd1.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + how_many_times_without_overlap(string, substring)\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + how_many_times_without_overlap(string, substring)).try_into().unwrap()\n\
    \  |     +                                                                   \
    \                                  +++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().count(|c|\
    \ string.contains(substring))\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpf_bd06u6.rs:9:46\n     |\n9    |     string.chars().count(|c| string.contains(substring))\n\
    \     |                                     -------- ^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                                     |\n     |\
    \                                     required by a bound introduced by this call\n\
    \     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider borrowing here\n     |\n9    |     string.chars().count(|c| string.contains(&substring))\n\
    \     |                                              +\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpf_bd06u6.rs:9:20\n\
    \    |\n9   |     string.chars().count(|c| string.contains(substring))\n    |\
    \                    ^^^^^ ------------------------------ supplied 1 argument\n\
    \    |                    |\n    |                    expected 0 arguments\n \
    \   |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpf_bd06u6.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|c|\
    \ string.contains(substring))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ string.contains(substring)).try_into().unwrap()\n  |                       \
    \                                  ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.find(substring) == String::npos {\n        return 0;\n    }\n    let\
    \ mut count = 0;\n    let mut pos = 0;\n    let mut last_pos = 0;\n    while pos\
    \ < string.len() {\n        if string.find(substring, pos) != String::npos {\n\
    \            count = count + 1;\n            last_pos = pos;\n        }\n    \
    \    pos = pos + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpn714tyey.rs:9:20\n     |\n9    |     if string.find(substring) ==\
    \ String::npos {\n     |               ---- ^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |               |\n     |               required\
    \ by a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n9    |     if string.find(&substring)\
    \ == String::npos {\n     |                    +\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \ --> /tmp/tmpn714tyey.rs:9:42\n  |\n9 |     if string.find(substring) == String::npos\
    \ {\n  |                                          ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0061]: this function takes 1 argument but\
    \ 2 arguments were supplied\n    --> /tmp/tmpn714tyey.rs:16:19\n     |\n16   |\
    \         if string.find(substring, pos) != String::npos {\n     |           \
    \        ^^^^ ---------  --- supplied 2 arguments\n     |                   |\n\
    \     |                   expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no function or associated item named `npos` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpn714tyey.rs:16:51\n\
    \   |\n16 |         if string.find(substring, pos) != String::npos {\n   |   \
    \                                                ^^^^ function or associated item\
    \ not found in `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmprlry6nep.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmprlry6nep.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().count(|c|\
    \ *c == substring)\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmppi2jb0hi.rs:9:27\n\
    \  |\n9 |     string.chars().count(|c| *c == substring)\n  |                 \
    \          ^ consider giving this closure parameter a type\n  |\n  = note: type\
    \ must be known at this point\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmppi2jb0hi.rs:9:20\n    |\n9   | \
    \    string.chars().count(|c| *c == substring)\n    |                    ^^^^^\
    \ ------------------- supplied 1 argument\n    |                    |\n    | \
    \                   expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n --> /tmp/tmppi2jb0hi.rs:9:5\n  |\n\
    8 | fn how_many_times(string: String, substring: String) -> isize {\n  |     \
    \                                                    ----- expected `isize` because\
    \ of return type\n9 |     string.chars().count(|c| *c == substring)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ *c == substring).try_into().unwrap()\n  |                                  \
    \            ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .position(|c| string.find(substring) == Some(c.to_ascii_lowercase()))\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpn_5un_qe.rs:10:35\n     |\n10   |         .position(|c| string.find(substring)\
    \ == Some(c.to_ascii_lowercase()))\n     |                              ---- ^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \         |\n     |                              required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is\
    \ not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n10   |         .position(|c|\
    \ string.find(&substring) == Some(c.to_ascii_lowercase()))\n     |           \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn_5un_qe.rs:10:54\n\
    \   |\n10 |         .position(|c| string.find(substring) == Some(c.to_ascii_lowercase()))\n\
    \   |                                                      ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `char`\n\nerror[E0599]: `Option<usize>` is not an iterator\n\
    \   --> /tmp/tmpn_5un_qe.rs:11:10\n    |\n11  |           .count()\n    |    \
    \        ^^^^^ `Option<usize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<usize>: Iterator`\n  \
    \          which is required by `&mut Option<usize>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `count` on type `Filter<Zip<Chars<'_>,\
    \ Chars<'_>>, [closure@/tmp/tmp2xrymeuf.rs:9:50: 9:74]>`\n --> /tmp/tmp2xrymeuf.rs:9:76\n\
    \  |\n9 |     string.chars().zip(substring.chars()).filter(|&(ref a, ref b)| a\
    \ == b).count\n  |                                                           \
    \                 ^^^^^ method, not a field\n  |\nhelp: use parentheses to call\
    \ the method\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count()\n  |                                            \
    \                                     ++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars())\n\
    \        .filter(|(a, b)| a == b)\n        .count();\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp47gzohst.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .chars()\n        .filter(|c| *c == substring.as_bytes())\n        .count()\
    \ - 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptb40otdx.rs:11:27\n   |\n\
    11 |         .filter(|c| *c == substring.as_bytes())\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&[u8]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptb40otdx.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string\n10 | |         .chars()\n11 | |         .filter(|c| *c == substring.as_bytes())\n\
    12 | |         .count() - 1\n   | |____________________^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n9  ~     (string\n10 |         .chars()\n\
    11 |         .filter(|c| *c == substring.as_bytes())\n12 ~         .count() -\
    \ 1).try_into().unwrap()\n   |\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ substring.contains(c)).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp08yxrobc.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp08yxrobc.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut cnt = 0;\n    let start_idx = string.find(substring);\n    while let Some(end_idx)\
    \ = string.find(substring, start_idx + 1) {\n        cnt += 1;\n        start_idx\
    \ = end_idx;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpnw15m1m0.rs:10:33\n     |\n10   |     let start_idx = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n10   |     let start_idx = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpnw15m1m0.rs:11:64\n   |\n11 |     while let Some(end_idx) = string.find(substring,\
    \ start_idx + 1) {\n   |                                                     \
    \ --------- ^ - {integer}\n   |                                              \
    \        |\n   |                                                      Option<usize>\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpnw15m1m0.rs:11:38\n     |\n11   |     while let Some(end_idx)\
    \ = string.find(substring, start_idx + 1) {\n     |                          \
    \            ^^^^ ---------  ------------- supplied 2 arguments\n     |      \
    \                                |\n     |                                   \
    \   expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnw15m1m0.rs:13:21\n   |\n10 |     let start_idx\
    \ = string.find(substring);\n   |                     ---------------------- expected\
    \ due to this value\n...\n13 |         start_idx = end_idx;\n   |            \
    \         ^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n13 |         start_idx = Some(end_idx);\n   |  \
    \                   +"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut position = 0;\n    while position < string.len() {\n        if string.starts_with(substring,\
    \ position) {\n            return 1;\n        }\n        position += 1;\n    }\n\
    \    0\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp0n7yh1gw.rs:11:19\n     |\n11   |         if string.starts_with(substring,\
    \ position) {\n     |                   ^^^^^^^^^^^ ---------  -------- supplied\
    \ 2 arguments\n     |                   |\n     |                   expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| a == b)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprz7p90b4.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a, b)| a == b)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    substring.chars().fold(0,\
    \ |acc, c| acc + string.count(c))\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp2o7bz8xc.rs:9:53\n\
    \    |\n9   |       substring.chars().fold(0, |acc, c| acc + string.count(c))\n\
    \    |                                                       ^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count() + how_many_times(substring, string.chars().filter(|c|\
    \ c != substring).last())\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppdorq5uq.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + how_many_times(substring,\
    \ string.chars().filter(|c| c != substring).last())\n  |                     \
    \            ^^ no implementation for `&char == String`\n  |\n  = help: the trait\
    \ `PartialEq<String>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `String`\n\
    \ --> /tmp/tmppdorq5uq.rs:9:111\n  |\n9 |     string.chars().filter(|c| c == substring).count()\
    \ + how_many_times(substring, string.chars().filter(|c| c != substring).last())\n\
    \  |                                                                         \
    \                                      ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmppdorq5uq.rs:9:83\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + how_many_times(substring, string.chars().filter(|c|\
    \ c != substring).last())\n  |                                               \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n  |\n  = note: expected struct\
    \ `String`\n               found enum `Option<char>`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmppdorq5uq.rs:9:57\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + how_many_times(substring, string.chars().filter(|c|\
    \ c != substring).last())\n  |                                               \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmppdorq5uq.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp4xd0uqlx.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp4xd0uqlx.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |                           \
    \                           ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = std::cmp::min::min(string.chars().count(|c| *c == substring), string.len());\n\
    \    if string.find(substring) != string.find(string.rsub(substring).unwrap())\
    \ { // If substring is contained in another substring\n        count = count +\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: expected type, found function `min` in\
    \ `cmp`\n --> /tmp/tmpmi633xa9.rs:9:31\n  |\n9 |     let mut count = std::cmp::min::min(string.chars().count(|c|\
    \ *c == substring), string.len());\n  |                               ^^^ expected\
    \ type, found function `min` in `cmp`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpmi633xa9.rs:9:55\n    |\n9   | \
    \    let mut count = std::cmp::min::min(string.chars().count(|c| *c == substring),\
    \ string.len());\n    |                                                      \
    \ ^^^^^ ------------------- supplied 1 argument\n    |                       \
    \                                |\n    |                                    \
    \                   expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \    --> /tmp/tmpmi633xa9.rs:10:20\n     |\n10   |     if string.find(substring)\
    \ != string.find(string.rsub(substring).unwrap()) { // If substring is contained\
    \ in another substring\n     |               ---- ^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |               |\n     |               required\
    \ by a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n10   |     if string.find(&substring)\
    \ != string.find(string.rsub(substring).unwrap()) { // If substring is contained\
    \ in another substring\n     |                    +\n\nerror[E0599]: no method\
    \ named `rsub` found for struct `String` in the current scope\n  --> /tmp/tmpmi633xa9.rs:10:53\n\
    \   |\n10 |     if string.find(substring) != string.find(string.rsub(substring).unwrap())\
    \ { // If substring is contained in another substring\n   |                  \
    \                                   ^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome e"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() {\n        return 0;\n    }\n    if substring.is_empty() {\n\
    \        return 1;\n    }\n\n    match find_index(&string, &substring) {\n   \
    \     Some(index) => index + how_many_times(&string[index..], &substring),\n \
    \       None => 0,\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_index` in this scope\n  --> /tmp/tmp3p2kih9r.rs:16:11\n\
    \   |\n16 |     match find_index(&string, &substring) {\n   |           ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3p2kih9r.rs:17:47\n\
    \   |\n17 |         Some(index) => index + how_many_times(&string[index..], &substring),\n\
    \   |                                               ^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n17 |         Some(index) => index + how_many_times((&string[index..]).to_string(),\
    \ &substring),\n   |                                               +         \
    \       +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3p2kih9r.rs:17:65\n\
    \   |\n17 |         Some(index) => index + how_many_times(&string[index..], &substring),\n\
    \   |                                                                 ^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n17 -         Some(index) => index + how_many_times(&string[index..],\
    \ &substring),\n17 +         Some(index) => index + how_many_times(&string[index..],\
    \ substring),\n   | \n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp3p2kih9r.rs:17:30\n\
    \   |\n17 |         Some(index) => index + how_many_times(&string[index..], &substring),\n\
    \   |                              ^ no implementation for `usize + isize`\n \
    \  |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .filter(|c| c == substring)\n        .count()\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n  --> /tmp/tmp9c2tz4fi.rs:10:23\n\
    \   |\n10 |         .filter(|c| c == substring)\n   |                       ^^\
    \ no implementation for `&char == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9c2tz4fi.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars()\n10 | |         .filter(|c|\
    \ c == substring)\n11 | |         .count()\n   | |________________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0;\n    string.char_indices()\n        .filter(|&(x, y)| x == substring[0]\
    \ && y != substring[0])\n        .for_each(|&(x, y)| i += 1);\n    i\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpjzybzdsn.rs:11:32\n   |\n11 |         .filter(|&(x, y)| x == substring[0]\
    \ && y != substring[0])\n   |                                ^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpjzybzdsn.rs:11:53\n   |\n11 |         .filter(|&(x, y)| x == substring[0]\
    \ && y != substring[0])\n   |                                                \
    \     ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzybzdsn.rs:12:20\n   |\n12 |         .for_each(|&(x,\
    \ y)| i += 1);\n   |                    ^^^^^^-\n   |                    |   \
    \  |\n   |                    |     expected due to this\n   |               \
    \     expected tuple, found reference\n   |\n   = note:  expected tuple `(usize,\
    \ char)`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut position = 0;\n\n    while position < string.len() {\n        match string.find(substring,\
    \ position) {\n            Some(index) => {\n                position += index;\n\
    \            }\n            None => return 0,\n        }\n        position +=\
    \ 1;\n    }\n\n    string.len()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp6b5w_zm9.rs:12:22\n     |\n12   |         match string.find(substring,\
    \ position) {\n     |                      ^^^^ ---------  -------- supplied 2\
    \ arguments\n     |                      |\n     |                      expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6b5w_zm9.rs:21:5\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n...\n\
    21 |     string.len()\n   |     ^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     string.len().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0\n    let mut index = string.find(substring)\n    while index >=\
    \ 0 {\n        count = count + 1;\n        index = string.find(substring, index\
    \ + 1)\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmporvssgpv.rs:9:22\n\
    \   |\n9  |     let mut count = 0\n   |                      ^ help: add `;` here\n\
    10 |     let mut index = string.find(substring)\n   |     --- unexpected token\n\
    \nerror: expected `;`, found keyword `while`\n  --> /tmp/tmporvssgpv.rs:10:43\n\
    \   |\n10 |     let mut index = string.find(substring)\n   |                 \
    \                          ^ help: add `;` here\n11 |     while index >= 0 {\n\
    \   |     ----- unexpected token\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n    --> /tmp/tmporvssgpv.rs:10:33\n     |\n10   | \
    \    let mut index = string.find(substring)\n     |                          \
    \  ---- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n     |     \
    \                       |\n     |                            required by a bound\
    \ introduced by this call\n     |\n     = note: the trait bound `String: Pattern<'_>`\
    \ is not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n10   |     let mut index\
    \ = string.find(&substring)\n     |                                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmporvssgpv.rs:11:20\n   |\n11 |     while index\
    \ >= 0 {\n   |                    ^ expected enum `Option`, found integer\n  \
    \ |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n11 |     while index >= Some(0)\
    \ {\n   |                    +++++ +\n\nerror[E0369]: cannot add `{integer}` to\
    \ `Option<usize>`\n  --> /tmp/tmporvssgpv.rs:13:46\n   |\n13 |         index =\
    \ string.find(substring, index + 1)\n   |                                    \
    \    ----- ^ - {integer}\n   |                                        |\n   |\
    \                                        Option<usize>\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmporvssgpv.rs:13:24\n\
    \     |\n13   |         index = string.find(substring, "
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    for (index, char) in string.chars().enumerate() {\n  \
    \      if char == substring {\n            counter += 1;\n            if index\
    \ != string.chars().last().unwrap() {\n                if char == string.chars()[index\
    \ + 1].unwrap() {\n                    counter += 1;\n                }\n    \
    \        }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplh00rx52.rs:11:20\n   |\n\
    11 |         if char == substring {\n   |                    ^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplh00rx52.rs:13:25\n\
    \   |\n13 |             if index != string.chars().last().unwrap() {\n   |   \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `char`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  -->\
    \ /tmp/tmplh00rx52.rs:14:28\n   |\n14 |                 if char == string.chars()[index\
    \ + 1].unwrap() {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter_map(|c|\
    \ {\n        if c.to_ascii_lowercase() == substring.to_ascii_lowercase() {\n \
    \           Some(c)\n        } else {\n            None\n        }\n    }).count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1n5uaqgh.rs:10:38\n   |\n\
    10 |         if c.to_ascii_lowercase() == substring.to_ascii_lowercase() {\n \
    \  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n5uaqgh.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars().filter_map(|c| {\n\
    10 | |         if c.to_ascii_lowercase() == substring.to_ascii_lowercase() {\n\
    11 | |             Some(c)\n12 | |         } else {\n13 | |             None\n\
    14 | |         }\n15 | |     }).count() + 1\n   | |__________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n9  ~     (string.chars().filter_map(|c|\
    \ {\n10 |         if c.to_ascii_lowercase() == substring.to_ascii_lowercase()\
    \ {\n11 |             Some(c)\n12 |         } else {\n13 |             None\n\
    14 |         }\n ...\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    substring.chars().zip(string.chars()).filter(|(a,\
    \ b)| a == b).count();\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk0g7ztbv.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for c in string.chars() {\n        if substring.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpopoxz0aj.rs:11:31\n\
    \     |\n11   |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count() as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpobti7pyi.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .chars()\n        .filter_map(|c| {\n            if let Some(i) = get_index(substring,\
    \ c) {\n                Some(i)\n            } else {\n                None\n\
    \            }\n        })\n        .fold(0, |a, b| {\n            if a > b {\n\
    \                a\n            } else {\n                b\n            }\n \
    \       })\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_index` in this scope\n  --> /tmp/tmpr8mng1qg.rs:12:30\n\
    \   |\n12 |             if let Some(i) = get_index(substring, c) {\n   |     \
    \                         ^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n   \
    \     if string[pos] == substring {\n            counter += 1;\n        }\n  \
    \      pos += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn64jqh0d.rs:12:12\n\
    \   |\n12 |         if string[pos] == substring {\n   |            ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter(|&(_, index)| string.chars().any(|c| c == c))\n        .filter(|&(_,\
    \ index)| string.chars().any(|c| c == c))\n        .filter(|&(_, index)| string.chars().contains(&substring[..]))\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp1w2e0_ht.rs:12:46\n   |\n12 |         .filter(|&(_,\
    \ index)| string.chars().contains(&substring[..]))\n   |                     \
    \                         ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1w2e0_ht.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.char_indices()\n10 | |         .filter(|&(_, index)| string.chars().any(|c|\
    \ c == c))\n11 | |         .filter(|&(_, index)| string.chars().any(|c| c == c))\n\
    12 | |         .filter(|&(_, index)| string.chars().contains(&substring[..]))\n\
    13 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ len = string.len();\n    let substring = substring.to_string();\n    let mut\
    \ pos = 0;\n    let mut count = 0;\n    while pos < len {\n        if string[pos]\
    \ == substring[0] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[1] {\n            count += 1;\n         \
    \   pos += 1;\n        }\n        if string[pos] == substring[2] {\n         \
    \   count += 1;\n            pos += 1;\n        }\n        if string[pos] == substring[3]\
    \ {\n            count += 1;\n            pos += 1;\n        }\n        if string[pos]\
    \ == substring[4] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[5] {\n            count += 1;\n         \
    \   pos += 1;\n        }\n        if string[pos] == substring[6] {\n         \
    \   count += 1;\n            pos += 1;\n        }\n        if string[pos] == substring[7]\
    \ {\n            count += 1;\n            pos += 1;\n        }\n        if string[pos]\
    \ == substring[8] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[9] {\n            count += 1;\n         \
    \   pos += 1;\n        }\n        if string[pos] == substring[10] {\n        \
    \    count += 1;\n            pos += 1;\n        }\n        if string[pos] ==\
    \ substring[11] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[12] {\n            count += 1;\n        \
    \    pos += 1;\n        }\n        if string[pos] == substring[13] {\n       \
    \     count += 1;\n            pos += 1;\n        }\n        if string[pos] ==\
    \ substring[14] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[15] {\n            count += 1;\n        \
    \    pos += 1;\n        }\n        if string[pos] == substring[16] {\n       \
    \     count += 1;\n            pos += 1;\n        }\n        if string[pos] ==\
    \ substring[17] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[18] {\n            count += 1;\n        \
    \    pos += 1;\n        }\n        if string[pos] == substring[19] {\n       \
    \     count += 1;\n            pos += 1;\n        }\n        if string[pos] ==\
    \ substring[20] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[21] {\n            count += 1;\n        \
    \    pos += 1;\n        }\n        if string[pos] == substring[22] {\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqibegr2c.rs:111:3\n\
    \    |\n8   | fn how_many_times(string: String, substring: String) -> isize {\n\
    \    |                                                               - unclosed\
    \ delimiter\n...\n13  |     while pos < len {\n    |                     - unclosed\
    \ delimiter\n...\n102 |         if string[pos] == substring[22] {\n    |     \
    \                                    - this delimiter might not be properly closed...\n\
    103 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    111 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqibegr2c.rs:14:12\n   |\n14 |         if string[pos] == substring[0]\
    \ {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpqibegr2c.rs:14:27\n\
    \   |\n14 |         if string[pos] == substring[0] {\n   |                   \
    \        ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqibegr2c."
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ The algorithm works fine only when substring is smaller than string.\n    //\
    \ When substring is longer than string, all possible substrings have to be checked\n\
    \    // to ensure that the substrings do not overlap.\n    if substring.length\
    \ < string.length {\n        return 0.into();\n    }\n    // Keep a count of the\
    \ number of occurrences.\n    let mut count = 0usize;\n\n    // Iterate from beginning\
    \ to end. Add 1 to count for each time the substring occurs.\n    for i in 0..substring.length\
    \ {\n        if string.contains(&substring[..i]) {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmp1_fjgwem.rs:12:18\n\
    \   |\n12 |     if substring.length < string.length {\n   |                  ^^^^^^\
    \ unknown field\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp1_fjgwem.rs:12:34\n\
    \   |\n12 |     if substring.length < string.length {\n   |                  \
    \                ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type\
    \ `String`\n  --> /tmp/tmp1_fjgwem.rs:19:27\n   |\n19 |     for i in 0..substring.length\
    \ {\n   |                           ^^^^^^ unknown field\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1_fjgwem.rs:24:5\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n...\n\
    24 |     count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |     count.try_into().unwrap()\n   |          ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.is_empty() {\n        return 0;\n    }\n    let mut iter_string =\
    \ string.char_indices();\n    let mut iter = substring.char_indices();\n    loop\
    \ {\n        if iter_string.next().is_none() {\n            break;\n        }\n\
    \        if iter.next().is_none() {\n            continue;\n        }\n      \
    \  if iter_string.next().unwrap().0 == iter.next().unwrap().0 {\n            iter.next()\n\
    \                .map(|c| match c {\n                    None => true,\n     \
    \               Some(c) => c == iter.next().unwrap().0\n                })\n \
    \               .count()\n        } else {\n            iter.next()\n        \
    \        .map(|c| match c {\n                    None => false,\n            \
    \        Some(c) => c == iter.next().unwrap().0\n                })\n        \
    \        .count()\n        }\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9rc26j7n.rs:16:13\n   |\n\
    8  | fn how_many_times(string: String, substring: String) -> isize {\n   |   \
    \                                                      ----- expected `isize`\
    \ because of return type\n...\n16 |             break;\n   |             ^^^^^\n\
    \   |             |\n   |             expected `isize`, found `()`\n   |     \
    \        help: give it a value of the expected type: `break 42`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9rc26j7n.rs:24:21\n   |\n23 |              \
    \   .map(|c| match c {\n   |                                - this expression\
    \ has type `(usize, char)`\n24 |                     None => true,\n   |     \
    \                ^^^^ expected tuple, found enum `Option`\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9rc26j7n.rs:25:21\n   |\n23 |              \
    \   .map(|c| match c {\n   |                                - this expression\
    \ has type `(usize, char)`\n24 |                     None => true,\n25 |     \
    \                Some(c) => c == iter.next().unwrap().0\n   |                \
    \     ^^^^^^^ expected tuple, found enum `Option`\n   |\n   = note: expected tuple\
    \ `(usize, char)`\n               found enum `Option<_>`\n\nerror[E0599]: `Option<bool>`\
    \ is not an iterator\n   --> /tmp/tmp9rc26j7n.rs:27:18\n    |\n27  |         \
    \          .count()\n    |                    ^^^^^ `Option<bool>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<bool>: Iterator`\n            which is required by `&mut Option<bool>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rc26j7n.rs:31:21\n\
    \   |\n30 |                 .map(|c| match c {\n   |                         \
    \       - this expression has type `(usize, char)`\n31 |                     None\
    \ => false,\n   |                     ^^^^ expected tuple, found enum `Option`\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9rc26j7n.rs:32:21"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().count(|x|\
    \ x == substring)\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp2qf5k7k5.rs:9:20\n    |\n9   |     string.chars().count(|x| x\
    \ == substring)\n    |                    ^^^^^ ------------------ supplied 1\
    \ argument\n    |                    |\n    |                    expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp2qf5k7k5.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|x|\
    \ x == substring)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().count(|x| x\
    \ == substring).try_into().unwrap()\n  |                                     \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .split_ascii_lowercase()\n        .rfind(substring.to_ascii_lowercase())\n\
    \        .unwrap_or(0)\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_ascii_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpl_261ayj.rs:10:10\n   |\n10 | \
    \        .split_ascii_lowercase()\n   |          ^^^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Find start position\n    let start = string.find(substring).unwrap();\n\n  \
    \  // Find end position\n    let end = string.rfind(substring).unwrap();\n\n \
    \   // Return how many times substring occurs\n    (end - start).abs() as isize\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpcd7sgfd6.rs:10:29\n     |\n10   |     let start = string.find(substring).unwrap();\n\
    \     |                        ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                        |\n     |                     \
    \   required by a bound introduced by this call\n     |\n     = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing here\n\
    \     |\n10   |     let start = string.find(&substring).unwrap();\n     |    \
    \                         +\n\nerror[E0277]: expected a `FnMut<(char,)>` closure,\
    \ found `String`\n  --> /tmp/tmpcd7sgfd6.rs:13:28\n   |\n13 |     let end = string.rfind(substring).unwrap();\n\
    \   |                      ----- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \   |                      |\n   |                      required by a bound introduced\
    \ by this call\n   |\n   = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nhelp: consider borrowing here\n   |\n13 |     let end = string.rfind(&substring).unwrap();\n\
    \   |                            +\n\nerror[E0599]: no method named `abs` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmpcd7sgfd6.rs:16:19\n   |\n\
    16 |     (end - start).abs() as isize\n   |                   ^^^ method not found\
    \ in `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().position(|c|\
    \ c == substring).map(|i| i + substring.length()).sum()\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpuca7ul6d.rs:9:38\n  |\n9 |\
    \     string.chars().position(|c| c == substring).map(|i| i + substring.length()).sum()\n\
    \  |                                      ^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n --> /tmp/tmpuca7ul6d.rs:9:71\n  |\n9 |     string.chars().position(|c|\
    \ c == substring).map(|i| i + substring.length()).sum()\n  |                 \
    \                                                      ^^^^^^ help: there is an\
    \ associated function with a similar name: `len`\n\nerror[E0599]: `Option<usize>`\
    \ is not an iterator\n   --> /tmp/tmpuca7ul6d.rs:9:81\n    |\n9   |       string.chars().position(|c|\
    \ c == substring).map(|i| i + substring.length()).sum()\n    |               \
    \                                                                    ^^^ `Option<usize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .chars()\n        .zip(substring.chars())\n        .filter(|(a, b)| a\
    \ == b)\n        .count() as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpafwuid_b.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Find how many times `substring` is in `string`\n    string\n        .chars()\n\
    \        .filter(|c| c.contains(&substring))\n        .count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpxnzm7kbo.rs:12:23\n   |\n12 |         .filter(|c|\
    \ c.contains(&substring))\n   |                       ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnzm7kbo.rs:10:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  |       // Find how many times `substring`\
    \ is in `string`\n10 | /     string\n11 | |         .chars()\n12 | |         .filter(|c|\
    \ c.contains(&substring))\n13 | |         .count()\n   | |________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Calculate the offset of the given substring in the string\n    let substring_index_offset\
    \ = (string.len() - substring.len()) as isize;\n\n    // If the substring is found\
    \ at the start or end of the string, return 0\n    if substring_index_offset <\
    \ 0 {\n        return 0;\n    }\n\n    // Otherwise, return the number of times\
    \ the substring can be found in the original string\n    if substring_index_offset\
    \ == 0 {\n        return string.chars().filter(|c| c == substring).count() + 1;\n\
    \    }\n\n    // Otherwise, find the index of the first character of the substring\
    \ in the string\n    let substring_index_start = string.chars().position(|c| c\
    \ == substring).unwrap();\n\n    // Return the number of times the substring can\
    \ be found in the original string\n    return substring_index_offset - substring_index_start\
    \ + substring.chars().count() + 1;\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n  --> /tmp/tmpxxxnvte2.rs:19:44\n\
    \   |\n19 |         return string.chars().filter(|c| c == substring).count() +\
    \ 1;\n   |                                            ^^ no implementation for\
    \ `&char == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxxxnvte2.rs:19:16\n   |\n8  | fn\
    \ how_many_times(string: String, substring: String) -> isize {\n   |         \
    \                                                ----- expected `isize` because\
    \ of return type\n...\n19 |         return string.chars().filter(|c| c == substring).count()\
    \ + 1;\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |         return\
    \ (string.chars().filter(|c| c == substring).count() + 1).try_into().unwrap();\n\
    \   |                +                                                     +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxxxnvte2.rs:23:66\n   |\n23 |\
    \     let substring_index_start = string.chars().position(|c| c == substring).unwrap();\n\
    \   |                                                                  ^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpxxxnvte2.rs:26:37\n   |\n26 |     return substring_index_offset\
    \ - substring_index_start + substring.chars().count() + 1;\n   |             \
    \                        ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpxxxnvte2.rs:26:35\n\
    \   |\n26 |     return substring_index_offset - substring_index_start + substring.chars().count()\
    \ + 1;\n   |                                   ^ no implementation for `isize\
    \ - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut pos = 0;\n    let mut count = usize::MAX;\n    while pos < string.len()\
    \ {\n        let end = string.find(substring, pos);\n        if end != String::npos\
    \ { // Found the substring\n            count = count + 1;\n            pos =\
    \ end + 1;\n        } else { // No more occurrences, return count\n          \
    \  return count;\n        }\n    }\n    // Didn't find substring, return 0\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp7vlash53.rs:12:26\n     |\n12   |         let end = string.find(substring,\
    \ pos);\n     |                          ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                          |\n     |                          expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ function or associated item named `npos` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp7vlash53.rs:13:27\n   |\n13 |         if end != String::npos\
    \ { // Found the substring\n   |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp7vlash53.rs:15:23\n   |\n15 |             pos = end + 1;\n   |\
    \                   --- ^ - {integer}\n   |                   |\n   |        \
    \           Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7vlash53.rs:17:20\n\
    \   |\n17 |             return count;\n   |                    ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |             return\
    \ count.try_into().unwrap();\n   |                         ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7vlash53.rs:21:5\n   |\n8  | fn\
    \ how_many_times(string: String, substring: String) -> isize {\n   |         \
    \                                                ----- expected `isize` because\
    \ of return type\n...\n21 |     count\n   |     ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |     count.try_into().unwrap()\n   |\
    \          ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308, E0369, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.count(substring)\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpt9upmi4q.rs:9:12\n\
    \    |\n9   |       string.count(substring)\n    |              ^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter_map(|pair| {\n            if\
    \ let Some(c1) = pair.0.contains(pair.0) {\n                Some(substring\n \
    \                   .chars()\n                    .skip_while(|&c| c1 == c)\n\
    \                    .count()\n                )\n            } else {\n     \
    \           None\n            }\n        })\n        .fold(0, |acc, x| {\n   \
    \         acc + x\n        })\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp01lfdp4y.rs:12:38\n   |\n12 |             if let Some(c1)\
    \ = pair.0.contains(pair.0) {\n   |                                      ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp01lfdp4y.rs:23:19\n\
    \   |\n23 |             acc + x\n   |                   ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot add `usize` to `isize`\n  --> /tmp/tmp01lfdp4y.rs:23:17\n\
    \   |\n23 |             acc + x\n   |                 ^ no implementation for\
    \ `isize + usize`\n   |\n   = help: the trait `Add<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0; // how many times substring occurs\n\n    // get index\n    let\
    \ mut index = string.find(substring);\n\n    // skip first occurrence\n    if\
    \ index != None {\n        index = skip_substring(&string, &substring, index);\n\
    \    }\n\n    loop {\n        // skip next occurrences\n        index = skip_substring(&string,\
    \ &substring, index);\n\n        // skip cases when substring appears consecutively\n\
    \        if index != None {\n            if string.chars().any(|c| c == index\
    \ + 1) {\n                count++;\n            }\n        }\n        else {\n\
    \            break;\n        }\n    }\n\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpniqvr1_s.rs:26:22\n\
    \   |\n26 |                 count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n26 |               \
    \  { let tmp = count; count += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n26 -                 count++;\n26 +                 count\
    \ += 1;\n   | \n\nerror[E0425]: cannot find function `skip_substring` in this\
    \ scope\n  --> /tmp/tmpniqvr1_s.rs:16:17\n   |\n16 |         index = skip_substring(&string,\
    \ &substring, index);\n   |                 ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `skip_substring` in this scope\n  --> /tmp/tmpniqvr1_s.rs:21:17\n\
    \   |\n21 |         index = skip_substring(&string, &substring, index);\n   |\
    \                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmpniqvr1_s.rs:12:33\n\
    \     |\n12   |     let mut index = string.find(substring);\n     |          \
    \                  ---- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |                            |\n     |                            required\
    \ by a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n12   |     let mut index\
    \ = string.find(&substring);\n     |                                 +\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpniqvr1_s.rs:25:50\n\
    \   |\n25 |             if string.chars().any(|c| c == index + 1) {\n   |    \
    \                                        ----- ^ - {integer}\n   |           \
    \                                 |\n   |                                    \
    \        Option<usize>\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0369, E0425.\nFor more information about\
    \ an erro"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().fold(0,\
    \ |acc, c| {\n        if string.contains(substring.as_bytes()) {\n           \
    \ acc + 1;\n        }\n        acc\n    })\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `[u8]`\n    --> /tmp/tmpgbm_k4v7.rs:10:28\n\
    \     |\n10   |         if string.contains(substring.as_bytes()) {\n     |   \
    \                -------- ^^^^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `[u8]`\n     |                   |\n     |                   required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `[u8]`\n     = help: the following other types implement\
    \ trait `Pattern<'a>`:\n               &'b [char; N]\n               &'b [char]\n\
    \               [char; N]\n     = note: required because of the requirements on\
    \ the impl of `FnOnce<(char,)>` for `&[u8]`\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&[u8]`\nnote: required by\
    \ a bound in `core::str::<impl str>::contains`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().count((substring.chars().collect::<String>())).min(string.length())\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n --> /tmp/tmp4f4b4it3.rs:9:26\n\
    \  |\n9 |     string.chars().count((substring.chars().collect::<String>())).min(string.length())\n\
    \  |                          ^                                     ^\n  |\n \
    \ = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \  |\n9 -     string.chars().count((substring.chars().collect::<String>())).min(string.length())\n\
    9 +     string.chars().count(substring.chars().collect::<String>()).min(string.length())\n\
    \  | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp4f4b4it3.rs:9:20\n    |\n9   |     string.chars().count((substring.chars().collect::<String>())).min(string.length())\n\
    \    |                    ^^^^^ --------------------------------------- supplied\
    \ 1 argument\n    |                    |\n    |                    expected 0\
    \ arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `length` found for struct `String` in the current scope\n --> /tmp/tmp4f4b4it3.rs:9:78\n\
    \  |\n9 |     string.chars().count((substring.chars().collect::<String>())).min(string.length())\n\
    \  |                                                                         \
    \     ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp4f4b4it3.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().count((substring.chars().collect::<String>())).min(string.length())\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count((substring.chars().collect::<String>())).min(string.length()).try_into().unwrap()\n\
    \  |                                                                         \
    \      "
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for (i, elem) in string.chars().zip(substring.chars()).skip(1).take(string.len()\
    \ - substring.len()).enumerate() {\n        if elem == substring {\n         \
    \   count = 1 + i;\n        }\n    }\n    return count;\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1e75wof6.rs:11:20\n   |\n\
    11 |         if elem == substring {\n   |                    ^^^^^^^^^ expected\
    \ tuple, found struct `String`\n   |\n   = note: expected tuple `(char, char)`\n\
    \             found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1e75wof6.rs:15:12\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n15 |     return count;\n   |            ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n15 |     return count.try_into().unwrap();\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut i = string.find(|&b| b == substring);\n    while\
    \ i != String::npos && i < string.len() {\n        if string[i] == substring {\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0631]: type mismatch in closure arguments\n    --> /tmp/tmpjdemy208.rs:10:24\n\
    \     |\n10   |     let mut i = string.find(|&b| b == substring);\n     |    \
    \                    ^^^^ ------------------- found signature of `fn(&_) -> _`\n\
    \     |                        |\n     |                        expected signature\
    \ of `fn(char) -> _`\n     |\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `[closure@/tmp/tmpjdemy208.rs:10:29: 10:48]`\n\
    note: required by a bound in `core::str::<impl str>::find`\n\nerror[E0599]: no\
    \ function or associated item named `npos` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpjdemy208.rs:11:24\n   |\n11 |     while i != String::npos\
    \ && i < string.len() {\n   |                        ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjdemy208.rs:11:36\n\
    \   |\n11 |     while i != String::npos && i < string.len() {\n   |          \
    \                          ^^^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n11 |     while i != String::npos\
    \ && i < Some(string.len()) {\n   |                                    +++++ \
    \           +\n\nerror[E0277]: the type `String` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmpjdemy208.rs:12:12\n   |\n12 |         if string[i] == substring\
    \ {\n   |            ^^^^^^^^^ `String` cannot be indexed by `Option<usize>`\n\
    \   |\n   = help: the trait `Index<Option<usize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| (a == b) || (a == 'a'\
    \ && b == 'a'))\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4qsr9jlp.rs:11:41\n\
    \   |\n11 |         .filter(|(a, b)| (a == b) || (a == 'a' && b == 'a'))\n   |\
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp4qsr9jlp.rs:11:53\n   |\n11 |   \
    \      .filter(|(a, b)| (a == b) || (a == 'a' && b == 'a'))\n   |            \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4qsr9jlp.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.chars()\n10 | |         .zip(substring.chars())\n11 | |     \
    \    .filter(|(a, b)| (a == b) || (a == 'a' && b == 'a'))\n12 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n12 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0;\n    while i < string.len() && i < string.len().saturating_sub(1)\
    \ && string[i] == substring[0] {\n        i += 1;\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3_f3wh0i.rs:10:69\n\
    \   |\n10 |     while i < string.len() && i < string.len().saturating_sub(1) &&\
    \ string[i] == substring[0] {\n   |                                          \
    \                           ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp3_f3wh0i.rs:10:82\n   |\n10 |     while i < string.len() && i <\
    \ string.len().saturating_sub(1) && string[i] == substring[0] {\n   |        \
    \                                                                          ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3_f3wh0i.rs:13:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n13 |     i\n   |     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |     i.try_into().unwrap"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    substring.chars().filter(|c|\
    \ string.contains(c)).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpcab5n7qd.rs:9:50\n\
    \     |\n9    |     substring.chars().filter(|c| string.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     substring.chars().filter(|c|\
    \ string.contains(*c)).count()\n     |                                       \
    \           +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcab5n7qd.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     substring.chars().filter(|c| string.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     substring.chars().filter(|c|\
    \ string.contains(c)).count().try_into().unwrap()\n  |                       \
    \                                      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut substring_iter = string.char_indices()\n     \
    \   .filter(|&i| i.0..=< substring.length())\n        .map(|i| i.0)\n        .collect::<Vec<usize>>();\n\
    \    substring_iter.sort();\n    for i in substring_iter {\n        if string.chars().any(|&c|\
    \ i == c) {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `.`\n\
    \  --> /tmp/tmp7gdqidnr.rs:11:39\n   |\n11 |         .filter(|&i| i.0..=< substring.length())\n\
    \   |                                       ^ expected one of 7 possible tokens\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter_map(|x| x.contains(substring))\n        .count() as isize\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmphzq_pb4n.rs:10:27\n   |\n10 |         .filter_map(|x|\
    \ x.contains(substring))\n   |                           ^^^^^^^^ method not found\
    \ in `(usize, char)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .chars()\n        .filter(|c| *c == substring)\n        .count() + 1\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppdsf_65v.rs:11:27\n   |\n\
    11 |         .filter(|c| *c == substring)\n   |                           ^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppdsf_65v.rs:9:5\n   |\n8  |   fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                                        \
    \                   ----- expected `isize` because of return type\n9  | /    \
    \ string\n10 | |         .chars()\n11 | |         .filter(|c| *c == substring)\n\
    12 | |         .count() + 1\n   | |____________________^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n9  ~     (string\n10 |         .chars()\n\
    11 |         .filter(|c| *c == substring)\n12 ~         .count() + 1).try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ *c == substring).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphn9jhuv1.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|c| *c == substring).count()\n  |                \
    \                     ^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmphn9jhuv1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| *c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ *c == substring).count().try_into().unwrap()\n  |                          \
    \                             ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut current_start = 0;\n    let mut count = 0;\n    while current_start < string.len()\
    \ {\n        if string.chars().position(|c| c == substring[current_start]).is_some()\
    \ {\n            count += 1;\n        }\n        current_start += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1grew7ma.rs:12:45\n\
    \   |\n12 |         if string.chars().position(|c| c == substring[current_start]).is_some()\
    \ {\n   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut index = 0;\n    let mut count = 0;\n    while index < string.len() {\n \
    \       let index = string.find(substring, index);\n        if index == None {\n\
    \            break;\n        }\n        index += 1;\n        count += 1;\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpgiwlsbzn.rs:12:28\n     |\n12   |         let index = string.find(substring,\
    \ index);\n     |                            ^^^^ ---------  ----- supplied 2\
    \ arguments\n     |                            |\n     |                     \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `Option<usize>`\n\
    \  --> /tmp/tmpgiwlsbzn.rs:16:9\n   |\n16 |         index += 1;\n   |        \
    \ -----^^^^^\n   |         |\n   |         cannot use `+=` on type `Option<usize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0368.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|&(a, b)| a == b)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppifk7jow.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|&(a, b)| a == b)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Using `std::mem::transmute` here because String::index\n    // doesn't seem\
    \ to work on Rust < 1.48.\n    let index = string.find(substring).map(|i| i as\
    \ usize).unwrap_or(0);\n    string.chars().take(index).count() + 1\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpnoq9km8y.rs:11:29\n     |\n11   |     let index = string.find(substring).map(|i|\
    \ i as usize).unwrap_or(0);\n     |                        ---- ^^^^^^^^^ expected\
    \ an implementor of trait `Pattern<'_>`\n     |                        |\n   \
    \  |                        required by a bound introduced by this call\n    \
    \ |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n   \
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n11   |     let index = string.find(&substring).map(|i|\
    \ i as usize).unwrap_or(0);\n     |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnoq9km8y.rs:12:5\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n...\n\
    12 |     string.chars().take(index).count() + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     (string.chars().take(index).count()\
    \ + 1).try_into().unwrap()\n   |     +                                      +++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter_map(|(i, _)| {\n            if substring.contains(&string[i])\
    \ {\n                Some(i + 1)\n            } else {\n                None\n\
    \            }\n        })\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdzicflo1.rs:11:36\n\
    \   |\n11 |             if substring.contains(&string[i]) {\n   |            \
    \                        ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdzicflo1.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.char_indices()\n10 | |         .filter_map(|(i, _)| {\n11 | |\
    \             if substring.contains(&string[i]) {\n12 | |                 Some(i\
    \ + 1)\n...  |\n16 | |         })\n17 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c != substring[0]).count() + string.chars().filter(|c| c == substring[0]).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmphqf8_hdp.rs:9:36\n  |\n9 |     string.chars().filter(|c| c != substring[0]).count()\
    \ + string.chars().filter(|c| c == substring[0]).count()\n  |                \
    \                    ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \  |\n  = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n --> /tmp/tmphqf8_hdp.rs:9:91\n\
    \  |\n9 |     string.chars().filter(|c| c != substring[0]).count() + string.chars().filter(|c|\
    \ c == substring[0]).count()\n  |                                            \
    \                                               ^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmphqf8_hdp.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| c != substring[0]).count() + string.chars().filter(|c|\
    \ c == substring[0]).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter_map(|(index, c)| {\n            c.is_ascii_case() || c.is_ascii_uppercase_ascii()\
    \ || c.is_ascii_lowercase()\n        })\n        .count(|&(index, c)| c == substring)\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_case` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpe361eayl.rs:11:15\n   |\n11 |             c.is_ascii_case()\
    \ || c.is_ascii_uppercase_ascii() || c.is_ascii_lowercase()\n   |            \
    \   ^^^^^^^^^^^^^ help: there is an associated function with a similar name: `is_ascii`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase_ascii` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpe361eayl.rs:11:36\n   |\n11 |          \
    \   c.is_ascii_case() || c.is_ascii_uppercase_ascii() || c.is_ascii_lowercase()\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_uppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe361eayl.rs:11:13\n   |\n11 |             c.is_ascii_case()\
    \ || c.is_ascii_uppercase_ascii() || c.is_ascii_lowercase()\n   |            \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n11 |             Some(c.is_ascii_case() || c.is_ascii_uppercase_ascii()\
    \ || c.is_ascii_lowercase())\n   |             +++++                         \
    \                                                  +\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpe361eayl.rs:13:10\n\
    \    |\n13  |         .count(|&(index, c)| c == substring)\n    |          ^^^^^\
    \ ---------------------------- supplied 1 argument\n    |          |\n    |  \
    \        expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe361eayl.rs:9:5\n   |\n8  |  \
    \ fn how_many_times(string: String, substring: String) -> isize {\n   |      \
    \                                                     ----- expected `isize` because\
    \ of return type\n9  | /     string.char_indices()\n10 | |         .filter_map(|(index,\
    \ c)| {\n11 | |             c.is_ascii_case() || c.is_ascii_uppercase_ascii()\
    \ || c.is_ascii"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    while index < string.len() {\n \
    \       let index = string.find(substring, index);\n        if index == String::npos\
    \ { break; }\n        count += 1;\n        index = index + 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp033_wx4x.rs:12:28\n     |\n12   |         let index = string.find(substring,\
    \ index);\n     |                            ^^^^ ---------  ----- supplied 2\
    \ arguments\n     |                            |\n     |                     \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp033_wx4x.rs:13:29\n   |\n13 |         if\
    \ index == String::npos { break; }\n   |                             ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmp033_wx4x.rs:15:23\n   |\n15 |         index\
    \ = index + 1;\n   |                 ----- ^ - {integer}\n   |               \
    \  |\n   |                 Option<usize>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = substr_counts(string);\n    count.into_iter().filter(|&(_, count)|\
    \ substring.find(&_).is_some()).count()\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `substr_counts` in this scope\n -->\
    \ /tmp/tmpk90c_xf1.rs:9:21\n  |\n9 |     let mut count = substr_counts(string);\n\
    \  |                     ^^^^^^^^^^^^^ not found in this scope\n\nerror: in expressions,\
    \ `_` can only be used on the left-hand side of an assignment\n  --> /tmp/tmpk90c_xf1.rs:10:60\n\
    \   |\n10 |     count.into_iter().filter(|&(_, count)| substring.find(&_).is_some()).count()\n\
    \   |                                                            ^ `_` not allowed\
    \ here\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 1;\n\n    for i in string.chars() {\n        if i >= substring.chars()\
    \ {\n            count += 1;\n        }\n        if string.contains(&substring)\
    \ {\n            count += 1;\n        }\n        if string.contains(&substring[..i])\
    \ {\n            count += 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphbwqm7vl.rs:12:17\n   |\n\
    12 |         if i >= substring.chars() {\n   |                 ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `Chars`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `RangeTo<char>`\n  --> /tmp/tmphbwqm7vl.rs:18:29\n   |\n18 | \
    \        if string.contains(&substring[..i]) {\n   |                         \
    \    ^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<char>`\n   |\n   =\
    \ help: the trait `Index<RangeTo<char>>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n        let\
    \ j = string.find(substring, i);\n        if j == String::npos {\n           \
    \ break;\n        }\n        i += j;\n        count += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp1b2tj_ii.rs:12:24\n     |\n12   |         let j = string.find(substring,\
    \ i);\n     |                        ^^^^ ---------  - supplied 2 arguments\n\
    \     |                        |\n     |                        expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0599]: no function or\
    \ associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp1b2tj_ii.rs:13:25\n   |\n13 |         if j == String::npos {\n\
    \   |                         ^^^^ function or associated item not found in `String`\n\
    \nerror[E0277]: cannot add-assign `Option<usize>` to `usize`\n  --> /tmp/tmp1b2tj_ii.rs:16:11\n\
    \   |\n16 |         i += j;\n   |           ^^ no implementation for `usize +=\
    \ Option<usize>`\n   |\n   = help: the trait `AddAssign<Option<usize>>` is not\
    \ implemented for `usize`\n   = help: the following other types implement trait\
    \ `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n             <f32\
    \ as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n\
    \             <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n \
    \            <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n     \
    \      and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|&(_, s)| s == s)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3nt7su1o.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|&(_, s)| s == s)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ len = string.len() as isize;\n    let sub_len = substring.len() as isize;\n\n\
    \    if len < sub_len {\n        return 0;\n    }\n\n    let mut count = 0;\n\n\
    \    let mut start = 0;\n    let mut end = 0;\n    while start < len {\n     \
    \   end = string.find(substring, start);\n\n        if end == -1 {\n         \
    \   return 0;\n        }\n\n        count += 1;\n        start = end + 1;\n  \
    \  }\n\n    return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp7byzuuai.rs:21:22\n     |\n21   |         end = string.find(substring,\
    \ start);\n     |                      ^^^^ ---------  ----- supplied 2 arguments\n\
    \     |                      |\n     |                      expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7byzuuai.rs:21:15\n   |\n19 |     let mut end = 0;\n   |      \
    \             - expected due to this value\n20 |     while start < len {\n21 |\
    \         end = string.find(substring, start);\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.contains(substring) {\n        return string.count(substring).unwrap();\n\
    \    }\n    let mut found = 0;\n    for (index, c) in string.char_indices().enumerate()\
    \ {\n        if let Some(i) = get_string_offset(substring, c) {\n            if\
    \ i == index {\n                found += 1;\n            }\n        }\n    }\n\
    \    found\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_string_offset` in this scope\n\
    \  --> /tmp/tmpbkvvfmnj.rs:14:26\n   |\n14 |         if let Some(i) = get_string_offset(substring,\
    \ c) {\n   |                          ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmpbkvvfmnj.rs:9:24\n\
    \     |\n9    |     if string.contains(substring) {\n     |               --------\
    \ ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n     |           \
    \    |\n     |               required by a bound introduced by this call\n   \
    \  |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n  \
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider borrowing here\n     |\n9    |     if string.contains(&substring)\
    \ {\n     |                        +\n\nerror[E0599]: `String` is not an iterator\n\
    \   --> /tmp/tmpbkvvfmnj.rs:10:23\n    |\n10  |           return string.count(substring).unwrap();\n\
    \    |                         ^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0usize;\n    let mut j = 0usize;\n    let mut found = false;\n    while\
    \ !found && i < string.len() {\n        if string.len() - j > substring.length\
    \ {\n            j += substring.length();\n            continue;\n        }\n\
    \        if string.as_str()[..j] == substring.as_str() {\n            i += 1;\n\
    \            j += substring.length();\n            found = true;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    i + (j - i);\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmpk7yeeavz.rs:13:41\n\
    \   |\n13 |         if string.len() - j > substring.length {\n   |           \
    \                              ^^^^^^ unknown field\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpk7yeeavz.rs:14:28\n\
    \   |\n14 |             j += substring.length();\n   |                       \
    \     ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpk7yeeavz.rs:17:33\n\
    \   |\n17 |         if string.as_str()[..j] == substring.as_str() {\n   |    \
    \                             ^^ no implementation for `str == &str`\n   |\n \
    \  = help: the trait `PartialEq<&str>` is not implemented for `str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpk7yeeavz.rs:19:28\n\
    \   |\n19 |             j += substring.length();\n   |                       \
    \     ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpk7yeeavz.rs:8:57\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |    --------------               \
    \                        ^^^^^ expected `isize`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter_map(|x| x.find(|c| c.is_ascii()))\n        .filter(|x| x.is_some())\n\
    \        .filter(|x| x.0 != x.1)\n        .filter(|(_, count)| count > 0)\n  \
    \      .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmppmx8j7b9.rs:10:27\n   |\n10 |         .filter_map(|x|\
    \ x.find(|c| c.is_ascii()))\n   |                           ^^^^ method not found\
    \ in `(usize, char)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.count(&substring).map(|n|\
    \ n * substring.length())\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpy461ox2k.rs:9:12\n\
    \    |\n9   |       string.count(&substring).map(|n| n * substring.length())\n\
    \    |              ^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n --> /tmp/tmpy461ox2k.rs:9:52\n  |\n9 |     string.count(&substring).map(|n|\
    \ n * substring.length())\n  |                                               \
    \     ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() {\n        return 0;\n    }\n    \n    let mut count = 0;\n\
    \    for i in 0..string.len() {\n        if string.chars().any(|c| c == i) {\n\
    \            count += 1;\n        }\n        if substring.chars().any(|c| c ==\
    \ i) {\n            count += 1;\n        }\n    }\n    \n    return count;\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmputg_s38f.rs:15:40\n   |\n\
    15 |         if string.chars().any(|c| c == i) {\n   |                       \
    \                 ^ expected `char`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmputg_s38f.rs:18:43\n   |\n18 |         if substring.chars().any(|c|\
    \ c == i) {\n   |                                           ^ expected `char`,\
    \ found `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut result = 0;\n\n    let mut strings = string.chars();\n    let mut substrings\
    \ = substring.chars();\n\n    while let Some(mut s) = strings.next() {\n     \
    \   while let Some(mut t) = substrings.next() {\n            if s == t {\n   \
    \             result += 1;\n            } else {\n                break;\n   \
    \         }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpe1n_zg4a.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpj1sjcyk9.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpj1sjcyk9.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpye19o8bu.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpye19o8bu.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Use rfind() rather than find() since find() does not return usize\n    string.rfind(substring).map(|pos|\
    \ pos as usize).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmp3m_t7wrc.rs:10:18\n   |\n10 |     string.rfind(substring).map(|pos|\
    \ pos as usize).count()\n   |            ----- ^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n   |            |\n   |            required by a bound\
    \ introduced by this call\n   |\n   = note: the trait bound `String: Pattern<'_>`\
    \ is not satisfied\n   = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nhelp: consider borrowing here\n   |\n10 |   \
    \  string.rfind(&substring).map(|pos| pos as usize).count()\n   |            \
    \      +\n\nerror[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmp3m_t7wrc.rs:10:53\n\
    \    |\n10  |       string.rfind(substring).map(|pos| pos as usize).count()\n\
    \    |                                                       ^^^^^ `Option<usize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| a == b)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6hnslh1k.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a, b)| a == b)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Start with the initial substring length so no overlapping matches.\n    let\
    \ mut pos = 0;\n\n    // We loop through the string as many times as we can to\
    \ find all overlapping matches.\n    while pos < string.len() {\n        let mut\
    \ found = false;\n        let mut start_pos = pos;\n        let mut end_pos =\
    \ pos;\n\n        // Keep going as long as the start position is before the end\
    \ position\n        while start_pos < end_pos && string.chars().skip(start_pos).find(|c|\
    \ *c == substring[start_pos]) {\n            start_pos += 1;\n        }\n\n  \
    \      // The start position should be before the end position\n        assert_eq!(start_pos,\
    \ end_pos);\n\n        // Keep going as long as the end position is after the\
    \ start position\n        while end_pos < start_pos && string.chars().skip(end_pos).find(|c|\
    \ *c == substring[end_pos]) {\n            end_pos += 1;\n        }\n\n      \
    \  // We should now have found a match for the substring on the string.\n    \
    \    if start_pos == end_pos {\n            // The string matches the substring\
    \ exactly.\n            if start_pos < string.len() {\n                // We need\
    \ to skip over any overlapping matches on the substring.\n                while\
    \ start_pos < end_pos && string.chars().skip(start_pos).find(|c| *c == substring[start_pos])\
    \ {\n                    start_pos += 1;\n                }\n            }\n \
    \           found = true;\n        }\n        pos += end_pos - start_pos + 1;\n\
    \    }\n\n    // We don't need to worry about the initial substring since we already\
    \ have found one.\n    !found && pos\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `found` in this scope\n  --> /tmp/tmpme5faz8o.rs:46:6\n\
    \   |\n46 |     !found && pos\n   |      ^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpme5faz8o.rs:19:84\n\
    \   |\n19 |         while start_pos < end_pos && string.chars().skip(start_pos).find(|c|\
    \ *c == substring[start_pos]) {\n   |                                        \
    \                                            ^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpme5faz8o.rs:19:38\n\
    \   |\n19 |         while start_pos < end_pos && string.chars().skip(start_pos).find(|c|\
    \ *c == substring[start_pos]) {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<char>`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpme5faz8o.rs:27:82\n   |\n27 |         while\
    \ end_pos < start_pos && string.chars().skip(end_pos).find(|c| *c == substring[end_pos])\
    \ {\n   |                                                                    \
    \              ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut idx: usize = 0;\n    loop {\n        idx += string.find(substring, idx).unwrap_or(1);\n\
    \        if idx == string.len() {\n            break;\n        }\n        if idx\
    \ == string.len() - substring.len() {\n            break;\n        }\n       \
    \ if string[idx..idx+substring.len()].iter().all(|&c| *c != string[idx+substring.len()])\
    \ {\n            break;\n        }\n    }\n    idx\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpd_3rgm9w.rs:11:23\n     |\n11   |         idx += string.find(substring,\
    \ idx).unwrap_or(1);\n     |                       ^^^^ ---------  --- supplied\
    \ 2 arguments\n     |                       |\n     |                       expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no method named `iter` found for type `str` in the current scope\n  --> /tmp/tmpd_3rgm9w.rs:18:45\n\
    \   |\n18 |         if string[idx..idx+substring.len()].iter().all(|&c| *c !=\
    \ string[idx+substring.len()]) {\n   |                                       \
    \      ^^^^ method not found in `str`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpd_3rgm9w.rs:18:67\n   |\n18 |         if\
    \ string[idx..idx+substring.len()].iter().all(|&c| *c != string[idx+substring.len()])\
    \ {\n   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_3rgm9w.rs:22:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n22 |     idx\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n22 |     idx.try_into().unwrap()\n   |  \
    \      ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0061"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    substring.chars().filter(|c|\
    \ string.contains(c)).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp64pgcm8n.rs:9:50\n\
    \     |\n9    |     substring.chars().filter(|c| string.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     substring.chars().filter(|c|\
    \ string.contains(*c)).count()\n     |                                       \
    \           +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp64pgcm8n.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     substring.chars().filter(|c| string.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     substring.chars().filter(|c|\
    \ string.contains(c)).count().try_into().unwrap()\n  |                       \
    \                                      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.len()\
    \ + substring.len() + 1 // to include overlaping cases\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmph5763nji.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.len() + substring.len() + 1 // to include overlaping\
    \ cases\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n  |\n9 |     (string.len() + substring.len() + 1).try_into().unwrap()\
    \ // to include overlaping cases\n  |     +                                  +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.len()\
    \ + substring.len()\n        .rposition(|&b| b == substring)\n        .expect(\"\
    Substring is not in string\")\n        .count() + 1\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rposition` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp6m2ipnfc.rs:10:10\n   |\n10 |         .rposition(|&b|\
    \ b == substring)\n   |          ^^^^^^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6m2ipnfc.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.len() + substring.len()\n10 | |         .rposition(|&b| b ==\
    \ substring)\n11 | |         .expect(\"Substring is not in string\")\n12 | | \
    \        .count() + 1\n   | |____________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n9  ~     (string.len() + substring.len()\n10 |    \
    \     .rposition(|&b| b == substring)\n11 |         .expect(\"Substring is not\
    \ in string\")\n12 ~         .count() + 1).try_into().unwrap()\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().count(|c|\
    \ c.contains(&substring))\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpo46saxca.rs:9:27\n\
    \  |\n9 |     string.chars().count(|c| c.contains(&substring))\n  |          \
    \                 ^ consider giving this closure parameter a type\n  |\n  = note:\
    \ type must be known at this point\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpo46saxca.rs:9:20\n    |\n9   | \
    \    string.chars().count(|c| c.contains(&substring))\n    |                 \
    \   ^^^^^ -------------------------- supplied 1 argument\n    |              \
    \      |\n    |                    expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n --> /tmp/tmpo46saxca.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().count(|c| c.contains(&substring))\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n  |\n9 |     string.chars().count(|c| c.contains(&substring)).try_into().unwrap()\n\
    \  |                                                     ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .chars()\n        .zip(substring.chars())\n        .filter(|(char, substring)|\
    \ char == substring)\n        .count();\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy116c9m1.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut found_count = 0 as isize;\n    for c in string.chars() {\n        if substring.contains(&c)\
    \ {\n            found_count += 1;\n        }\n    }\n    found_count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpr8jla4uy.rs:11:31\n\
    \     |\n11   |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| a != b)\n        .count()\
    \ + how_many_times(substring, &string[..])\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdc0uegd7.rs:12:46\n   |\n\
    12 |         .count() + how_many_times(substring, &string[..])\n   |         \
    \                                     ^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n12 |         .count()\
    \ + how_many_times(substring, (&string[..]).to_string())\n   |               \
    \                               +           +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdc0uegd7.rs:12:20\n   |\n12 |         .count() + how_many_times(substring,\
    \ &string[..])\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdc0uegd7.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a, b)| a != b)\n12 | |         .count() + how_many_times(substring,\
    \ &string[..])\n   | |_________________________________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n9  ~     (string.chars()\n\
    10 |         .zip(substring.chars())\n11 |         .filter(|(a, b)| a != b)\n\
    12 ~         .count() + how_many_times(substring, &string[..])).try_into().unwrap()\n\
    \   |\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpdc0uegd7.rs:12:18\n\
    \   |\n12 |         .count() + how_many_times(substring, &string[..])\n   |  \
    \                ^ no implementation for `usize + isize`\n   |\n   = help: the\
    \ trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter_map(|index| {\n            let mut it = index.to_ascii_lowercase();\n\
    \            it.extend(substring);\n            Some(it)\n        })\n       \
    \ .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_ascii_lowercase` found for tuple `(usize,\
    \ char)` in the current scope\n  --> /tmp/tmpd9t9allg.rs:11:32\n   |\n11 |   \
    \          let mut it = index.to_ascii_lowercase();\n   |                    \
    \            ^^^^^^^^^^^^^^^^^^ method not found in `(usize, char)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd9t9allg.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.char_indices()\n10 | |         .filter_map(|index| {\n11 | |\
    \             let mut it = index.to_ascii_lowercase();\n12 | |             it.extend(substring);\n\
    13 | |             Some(it)\n14 | |         })\n15 | |         .count()\n   |\
    \ |________________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    15 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut so_far\
    \ = 0;\n    let mut pos = 0;\n\n    while so_far < string.len() {\n        if\
    \ string.starts_with(substring, pos, so_far) {\n            so_far += substring.len();\n\
    \            pos += substring.len();\n        } else {\n            so_far +=\
    \ 1;\n            pos += 1;\n        }\n    }\n\n    so_far\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \    --> /tmp/tmp74ht9ekj.rs:17:19\n     |\n17   |         if string.starts_with(substring,\
    \ pos, so_far) {\n     |                   ^^^^^^^^^^^ ---------  ---  ------\
    \ supplied 3 arguments\n     |                   |\n     |                   expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp74ht9ekj.rs:26:5\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n...\n\
    26 |     so_far\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |     so_far.try_into().unwrap()\n   |           ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 1; // counting overlapping occurrences\n    let mut i = 0;\n   \
    \ while i < string.len() {\n        i += match string[i + substring.len()..].contains(&substring)\
    \ {\n            true => substring.len(),\n            false => 1,\n        };\n\
    \        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpo7o2tcm6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp8u67fc6v.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp8u67fc6v.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |                           \
    \                           ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(string.chars())\n        .filter(|(c1, c2)| c1 == c2)\n        .filter(|(c1,\
    \ c2)| c1 == c2 && c1 == substring[0])\n        .count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpo3n7m4u7.rs:12:46\n   |\n12 |         .filter(|(c1, c2)| c1 == c2 &&\
    \ c1 == substring[0])\n   |                                              ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut position = 0usize;\n\n    while position < string.len() {\n        let found\
    \ = string.find(substring, position);\n        if found == std::string::npos {\n\
    \            return 0;\n        }\n\n        if found > position {\n         \
    \   return found - position + 1;\n        }\n\n        position = found + 1;\n\
    \    }\n\n    0\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `npos` in module `std::string`\n  --> /tmp/tmp34ddixjs.rs:13:34\n\
    \   |\n13 |         if found == std::string::npos {\n   |                    \
    \              ^^^^ not found in `std::string`\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp34ddixjs.rs:12:28\n\
    \     |\n12   |         let found = string.find(substring, position);\n     |\
    \                            ^^^^ ---------  -------- supplied 2 arguments\n \
    \    |                            |\n     |                            expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp34ddixjs.rs:17:20\n   |\n17 |         if found\
    \ > position {\n   |                    ^^^^^^^^ expected enum `Option`, found\
    \ `usize`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n17 |      \
    \   if found > Some(position) {\n   |                    +++++        +\n\nerror[E0369]:\
    \ cannot subtract `usize` from `Option<usize>`\n  --> /tmp/tmp34ddixjs.rs:18:26\n\
    \   |\n18 |             return found - position + 1;\n   |                   \
    \ ----- ^ -------- usize\n   |                    |\n   |                    Option<usize>\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp34ddixjs.rs:21:26\n\
    \   |\n21 |         position = found + 1;\n   |                    ----- ^ - {integer}\n\
    \   |                    |\n   |                    Option<usize>\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0369, E0425.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars()).count(|&(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpgbjgcuyv.rs:9:43\n    |\n9   |     string.chars().zip(substring.chars()).count(|&(a,\
    \ b)| a == b)\n    |                                           ^^^^^ ----------------\
    \ supplied 1 argument\n    |                                           |\n   \
    \ |                                           expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n --> /tmp/tmpgbjgcuyv.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().zip(substring.chars()).count(|&(a,\
    \ b)| a == b)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).count(|&(a,\
    \ b)| a == b).try_into().unwrap()\n  |                                       \
    \                           ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter(|(&a, &b)| a == b)\n        .count()\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb8dz0mtn.rs:10:19\n   |\n\
    10 |         .filter(|(&a, &b)| a == b)\n   |                   ^^    - expected\
    \ due to this\n   |                   |\n   |                   expected `usize`,\
    \ found reference\n   |                   help: you can probably remove the explicit\
    \ borrow: `a`\n   |\n   = note:   expected type `usize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb8dz0mtn.rs:10:23\n  \
    \ |\n10 |         .filter(|(&a, &b)| a == b)\n   |                       ^^- expected\
    \ due to this\n   |                       |\n   |                       expected\
    \ `char`, found reference\n   |                       help: you can probably remove\
    \ the explicit borrow: `b`\n   |\n   = note:   expected type `char`\n        \
    \   found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb8dz0mtn.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.char_indices()\n10 | |   \
    \      .filter(|(&a, &b)| a == b)\n11 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars()).filter(|(&a,\
    \ &b)| a == b).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4t3gsxp1.rs:9:52\n  |\n9 |\
    \     string.chars().zip(substring.chars()).filter(|(&a, &b)| a == b).count()\n\
    \  |                                                    ^^    - expected due to\
    \ this\n  |                                                    |\n  |        \
    \                                            expected `char`, found reference\n\
    \  |                                                    help: you can probably\
    \ remove the explicit borrow: `a`\n  |\n  = note:   expected type `char`\n   \
    \       found reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4t3gsxp1.rs:9:56\n\
    \  |\n9 |     string.chars().zip(substring.chars()).filter(|(&a, &b)| a == b).count()\n\
    \  |                                                        ^^- expected due to\
    \ this\n  |                                                        |\n  |    \
    \                                                    expected `char`, found reference\n\
    \  |                                                        help: you can probably\
    \ remove the explicit borrow: `b`\n  |\n  = note:   expected type `char`\n   \
    \       found reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4t3gsxp1.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().zip(substring.chars()).filter(|(&a,\
    \ &b)| a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(&a,\
    \ &b)| a == b).count().try_into().unwrap()\n  |                              \
    \                                              ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpb8ziyapp.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count() + 1).try_into().unwrap()\n  |     +                    \
    \                                                     +++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter_map(|i| if i.0 == substring.len() {\n            None\n     \
    \   } else {\n            Some((*i).1.iter().count(|j| j == substring.len()))\n\
    \        })\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `(usize, char)` cannot be dereferenced\n  --> /tmp/tmpxdyn_3vg.rs:13:18\n\
    \   |\n13 |             Some((*i).1.iter().count(|j| j == substring.len()))\n\
    \   |                  ^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxdyn_3vg.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.char_indices()\n10 | |   \
    \      .filter_map(|i| if i.0 == substring.len() {\n11 | |             None\n\
    12 | |         } else {\n13 | |             Some((*i).1.iter().count(|j| j ==\
    \ substring.len()))\n14 | |         })\n15 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0; // keep track of how many times substring occurs\n    let len\
    \ = string.len();\n    for pos in 0..len {\n        if string.eq(substring, pos)\
    \ {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpe99bqpie.rs:12:19\n    |\n12  |         if string.eq(substring,\
    \ pos) {\n    |                   ^^ ---------  --- supplied 2 arguments\n   \
    \ |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().filter(|c|\
    \ c == substring).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpplm46pnf.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpplm46pnf.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |                           \
    \                           ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    string\n        .split_whitespace()\n        .into_iter()\n\
    \        .map(|x| match x {\n            x if x == substring => counter = counter\
    \ + 1;\n            _ => (),\n        })\n        .collect::<Vec<_>>()\n     \
    \   .iter()\n        .fold(0, |acc, x| acc + x);\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: `match` arm body without braces\n  --> /tmp/tmpwilkq1ri.rs:14:36\n\
    \   |\n14 |             x if x == substring => counter = counter + 1;\n   |  \
    \                               -- ^^^^^^^^^^^^^^^^^^^^^- help: use a comma to\
    \ end a `match` arm expression: `,`\n   |                                 |  |\n\
    \   |                                 |  this statement is not surrounded by a\
    \ body\n   |                                 while parsing the `match` arm starting\
    \ here\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut pos = 0;\n    let mut i = 0;\n    while pos < string.len() {\n        i\
    \ = string.find(substring, pos);\n        if i == -1 {\n            break;\n \
    \       }\n        pos += i + 1;\n    }\n    i + 1\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpbh6yyrw9.rs:12:20\n     |\n12   |         i = string.find(substring,\
    \ pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                    |\n     |                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbh6yyrw9.rs:12:13\n   |\n10 |     let mut i = 0;\n   |        \
    \         - expected due to this value\n11 |     while pos < string.len() {\n\
    12 |         i = string.find(substring, pos);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpbh6yyrw9.rs:13:17\n   |\n13 |         if\
    \ i == -1 {\n   |                 ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbh6yyrw9.rs:18:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n18 |     i + 1\n   |     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     (i + 1).try_into().unwrap()\n\
    \   |     +     +++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut index = 0;\n\n    while index < string.len() {\n\
    \        let index = string.find(substring, index);\n\n        if index == String::npos\
    \ { break; }\n        index = index + substring.len();\n        counter += 1;\n\
    \    }\n\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpwk3dkw15.rs:13:28\n     |\n13   |         let index = string.find(substring,\
    \ index);\n     |                            ^^^^ ---------  ----- supplied 2\
    \ arguments\n     |                            |\n     |                     \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpwk3dkw15.rs:15:29\n   |\n15 |         if\
    \ index == String::npos { break; }\n   |                             ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot add `usize`\
    \ to `Option<usize>`\n  --> /tmp/tmpwk3dkw15.rs:16:23\n   |\n16 |         index\
    \ = index + substring.len();\n   |                 ----- ^ --------------- usize\n\
    \   |                 |\n   |                 Option<usize>\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| a == b)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2qkex70d.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a, b)| a == b)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|&[start, end]| start <= end)\n\
    \        .count();\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0529]: expected an array or slice, found `(char, char)`\n  --> /tmp/tmp9_knfhyp.rs:11:19\n\
    \   |\n11 |         .filter(|&[start, end]| start <= end)\n   |              \
    \     ^^^^^^^^^^^^ pattern cannot match with input type `(char, char)`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp9_knfhyp.rs:8:57\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |    --------------               \
    \                        ^^^^^ expected `isize`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0529.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.char_indices()\n\
    \        .filter_map(|i| i.find(substring, ::std::cmp::Ordering::Equal))\n   \
    \     .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmps8pwwbeu.rs:10:27\n   |\n10 |         .filter_map(|i|\
    \ i.find(substring, ::std::cmp::Ordering::Equal))\n   |                      \
    \     ^^^^ method not found in `(usize, char)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps8pwwbeu.rs:9:5\n   |\n8  |   fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                                        \
    \                   ----- expected `isize` because of return type\n9  | /    \
    \ string.char_indices()\n10 | |         .filter_map(|i| i.find(substring, ::std::cmp::Ordering::Equal))\n\
    11 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0\n    for (i, c) in string.chars().zip(substring.chars()).filter(|&&(_,\
    \ c2)| c.eq(c2)).enumerate() {\n        if i >= substring.len() {\n          \
    \  break\n        }\n        count += (i == 0) ? 0 : 1;\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpm7msiptk.rs:9:22\n\
    \   |\n9  |     let mut count = 0\n   |                      ^ help: add `;` here\n\
    10 |     for (i, c) in string.chars().zip(substring.chars()).filter(|&&(_, c2)|\
    \ c.eq(c2)).enumerate() {\n   |     --- unexpected token\n\nerror: expected one\
    \ of `.`, `;`, `?`, `}`, or an operator, found `0`\n  --> /tmp/tmpm7msiptk.rs:14:29\n\
    \   |\n14 |         count += (i == 0) ? 0 : 1;\n   |                         \
    \    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0425]: cannot\
    \ find value `c` in this scope\n  --> /tmp/tmpm7msiptk.rs:10:76\n   |\n10 |  \
    \   for (i, c) in string.chars().zip(substring.chars()).filter(|&&(_, c2)| c.eq(c2)).enumerate()\
    \ {\n   |                                                                    \
    \        ^ help: a local variable with a similar name exists: `c2`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm7msiptk.rs:10:66\n   |\n10 |     for (i, c)\
    \ in string.chars().zip(substring.chars()).filter(|&&(_, c2)| c.eq(c2)).enumerate()\
    \ {\n   |                                                                  ^^^^^^^-\n\
    \   |                                                                  |     \
    \ |\n   |                                                                  | \
    \     expected due to this\n   |                                             \
    \                     expected tuple, found reference\n   |\n   = note:  expected\
    \ tuple `(char, char)`\n           found reference `&_`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string\n\
    \        .split_last_mut()\n        .find(|x| x == substring)\n        .map(|i|\
    \ i + substring.length())\n        .unwrap_or_else(|| 0)\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpwkl6rt2c.rs:10:10\n   |\n10 |         .split_last_mut()\n\
    \   |          ^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_at`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpwkl6rt2c.rs:12:32\n   |\n12 | \
    \        .map(|i| i + substring.length())\n   |                              \
    \  ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0; // current position\n    for ch in string.chars() {\n        if substring\
    \ == ch {\n            i += 1;\n        } else if i >= substring.length() - 1\
    \ {\n            break;\n        }\n\n        i += 1;\n    }\n\n    i\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpq9r5sskv.rs:11:22\n\
    \   |\n11 |         if substring == ch {\n   |                      ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpq9r5sskv.rs:13:34\n\
    \   |\n13 |         } else if i >= substring.length() - 1 {\n   |            \
    \                      ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut index = 0;\n    let mut match_count = 0;\n    while index <= string.len()\
    \ {\n        if string.contains(substring, index) {\n            match_count +=\
    \ 1;\n        }\n        index += 1;\n    }\n    match_count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpxvg9elxk.rs:12:19\n     |\n12   |         if string.contains(substring,\
    \ index) {\n     |                   ^^^^^^^^ ---------  ----- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut cnt = 0;\n    string\n        .chars()\n        .filter(|c| c == substring)\n\
    \        .filter(|c| c != '\\0')\n        .for_each(|c| {\n            cnt +=\
    \ 1;\n            if cnt > 1 {\n                cnt -= 1;\n            }\n   \
    \     });\n    cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n  --> /tmp/tmp3vwv8bca.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == substring)\n   |                       ^^\
    \ no implementation for `&char == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3vwv8bca.rs:13:23\n\
    \   |\n13 |         .filter(|c| c != '\\0')\n   |                       ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqx3nl6nm.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ substring: Vec<Char> = string.chars().collect();\n    string.chars().filter(|c|\
    \ *c != *substring).count() - 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n --> /tmp/tmp50xffq82.rs:9:24\n\
    \  |\n9 |     let substring: Vec<Char> = string.chars().collect();\n  |      \
    \                  ^^^^\n  |\nhelp: a builtin type with a similar name exists\n\
    \  |\n9 |     let substring: Vec<char> = string.chars().collect();\n  |      \
    \                  ~~~~\nhelp: you might be missing a type parameter\n  |\n8 |\
    \ fn how_many_times<Char>(string: String, substring: String) -> isize {\n  | \
    \                 ++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp50xffq82.rs:10:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n9  |     let substring: Vec<Char> = string.chars().collect();\n\
    10 |     string.chars().filter(|c| *c != *substring).count() - 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (string.chars().filter(|c|\
    \ *c != *substring).count() - 1).try_into().unwrap()\n   |     +             \
    \                                          +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|c| c.0 == c.1)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp930istak.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|c| c.0 == c.1)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.chars().take_while(|c|\
    \ c == substring).count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpv2gkhbqr.rs:9:37\n\
    \  |\n9 |     string.chars().take_while(|c| c == substring).count() + 1\n  | \
    \                                    ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpv2gkhbqr.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().take_while(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().take_while(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                         +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut found = 0;\n    for c in string.chars() {\n        if substring.contains(c)\
    \ {\n            found += 1;\n        }\n    }\n    found\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `4`', /tmp/tmp_wiflq0s.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count: usize = 0;\n    for ch in string.chars() {\n        if string.contains(ch)\
    \ && substring.contains(ch) {\n            count += 1;\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps39w3s0s.rs:15:5\n   |\n\
    8  | fn how_many_times(string: String, substring: String) -> isize {\n   |   \
    \                                                      ----- expected `isize`\
    \ because of return type\n...\n15 |     count\n   |     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut position = 0;\n    while counter < string.len()\
    \ && position != string.len() {\n        if string[position..].find(substring)\
    \ != Some(position..) {\n            break;\n        }\n        position += 1;\n\
    \        counter += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp2jzk95hf.rs:12:36\n     |\n12   |         if string[position..].find(substring)\
    \ != Some(position..) {\n     |                               ---- ^^^^^^^^^ expected\
    \ an implementor of trait `Pattern<'_>`\n     |                              \
    \ |\n     |                               required by a bound introduced by this\
    \ call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n12   |         if string[position..].find(&substring)\
    \ != Some(position..) {\n     |                                    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2jzk95hf.rs:12:55\n   |\n12 |         if string[position..].find(substring)\
    \ != Some(position..) {\n   |                                                \
    \       ^^^^^^^^^^ expected `usize`, found struct `RangeFrom`\n   |\n   = note:\
    \ expected type `usize`\n            found struct `RangeFrom<usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2jzk95hf.rs:18:5\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n...\n\
    18 |     counter\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |     counter.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut s = string;\n    loop {\n        if s.contains(substring) {\n          \
    \  return 1 + s.find(substring).unwrap();\n        }\n        s = &s[..s.len()-1];\n\
    \    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpqeaknrt9.rs:11:23\n     |\n11   |         if s.contains(substring)\
    \ {\n     |              -------- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |              |\n     |              required by a bound introduced by\
    \ this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider borrowing here\n     |\n11   |         if s.contains(&substring)\
    \ {\n     |                       +\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n    --> /tmp/tmpqeaknrt9.rs:12:31\n     |\n12   | \
    \            return 1 + s.find(substring).unwrap();\n     |                  \
    \        ---- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n     |\
    \                          |\n     |                          required by a bound\
    \ introduced by this call\n     |\n     = note: the trait bound `String: Pattern<'_>`\
    \ is not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n12   |             return\
    \ 1 + s.find(&substring).unwrap();\n     |                               +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqeaknrt9.rs:12:20\n   |\n12 |  \
    \           return 1 + s.find(substring).unwrap();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |           \
    \  return (1 + s.find(substring).unwrap()).try_into().unwrap();\n   |        \
    \            +                              +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqeaknrt9.rs:14:13\n   |\n9  |     let mut s\
    \ = string;\n   |                 ------ expected due to this value\n...\n14 |\
    \         s = &s[..s.len()-"
  exit_code: 1
  status: SyntaxError
