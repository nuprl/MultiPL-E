name: HumanEval_31_is_prime
language: rust
results:
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    if n <=\
    \ 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n\
    \    }\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 3;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6__y3f4n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    use num_bigint::BigInt;\n    (n - 2) as BigInt == 0 &&\n\
    \        n\n            .checked_add((n - 2) as u8)\n            .checked_add((n\
    \ - 2) as u8)\n            .checked_add(2)\n            .checked_mul(8)\n    \
    \        .checked_mul(n - 2)\n            .is_odd()\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `num_bigint`\n  --> /tmp/tmpbr_byilz.rs:17:9\n\
    \   |\n17 |     use num_bigint::BigInt;\n   |         ^^^^^^^^^^ maybe a missing\
    \ crate `num_bigint`?\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbr_byilz.rs:20:26\n\
    \   |\n20 |             .checked_add((n - 2) as u8)\n   |                    \
    \      ^^^^^^^^^^^^^ expected `isize`, found `u8`\n   |\nhelp: you can convert\
    \ a `u8` to an `isize`\n   |\n20 |             .checked_add(((n - 2) as u8).into())\n\
    \   |                          +             ++++++++\n\nerror[E0599]: no method\
    \ named `checked_add` found for enum `Option` in the current scope\n  --> /tmp/tmpbr_byilz.rs:21:14\n\
    \   |\n21 |             .checked_add((n - 2) as u8)\n   |              ^^^^^^^^^^^\
    \ method not found in `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // Check base cases\n    if n <= 2 {\n        return n\
    \ % 2 == 0;\n    }\n\n    // If n is odd or even, it's prime\n    if n % 2 ==\
    \ 0 {\n        return true;\n    }\n\n    // Check all the even numbers up to\
    \ sqrt(n)\n    for i in 1..=u64::from(n as isize).sqrt().max() {\n        if n\
    \ % i == 0 {\n            return false;\n        }\n    }\n\n    // If n is prime,\
    \ it's prime\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `u64: From<isize>` is not satisfied\n  -->\
    \ /tmp/tmp4xgmoc4d.rs:28:18\n   |\n28 |     for i in 1..=u64::from(n as isize).sqrt().max()\
    \ {\n   |                  ^^^^^^^^^ the trait `From<isize>` is not implemented\
    \ for `u64`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <f32 as From<i16>>\n             <f32 as From<i8>>\n           \
    \  <f32 as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n\nerror[E0599]: no method named\
    \ `sqrt` found for type `u64` in the current scope\n  --> /tmp/tmp4xgmoc4d.rs:28:40\n\
    \   |\n28 |     for i in 1..=u64::from(n as isize).sqrt().max() {\n   |      \
    \                                  ^^^^ method not found in `u64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    if n %\
    \ 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as usize) {\n   \
    \     if n % i == 0 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyiuktii8.rs:24:16\n   |\n\
    24 |         if n % i == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpyiuktii8.rs:24:14\n\
    \   |\n24 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n >= 2\n        && (n % 2) == 0\n        && is_factor(n)\
    \ == true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_factor` in this scope\n  --> /tmp/tmpcak4rn09.rs:19:12\n\
    \   |\n19 |         && is_factor(n) == true\n   |            ^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 1\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpppumxukf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    !n.is_power_of_two() || is_prime(n as u64)\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpibv8vugm.rs:17:8\n   |\n17 |     !n.is_power_of_two()\
    \ || is_prime(n as u64)\n   |        ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpibv8vugm.rs:17:38\n   |\n17 |\
    \     !n.is_power_of_two() || is_prime(n as u64)\n   |                       \
    \               ^^^^^^^^ expected `isize`, found `u64`\n   |\nhelp: you can convert\
    \ a `u64` to an `isize` and panic if the converted value doesn't fit\n   |\n17\
    \ |     !n.is_power_of_two() || is_prime((n as u64).try_into().unwrap())\n   |\
    \                                      +        +++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 2 && (n as u64) < PRIMES as u64\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `PRIMES` in this scope\n  --> /tmp/tmp_zrbi4t5.rs:17:27\n\
    \   |\n17 |     n > 2 && (n as u64) < PRIMES as u64\n   |                    \
    \       ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    !((2..n).filter(|i| {\n        let mut j = 1;\n      \
    \  (1..i).filter(|j| j % i == 0).count() > 1\n    }).is_empty())\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6gwqaxmb.rs:19:13\n   |\n\
    19 |         (1..i).filter(|j| j % i == 0).count() > 1\n   |             ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |         (1..*i).filter(|j| j % i == 0).count() > 1\n   |             +\n\n\
    error[E0599]: no method named `is_empty` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmp6gwqaxmb.rs:20:8\n   |\n20 |     }).is_empty())\n   | \
    \       ^^^^^^^^ method not found in `Filter<std::ops::Range<isize>, [closure@/tmp/tmp6gwqaxmb.rs:17:21:\
    \ 20:6]>`\n   |\nhelp: one of the expressions' fields has a method of the same\
    \ name\n   |\n20 |     }).iter.is_empty())\n   |        +++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n >= 2 && is_divisible_by_two(n)\n}\n\nfn main() {\n \
    \   let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_divisible_by_two` in this scope\n\
    \  --> /tmp/tmpyu_th2oi.rs:17:15\n   |\n17 |     n >= 2 && is_divisible_by_two(n)\n\
    \   |               ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 0);\n    if n == 1 {\n        return false;\n\
    \    }\n    \n    // Optimization: We only need to check odd numbers.\n    if\
    \ n % 2 == 0 {\n        return false;\n    }\n\n    for i in 2..n / 2 {\n    \
    \    if n % i == 0 {\n            return false;\n        }\n    }\n    \n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    use integer::Integer;\n    (n & 1) == 0 ||\n    match\
    \ ((n as usize).checked_mul((n as usize).checked_div(2)),\n           (n as usize).checked_div(3))\
    \ {\n        (Some(x), (Some(mod x)))\n        | (None, (Some(mod x)))\n     \
    \   | _, (None, None)\n        => x.is_prime(),\n        (None, None) => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmp2xnd76ki.rs:21:25\n\
    \   |\n21 |         (Some(x), (Some(mod x)))\n   |                         ^^^\
    \ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`,\
    \ or `|`, found `x`\n  --> /tmp/tmp2xnd76ki.rs:21:29\n   |\n21 |         (Some(x),\
    \ (Some(mod x)))\n   |                            -^ expected one of `)`, `,`,\
    \ `@`, or `|`\n   |                            |\n   |                       \
    \     help: missing `,`\n\nerror: expected identifier, found keyword `mod`\n \
    \ --> /tmp/tmp2xnd76ki.rs:22:24\n   |\n22 |         | (None, (Some(mod x)))\n\
    \   |                        ^^^ expected identifier, found keyword\n\nerror:\
    \ expected one of `)`, `,`, `@`, or `|`, found `x`\n  --> /tmp/tmp2xnd76ki.rs:22:28\n\
    \   |\n22 |         | (None, (Some(mod x)))\n   |                           -^\
    \ expected one of `)`, `,`, `@`, or `|`\n   |                           |\n  \
    \ |                           help: missing `,`\n\nerror: unexpected `,` in pattern\n\
    \  --> /tmp/tmp2xnd76ki.rs:23:12\n   |\n23 |         | _, (None, None)\n   | \
    \           ^\n   |\nhelp: try adding parentheses to match on a tuple...\n   |\n\
    23 |         | (_, (None, None))\n   |           +               +\nhelp: ...or\
    \ a vertical bar to match on multiple alternatives\n   |\n23 |         | _ | (None\
    \ | None)\n   |           ~~~~~~~~~~~~~~~~~\n\nerror[E0432]: unresolved import\
    \ `integer`\n  --> /tmp/tmp2xnd76ki.rs:17:9\n   |\n17 |     use integer::Integer;\n\
    \   |         ^^^^^^^ maybe a missing crate `integer`?\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2xnd76ki.rs:19:37\n   |\n19 |     match ((n as usize).checked_mul((n\
    \ as usize).checked_div(2)),\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 2 && n.is_prime()\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpdbzcq7ss.rs:17:16\n   |\n17 |     n > 2 && n.is_prime()\n\
    \   |                ^^^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 2 || is_prime_exact(n) || n % 2 == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_exact` in this scope\n  -->\
    \ /tmp/tmpn1veh5um.rs:17:15\n   |\n17 |     n <= 2 || is_prime_exact(n) || n %\
    \ 2 == 0\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_odd(n) {\n        return false;\n    }\n    if n\
    \ <= 2 {\n        return true;\n    }\n    let mut i: isize = 2;\n    while i\
    \ < n {\n        if n % i == 0 {\n            return false;\n        }\n     \
    \   i += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_odd` in this scope\n  --> /tmp/tmpuzayynw4.rs:17:8\n\
    \   |\n17 |     if is_odd(n) {\n   |        ^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // If n is prime, return true\n    if n == 2 || n == 3\
    \ || n % 2 == 0 || n % 3 == 0 {\n        return true;\n    }\n\n    // Test for\
    \ divisibility by 2, 3, and 5\n    for &d in &[1, 3, 5, 7, 11, 13, 17] {\n   \
    \     if n % d == 0 {\n            return false;\n        }\n    }\n\n    // If\
    \ we've exhausted all options, return false\n    return n != 1;\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp07xlhd8g.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime: isize = 1;\n    for i in 2..=n {\n    \
    \    if prime % i == 0 {\n            return false;\n        }\n        prime\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgfdsuzq2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in\
    \ 2..(n/2) {\n        if n % i == 0 {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo0hv2cw1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 1);\n    assert!(n % 2 != 0);\n    for (p\
    \ from 2 to n / 2)\n        if n % p == 0 {\n            return false;\n     \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `from`\n  --> /tmp/tmpta7uvh8b.rs:19:12\n\
    \   |\n19 |     for (p from 2 to n / 2)\n   |           -^^^^ expected one of\
    \ `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\n\
    error: expected one of `)`, `,`, `@`, or `|`, found `2`\n  --> /tmp/tmpta7uvh8b.rs:19:17\n\
    \   |\n19 |     for (p from 2 to n / 2)\n   |                -^ expected one of\
    \ `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing\
    \ `,`\n\nerror: expected one of `)`, `,`, `...`, `..=`, `..`, or `|`, found `to`\n\
    \  --> /tmp/tmpta7uvh8b.rs:19:19\n   |\n19 |     for (p from 2 to n / 2)\n   |\
    \                  -^^ expected one of `)`, `,`, `...`, `..=`, `..`, or `|`\n\
    \   |                  |\n   |                  help: missing `,`\n\nerror: expected\
    \ one of `)`, `,`, `@`, or `|`, found `n`\n  --> /tmp/tmpta7uvh8b.rs:19:22\n \
    \  |\n19 |     for (p from 2 to n / 2)\n   |                     -^ expected one\
    \ of `)`, `,`, `@`, or `|`\n   |                     |\n   |                 \
    \    help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found\
    \ `/`\n  --> /tmp/tmpta7uvh8b.rs:19:24\n   |\n19 |     for (p from 2 to n / 2)\n\
    \   |                        ^ expected one of `)`, `,`, `@`, or `|`\n\nerror:\
    \ missing `in` in `for` loop\n  --> /tmp/tmpta7uvh8b.rs:19:23\n   |\n19 |    \
    \ for (p from 2 to n / 2)\n   |                       ^ help: try adding `in`\
    \ here\n\nerror: expected expression, found `/`\n  --> /tmp/tmpta7uvh8b.rs:19:24\n\
    \   |\n19 |     for (p from 2 to n / 2)\n   |                        ^ expected\
    \ expression\n\nerror: aborting due to 7 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..(n/2usize)).all(|n|\n        (n % 2 == 0 || is_prime(n/2))\n\
    \    )\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwrm_koe6.rs:17:12\n   |\n\
    17 |     (1..(n/2usize)).all(|n|\n   |            ^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide `isize` by `usize`\n  --> /tmp/tmpwrm_koe6.rs:17:11\n\
    \   |\n17 |     (1..(n/2usize)).all(|n|\n   |           ^ no implementation for\
    \ `isize / usize`\n   |\n   = help: the trait `Div<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 1u64;\n    let mut j = 2u64;\n    loop {\n\
    \        if i % n == 0 {\n            return false;\n        }\n        if j <\
    \ n {\n            j += 1;\n        }\n        i += 1;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2sp6du2k.rs:20:16\n   |\n\
    20 |         if i % n == 0 {\n   |                ^ expected `u64`, found `isize`\n\
    \nerror[E0277]: cannot mod `u64` by `isize`\n  --> /tmp/tmp2sp6du2k.rs:20:14\n\
    \   |\n20 |         if i % n == 0 {\n   |              ^ no implementation for\
    \ `u64 % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented for\
    \ `u64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n  \
    \           <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n      \
    \       <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n        \
    \     <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n            \
    \ <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2sp6du2k.rs:23:16\n\
    \   |\n23 |         if j < n {\n   |                ^ expected `u64`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u64` and panic if the converted\
    \ value doesn't fit\n   |\n23 |         if j < n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 || n > 1000 {\n        return false;\n    }\n\
    \n    for i in 1..n {\n        if n % i == 0 {\n            return false;\n  \
    \      }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbdalyvhq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    use rand::Rng;\n\n    let mut rng = rand::thread_rng();\n\
    \n    if n % 2 == 0 {\n        return false;\n    }\n\n    for i in 1..n / 2 {\n\
    \        if n % i == 0 {\n            return false;\n        }\n    }\n\n    for\
    \ _ in 0..n / 2 {\n        if rng.gen::<usize>() % n == 0 {\n            return\
    \ false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `rand`\n  --> /tmp/tmpf_swwopn.rs:17:9\n\
    \   |\n17 |     use rand::Rng;\n   |         ^^^^ maybe a missing crate `rand`?\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpf_swwopn.rs:19:19\n   |\n19 |     let mut rng = rand::thread_rng();\n\
    \   |                   ^^^^ use of undeclared crate or module `rand`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_test = true;\n\n    if n == 2 {\n      \
    \  prime_test = false;\n    }\n\n    for i in 2..(n/2) as usize {\n        if\
    \ n % i == 0 {\n            prime_test = false;\n        }\n    }\n\n    prime_test\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt3kg96o2.rs:24:16\n   |\n\
    24 |         if n % i == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpt3kg96o2.rs:24:14\n\
    \   |\n24 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::Ordering;\n    if n < 2 {\n        return\
    \ n == 1;\n    }\n    if n == 1 {\n        return false;\n    }\n    for a in\
    \ 2..n {\n        if n % a == 0 {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpahcfnpco.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    \n    if\
    \ n == 2 {\n        return true;\n    }\n    \n    let mut i = 2;\n    while i\
    \ <= n {\n        if n % i == 0 {\n            return false;\n        }\n    \
    \    i += 1;\n    }\n    \n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp09zpgwjr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    !(n%2)\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixgkj_d9.rs:17:5\n   |\n\
    16 | fn is_prime(n: isize) -> bool {\n   |                          ---- expected\
    \ `bool` because of return type\n17 |     !(n%2)\n   |     ^^^^^^ expected `bool`,\
    \ found `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..n).all(|&x| {\n        fn inner(n: isize) -> bool\
    \ {\n            let mut c = n as u64;\n            if c < 3 {\n             \
    \   return false;\n            }\n            c -= 2;\n            c <= (n/3).cmp(&mut\
    \ c)\n        }\n        (inner(x) as i32) as bool\n    })\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsddhwy0v.rs:17:17\n   |\n\
    17 |     (1..n).all(|&x| {\n   |                 ^--\n   |                 ||\n\
    \   |                 |expected due to this\n   |                 expected `isize`,\
    \ found reference\n   |                 help: did you mean `x`: `&isize`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0054]:\
    \ cannot cast as `bool`\n  --> /tmp/tmpsddhwy0v.rs:26:9\n   |\n26 |         (inner(x)\
    \ as i32) as bool\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: compare with zero\
    \ instead: `(inner(x) as i32) != 0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsddhwy0v.rs:24:28\n\
    \   |\n24 |             c <= (n/3).cmp(&mut c)\n   |                         \
    \   ^^^^^^ expected `isize`, found `u64`\n   |\n   = note:      expected reference\
    \ `&isize`\n           found mutable reference `&mut u64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsddhwy0v.rs:24:18\n   |\n24 |             c <= (n/3).cmp(&mut\
    \ c)\n   |                  ^^^^^^^^^^^^^^^^^ expected `u64`, found enum `std::cmp::Ordering`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0054, E0308.\nFor more information about an error, try `rustc --explain E0054`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 1\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_fz6185u.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime = true; // True is prime, false is composite\n\
    \    let mut prime_check = 2; // Start check at 2\n    while prime_check < n {\n\
    \        if n % prime_check == 0 {\n            prime = false;\n            break;\n\
    \        }\n        prime_check += 1;\n    }\n    prime\n}\n\nfn main() {\n  \
    \  let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaddvhgoe.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    let mut\
    \ n = n;\n    while n > 2 {\n        if n % 2 != 0 {\n            return false;\n\
    \        }\n        n /= 2;\n    }\n    n > 1 && n % 1 == 0\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp36dzn8d7.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 2 && is_prime(n/2) && n % 2 == 0\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5g0yjfu8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 2 && is_prime(n - 2) || n == 1\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0l9240z8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::Ordering;\n    use self::primes::*;\n\n\
    \    let mut counter = 1;\n    let mut max_counter = S;\n\n    while counter <=\
    \ max_counter {\n        if is_prime_iterative(counter, n)\n            && (counter\
    \ < n || is_prime_iterative(counter + 1, n))\n        {\n            return true;\n\
    \        }\n        counter += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `self::primes`\n  --> /tmp/tmppso8b2in.rs:18:15\n\
    \   |\n18 |     use self::primes::*;\n   |               ^^^^^^ maybe a missing\
    \ crate `primes`?\n\nerror[E0425]: cannot find value `S` in this scope\n  -->\
    \ /tmp/tmppso8b2in.rs:21:27\n   |\n21 |     let mut max_counter = S;\n   |   \
    \                        ^\n   |\nhelp: a local variable with a similar name exists\n\
    \   |\n21 |     let mut max_counter = n;\n   |                           ~\nhelp:\
    \ you might be missing a type parameter\n   |\n16 | fn is_prime<S>(n: isize) ->\
    \ bool {\n   |            +++\n\nerror[E0425]: cannot find function `is_prime_iterative`\
    \ in this scope\n  --> /tmp/tmppso8b2in.rs:24:12\n   |\n24 |         if is_prime_iterative(counter,\
    \ n)\n   |            ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime_iterative` in this scope\n  --> /tmp/tmppso8b2in.rs:25:32\n\
    \   |\n25 |             && (counter < n || is_prime_iterative(counter + 1, n))\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nwarning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmppso8b2in.rs:17:9\n\
    \   |\n17 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to\
    \ 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return true;\n    }\n    fn is_divisor(n:\
    \ isize) -> bool {\n        if n & 1 == 0 {\n            return false;\n     \
    \   }\n        n >> 1 != 0\n    }\n    if n % 2 == 0 {\n        return false;\n\
    \    }\n    fn is_prime2(n: isize) -> bool {\n        n < 2\n    }\n    let mut\
    \ prime = prime::new();\n    prime.is_prime(&n, |e| is_divisor(n));\n    prime.is_prime2(&n,\
    \ |e| is_prime2(n));\n    prime.is_prime3(&n, |e| is_prime2(n));\n    prime.is_prime4(|e|\
    \ is_prime2(n));\n    prime.is_prime5(|e| is_prime2(n));\n    prime.is_prime6(|e|\
    \ is_prime2(n));\n    prime.is_prime7(|e| is_prime2(n));\n    prime.is_prime8(|e|\
    \ is_prime2(n));\n    prime.is_prime9(|e| is_prime2(n));\n    prime.is_prime10(|e|\
    \ is_prime2(n));\n    prime.is_prime11(|e| is_prime2(n));\n    prime.is_prime12(|e|\
    \ is_prime2(n));\n    prime.is_prime13(|e| is_prime2(n));\n    prime.is_prime14(|e|\
    \ is_prime2(n));\n    prime.is_prime15(|e| is_prime2(n));\n    prime.is_prime16(|e|\
    \ is_prime2(n));\n    prime.is_prime17(|e| is_prime2(n));\n    prime.is_prime18(|e|\
    \ is_prime2(n));\n    prime.is_prime19(|e| is_prime2(n));\n    prime.is_prime20(|e|\
    \ is_prime2(n));\n    prime.is_prime21(|e| is_prime2(n));\n    prime.is_prime22(|e|\
    \ is_prime2(n));\n    prime.is_prime23(|e| is_prime2(n));\n    prime.is_prime24(|e|\
    \ is_prime2(n));\n    prime.is_prime25(|e| is_prime2(n));\n    prime.is_prime26(|e|\
    \ is_prime2(n));\n    prime.is_prime27(|e| is_prime2(n));\n    prime.is_prime28(|e|\
    \ is_prime2(n));\n    prime.is_prime29(|e| is_prime2(n));\n    prime.is_\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `prime`\n\
    \  --> /tmp/tmpzguw_3dm.rs:32:21\n   |\n32 |     let mut prime = prime::new();\n\
    \   |                     ^^^^^ use of undeclared crate or module `prime`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // Loop invariant for primality\n    //\
    \ Stop at sqrt(n)\n    let mut b = true;\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            b = false;\n            break;\n        }\n        i\
    \ += 1;\n    }\n    b\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2c60ayrb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // Loop limit\n    let mut s = true; //\
    \ Stop flag initialization\n    while s < false && i < n {\n        if n % i ==\
    \ 0 {\n            s = false;\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    s\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbt_uit68.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_candidates = vec![true; n + 1];\n    prime_candidates[0]\
    \ = false;\n    for i in 1..n {\n        if prime_candidates[i] {\n          \
    \  for p in 2..i {\n                prime_candidates[p] = !prime_candidates[p];\n\
    \            }\n        }\n    }\n    prime_candidates[n]\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppk932m8s.rs:17:43\n   |\n\
    17 |     let mut prime_candidates = vec![true; n + 1];\n   |                 \
    \                          ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     let mut prime_candidates = vec![true; (n + 1).try_into().unwrap()];\n\
    \   |                                           +     +++++++++++++++++++++\n\n\
    error[E0277]: the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmppk932m8s.rs:20:12\n\
    \   |\n20 |         if prime_candidates[i] {\n   |            ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmppk932m8s.rs:22:17\n\
    \   |\n22 |                 prime_candidates[p] = !prime_candidates[p];\n   |\
    \                 ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmppk932m8s.rs:22:40\n   |\n22 |                 prime_candidates[p]\
    \ = !prime_candidates[p];\n   |                                        ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmppk932m8s.rs:26:5\n\
    \   |\n26 |"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // Check up to the square root of the number.\n    for\
    \ &p in primes() {\n        if p == n {\n            return true;\n        }\n\
    \n        if n % p == 0 {\n            return false;\n        }\n    }\n\n   \
    \ // We didn't find any primes larger than the given number.\n    false\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `primes` in this scope\n  --> /tmp/tmpnb8e2y2h.rs:18:15\n\
    \   |\n18 |     for &p in primes() {\n   |               ^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let mut\
    \ primes = vec![true; n];\n    let mut i = 2;\n    while i <= n {\n        if\
    \ !primes[i] {\n            return false;\n        }\n        if n % i == 0 {\n\
    \            primes[i] = false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3hdm4yf0.rs:20:33\n   |\n\
    20 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n20 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp3hdm4yf0.rs:23:13\n   |\n23 |         if !primes[i]\
    \ {\n   |             ^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp3hdm4yf0.rs:27:13\n   |\n27 |             primes[i] = false;\n\
    \   |             ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // Trial division https://en.wikipedia.org/wiki/Trial_division\n\
    \    // First trial division\n    let mut trial_divisor_count = *n % 48;\n   \
    \ \n    if n <= 2 {\n        return false;\n    }\n\n    // Subsequent trial division\
    \ using continued fractions, see http://en.wikipedia.org/wiki/Continued_fraction\n\
    \    for divisor in 2..(n as usize).try_into() {\n        if trial_divisor_count\
    \ == 0 {\n            return true;\n        }\n        \n        if *n % divisor\
    \ == 0 {\n            trial_divisor_count -= 1;\n        } else {\n          \
    \  return false;\n        }\n    }\n    \n    // The number is prime\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp86x42zax.rs:19:35\n\
    \   |\n19 |     let mut trial_divisor_count = *n % 48;\n   |                 \
    \                  ^^\n\nerror[E0599]: no method named `try_into` found for type\
    \ `usize` in the current scope\n   --> /tmp/tmp86x42zax.rs:26:36\n    |\n26  |\
    \     for divisor in 2..(n as usize).try_into() {\n    |                     \
    \               ^^^^^^^^ method not found in `usize`\n    |\n    = help: items\
    \ from traits can only be used if the trait is in scope\n    = note: 'std::convert::TryInto'\
    \ is included in the prelude starting in Edition 2021\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n    |\n1   | use\
    \ std::convert::TryInto;\n    |\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp86x42zax.rs:31:12\n   |\n31 |         if *n % divisor == 0 {\n\
    \   |            ^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq51prr0n.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n >= 2\n        && primes.contains(&n)\n        && (n\
    \ & 1 == 0)\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmpbdwdhibv.rs:18:12\n\
    \   |\n18 |         && primes.contains(&n)\n   |            ^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut primes = &[1..(n/2) as usize];\n    let mut i\
    \ = 1;\n    while i <= n {\n        if primes[i] < n {\n            i += 1;\n\
    \        } else {\n            primes[i] = i;\n            i += 1;\n        }\n\
    \    }\n    for i in primes.iter().rev() {\n        if n % i == 0 {\n        \
    \    return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n   \
    \ let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[std::ops::Range<usize>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpbz1kf0by.rs:20:12\n   |\n20 |         if primes[i] <\
    \ n {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<usize>]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[std::ops::Range<usize>]`\n\nerror[E0277]: the type `[std::ops::Range<usize>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbz1kf0by.rs:23:13\n   |\n23 |  \
    \           primes[i] = i;\n   |             ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<usize>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[std::ops::Range<usize>]`\n\nerror[E0277]: cannot mod `isize`\
    \ by `&std::ops::Range<usize>`\n  --> /tmp/tmpbz1kf0by.rs:28:14\n   |\n28 |  \
    \       if n % i == 0 {\n   |              ^ no implementation for `isize % &std::ops::Range<usize>`\n\
    \   |\n   = help: the trait `Rem<&std::ops::Range<usize>>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i < n.checked_mul(2).unwrap()\
    \ {\n        if n % i == 0 {\n            return false;\n        }\n        i\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5ebo4x5j.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return true\n    }\n    fn check(digit:\
    \ isize) -> bool {\n        return n % digit == 0;\n    }\n    let mut lower =\
    \ 2;\n    let mut upper = sqrt(n as f64);\n    while lower.is_positive() {\n \
    \       if check(lower) {\n            return false;\n        }\n        lower\
    \ = upper + 1;\n    }\n    lower = 2;\n    upper = sqrt(n as f64);\n    while\
    \ upper.is_positive() {\n        if check(upper) {\n            return false;\n\
    \        }\n        upper = lower + 1;\n    }\n    for d in 0..n {\n        check(d)\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpa_wv3jqw.rs:21:16\n\
    \   |\n21 |         return n % digit == 0;\n   |                ^\n   |\n   =\
    \ help: use the `|| { ... }` closure form instead\n\nerror[E0425]: cannot find\
    \ function `sqrt` in this scope\n  --> /tmp/tmpa_wv3jqw.rs:24:21\n   |\n24 | \
    \    let mut upper = sqrt(n as f64);\n   |                     ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `sqrt` in this scope\n \
    \ --> /tmp/tmpa_wv3jqw.rs:32:13\n   |\n32 |     upper = sqrt(n as f64);\n   |\
    \             ^^^^ not found in this scope\n\nerror[E0689]: can't call method\
    \ `is_positive` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpa_wv3jqw.rs:25:17\n\
    \   |\n25 |     while lower.is_positive() {\n   |                 ^^^^^^^^^^^\n\
    \   |\nhelp: you must specify a type for this binding, like `i32`\n   |\n23 |\
    \     let mut lower: i32 = 2;\n   |         ~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa_wv3jqw.rs:40:9\n   |\n40 |         check(d)\n   |   \
    \      ^^^^^^^^ expected `()`, found `bool`\n   |\nhelp: consider using a semicolon\
    \ here\n   |\n40 |         check(d);\n   |                 +\nhelp: you might\
    \ have meant to return this value\n   |\n40 |         return check(d);\n   | \
    \        ++++++         +\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425, E0434, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            return false;\n        }\n        i += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpug0zaz51.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpql8kpsoj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut n = n as usize;\n    let mut is_prime = true;\n\
    \n    while n > 1 {\n        if n % 2 == 0 {\n            is_prime = false;\n\
    \        }\n        n /= 2;\n    }\n\n    is_prime\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_2mdmnn7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // https://primes.utm.edu/lists/small/millions/2010-07-01.txt\n\
    \    fn isprime(n: isize) -> bool {\n        if n < 2 {\n            return false;\n\
    \        }\n        let mut i = 2;\n        loop {\n            if n % i == 0\
    \ {\n                return false;\n            }\n            i += 1;\n     \
    \   }\n        true\n    }\n    if n == 0 {\n        return false;\n    }\n  \
    \  if is_prime(n) {\n        return true;\n    }\n    for i in 2..=n {\n     \
    \   if is_prime(i) {\n            return false;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n % 2 == 0 {\n        return false;\n    }\n    for\
    \ i in 3..(n as isize / 2) {\n        if n % i == 0 {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb8vzappg.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut factors = vec![true; n];\n    factors.push(true);\n\
    \    factors.sort();\n    for i in 1..n {\n        if factors[i] {\n         \
    \   if n % i == 0 {\n                factors[i] = false;\n                break;\n\
    \            }\n        }\n    }\n    !factors[n - 1]\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf99l10_g.rs:17:34\n   |\n\
    17 |     let mut factors = vec![true; n];\n   |                              \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut factors = vec![true; n.try_into().unwrap()];\n   |                     \
    \              ++++++++++++++++++++\n\nerror[E0277]: the type `[bool]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpf99l10_g.rs:21:12\n   |\n21 |         if\
    \ factors[i] {\n   |            ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpf99l10_g.rs:23:17\n   |\n23 |                 factors[i] = false;\n\
    \   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpf99l10_g.rs:28:6\n   |\n28 |     !factors[n - 1]\n   |      ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    if n ==\
    \ 2 {\n        return true;\n    }\n\n    for d in factors(n) {\n        if n\
    \ % d == 0 {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmpobf9kxe5.rs:24:14\n\
    \   |\n24 |     for d in factors(n) {\n   |              ^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 2);\n    let mut i = 2;\n    let mut b = false;\n\
    \    while i < n {\n        if n % i == 0 {\n            b = false;\n        }\
    \ else {\n            b = true;\n        }\n        i += 1;\n    }\n    b\n}\n\
    \nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpar4sycd8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 2 || n % 2 == 0 {\n        return false\n    }\n\
    \n    let mut i = 2\n    let mut m = 4\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false\n        }\n        i += 2\n        if m\
    \ == 2 {\n            break\n        }\n        m += 2\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpkr9g_8ic.rs:21:18\n\
    \   |\n21 |     let mut i = 2\n   |                  ^ help: add `;` here\n22\
    \ |     let mut m = 4\n   |     --- unexpected token\n\nerror: expected `;`, found\
    \ keyword `while`\n  --> /tmp/tmpkr9g_8ic.rs:22:18\n   |\n22 |     let mut m =\
    \ 4\n   |                  ^ help: add `;` here\n23 |     while i * i <= n {\n\
    \   |     ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpkr9g_8ic.rs:27:15\n   |\n27 |         i += 2\n   |            \
    \   ^ help: add `;` here\n28 |         if m == 2 {\n   |         -- unexpected\
    \ token\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    let mut j = (3..=n)\n        .next()\n\
    \        .unwrap()\n        .try_fold(\n            Some(0),\n            |mut\
    \ acc, _| -> Some(acc.clone() + 1).map(|x| *x),\n        );\n    while !j.is_some()\
    \ {\n        if n % i == 0 {\n            return false;\n        }\n        if\
    \ j.is_some() && n % j == 0 {\n            return false;\n        }\n        i\
    \ += 1;\n        j = if i == 101 { None } else { Some(i * i) };\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `.`\n\
    \  --> /tmp/tmpa9cc566_.rs:23:37\n   |\n23 |             |mut acc, _| -> Some(acc.clone()\
    \ + 1).map(|x| *x),\n   |                                     ^\n   |        \
    \                             |\n   |                                     expected\
    \ one of 7 possible tokens\n   |                                     help: missing\
    \ `,`\n\nerror: expected one of `!`, `(`, `)`, `,`, `?`, `for`, `~`, lifetime,\
    \ or path, found `1`\n  --> /tmp/tmpa9cc566_.rs:23:48\n   |\n23 |            \
    \ |mut acc, _| -> Some(acc.clone() + 1).map(|x| *x),\n   |                   \
    \                             ^ expected one of 9 possible tokens\n\nerror: expected\
    \ `{`, found `1`\n  --> /tmp/tmpa9cc566_.rs:23:48\n   |\n23 |             |mut\
    \ acc, _| -> Some(acc.clone() + 1).map(|x| *x),\n   |                        \
    \                        ^ expected `{`\n   |\nhelp: try placing this code inside\
    \ a block\n   |\n23 |             |mut acc, _| -> Some(acc.clone() + { 1 }).map(|x|\
    \ *x),\n   |                                                +   +\n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    for i in 2..=n / 2 {\n        if n % i == 0 {\n      \
    \      return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt1s7l711.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // If n is even, return False\n    if n % 2 == 0 {\n \
    \       return false;\n    }\n\n    // If n is 1, return False\n    if n == 1\
    \ {\n        return false;\n    }\n\n    // If n is prime, return True\n    if\
    \ n == 2 {\n        return true;\n    }\n\n    // If n is even, return False for\
    \ all even numbers except 1 and itself\n    if n % 2 == 0 {\n        for &d in\
    \ &[3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] {\n    \
    \        if n % d == 0 {\n                return false;\n            }\n     \
    \   }\n\n        return true;\n    }\n\n    // If n is even, return True for all\
    \ odd numbers except 2 and itself\n    if n % 2 == 0 {\n        for &d in &[7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] {\n            if\
    \ n % d == 0 {\n                return true;\n            }\n        }\n\n   \
    \     return false;\n    }\n\n    // If n is prime, return True for all odd numbers\n\
    \    for &d in &[7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]\
    \ {\n        if n % d == 0 {\n            return true;\n        }\n    }\n\n \
    \   // If n is prime, return True for all odd numbers except 2\n    for &d in\
    \ &[7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] {\n       \
    \ if n % d == 0 {\n            return true;\n        }\n    }\n\n    // If n is\
    \ prime, return True for all odd numbers except 2 and itself\n    for &d in &[7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] {\n        if n\
    \ % d == 0 {\n            return true;\n        }\n    }\n\n    // If n is prime,\
    \ return False for all odd numbers except 2 and itself\n    for &d in &[7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] {\n        if n % d\
    \ == 0 {\n            return false;\n        }\n    }\n\n    // If n is prime,\
    \ return False for all odd numbers except 2 and itself\n    for &d in &[7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] {\n        if n % d\
    \ == 0 {\n            return false;\n        }\n    }\n\n    // If n is prime,\
    \ return False for all odd numbers except 2 and itself\n    for &d in &[7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] {\n        if n % d\
    \ == 0 {\n            return false;\n        }\n    }\n\n    // If n is prime,\
    \ return False for all odd numbers except 2 and itself\n    for &d in &[7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, \n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpu7swi50b.rs:98:1\n   |\n\
    98 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpu7swi50b.rs:97:16\n   |\n16 | fn is_prime(n: isize) -> bool {\n   |\
    \                               - closing delimiter possibly meant for this\n\
    ...\n97 |     for &d in &[7, 11, 13, 17, 19, 23, 29, 31, 37, 41, \n   |      \
    \          ^ unclosed delimiter\n98 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    fn check_p(n:\
    \ isize) -> bool {\n        if n == 1 {\n            return true;\n        }\n\
    \        if n % 2 == 0 {\n            return false;\n        }\n        for i\
    \ in 3..(n - 1) {\n            if n % i == 0 {\n                return false;\n\
    \            }\n        }\n        return true;\n    }\n    for i in 2..(n - 1)\
    \ {\n        if check_p(i) {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpop0kksz7.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7mowiw4w.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // 2 is prime\n    let mut test = 2; //\
    \ prime test 2\n    while i <= n {\n        if test * i <= n {\n            return\
    \ false;\n        }\n        i += 1;\n        test += 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpybt9707q.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime = false;\n    let mut i = 1;\n    while\
    \ i <= n {\n        if n % i == 0 {\n            prime = true;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    prime\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    for i in 2..n / 2 {\n        if n % i == 0 {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4y5l990y.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n >= 2\n        && (n % 2) == 0\n        && (!(n % 3)\
    \ == 0)\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd4bgj9i1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // All primes except two which are not divisible by 4\
    \ and 5\n    if n < 2 {\n        return false;\n    }\n\n    // All prime numbers\
    \ except 2 and 3\n    if n % 8 == 0 {\n        return false;\n    }\n\n    //\
    \ All prime numbers except 2 and 3 which are not divisible by 7\n    if n % 7\
    \ == 0 {\n        return false;\n    }\n\n    // All prime numbers except 2 and\
    \ 3 which are not divisible by 11\n    if n % 11 == 0 {\n        return false;\n\
    \    }\n\n    let mut i = 0;\n    // All prime numbers except 2 and 3 which are\
    \ not divisible by 13\n    while i < n / 13 {\n        i += 6;\n    }\n    for\
    \ n in 2..n / 13 {\n        if n % 13 == 0 {\n            return false;\n    \
    \    }\n    }\n    for n in 3..n / 13 {\n        if n % 13 == 0 {\n          \
    \  return false;\n        }\n    }\n    // All prime numbers except 2 and 3 which\
    \ are not divisible by 17\n    if n % 17 == 0 {\n        return false;\n    }\n\
    \n    // All prime numbers except 2 and 3 which are not divisible by 19\n    if\
    \ n % 19 == 0 {\n        return false;\n    }\n\n    // All prime numbers except\
    \ 2 and 3 which are not divisible by 23\n    if n % 23 == 0 {\n        return\
    \ false;\n    }\n\n    // All prime numbers except 2 and 3 which are not divisible\
    \ by 29\n    if n % 29 == 0 {\n        return false;\n    }\n\n    // All prime\
    \ numbers except 2 and 3 which are not divisible by 31\n    if n % 31 == 0 {\n\
    \        return false;\n    }\n\n    // All prime numbers except 2 and 3 which\
    \ are not divisible by 37\n    if n % 37 == 0 {\n        return false;\n    }\n\
    \n    // All prime numbers except 2 and 3 which are not divisible by 41\n    if\
    \ n % 41 == 0 {\n        return false;\n    }\n\n    // All prime numbers except\
    \ 2 and 3 which are not divisible by 43\n    if n % 43 == 0 {\n        return\
    \ false;\n    }\n\n    // All prime numbers except 2 and 3 which are not divisible\
    \ by 47\n    if n % 47 == 0 {\n        return false;\n    }\n\n    // All prime\
    \ numbers except 2 and 3 which are not divisible by 53\n    if n % 53 == 0 {\n\
    \        return false;\n    }\n\n    // All prime numbers except 2 and 3 which\
    \ are not divisible by 59\n    if n % 59 == 0 {\n        return false;\n    }\n\
    \n    // All prime numbers except 2 and 3 which are not divisible by 61\n    if\
    \ n % 61 == 0 {\n        return false;\n    }\n\n    // All prime numbers except\
    \ 2 and 3 which are not divisible by 67\n    if n % 67 == 0 {\n        return\
    \ false;\n    }\n\n    // All prime numbers except 2 and 3 which are not divisible\
    \ by 71\n    if n % 71 == 0 {\n        return false;\n    }\n\n    // All prime\
    \ numbers except 2 and 3 which are not divisible \n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n   --> /tmp/tmpl550j9_a.rs:118:5\n\
    \    |\n16  |   fn is_prime(n: isize) -> bool {\n    |                       \
    \     ---- expected `bool` because of this return type\n...\n118 | /     if n\
    \ % 71 == 0 {\n119 | |         return false;\n120 | |     }\n    | |_____^ expected\
    \ `bool`, found `()`\n    |\n    = note: `if` expressions without `else` evaluate\
    \ to `()`\n    = help: consider adding an `else` block that evaluates to the expected\
    \ type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::{max, min};\n    let mut n = n as usize;\n\
    \    let mut i = 1;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ n = n as usize;\n        } else {\n            i += 1;\n        }\n    }\n \
    \   n < 3\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let mut\
    \ n = n;\n    let mut result = true;\n    while n > 1 {\n        let d = *n /\
    \ 2;\n        if n % d == 0 {\n            result = False;\n            break;\n\
    \        }\n        n = d;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `False` in this scope\n  --> /tmp/tmp6ln21xl8.rs:25:22\n\
    \   |\n25 |             result = False;\n   |                      ^^^^^ not found\
    \ in this scope\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp6ln21xl8.rs:23:17\n\
    \   |\n23 |         let d = *n / 2;\n   |                 ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0614.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    fn check(n: isize) -> bool {\n        if n < 2 || n %\
    \ 2 == 0 {\n            return false;\n        }\n        if n == 2 {\n      \
    \      return true;\n        }\n        for d in 3..(n / 2)+1 {\n            if\
    \ n % d == 0 {\n                return false;\n            }\n        }\n    \
    \    true\n    }\n\n    for i in 0..n-1 {\n        if check(i) {\n           \
    \ return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2a1r98ca.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5akgjz4x.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu15ik6zg.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i <= sqrt(n) {\n        if n\
    \ % i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmptq7sbfba.rs:18:16\n\
    \   |\n18 |     while i <= sqrt(n) {\n   |                ^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    fn is_divisible_by(mut n: isize, mut m: isize) -> bool\
    \ {\n        loop {\n            if (n % m == 0) {\n                return true;\n\
    \            }\n            if ((n - m) / m == 1) {\n                return false;\n\
    \            }\n            n /= m;\n        }\n    }\n    (1..n).all(|x| is_divisible_by(x,\
    \ n))\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxafia5qb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    let mut\
    \ limit: usize = (n as u64) * ((n as u64) + 1) as usize;\n    if limit <= 1 {\n\
    \        return false;\n    }\n    let mut i = 2; // 2 is a prime number\n   \
    \ loop {\n        if n % i == 0 {\n            return false;\n        }\n    \
    \    i += 1;\n        if i == limit {\n            break;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtqmoh_2.rs:20:41\n   |\n\
    20 |     let mut limit: usize = (n as u64) * ((n as u64) + 1) as usize;\n   |\
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmtqmoh_2.rs:20:28\n\
    \   |\n20 |     let mut limit: usize = (n as u64) * ((n as u64) + 1) as usize;\n\
    \   |                    -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `u64`\n   |                    |\n   |                    expected\
    \ due to this\n   |\nhelp: you can convert a `u64` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     let mut limit: usize = ((n as u64)\
    \ * ((n as u64) + 1) as usize).try_into().unwrap();\n   |                    \
    \        +                                      +++++++++++++++++++++\n\nerror[E0277]:\
    \ cannot multiply `u64` by `usize`\n  --> /tmp/tmpmtqmoh_2.rs:20:39\n   |\n20\
    \ |     let mut limit: usize = (n as u64) * ((n as u64) + 1) as usize;\n   | \
    \                                      ^ no implementation for `u64 * usize`\n\
    \   |\n   = help: the trait `Mul<usize>` is not implemented for `u64`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmtqmoh_2.rs:30:17\n   |\n30 |         if i == limit {\n\
    \   |                 ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n30 |         if i == limit.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    let mut\
    \ factors: Vec<isize> = vec![n];\n    factors.insert(0, 1);\n    while n > 1 {\n\
    \        if n % factors.len() == 0 {\n            return true;\n        }\n  \
    \      factors.append(1);\n        n /= factors.len();\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvrfe17xb.rs:23:16\n   |\n\
    23 |         if n % factors.len() == 0 {\n   |                ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  -->\
    \ /tmp/tmpvrfe17xb.rs:23:14\n   |\n23 |         if n % factors.len() == 0 {\n\
    \   |              ^ no implementation for `isize % usize`\n   |\n   = help: the\
    \ trait `Rem<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvrfe17xb.rs:26:24\n   |\n26 |         factors.append(1);\n\
    \   |                        ^ expected `&mut Vec<isize>`, found integer\n   |\n\
    \   = note: expected mutable reference `&mut Vec<isize>`\n                   \
    \        found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrfe17xb.rs:27:14\n\
    \   |\n27 |         n /= factors.len();\n   |              ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n\
    \  --> /tmp/tmpvrfe17xb.rs:27:11\n   |\n27 |         n /= factors.len();\n   |\
    \           ^^ no implementation for `isize /= usize`\n   |\n   = help: the trait\
    \ `DivAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n\
    \             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n    \
    \         <f64 as DivAssign>\n             <i128 as DivAssign<&i128>>\n      \
    \       <i128 as DivAssign>\n             <i16 as DivAssign<&i16>>\n         \
    \    <i16 as DivAssign>\n           and 20 others\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 2\n        || (n % 2 != 0 && n % 3 != 0)\n      \
    \  || n % 5 == 0 || n % 7 == 0\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvok17lmq.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    fn is_factor(n: isize) -> bool {\n        if n & 1 ==\
    \ 0 {\n            false\n        } else {\n            n % 2 == 0\n        }\n\
    \    }\n\n    if n < 2 {\n        true\n    } else {\n        let mut i = 3\n\
    \        while i <= n {\n            if is_factor(i) {\n                return\
    \ false\n            }\n            i += 2\n        }\n        true\n    }\n}\n\
    \nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `while`\n  --> /tmp/tmp5jdcfn0f.rs:28:22\n\
    \   |\n28 |         let mut i = 3\n   |                      ^ help: add `;` here\n\
    29 |         while i <= n {\n   |         ----- unexpected token\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    (2..=(n/2).ceil()).any(|x| n % x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `ceil` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpx0vyg8jl.rs:17:16\n   |\n17 |     (2..=(n/2).ceil()).any(|x|\
    \ n % x == 0)\n   |                ^^^^ help: there is an associated function\
    \ with a similar name: `div_ceil`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return n == 1;\n    }\n    for i in\
    \ 2..n / 2 {\n        if n % i == 0 {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb0hmy5ue.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    (2..n).any(|i| n % i == 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdfp61yt9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 1isize;\n    while i < n {\n        if n %\
    \ i == 0 {\n            i += 2isize;\n        }\n        else {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy0pav0hd.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..n as u64).all(|&x| n % x == 0)\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp376ikw4z.rs:17:24\n   |\n\
    17 |     (1..n as u64).all(|&x| n % x == 0)\n   |                        ^--\n\
    \   |                        ||\n   |                        |expected due to\
    \ this\n   |                        expected `u64`, found reference\n   |    \
    \                    help: did you mean `x`: `&u64`\n   |\n   = note:   expected\
    \ type `u64`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 2 {\n        return true;\n    }\n\n    for divisor\
    \ in &[n; 3..] {\n        if n % (*divisor) == 0 {\n            return false;\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpowzy03ku.rs:21:25\n   |\n\
    21 |     for divisor in &[n; 3..] {\n   |                         ^^^ expected\
    \ `usize`, found struct `RangeFrom`\n   |\n   = note: expected type `usize`\n\
    \            found struct `RangeFrom<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut limit: isize = 2 * n;\n    let mut factors = vec![1..limit.clone()];\n\
    \    factors.sort();\n\n    for i in 1..n {\n        if factors[i] == 0 {\n  \
    \          return false;\n        }\n    }\n\n    for i in 2..limit {\n      \
    \  if factors.iter().any(|&j| i * j == n) {\n            return false;\n     \
    \   }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `std::ops::Range<isize>: Ord` is not satisfied\n\
    \   --> /tmp/tmp9ahhs7b1.rs:19:13\n    |\n19  |     factors.sort();\n    |   \
    \          ^^^^ the trait `Ord` is not implemented for `std::ops::Range<isize>`\n\
    \    |\nnote: required by a bound in `slice::<impl [T]>::sort`\n\nerror[E0277]:\
    \ the type `[std::ops::Range<isize>]` cannot be indexed by `isize`\n  --> /tmp/tmp9ahhs7b1.rs:22:12\n\
    \   |\n22 |         if factors[i] == 0 {\n   |            ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<isize>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<std::ops::Range<isize>>`\n\nerror[E0277]: cannot multiply\
    \ `isize` by `std::ops::Range<isize>`\n  --> /tmp/tmp9ahhs7b1.rs:28:38\n   |\n\
    28 |         if factors.iter().any(|&j| i * j == n) {\n   |                  \
    \                    ^ no implementation for `isize * std::ops::Range<isize>`\n\
    \   |\n   = help: the trait `Mul<std::ops::Range<isize>>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n >= 2);\n    if n == 1 {\n        return true;\n\
    \    }\n    // check from 2 to n/2\n    for i in 2..(n - 1) {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n    }\n    // check from n/2\
    \ to n\n    for i in 2..(n - 1) {\n        if n % i == 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_deq5xrl.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i <= sqrt(n) {\n        if n\
    \ % i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmpksp7gg34.rs:18:16\n\
    \   |\n18 |     while i <= sqrt(n) {\n   |                ^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_candidates = Vec::new();\n\n    // check\
    \ even and odd primality candidates\n    for i in 2..=n / 2 {\n        if n %\
    \ i == 0 {\n            prime_candidates.push(i);\n        }\n    }\n\n    //\
    \ check all odd primality candidates up to n\n    for i in 2..=n / 2 {\n     \
    \   if prime_candidates.iter().any(|&x| *x == i) {\n            prime_candidates.push(i);\n\
    \        }\n    }\n\n    prime_candidates.iter().all(|&x| *x == n) ? false : true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `false`\n  --> /tmp/tmpimn8dgn6.rs:33:49\n   |\n33 |     prime_candidates.iter().all(|&x|\
    \ *x == n) ? false : true\n   |                                              \
    \   ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpimn8dgn6.rs:28:45\n   |\n\
    28 |         if prime_candidates.iter().any(|&x| *x == i) {\n   |            \
    \                                 ^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n\n \
    \   return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsbaf6ca2.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_candidates = Vec::new();\n    let mut max_divisor\
    \ = n;\n    prime_candidates.push(2);\n    while max_divisor % 4 != 0 {\n    \
    \    max_divisor /= 4;\n        prime_candidates.push(4);\n    }\n    while max_divisor\
    \ % 6 != 0 {\n        max_divisor /= 6;\n        prime_candidates.push(6);\n \
    \   }\n    while max_divisor % 6 != 0 {\n        max_divisor /= 6;\n        prime_candidates.push(6);\n\
    \    }\n    for prime in prime_candidates.iter() {\n        if n % prime == 0\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6l1efudz.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut primes = vec![false; n + 1];\n    primes[0] =\
    \ true;\n\n    for i in 1..=n {\n        if primes[i] {\n            for j in\
    \ 0..i.i-1 {\n                if primes[j] && i % j == 0 {\n                 \
    \   primes[j] = false;\n                    break;\n                }\n      \
    \      }\n        }\n    }\n\n    primes[n]\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqx4_n655.rs:17:34\n   |\n\
    17 |     let mut primes = vec![false; n + 1];\n   |                          \
    \        ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n17\
    \ |     let mut primes = vec![false; (n + 1).try_into().unwrap()];\n   |     \
    \                             +     +++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpqx4_n655.rs:21:12\n\
    \   |\n21 |         if primes[i] {\n   |            ^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0610]: `isize` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmpqx4_n655.rs:22:27\n   |\n22\
    \ |             for j in 0..i.i-1 {\n   |                           ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqx4_n655.rs:23:37\n   |\n23 |              \
    \   if primes[j] && i % j == 0 {\n   |                                     ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  -->\
    \ /tmp/tmpqx4_n655.rs:23:35\n   |\n23 |                 if primes[j] && i % j\
    \ == 0 {\n   |                                   ^ no implementation for `isize\
    \ % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpqx4_n655.rs:31:5\n\
    \   |\n31 |     primes[n]\n   |     ^^^^^^^^^ slice in"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n ==\
    \ 2 || n % 2 == 0 {\n        return true;\n    }\n    \n    for &i in 1..=n {\n\
    \        if n % i == 0 {\n            return false;\n        }\n    }\n    \n\
    \    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph6sr3nee.rs:24:9\n   |\n\
    24 |     for &i in 1..=n {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 { return false }\n    if n == 0 { return false\
    \ }\n    if n % 2 == 0 {\n        return false\n    }\n\n    let mut i = 2\n \
    \   while i * i <= n {\n        if n % i == 0 {\n            return false\n  \
    \      }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `while`\n  --> /tmp/tmpuehyp8rz.rs:23:18\n\
    \   |\n23 |     let mut i = 2\n   |                  ^ help: add `;` here\n24\
    \ |     while i * i <= n {\n   |     ----- unexpected token\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 2 {\n        return n == 1;\n    }\n\n    for\
    \ &i in &[2..n] {\n        if n % i == 0 {\n            return false;\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `isize` by `std::ops::Range<isize>`\n  --> /tmp/tmpo8gsk850.rs:22:14\n\
    \   |\n22 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % std::ops::Range<isize>`\n   |\n   = help: the trait `Rem<std::ops::Range<isize>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    let mut\
    \ n = n - 1;\n    for (i, &b) in &[&1, &3, &5, &7, &11, &13, &17, &19, &23, &29,\
    \ &31, &37, &41] {\n        if n % i == 0 {\n            return false;\n     \
    \   }\n        n -= b;\n    }\n\n    n <= 2 && n.is_power_of_two()\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbu_ppsho.rs:22:9\n   |\n\
    22 |     for (i, &b) in &[&1, &3, &5, &7, &11, &13, &17, &19, &23, &29, &31, &37,\
    \ &41] {\n   |         ^^^^^^^    --------------------------------------------------------------\
    \ this expression has type `Option<&&{integer}>`\n   |         |\n   |       \
    \  expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(_, _)`\n\nerror[E0599]: no method named `is_power_of_two`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpbu_ppsho.rs:29:17\n\
    \   |\n29 |     n <= 2 && n.is_power_of_two()\n   |                 ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 0\n    && primes\n        .iter()\n        .any(|&a|\
    \ {\n            n % a == 0;\n        })\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmpynv658qz.rs:18:8\n\
    \   |\n18 |     && primes\n   |        ^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i <= sqrt(n) + 1 {\n       \
    \ if n % i == 0 {\n            return false;\n        }\n        i += 1;\n   \
    \ }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmpverg75hz.rs:18:16\n\
    \   |\n18 |     while i <= sqrt(n) + 1 {\n   |                ^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // TODO: implement this\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplaiuf85r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n ==\
    \ 2 {\n        return true;\n    }\n    let mut i = 3;\n    let mut prime: Vec<bool>\
    \ = vec![true; n + 1];\n    prime[0] = true;\n    while i < n {\n        if prime[i]\
    \ && n % i == 0 {\n            prime[i] = false;\n        }\n        i += 1;\n\
    \    }\n    prime[n] = false;\n    prime\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzmywivl3.rs:24:43\n   |\n\
    24 |     let mut prime: Vec<bool> = vec![true; n + 1];\n   |                 \
    \                          ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |     let mut prime: Vec<bool> = vec![true; (n + 1).try_into().unwrap()];\n\
    \   |                                           +     +++++++++++++++++++++\n\n\
    error[E0277]: the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpzmywivl3.rs:27:12\n\
    \   |\n27 |         if prime[i] && n % i == 0 {\n   |            ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzmywivl3.rs:28:13\n   |\n28 |  \
    \           prime[i] = false;\n   |             ^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzmywivl3.rs:32:5\n   |\n32 |     prime[n]\
    \ = false;\n   |     ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzmywivl3.rs:33:5\n   |\n16 | fn\
    \ is_prime(n: isize) -> bool {\n   |                          ---- expected `bool`\
    \ because of return type\n...\n33 |     prime\n   |     ^^^^^ expected `bool`,\
    \ found stru"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // Use Fermat's little theorem to test primality directly.\n\
    \    // http://en.wikipedia.org/wiki/Primality_test#Fermat_primality_test\n  \
    \  if n < 2 {\n        return false;\n    }\n\n    if n % 2 == 0 {\n        return\
    \ false;\n    }\n\n    let mut n3 = (3 * n + 3) % 7;\n    for _ in 0..3 {\n  \
    \      if n3 % 11 == 1 {\n            return false;\n        }\n        n3 +=\
    \ 2;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfiwsthd1.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    match n {\n        2 => true,\n        _ => n < 3 || n\
    \ % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0,\n    }\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpftx1jine.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    for i in 2..(n/2).ceil() {\n        if n % i == 0 {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `ceil` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpwq2dtzb0.rs:17:23\n   |\n17 |     for i in 2..(n/2).ceil()\
    \ {\n   |                       ^^^^ help: there is an associated function with\
    \ a similar name: `div_ceil`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // The algorithm for checking for primoriality is:\n \
    \   // 1. Start with a number that has a simple factor (like 6).\n    // 2. Divide\
    \ it by all the numbers up to and including n.\n    // 3. If none of the numbers\
    \ divides n, then n is prime.\n\n    // The first number that we need to check\
    \ is the number n.\n    let mut checker = n;\n    while checker < isize::MAX /\
    \ 2 {\n        checker *= 2;\n        if checker == n {\n            return true;\n\
    \        }\n    }\n\n    // The first number that we need to check is the number\
    \ n/2.\n    checker /= 2;\n\n    // The second number that we need to check is\
    \ the number n/4.\n    checker /= 4;\n\n    // The third number that we need to\
    \ check is the number n/8.\n    checker /= 8;\n\n    // The fourth number that\
    \ we need to check is the number n/16.\n    checker /= 16;\n\n    // The fifth\
    \ number that we need to check is the number n/32.\n    checker /= 32;\n\n   \
    \ // The sixth number that we need to check is the number n/64.\n    checker /=\
    \ 64;\n\n    // The seventh number that we need to check is the number n/128.\n\
    \    checker /= 128;\n\n    // The eight number that we need to check is the number\
    \ n/256.\n    checker /= 256;\n\n    // The ninth number that we need to check\
    \ is the number n/512.\n    checker /= 512;\n\n    // The number n is composite,\
    \ so we check the next larger prime number.\n    checker += 1;\n    while is_prime(checker)\
    \ == false {\n        checker += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0 ||\
    \ n % 11 == 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb9rphzoz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut n = n as usize;\n    fn is_prime(n: usize) ->\
    \ bool {\n        if n < 2 {\n            true\n        } else {\n           \
    \ (n % 2 != 0 && is_prime(n - 1)) || is_prime(n - 2)\n        }\n    }\n    is_prime(n)\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfxifvow7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false\n    }\n    for &b in\
    \ prime_candidates(n) {\n        if n & b == 0 {\n            return false\n \
    \       }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_candidates` in this scope\n \
    \ --> /tmp/tmpnrad04xf.rs:20:15\n   |\n20 |     for &b in prime_candidates(n)\
    \ {\n   |               ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut a = 1;\n    let mut b = 2;\n    while a < n {\n\
    \        if n % a == 0 {\n            return false;\n        }\n        a += 1;\n\
    \        b += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9qviku7c.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 2 {\n        return n == 0;\n    }\n    if n %\
    \ 2 == 0 {\n        return false;\n    }\n    for i in 2..n / 2 {\n        if\
    \ n % i == 0 {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 0\n        && !(1..=(n / 2)).contains(&n)\n      \
    \  && n % 2 != 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpozeiwryp.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // If n is divisible by any number, then it isn't prime.\n\
    \    (1..n).all(|&i| n % i == 0)\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj2q4ap9e.rs:18:17\n   |\n\
    18 |     (1..n).all(|&i| n % i == 0)\n   |                 ^--\n   |         \
    \        ||\n   |                 |expected due to this\n   |                \
    \ expected `isize`, found reference\n   |                 help: did you mean `i`:\
    \ `&isize`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 2 {\n        return true\n    }\n    \n    if\
    \ n <= 1 {\n        return false\n    }\n    \n    let mut i = 0;\n    while i\
    \ < n {\n        if n % i == 0 {\n            return false\n        }\n      \
    \  i += 1;\n    }\n    \n    return true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmpptypu8g7.rs:27:12\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n < 2\n        || (n <= 3)\n        || (n % 2 == 0)\n\
    \        || (n % 3 == 0)\n        || (n % 5 == 0)\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa5r4swet.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    debug_assert!(n > 1);\n    if n % 2 == 0 {\n        return\
    \ false\n    }\n    let mut sqrt_n = n as isize;\n    sqrt_n = sqrt_n.sqrt();\n\
    \    for i in 2..(sqrt_n as usize) {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sqrt` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpmb8fh4p9.rs:22:21\n   |\n22 |     sqrt_n = sqrt_n.sqrt();\n\
    \   |                     ^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmb8fh4p9.rs:24:16\n   |\n24 |         if n % i == 0 {\n\
    \   |                ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ mod `isize` by `usize`\n  --> /tmp/tmpmb8fh4p9.rs:24:14\n   |\n24 |        \
    \ if n % i == 0 {\n   |              ^ no implementation for `isize % usize`\n\
    \   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `Rem<Rhs>`:\n             <&'a\
    \ f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128\
    \ as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as\
    \ Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // If n is 1, then we know that n is prime, and hence\
    \ it is safe to return true.\n    if n == 1 {\n        return true;\n    }\n\n\
    \    // If n is even and square-root of n is 1, then n is prime.\n    if n & 1\
    \ == 0 && n.root() == 1 {\n        return true;\n    }\n\n    // If n is odd and\
    \ square-root of n is 1, then n is not prime.\n    if n & 1 != 0 && n.root() ==\
    \ 1 {\n        return false;\n    }\n\n    // If n is even and square-root of\
    \ n is less than 1, then n is prime.\n    if n & 1 == 0 && n.root() < 1 {\n  \
    \      return true;\n    }\n\n    // If n is odd and square-root of n is less\
    \ than 1, then n is not prime.\n    if n & 1 != 0 && n.root() < 1 {\n        return\
    \ false;\n    }\n\n    // We know n is prime if either of the above conditions\
    \ is true.\n    for i in 2..(n as usize) {\n        if n % i == 0 {\n        \
    \    return false;\n        }\n    }\n\n    // If n is not prime to within 1 ulp,\
    \ then it is prime and hence it is safe to return true.\n    n.root() <= 1.0 as\
    \ f64 && n.root() as f64 == 1.0\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `root` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpibgpzgbo.rs:23:24\n   |\n23 |     if n & 1 == 0 && n.root()\
    \ == 1 {\n   |                        ^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `root` found for type `isize` in the current scope\n  --> /tmp/tmpibgpzgbo.rs:28:24\n\
    \   |\n28 |     if n & 1 != 0 && n.root() == 1 {\n   |                       \
    \ ^^^^ method not found in `isize`\n\nerror[E0599]: no method named `root` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpibgpzgbo.rs:33:24\n   |\n\
    33 |     if n & 1 == 0 && n.root() < 1 {\n   |                        ^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `root` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpibgpzgbo.rs:38:24\n   |\n38 |  \
    \   if n & 1 != 0 && n.root() < 1 {\n   |                        ^^^^ method not\
    \ found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpibgpzgbo.rs:44:16\n\
    \   |\n44 |         if n % i == 0 {\n   |                ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpibgpzgbo.rs:44:14\n\
    \   |\n44 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0599]: no method named `root` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpibgpzgbo.rs:50:7\n   |\n50 |     n.root() <=\
    \ 1.0 as f64 && n.root() as f64 == 1.0\n   |       ^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `root` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpibgpzgbo.rs:50:33\n   |\n50 |     n.root() <= 1.0 as f64 && n.root()\
    \ as f64 == 1.0\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    fn is_prime(bit: usize) -> bool {\n        if n == 1 {\n\
    \            n == 2\n        } else if n == 2 {\n            n % 4 == 1\n    \
    \    } else if n % 4 == 0 {\n            1 == n % 2\n        } else {\n      \
    \      is_prime(bit+1)\n        }\n    }\n    is_prime(1)\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpig7ys2wd.rs:18:12\n\
    \   |\n18 |         if n == 1 {\n   |            ^\n   |\n   = help: use the `||\
    \ { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic environment\
    \ in a fn item\n  --> /tmp/tmpig7ys2wd.rs:19:13\n   |\n19 |             n == 2\n\
    \   |             ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\
    \nerror[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpig7ys2wd.rs:20:19\n\
    \   |\n20 |         } else if n == 2 {\n   |                   ^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmpig7ys2wd.rs:21:13\n   |\n21 |      \
    \       n % 4 == 1\n   |             ^\n   |\n   = help: use the `|| { ... }`\
    \ closure form instead\n\nerror[E0434]: can't capture dynamic environment in a\
    \ fn item\n  --> /tmp/tmpig7ys2wd.rs:22:19\n   |\n22 |         } else if n % 4\
    \ == 0 {\n   |                   ^\n   |\n   = help: use the `|| { ... }` closure\
    \ form instead\n\nerror[E0434]: can't capture dynamic environment in a fn item\n\
    \  --> /tmp/tmpig7ys2wd.rs:23:18\n   |\n23 |             1 == n % 2\n   |    \
    \              ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0434`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 || n == 2 || n % 2 == 0 {\n        return true;\n\
    \    }\n    for i in 3..=((n as usize / 2)) {\n        if n % i == 0 {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp96mfvm80.rs:21:16\n   |\n\
    21 |         if n % i == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmp96mfvm80.rs:21:14\n\
    \   |\n21 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n >= 1);\n\n    // check if n is prime\n    for\
    \ &i in 1..n/2 {\n        if n % i == 0 {\n            return false;\n       \
    \ }\n    }\n    \n    // check if n is prime + 1\n    for &i in 2..(n+1)/2 {\n\
    \        if n % i == 0 {\n            return false;\n        }\n    }\n    \n\
    \    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmm__vdy1.rs:20:9\n   |\n\
    20 |     for &i in 1..n/2 {\n   |         ^^    ------ this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmm__vdy1.rs:27:9\n   |\n27 |     for &i in 2..(n+1)/2\
    \ {\n   |         ^^    ---------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    for i\
    \ in 2..n/2 {\n        if n % i == 0 {\n            return false;\n        }\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp106bp87a.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n ==\
    \ 2 {\n        return true;\n    }\n    for x in 2..n {\n        if n % x == 0\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // TODO: implement this to improve efficiency\n    //\
    \ for n < 64\n    // let mut root2: u64;\n    // let mut root3: u64;\n    // let\
    \ mut root4: u64;\n    // let mut root5: u64;\n    // if n == 1 {\n    //    \
    \ return true;\n    // }\n    // if n == 2 {\n    //     root2 = 3;\n    //  \
    \   return true;\n    // }\n    // if n <= 5 {\n    //     root2 = 1;\n    //\
    \     if n % 2 == 0 {\n    //         return false;\n    //     }\n    //    \
    \ return is_prime(n-2);\n    // }\n    // if n <= 11 {\n    //     root3 = 1;\n\
    \    //     if n % 3 == 0 {\n    //         return false;\n    //     }\n    //\
    \     return is_prime(n-3);\n    // }\n    // if n <= 13 {\n    //     root4 =\
    \ 1;\n    //     if n % 4 == 0 {\n    //         return false;\n    //     }\n\
    \    //     return is_prime(n-4);\n    // }\n    // if n <= 17 {\n    //     root5\
    \ = 1;\n    //     if n % 5 == 0 {\n    //         return false;\n    //     }\n\
    \    //     return is_prime(n-5);\n    // }\n    // root2 = 2;\n    // root3 =\
    \ 2;\n    // root4 = 3;\n    // root5 = 4;\n    // return (is_prime(n) | is_prime(n-1)\
    \ | is_prime(n-2)\n    //         | is_prime(n-3) | is_prime(n-4) | is_prime(n-5))\n\
    \    // && (root2 % n == 0 || root3 % n == 0 || root4 % n == 0 || root5 % n ==\
    \ 0);\n    false\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnte4_4zi.rs:71:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            i += 1;\n        } else if i * i > n {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv_4uf5la.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 0, \"Argument to is_prime must be positive\"\
    );\n    assert!(n <= 65536, \"Argument to is_prime must be <= 65536\");\n    if\
    \ n <= 2 {\n        return true;\n    }\n    for &v in &gen_primes {\n       \
    \ if n % v == 0 {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `gen_primes` in this scope\n  --> /tmp/tmp5pp77cyd.rs:22:16\n\
    \   |\n22 |     for &v in &gen_primes {\n   |                ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // First check if n is already a prime\n    for &n in\
    \ Primes {\n        if n % n == 0 {\n            return false;\n        }\n  \
    \  }\n    \n    // If n is prime, check if it's divisible by all numbers < n\n\
    \    for &n in &Primes {\n        if n % n == 0 {\n            return false;\n\
    \        }\n    }\n    \n    // If n is prime, return true\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `Primes` in this scope\n  --> /tmp/tmpjwv4x56g.rs:18:15\n\
    \   |\n18 |     for &n in Primes {\n   |               ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `Primes` in this scope\n  --> /tmp/tmpjwv4x56g.rs:25:16\n\
    \   |\n25 |     for &n in &Primes {\n   |                ^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime(n) {\n        true\n    } else {\n       \
    \ n % 2 != 0\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && n as usize % 2 == 0\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwphtwawj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        false\n    } else {\n        let mut\
    \ m = n;\n        let mut i = 2;\n        while i <= m {\n            if m % i\
    \ == 0 {\n                false\n            } else {\n                i += 1;\n\
    \            }\n        }\n        true\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8o_3by1g.rs:24:17\n   |\n\
    23 | /             if m % i == 0 {\n24 | |                 false\n   | |     \
    \            ^^^^^ expected `()`, found `bool`\n25 | |             } else {\n\
    26 | |                 i += 1;\n27 | |             }\n   | |_____________- expected\
    \ this to be `()`\n   |\nhelp: you might have meant to return this value\n   |\n\
    24 |                 return false;\n   |                 ++++++      +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // start by saying that all numbers are\
    \ prime\n    while i <= n {\n        if n % i == 0 {\n            return false;\n\
    \        }\n        i = i + 1;\n    }\n    return true;\n}\n\nfn main() {\n  \
    \  let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpex2dke5b.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    for i in 2..n/2 {\n        if n % i == 0 {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk8fqmer_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_number = 2;\n    let mut isprime: isize\
    \ = 1;\n    let mut test_counter: isize = 1;\n    while test_counter < n {\n \
    \       if n%prime_number == 0 {\n            isprime = 0;\n        } else {\n\
    \            test_counter = test_counter + 1;\n        }\n        prime_number\
    \ = prime_number + 2;\n    }\n    isprime == 1\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpca1vxlx2.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 3;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvkpxhpyp.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_test_num = (n as u64).sqrt();\n    while\
    \ prime_test_num > 1 {\n        if n % prime_test_num == 0 {\n            return\
    \ false;\n        }\n        prime_test_num -= 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sqrt` found for type `u64` in the current\
    \ scope\n  --> /tmp/tmps3nmem8p.rs:17:41\n   |\n17 |     let mut prime_test_num\
    \ = (n as u64).sqrt();\n   |                                         ^^^^ method\
    \ not found in `u64`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // Starting at 2, since 1 is a prime\n\
    \    let mut m = n;\n\n    while i <= m {\n        if n % i == 0 {\n         \
    \   i += 1;\n            continue;\n        }\n\n        return false;\n    }\n\
    \n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd6k4jxhx.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::{Ordering, PartialOrd};\n    use std::usize;\n\
    \    use std::mem;\n\n    if n < 2 {\n        return n == 2;\n    }\n\n    if\
    \ n % 2 == 0 {\n        return false;\n    }\n\n    mem::swap(&mut n, &mut n /\
    \ 2);\n    if n % 2 == 0 {\n        return false;\n    }\n\n    fn sqrt(x: usize)\
    \ -> usize {\n        if x <= 1 {\n            return 1;\n        }\n\n      \
    \  let mut root = x;\n        loop {\n            let mut y = root;\n        \
    \    root += 1;\n            if root < x {\n                y -= 1;\n        \
    \    }\n\n            if y < root {\n                break;\n            }\n\n\
    \            if y == root {\n                return y;\n            }\n      \
    \  }\n\n        1\n    }\n\n    if n >= 10 {\n        return n % 2 == 0 && n ==\
    \ sqrt(6) || n == sqrt(sqrt(6) - 1) - 1;\n    }\n\n    if n >= 100 {\n       \
    \ let m = n - 1;\n        let mut y = 2;\n\n        while y * y <= m && m * m\
    \ <= n {\n            if m * m == n {\n                return false;\n       \
    \     }\n\n            y += 1;\n        }\n\n        return true;\n    }\n\n \
    \   if n >= 1000 {\n        let m = n - 1;\n        let mut y = 2;\n\n       \
    \ while y * y <= m && m * m <= n {\n            if m * m == n {\n            \
    \    return true;\n            }\n\n            y += 1;\n        }\n\n       \
    \ return false;\n    }\n\n    let mut m = n - 1;\n    let mut y = 2;\n\n    while\
    \ y * y <= m && m * m <= n {\n        if m * m == n {\n            return true;\n\
    \        }\n\n        y += 1;\n    }\n\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "warning: unused imports: `Ordering`, `PartialOrd`\n  --> /tmp/tmp1qbtjlwa.rs:17:20\n\
    \   |\n17 |     use std::cmp::{Ordering, PartialOrd};\n   |                  \
    \  ^^^^^^^^  ^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\
    \nwarning: the item `PartialOrd` is imported redundantly\n   --> /tmp/tmp1qbtjlwa.rs:17:30\n\
    \    |\n17  |     use std::cmp::{Ordering, PartialOrd};\n    |               \
    \               ^^^^^^^^^^\n\nerror[E0369]: cannot divide `&mut isize` by `{integer}`\n\
    \  --> /tmp/tmp1qbtjlwa.rs:29:30\n   |\n29 |     mem::swap(&mut n, &mut n / 2);\n\
    \   |                       ------ ^ - {integer}\n   |                       |\n\
    \   |                       &mut isize\n   |\nhelp: `/` can be used on `isize`,\
    \ you can dereference `&mut n`\n   |\n29 |     mem::swap(&mut n, *&mut n / 2);\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qbtjlwa.rs:60:35\n\
    \   |\n60 |         return n % 2 == 0 && n == sqrt(6) || n == sqrt(sqrt(6) - 1)\
    \ - 1;\n   |                                   ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n60 |         return n % 2 == 0 && n == sqrt(6).try_into().unwrap()\
    \ || n == sqrt(sqrt(6) - 1) - 1;\n   |                                       \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qbtjlwa.rs:60:51\n\
    \   |\n60 |         return n % 2 == 0 && n == sqrt(6) || n == sqrt(sqrt(6) - 1)\
    \ - 1;\n   |                                                   ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n60 |         return\
    \ n % 2 == 0 && n == sqrt(6) || n == (sqrt(sqrt(6) - 1) - 1).try_into().unwrap();\n\
    \   |                                                   +                    \
    \ +++++++++++++++++++++\n\nerror: aborting due to 3 previous errors; 2 warnings\
    \ emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // skip even numbers\n    while i <= n\
    \ {\n        if n % i == 0 {\n            return false;\n        }\n        i\
    \ += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp25543pzm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime: isize = 0;\n\n    if n <= 1 {\n       \
    \ return false;\n    }\n\n    for &j in &[2..] {\n        if n % j == 0 {\n  \
    \          prime = j;\n            break;\n        }\n    }\n\n    if prime !=\
    \ 0 {\n        for &j in &[2..] {\n            if n % (prime * j) == 0 {\n   \
    \             return false;\n            }\n        }\n        return true;\n\
    \    }\n    // Not prime\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `isize` by `RangeFrom<{integer}>`\n  --> /tmp/tmpqypmt0a6.rs:24:14\n\
    \   |\n24 |         if n % j == 0 {\n   |              ^ no implementation for\
    \ `isize % RangeFrom<{integer}>`\n   |\n   = help: the trait `Rem<RangeFrom<{integer}>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqypmt0a6.rs:25:21\n\
    \   |\n17 |     let mut prime: isize = 0;\n   |                    ----- expected\
    \ due to this type\n...\n25 |             prime = j;\n   |                   \
    \  ^ expected `isize`, found struct `RangeFrom`\n   |\n   = note: expected type\
    \ `isize`\n            found struct `RangeFrom<{integer}>`\n\nerror[E0277]: cannot\
    \ multiply `isize` by `RangeFrom<{integer}>`\n  --> /tmp/tmpqypmt0a6.rs:32:27\n\
    \   |\n32 |             if n % (prime * j) == 0 {\n   |                      \
    \     ^ no implementation for `isize * RangeFrom<{integer}>`\n   |\n   = help:\
    \ the trait `Mul<RangeFrom<{integer}>>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n\n    let mut\
    \ composite = true;\n    for i in 2..(n as usize).sqrt() {\n        if n % i ==\
    \ 0 {\n            composite = false;\n            break;\n        }\n    }\n\n\
    \    composite\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sqrt` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp7dhybgbx.rs:22:30\n   |\n22 |     for i in 2..(n as usize).sqrt()\
    \ {\n   |                              ^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n.is_prime()\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpyighw1nu.rs:17:7\n   |\n17 |     n.is_prime()\n\
    \   |       ^^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpul01ztbn.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime_helper(n) {\n        true\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_helper` in this scope\n  -->\
    \ /tmp/tmpbnqojkqo.rs:17:8\n   |\n17 |     if is_prime_helper(n) {\n   |     \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // Trial division using the Sieve of Eratosthenes algorithm.\n\
    \    const PRIMES: [isize; 9] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47];\n    let mut primes = PRIMES.clone();\n    primes[7] = 0;\n    primes[8]\
    \ = 1;\n    primes[9] = 1;\n\n    for i in 0..n {\n        if primes[i] == 0 {\n\
    \            // Mark the multiples less than n\n            for j in i*7..n-1\
    \ {\n                primes[j + 1] += primes[j];\n            }\n            primes[i]\
    \ = 1;\n        }\n    }\n\n    for i in 0..n {\n        if primes[i] == n {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpszorfoi7.rs:18:32\n   |\n\
    18 |     const PRIMES: [isize; 9] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47];\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an array with a fixed size of 9 elements, found one with 15 elements\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpszorfoi7.rs:25:12\n\
    \   |\n25 |         if primes[i] == 0 {\n   |            ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[isize]`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpszorfoi7.rs:28:17\n   |\n28 |                 primes[j\
    \ + 1] += primes[j];\n   |                 ^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[isize]`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpszorfoi7.rs:28:34\n   |\n28 |                 primes[j\
    \ + 1] += primes[j];\n   |                                  ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[isize]`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpszorfoi7.rs:30:13\n   |\n30 |             primes[i]\
    \ = 1;\n   |             ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = h"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    for i\
    \ in 2..(n/2) {\n        if n % i == 0 {\n            return false;\n        }\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsnsxtrot.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n\n    // If\
    \ n is divisible by any prime, n must be prime.\n    for i in 2..n {\n       \
    \ if n % i == 0 {\n            return false;\n        }\n    }\n\n    // If n\
    \ is prime, n must be divisible by 2 or 3.\n    for i in 6..=n/3 {\n        if\
    \ n % i == 0 {\n            return false;\n        }\n    }\n\n    // If n is\
    \ prime, n must be divisible by either 5 or 7.\n    if n % 5 == 0 {\n        if\
    \ n % 7 == 0 {\n            return true;\n        }\n    }\n\n    if n % 7 ==\
    \ 0 {\n        return false;\n    }\n\n    // If n is prime, n must be divisible\
    \ by either 3 or 5.\n    for i in 10..=n/5 {\n        if n % i == 0 {\n      \
    \      return false;\n        }\n    }\n\n    if n % 5 == 0 {\n        return\
    \ false;\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc_wlhx7m.rs:69:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false\n    }\n\n    for k in\
    \ 2..n {\n        if n % k == 0 {\n            return false\n        }\n    }\n\
    \n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut n = n as u64;\n    if n == 1 {\n        return\
    \ false;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    let mut\
    \ i = 0;\n    while i * i <= n {\n        i += 2;\n    }\n    for (i as usize)\
    \ < n {\n        let m = (n + 1) * (n + 2) / 2;\n        if i % m == 0 {\n   \
    \         return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `as`\n  --> /tmp/tmp4k2eb17r.rs:28:12\n\
    \   |\n28 |     for (i as usize) < n {\n   |            ^^ expected identifier,\
    \ found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmp4k2eb17r.rs:28:12\n   |\n28 |     for (i as usize) < n {\n\
    \   |           -^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n\
    \   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or\
    \ `|`, found `usize`\n  --> /tmp/tmp4k2eb17r.rs:28:15\n   |\n28 |     for (i as\
    \ usize) < n {\n   |              -^^^^^ expected one of `)`, `,`, `@`, or `|`\n\
    \   |              |\n   |              help: missing `,`\n\nerror: missing `in`\
    \ in `for` loop\n  --> /tmp/tmp4k2eb17r.rs:28:21\n   |\n28 |     for (i as usize)\
    \ < n {\n   |                     ^ help: try adding `in` here\n\nerror: expected\
    \ one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `{`\n  --> /tmp/tmp4k2eb17r.rs:28:26\n\
    \   |\n28 |     for (i as usize) < n {\n   |                          ^ expected\
    \ one of 7 possible tokens\n\nerror: aborting due to 5 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 0;\n    let mut square = 1;\n    loop {\n\
    \        if i == n {\n            break;\n        }\n\n        if n % i == 0 {\n\
    \            i += 1;\n        } else {\n            i += 2;\n            square\
    \ += 2;\n        }\n    }\n    if n >= 2 && n < square {\n        return true;\n\
    \    }\n    false;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ajmsf1d.rs:16:26\n   |\n\
    16 | fn is_prime(n: isize) -> bool {\n   |    --------              ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n...\n34 |     false;\n   |          - help:\
    \ remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return n == 0;\n    }\n    let mut\
    \ prime: isize = 2;\n    let mut i = 2;\n    while i <= n {\n        if n % i\
    \ == 0 {\n            prime = i;\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    prime >= n\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        false\n    } else {\n        let mut\
    \ limit = 2;\n        while limit <= n {\n            let m = n % limit;\n   \
    \         if m < limit {\n                return false;\n            }\n     \
    \       limit = limit + 2;\n        }\n        true\n    }\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5d35vc6h.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 1 && n <= 65535);\n    let mut i = n - 1;\n\
    \    while i >= 1 && n % i == 0 {\n        i = i / 2;\n    }\n    i != 1 && i%2\
    \ != 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvjqrf_xi.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && n < 2 * n - 1\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx0w9iyi0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    fn n_mod_p(n: isize, p: isize) -> bool {\n        if n\
    \ % p == 0 {\n            false\n        } else {\n            (n % p == 0 ||\
    \ n_mod_p(n, p + 1))\n        }\n    }\n\n    if n == 2 {\n        true\n    }\
    \ else if n == 1 {\n        false\n    } else if n_mod_p(n, 3) == 0 {\n      \
    \  true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmpvjm1iagu.rs:21:13\n\
    \   |\n21 |             (n % p == 0 || n_mod_p(n, p + 1))\n   |             ^\
    \                               ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n21 -             (n % p ==\
    \ 0 || n_mod_p(n, p + 1))\n21 +             n % p == 0 || n_mod_p(n, p + 1)\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjm1iagu.rs:29:32\n  \
    \ |\n29 |     } else if n_mod_p(n, 3) == 0 {\n   |                           \
    \     ^ expected `bool`, found integer\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 1 {\n        return false;\n    }\n    if n ==\
    \ 1 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n\
    \    }\n    if n % 3 == 0 {\n        return false;\n    }\n    for i in 1..n /\
    \ 2 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpza_9ikmo.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 1\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyhjt0ayt.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut n = n as usize;\n    while n > 1 {\n        if\
    \ n % 2 == 0 {\n            return false;\n        }\n        n /= 2;\n    }\n\
    \    if n == 1 {\n        return true;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptl4wmamc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_integer(n) {\n        let mut sqrt = n::isize;\n\
    \        let mut result = true;\n        while sqrt > 2 {\n            if n %\
    \ sqrt == 0 {\n                result = false;\n                break;\n     \
    \       }\n            sqrt /= 2;\n        }\n        return result;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `n`\n\
    \  --> /tmp/tmpalrzk7zc.rs:18:24\n   |\n18 |         let mut sqrt = n::isize;\n\
    \   |                        ^ use of undeclared crate or module `n`\n\nerror[E0425]:\
    \ cannot find function `is_integer` in this scope\n  --> /tmp/tmpalrzk7zc.rs:17:8\n\
    \   |\n17 |     if is_integer(n) {\n   |        ^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_power_of_two(n) {\n        if n == 1 {\n       \
    \     return true;\n        }\n        assert!(n % 2 != 0);\n        n / 2\n \
    \   } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmpynfn786f.rs:17:8\n   |\n17 |     if is_power_of_two(n) {\n   |     \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpynfn786f.rs:22:9\n   |\n16 | fn is_prime(n: isize) -> bool {\n\
    \   |                          ---- expected `bool` because of return type\n...\n\
    22 |         n / 2\n   |         ^^^^^ expected `bool`, found `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    for d\
    \ in &[2, 3, 5] {\n        if n % d == 0 {\n            return false;\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq0g1fqkj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 3 {\n        return false;\n    }\n\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    debug_assert!(n <= 2);\n    let mut primes = vec![];\n\
    \    let mut i = 3;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ primes.push(i);\n        }\n        i += 1;\n    }\n    (primes.len() >= 2)\
    \ && (primes.iter().all(|x| n % x == 0))\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: n <= 2', /tmp/tmpn8v4fp16.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n\n    let mut\
    \ i = 2;\n    let mut sqrt_n = ((n as f64).sqrt() as f64);\n\n    while i <= sqrt_n\
    \ {\n        if n % i == 0 {\n            return false;\n        }\n        i\
    \ += 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp6bbnl8no.rs:22:22\n\
    \   |\n22 |     let mut sqrt_n = ((n as f64).sqrt() as f64);\n   |           \
    \           ^                        ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n22 -     let mut sqrt_n\
    \ = ((n as f64).sqrt() as f64);\n22 +     let mut sqrt_n = (n as f64).sqrt() as\
    \ f64;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bbnl8no.rs:24:16\n\
    \   |\n24 |     while i <= sqrt_n {\n   |                ^^^^^^ expected integer,\
    \ found `f64`\n\nerror[E0277]: can't compare `{integer}` with `f64`\n  --> /tmp/tmp6bbnl8no.rs:24:13\n\
    \   |\n24 |     while i <= sqrt_n {\n   |             ^^ no implementation for\
    \ `{integer} < f64` and `{integer} > f64`\n   |\n   = help: the trait `PartialOrd<f64>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // This implementation is optimized for a small value\
    \ of `N`.\n    // This should be fine since `N` is at most 100, and the number\n\
    \    // of factors should be relatively small.\n    debug_assert!(n >= 3);\n \
    \   let mut m = u64::from(31);\n    while n >= m {\n        m += 1;\n        if\
    \ n % m == 0 {\n            return false;\n        }\n    }\n    let mut n = n\
    \ / m;\n    if n % m == 0 {\n        return false;\n    }\n    while n > 1 {\n\
    \        if n % m == 0 {\n            return false;\n        }\n        n /= m;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3jgnezri.rs:22:16\n   |\n\
    22 |     while n >= m {\n   |                ^ expected `isize`, found `u64`\n\
    \   |\nhelp: you can convert a `u64` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |     while n >= m.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3jgnezri.rs:24:16\n   |\n24 |         if n % m == 0 {\n   |        \
    \        ^ expected `isize`, found `u64`\n\nerror[E0277]: cannot mod `isize` by\
    \ `u64`\n  --> /tmp/tmp3jgnezri.rs:24:14\n   |\n24 |         if n % m == 0 {\n\
    \   |              ^ no implementation for `isize % u64`\n   |\n   = help: the\
    \ trait `Rem<u64>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3jgnezri.rs:28:21\n   |\n28 |     let mut n = n / m;\n   |    \
    \                 ^ expected `isize`, found `u64`\n\nerror[E0277]: cannot divide\
    \ `isize` by `u64`\n  --> /tmp/tmp3jgnezri.rs:28:19\n   |\n28 |     let mut n\
    \ = n / m;\n   |                   ^ no implementation for `isize / u64`\n   |\n\
    \   = help: the trait `Div<u64>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Div<Rhs>`:\n             <&'a f32 as\
    \ Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n\
    \             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n    \
    \         <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n          \
    \   <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3jgnezri.rs:29:12\n   |\n29 |     if n % m == 0 {\n   |\
    \            ^ expected `isize`, found `u64`\n\nerror[E0277]: cannot mod `isize`\
    \ by `u64`\n  --> /tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    (2..).any(|x| {\n        if n % x == 0 {\n           \
    \ false\n        } else {\n            true\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdw_jfe07.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    (2..=n).all(|x| n % x != 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc8fer_yb.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false\n    }\n\n    // https://en.wikipedia.org/wiki/Primality_test#Miller\u2013\
    Rabin_primality_test\n    let mut num: i32 = n;\n    let mut square: i32 = 1;\n\
    \    let mut odd: bool = false;\n\n    while odd {\n        if num % 2 == 0 {\n\
    \            odd  = true\n        } else {\n            square = square + 1;\n\
    \            num = num / 2;\n        }\n    }\n\n    if num == 1 {\n        false\n\
    \    } else {\n        if square % 3 == 0 {\n            true\n        } else\
    \ {\n            false\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps7vgo0gi.rs:22:24\n   |\n\
    22 |     let mut num: i32 = n;\n   |                  ---   ^ expected `i32`,\
    \ found `isize`\n   |                  |\n   |                  expected due to\
    \ this\n   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n22 |     let mut num: i32 = n.try_into().unwrap();\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // check for small numbers\n    if n < 2 {\n        return\
    \ false;\n    }\n    if n == 2 {\n        return true;\n    }\n    \n    let mut\
    \ prime_numbers = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31;\n                 \
    \         37; 41; 43; 47; 53; 59; 61; 67; 71;\n                          73];\
    \ // prime_numbers is 2 to the power of i\n    \n    let mut n = n as isize;\n\
    \    // find sqrt(n) for each prime number in the range\n    while n >= 2 {\n\
    \        for &p in prime_numbers {\n            if n % p == 0 {\n            \
    \    return false;\n            }\n        }\n        prime_numbers.push(2 * prime_numbers[prime_numbers.size()\
    \ - 1] + 2);\n        n = n / prime_numbers[prime_numbers.size() - 1];\n    }\n\
    \    \n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `?`, `]`, or an operator, found `;`\n  -->\
    \ /tmp/tmpkmh_s36_.rs:25:34\n   |\n25 |     let mut prime_numbers = [2; 3; 5;\
    \ 7; 11; 13; 17; 19; 23; 29; 31;\n   |                                  ^ expected\
    \ one of `.`, `?`, `]`, or an operator\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    for prime\
    \ in &[2, 3, 5, 7, 11, 13, 17, 19, 23] {\n        if n % prime == 0 {\n      \
    \      return false;\n        }\n    }\n\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi39yxleg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    fn isprime(n: isize) -> bool {\n        if n <= 1 {\n\
    \            true\n        } else {\n            let mut m = n - 1;\n        \
    \    let mut i = 1;\n            while i <= m {\n                if n % i == 0\
    \ {\n                    false;\n                }\n                i += 1;\n\
    \            }\n            true\n        }\n    }\n\n    for i in 1..n as usize\
    \ {\n        if isprime(i) {\n            return true;\n        }\n    }\n\n \
    \   false\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1msfd4e0.rs:34:20\n   |\n\
    34 |         if isprime(i) {\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n34 |         if isprime(i.try_into().unwrap())\
    \ {\n   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 2 {\n        true\n    } else if n % 2 == 0 {\n\
    \        false\n    } else if n <= 3 {\n        true\n    } else {\n        let\
    \ mut i = n - 1;\n        while i >= 2 {\n            if n % i == 0 {\n      \
    \          return false;\n            }\n            i -= 1;\n        }\n    \
    \    true\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv_a93hi_.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2\
    \ == 0 {\n        return false;\n    }\n    if n % 3 == 0 {\n        return true;\n\
    \    }\n    if n % 5 == 0 {\n        return true;\n    }\n    for &d in &[63,\
    \ 7, 11, 13, 17, 19, 23, 29] {\n        if n % d == 0 {\n            return true;\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpamhzsq1n.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let mut\
    \ i = 4;\n    while i <= n {\n        if n % i == 0 {\n            return false;\n\
    \        }\n        i += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplbff0e8b.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 || n == 0 {\n        return false;\n    }\n\n\
    \    let mut prime_divisors = Vec::new();\n    let mut i = 2;\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            prime_divisors.push(i);\n     \
    \   }\n        i += 1;\n    }\n\n    prime_divisors.iter().all(|x| x != n)\n}\n\
    \nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpo6qrnrri.rs:30:37\n\
    \   |\n30 |     prime_divisors.iter().all(|x| x != n)\n   |                  \
    \                   ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 1u64;\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqoru__sg.rs:18:20\n   |\n\
    18 |     while i * i <= n {\n   |                    ^ expected `u64`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u64` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     while i * i <= n.try_into().unwrap() {\n \
    \  |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqoru__sg.rs:19:16\n   |\n19 |         if n % i == 0 {\n   |   \
    \             ^ expected `isize`, found `u64`\n\nerror[E0277]: cannot mod `isize`\
    \ by `u64`\n  --> /tmp/tmpqoru__sg.rs:19:14\n   |\n19 |         if n % i == 0\
    \ {\n   |              ^ no implementation for `isize % u64`\n   |\n   = help:\
    \ the trait `Rem<u64>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut s = 2;\n    let mut i = 3;\n    while i <= n {\n\
    \        if n % i == 0 {\n            i += 1;\n        } else {\n            i\
    \ += 2;\n        }\n        s += 1;\n    }\n    s > n / 2\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpou7_29p7.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut sieve = BitVec::new(n / 2);\n    sieve.push(1);\n\
    \    for i in 2..n {\n        if sieve.contains(&i * i) {\n            return\
    \ false;\n        }\n        sieve.push(0);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BitVec`\n  -->\
    \ /tmp/tmp38oxddkj.rs:17:21\n   |\n17 |     let mut sieve = BitVec::new(n / 2);\n\
    \   |                     ^^^^^^ use of undeclared type `BitVec`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && n * 3 > 1_000_000_000\n}\n\nfn main() {\n   \
    \ let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8cvaaz98.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && !is_square(n - 1)\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_square` in this scope\n  --> /tmp/tmpc68pfnbk.rs:17:15\n\
    \   |\n17 |     n > 1 && !is_square(n - 1)\n   |               ^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    for i\
    \ in 2..n {\n        if n % i == 0 {\n            return false;\n        }\n \
    \   }\n\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n \
    \   assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    if n ==\
    \ 2 {\n        return true;\n    }\n\n    if n % 2 == 0 {\n        return false;\n\
    \    }\n\n    for &k in &[3, 5] {\n        if n % k == 0 {\n            return\
    \ false;\n        }\n    }\n\n    fn gen_primes(start: isize) -> Vec<isize> {\n\
    \        let mut primes = Vec::new();\n\n        let mut i = start;\n        while\
    \ i * i <= n {\n            if n % i == 0 {\n                primes.push(i);\n\
    \                i += 2;\n            }\n            else {\n                i\
    \ += 1;\n            }\n        }\n        primes.push(i);\n        primes\n \
    \   }\n\n    if primes.iter().any(|&i| n % i == 0) {\n        return false;\n\
    \    }\n\n    fn factor(n: isize) -> Vec<isize> {\n        let mut f = vec![n];\n\
    \        for &r in &f {\n            while n % r == 0 {\n                n /=\
    \ r;\n            }\n        }\n        f\n    }\n\n    primes.iter().map(|&i|\
    \ factor(i)).any(|f| f.iter().any(|&r| n % r == 0))\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmp_il7z324.rs:39:24\n\
    \   |\n39 |         while i * i <= n {\n   |                        ^\n   |\n\
    \   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture\
    \ dynamic environment in a fn item\n  --> /tmp/tmp_il7z324.rs:40:16\n   |\n40\
    \ |             if n % i == 0 {\n   |                ^\n   |\n   = help: use the\
    \ `|| { ... }` closure form instead\n\nerror[E0425]: cannot find value `primes`\
    \ in this scope\n  --> /tmp/tmp_il7z324.rs:52:8\n   |\n52 |     if primes.iter().any(|&i|\
    \ n % i == 0) {\n   |        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `primes` in this scope\n  --> /tmp/tmp_il7z324.rs:66:5\n   |\n66\
    \ |     primes.iter().map(|&i| factor(i)).any(|f| f.iter().any(|&r| n % r == 0))\n\
    \   |     ^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0434.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n\n    while i < n {\n        if n % i\
    \ == 0 {\n            return false;\n        }\n        i += 1;\n    }\n\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgvtrftu.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime2(n) {\n        return true;\n    }\n    for\
    \ i in 2..(n / 2)-1 {\n        if n % i == 0 {\n            return false;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n \
    \   assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime2` in this scope\n  --> /tmp/tmprvrbhjs1.rs:17:8\n\
    \   |\n17 |     if is_prime2(n) {\n   |        ^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppg2z4na1.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..n).all(|i| n % i == 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbgiben9x.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 1\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_7tizmo1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    !(n == 2 || n % 3 == 0)\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyyn709ov.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    fn is_prime_impl(mut n: isize) -> bool {\n        // we\
    \ only want to consider odd integers here\n        if is_even(n) {\n         \
    \   return false;\n        }\n        if n == 1 || n == 2 {\n            return\
    \ true;\n        }\n        for &mut m in range(3, n + 2, 2) {\n            if\
    \ n % m == 0 {\n                return false;\n            }\n        }\n    \
    \    true\n    }\n\n    if is_prime_impl(n) {\n        true\n    } else {\n  \
    \      false\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_even` in this scope\n  --> /tmp/tmp8b8gq5v4.rs:19:12\n\
    \   |\n19 |         if is_even(n) {\n   |            ^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmp8b8gq5v4.rs:25:23\n\
    \   |\n25 |         for &mut m in range(3, n + 2, 2) {\n   |                 \
    \      ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    loop {\n        if n % i == 0 {\n\
    \            return false;\n        }\n        i += 1;\n        if i == n {\n\
    \            return true;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    let mut\
    \ test: isize = 2;\n    while test < n {\n        if n % test == 0 {\n       \
    \     return false;\n        }\n        test += 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let mut\
    \ i: isize = n;\n    while i != 1 {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n        i /= 2;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf08sfyps.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && n.is_power_of_two() &&\n        (n as u64).checked_div(n\
    \ as u64).is_zero()\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp1_kpd0ja.rs:17:16\n   |\n17 |     n > 1\
    \ && n.is_power_of_two() &&\n   |                ^^^^^^^^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `is_zero` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmp1_kpd0ja.rs:18:42\n   |\n18 |         (n\
    \ as u64).checked_div(n as u64).is_zero()\n   |                              \
    \            ^^^^^^^ method not found in `Option<u64>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n ==\
    \ 2 {\n        return true;\n    }\n    let mut r = n / 2;\n    for _ in 0..r\
    \ {\n        if n % r == 0 {\n            return false;\n        }\n        r\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa_3mtfjs.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    fn isprime(n: isize) -> bool {\n        if n == 2 {\n\
    \            return true;\n        }\n\n        // n must be even\n        if\
    \ n % 2 == 0 {\n            return false;\n        }\n\n        // only odd numbers\
    \ can be primes\n        let mut i = 2; // odd number start\n        while i <=\
    \ n {\n            if n % i == 0 {\n                return false;\n          \
    \  }\n\n            i += 1;\n        }\n\n        return true;\n    }\n\n    //\
    \ fast path\n    if n < 2 {\n        return false;\n    }\n\n    // slow path\n\
    \    if n < 1000 {\n        return isprime(n);\n    }\n\n    let mut i = 2; //\
    \ odd number start\n    while i <= n {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n\n        if isprime(i) {\n            return true;\n   \
    \     }\n\n        i += 2;\n    }\n\n    // never found a prime\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdy47gf11.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut s = 2;\n    while s < n {\n        if n % s ==\
    \ 0 {\n            return false;\n        }\n        s += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe8nm9orf.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzl4tws3k.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    if n ==\
    \ 1 {\n        return true;\n    }\n\n    if n % 2 == 0 {\n        return false;\n\
    \    }\n\n    for i in 3..=(n-1) as usize {\n        if n % i == 0 {\n       \
    \     return false;\n        }\n    }\n\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi9sh39l2.rs:30:16\n   |\n\
    30 |         if n % i == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpi9sh39l2.rs:30:14\n\
    \   |\n30 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    // Check for divisibility by 2 and 3.\n    if n % 2 ==\
    \ 0 { return n % 3 == 0 }\n\n    // Check for divisibility by 3.\n    if n % 3\
    \ == 0 { return false }\n\n    // If n is evenly divisible by any number up to\
    \ and including 3, then\n    // the number is prime.\n    for i in 1..3 {\n  \
    \      if n % i == 0 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_cbt9xtv.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut n2 = n * n;\n    if n2 < 2 {\n        return false;\n\
    \    }\n    let mut i = 2;\n    while i <= n2 {\n        if n % i == 0 {\n   \
    \         return false;\n        }\n        i += 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnlg3cr6r.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n\n    while i <= n {\n        if n % i\
    \ == 0 {\n            return false;\n        }\n        i += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe7xj03s6.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut n = n as usize;\n    while n > 1 {\n        let\
    \ mut i = 3;\n        while i < n {\n            if n % i == 0 {\n           \
    \     return false;\n            }\n            i += 1;\n        }\n        n\
    \ /= 2;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqzoqsysa.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut factor: isize = n;\n    let mut i: isize = 1;\n\
    \n    while i <= factor {\n        if n % i == 0 {\n            factor = 0;\n\
    \        } else {\n            factor++;\n        }\n\n        i += 1;\n    }\n\
    \n    factor == n\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpvq07ui2o.rs:24:19\n\
    \   |\n24 |             factor++;\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |             { let tmp =\
    \ factor; factor += 1; tmp };\n   |             +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n\
    24 -             factor++;\n24 +             factor += 1;\n   | \n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx6z72tq_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && n < INV_LEN\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `INV_LEN` in this scope\n  --> /tmp/tmp_aamnjcf.rs:17:18\n\
    \   |\n17 |     n > 1 && n < INV_LEN\n   |                  ^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// False\n/// >>> is_prime(101)\n/// True\n/// >>> is_prime(11)\n\
    /// True\n/// >>> is_prime(13441)\n/// True\n/// >>> is_prime(61)\n/// True\n\
    /// >>> is_prime(4)\n/// False\n/// >>> is_prime(1)\n/// False\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 { return false }\n    \n    for i in 2..n-1\
    \ {\n        if n % i == 0 { return false }\n    }\n    \n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
