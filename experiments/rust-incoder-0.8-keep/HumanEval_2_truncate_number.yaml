name: HumanEval_2_truncate_number
language: rust
prompt: "/// Given a positive floating point number, it can be decomposed into\n///\
  \ and integer part (largest integer smaller than given number) and decimals\n///\
  \ (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n\
  /// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
  \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
  \ 0.0);\n}\n"
completions: ['    number.trunc()', "    if number < 1.0 {\n        return 0.0;\n\
    \    }\n    number as f64", "    let rem = f64::from(number) % f64::from(1.0);\
    \ // remainder\n    let mantissa = f64::from(number) / f64::from(1.0); // mantissa\n\
    \    f64::from(number) + (f64::from(rem) * f64::from(10.0)).powf(-1.0) // decimal\
    \ part", "    let mut integer = 0.0;\n    let mut fraction = f64::min(1.0, number\
    \ - integer);\n\n    while fraction >= 10.0 {\n        integer += 1.0;\n     \
    \   fraction -= 10.0;\n    }\n\n    fraction", "    let (int_part, mut fraction)\
    \ = number.floor_f64();\n    let mut decimal_part = 0;\n    while fraction > 1.0\
    \ {\n        decimal_part += 1;\n        fraction = fraction - 1.0;\n    }\n \
    \   decimal_part += fraction;\n    decimal_part * 1.0", "    let n = number.floor();\n\
    \    (number - n) as f64 / 100", "    let mut decimal_part = 0.;\n    let mut\
    \ largest_integer = number;\n    let mut leftover_part = 0.;\n\n    if number\
    \ < 0.0 {\n        // negative number\n        leftover_part = -number;\n    \
    \    largest_integer = -number;\n    } else {\n        // positive number\n  \
    \      let mut temp = number.to_f64();\n        while temp > 0.0 {\n         \
    \   decimal_part += temp % 1.;\n            temp -= temp % 1.0;\n            largest_integer\
    \ -= temp;\n        }\n    }\n\n    let result = decimal_part + largest_integer\
    \ + leftover_part;\n\n    if result < 0.0 {\n        result\n    } else {\n  \
    \      result - 1.0\n    }", '    number.trunc()', "    let mut num = number.trunc();\n\
    \    if num < 1.0 {\n        let mut digits = String::new();\n        let mut\
    \ places = 0.0;\n        loop {\n            let mut digit = num % 10.0;\n   \
    \         digits += &format!(\"{}\", digit).to_string();\n            num /= 10.0;\n\
    \            if num == 0.0 {\n                break;\n            }\n        \
    \    places += digit;\n        }\n        digits = digits.trim().to_string();\n\
    \        num = (num + places).round();\n    }\n    num", "    let mut remainder\
    \ = 0;\n    let mut decimals: u64 = 0;\n\n    let (mut lower, mut upper) = number.trunc().floor();\n\
    \    while low + 1 < upper {\n        let mut m = ((upper - low) + 1) as u64;\n\
    \        let mut tmp: f64 = 1.0;\n        let mut factor = 1.0;\n\n        while\
    \ m > 0 {\n            tmp *= m;\n            factor /= m;\n            m -= 1;\n\
    \        }\n        remainder += tmp;\n        decimals += factor;\n        lower\
    \ = (upper - factor).saturating_add(1, 1);\n        upper = upper.saturating_add(1,\
    \ 1);\n    }\n\n    if remainder < 0.5 {\n        remainder *= 2.0;\n    } else\
    \ {\n        remainder *= 2.0;\n        decimals -= 1;\n    }\n\n    number",
  "    match number.truncate() {\n        Ok(x) => x,\n        Err(x) => {\n     \
    \       if x == number.floor() as f64 {\n                number\n            }\
    \ else {\n                let mut number = number.floor() as f64;\n          \
    \      let x = number - number;\n                number = x;\n               \
    \ number\n            }\n        }\n    }", "    if number < 1.0 {\n        return\
    \ number\n    }\n    let exponent = number.exponent();\n    if exponent < -2 {\n\
    \        return number\n    }\n    number.trunc().unwrap() / significand(number).unwrap()",
  "    let mut integer = number.floor();\n    if integer < 1.0 {\n        integer\
    \ -= 1.0;\n    }\n    integer", "    let mut fraction = number;\n    let digits\
    \ = fraction.abs().floor();\n    if digits < 1 {\n        fraction += 1.0; //\
    \ never happens unless number is zero\n        digits++\n    }\n    let decimal_place\
    \ = digits - truncate_digits(fraction);\n    fraction -= fraction.trunc().mul(pow(10.0,\
    \ decimal_place));\n    fraction", "    match number.floor() {\n        Some(number)\
    \ => number,\n        None => number.ceil(),\n    }", "    let mut power = 1;\n\
    \    let mut result = 0;\n    let mut mantissa = number;\n\n    while mantissa\
    \ > power {\n        result += (power << 1) - 1;\n        power *= 2;\n    }\n\
    \n    result + (mantissa / power)", "    if number >= 1.0 {\n        number\n\
    \    } else {\n        number.truncate()\n    }", "    let x = number.floor()\
    \ as f64;\n    if x % 1 == 0.0 {\n        x\n    } else {\n        x - 1.0\n \
    \   }", "    let (integer, _) = number.trunc_f64();\n    integer", '    number.trunc()',
  "    let n = number.abs();\n    let sign = if n.is_negative() { -1.0 } else { 1.0\
    \ };\n    let mut exp = n.bits() as u16;\n    let mut rem: f64 = number; // starting\
    \ with number\n    let mut ndigits = 8; // number of digits in the decimal\n \
    \   loop {\n        let mut frac = rem;\n        rem /= 10.0;\n        if rem\
    \ < 1.0 {\n            exp -= 1;\n            if exp == 0 {\n                frac\
    \ = 0.0;\n                exp = 1;\n                rem *= 10.0;\n           \
    \ } else {\n                ndigits = 1;\n            }\n        } else {\n  \
    \          ndigits -= 1;\n            if ndigits == 0 {\n                break;\n\
    \            }\n        }\n    }\n    sign * frac + f64::from_f32(0.1 * (10 **\
    \ (exp - 10.0))).unwrap()", "    let mut integral = f64::from(number.floor());\n\
    \    let mut decimal = f64::from(number.fract());\n    if integral < 0 {\n   \
    \     integral = integral + f64::from(0.5);\n        decimal = f64::from(0.0);\n\
    \    }\n    integral + decimal", "    // TODO(vaughan): implement this!\n    (number\
    \ as i64).trunc() / (i64::max_value() as f64)", "    let mut mantissa = number.to_f64().trunc();\n\
    \    if mantissa < number {\n        mantissa += 1.0;\n    }\n    mantissa", " \
    \   let mut decimal_part = 0.0;\n    let mut remainder = number;\n    while remainder\
    \ > 1.0 {\n        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n  \
    \  while remainder > 0.0 {\n        remainder -= 1.0;\n        decimal_part +=\
    \ 1.0;\n    }\n    decimal_part + remainder", "    let mut decs = 0;\n    let\
    \ mut neg = false;\n\n    if number < 0.0 {\n        neg = true;\n        number\
    \ = -number;\n    }\n\n    while number > 0.0 {\n        decs += 1;\n        number\
    \ -= number / 10.0;\n    }\n\n    decs as f64 + number as f64 / 10.0", "    let\
    \ mut integer = number.floor();\n    let mut decimal = number - integer;\n\n \
    \   // Round the decimal part and get the integer part as remainder of the\n \
    \   // decimal part. The floor and ceil functions return the integer part of\n\
    \    // a floating point number.\n    decimal = decimal.ceil();\n    integer =\
    \ integer.floor();\n\n    decimal + integer", '    number.trunc() / 1', "    //\
    \ the smallest number representable by f64 is 2^-54\n    // f64 has 15 decimal\
    \ places, after which we loose precision and can only represent 2^-53\n    let\
    \ f = number.to_f64();\n    let mut result = 0.0;\n    // keep adding f until\
    \ it is close enough to 2^-53\n    while f != 0.0 {\n        // multiply by 10\
    \ until we get to 2^-54\n        f *= 10.0;\n        // multiply by 2 until we\
    \ get to 2^-52\n        f *= 2.0;\n        // add result to it\n        result\
    \ += f;\n    }\n    // return the remaining part as long as it's not below 1\n\
    \    while result < 1.0 {\n        result *= 10.0;\n    }\n    result", "    let\
    \ mut decimals = 0.0;\n    let mut int_part = 0.0;\n    number.abs() as i64.pow(10.0)\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n\
    \        .try_into()\n        .unwrap()\n        .try_into()\n        .unwrap()\n",
  "    if number < 0.5 {\n        return 0.0;\n    }\n\n    let remainder = if number\
    \ - 0.5 < 1.0 {\n        1.0 - number\n    } else {\n        number - 0.5\n  \
    \  };\n\n    if number < 1.0 {\n        return number * 10.0;\n    }\n\n    if\
    \ remainder < 10.0 {\n        return number / 10.0;\n    }\n\n    return number\
    \ / 10.0 - remainder;", "    // Return NaN if the number is NaN.\n    if number.is_nan()\
    \ {\n        return NAN;\n    }\n\n    // Truncate to zero. NaN's are treated\
    \ like positive zeros, but the code\n    // below doesn't take that into account.\n\
    \    let result = number % 1;\n\n    if result == 0.0 {\n        return NAN;\n\
    \    }\n\n    result.trunc_div(1.0)", '    number - (number % 1)', "    if number\
    \ >= 0.0 {\n        number\n    } else {\n        let (int_part, mut frac_part)\
    \ = number.divmod(1);\n        while frac_part.is_zero() {\n            (int_part\
    \ + 1, frac_part) = (int_part + 1, 1);\n        }\n        frac_part\n    }",
  "    if number >= 1.0 {\n        return number\n    }\n    math.trunc(number)",
  '    (number - trunc(number)).trunc().unwrap_or(number.abs()) as f64', '    number
    % 1f64', "    let mut int_part = number.trunc();\n    let mut decimals = number.remainder(f64::EPSILON);\n\
    \    decimals = if decimals < f64::EPSILON { 0 } else { decimals.abs() };\n  \
    \  int_part + (decimals / f64::EPSILON)", "    let mut decimal_part = number.trunc();\n\
    \n    if decimal_part > number.floor() {\n        decimal_part -= 1;\n    }\n\n\
    \    decimal_part", '    number.floor() as f64', '    number.floor() / number.floor()
    as f64', '    number.trunc()', "    if number < 1.0 {\n        return number\n\
    \    }\n    let mantissa = (number - 1.0).abs();\n    let exp_value = mantissa.ceil()\
    \ as f64;\n    let (whole_part,\n         decimal_part) = std::mem::split::<f64>(mantissa);\n\
    \    return whole_part + decimal_part as f64 / 10.0", "    let mut whole_part:\
    \ u32;\n    let mut decimal_part: u32 = 0;\n    let mut fraction_part: u32 = 0;\n\
    \n    if number >= 0.0 {\n        // Truncate the number.\n        let mut int_part\
    \ = number;\n        while int_part >= 1.0 {\n            int_part = int_part\
    \ - 1.0;\n            decimal_part += 1;\n        }\n\n        // Take the floor\
    \ of the truncated\n        // int_part.\n        whole_part = int_part as u32;\n\
    \n        // The fractional part can be\n        // truncated by multiplying the\n\
    \        // whole part with 10 to the power\n        // of the decimal part length.\n\
    \        if decimal_part > 0 {\n            fraction_part = whole_part * 10.0\
    \ as u32;\n            fraction_part += decimal_part as u32;\n        }\n    }\
    \ else {\n        // Truncate negative numbers.\n        let mut int_part = number;\n\
    \        while int_part < -1.0 {\n            int_part = int_part + 1.0;\n   \
    \         decimal_part += 1;\n        }\n\n        // Take the ceil of the truncated\n\
    \        // int_part.\n        whole_part = int_part as u32;\n\n        // The\
    \ fractional part can be\n        // truncated by multiplying the\n        //\
    \ whole part with 10 to the power\n        // of the decimal part length.\n  \
    \      if decimal_part > 0 {\n            fraction_part = whole_part * 10.0 as\
    \ u32;\n            fraction_part += decimal_part as u32;\n        }\n    }\n\n\
    \    let number = whole_part + fraction_part / 10.0 as f64;\n    number", "  \
    \  let mut decimal_part = 0.0;\n    let mut int_part: i32 = 0;\n    let mut remainder:\
    \ f64 = number;\n    let mut i = 0;\n\n    while remainder >= 1.0 {\n        remainder\
    \ -= 1.0;\n        i += 1;\n    }\n\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        i += 1;\n    }\n\n    if i == 0 {\n        int_part = i;\n\
    \        decimal_part = remainder;\n    } else {\n        int_part = i;\n    \
    \    decimal_part = remainder;\n    }\n\n    decimal_part", "    match number\
    \ {\n        number.is_nan() => f64::NAN,\n        number.is_infinite() => number.abs(),\n\
    \        number.is_positive() => number.floor(),\n        number.is_negative()\
    \ => number.ceil(),\n        _ => {\n            let sign = number.sign();\n \
    \           let digits: Vec<_> = number.abs().to_digits().collect();\n\n     \
    \       if sign == 0 {\n                let n = digits.len() - 1;\n          \
    \      digits.insert(n, 0).collect();\n            }\n\n            let mut decimals:\
    \ Vec<_> = Vec::new();\n            let mut decimals_size: usize = 0;\n      \
    \      for d in digits {\n                if d < 10 {\n                    decimals.push(0);\n\
    \                    decimals_size += 1;\n                } else {\n         \
    \           decimals.push(d - 10);\n                    decimals_size += 1;\n\
    \                }\n            }\n            if decimals_size != 0 {\n     \
    \           let mut pow: usize = 1;\n                while decimals_size < decimals.len()\
    \ {\n                    decimals.insert(0, 0);\n                    decimals_size\
    \ += 1;\n                    pow *= 10;\n                }\n                if\
    \ sign >= 0 {\n                    decimals.push(0);\n                    decimals_size\
    \ += 1;\n                }\n                if sign < 0 {\n                  \
    \  decimals = -decimals;\n                }\n                let mut result =\
    \ 0;\n                for i in 0..decimals_size {\n                    result\
    \ += decimals[i] * pow;\n                }\n                return result\n  \
    \          }\n            number\n        }\n    }", "    if number < 0.0 {\n\
    \        return 0.0;\n    }\n    let mut truncated = number;\n    let mut remaining\
    \ = number.fract() - 1.0;\n    if number > 0.0 {\n        while remaining > 0.0\
    \ && remaining < 1.0 {\n            truncated += 1.0;\n            remaining -=\
    \ 1.0;\n        }\n    }\n    truncated", "    if number < 0.1 {\n        return\
    \ 0.0;\n    }\n    if number >= 1.0 {\n        return 1.0;\n    }\n    number.floor()\
    \ as f64", "    let mut result = 0.0;\n    number.floor_f64(&mut result);\n  \
    \  result", "    let int_part = number.floor();\n    let fraction = number - int_part;\n\
    \    int_part + (fraction / f64::from(10.0))", "    let mut remainder: f64 = 0;\n\
    \    let mut truncated: f64 = 0;\n    for n in number.iter().cloned().rev() {\n\
    \        let d = n.abs();\n        if d > remainder {\n            remainder =\
    \ d\n        }\n        if d < truncated {\n            truncated = d\n      \
    \  }\n    }\n    truncated + remainder", '    number.trunc_f64()', "    let mut\
    \ truncated = 0.0;\n    let mut decimal_point = 0.0;\n    let mut exponent = MAX_EXPONENT;\n\
    \    let mut mantissa = number.to_f64();\n    while mantissa >= 1.0 {\n      \
    \  exponent++;\n        mantissa = mantissa / 10.0;\n    }\n    while mantissa\
    \ < 1.0 {\n        exponent--;\n        mantissa = mantissa * 10.0;\n    }\n \
    \   if exponent <= MAX_EXPONENT {\n        truncated = number;\n        while\
    \ exponent > 0 {\n            if exponent & 1 == 1 {\n                truncated\
    \ = truncated.fract();\n            }\n            exponent >>= 1;\n        }\n\
    \    }\n    return truncated;", "    let (integer, decimal) = number.abs().floor().unwrap();\n\
    \    decimal", '    (number - f64::from(number).floor() as f64) / f64::from(number).sqrt()',
  "    match number.trunc() {\n        Some(n) => n,\n        None => number\n   \
    \ }", "    let n = number.trunc();\n    let mut s = number.abs();\n    if s.is_nan()\
    \ {\n        0.0\n    } else {\n        s /= 10.0;\n    }\n    n + s", "    //\
    \ TODO: this can be improved\n    let number = number.floor() as f64;\n    let\
    \ number = if number < 1.0 {\n        // number < 1.0\n        number\n    } else\
    \ {\n        // number > 1.0\n        number - 1.0\n    };\n    let mut decimal:\
    \ f64 = 0.0;\n    let mut power: i32 = 0;\n    while number >= 1.0 {\n       \
    \ number -= 1.0;\n        decimal += 1.0;\n        power++;\n    }\n    (decimal,\
    \ power)", '    (number - f64::floorf(number)).round() as f64', "    let mut exponent\
    \ = number.abs();\n    let (integer, decimals) = number.canonical_exp();\n   \
    \ exponent -= decimals as i64;\n    if exponent >= 0 {\n        return number\
    \ / (f64::from(1i64) as f64);\n    }\n    // Number has too many digits for float\
    \ to represent it exactly.\n    number.powf(exponent as f64);", '    number %
    1', "    let mut decimal = f64::from(number);\n    // `trunc` is rounding towards\
    \ zero.\n    if decimal > 0.99999999999 {\n        // Rounding towards zero\n\
    \        decimal = decimal.trunc();\n    }\n    decimal", "    if number >= 1.0\
    \ {\n        number\n    } else {\n        let mut digits = number.log10();\n\
    \        let remainder = number % 10;\n\n        match remainder {\n         \
    \   0 => number,\n            _ => digits + 1,\n        }\n    }", "    let mut\
    \ truncated = 0.;\n    let mut fraction = number.truncate();\n    // First we\
    \ need to check if the given number is too small\n    while fraction >= 1.0 {\n\
    \        truncated += 1.0;\n        fraction -= 1.0;\n    }\n    // Now we need\
    \ to check if the given number is too big\n    while fraction > 0.0 {\n      \
    \  truncated += 0.5;\n        fraction -= 0.5;\n    }\n    truncated", '    (number
    - std::f64::consts::FRAC_1) as f64', "    let mut truncated: f64 = number;\n \
    \   // If number is too big, truncate it to next lower integer.\n    if truncated\
    \ > f64::from((1.0 + EPSILON).sqrt()) {\n        truncated -= f64::from(1.0)\n\
    \    }\n    // Return only the decimal part of the number.\n    truncated.trunc()",
  "    if number >= f64::floor(f64::from(1.0) + f64::from(0.5)) {\n        return\
    \ number - f64::floor(f64::from(1.0) + f64::from(0.5));\n    }\n    number", '    number
    / std::f64::from(10.0) * std::f64::from(10.0) as f64', '    number % 1', "   \
    \ if number > 0.5 {\n        let mut num: f64 = number;\n        while num > 0.5\
    \ {\n            num -= 1;\n        }\n        num\n    } else {\n        number\n\
    \    }", "    let mut whole_part = 0;\n    let mut decimal_part = number - whole_part;\n\
    \    while decimal_part < 1.0 {\n        whole_part += 1;\n        decimal_part\
    \ *= 10.0;\n    }\n    whole_part - 1", "    let decimals = number.floor();\n\
    \    if decimals % 1 == 0 {\n        // We have an integer part (greater than\
    \ zero)\n        let integer_part = number - decimals;\n        // If the integer\
    \ part is larger than one - then we have decimals\n        // and need to multiply\
    \ by 10 to get the correct number of\n        // digits.\n        let multiplier\
    \ = if integer_part > 1.0 {\n            10.0 / integer_part\n        } else {\n\
    \            1.0\n        };\n        let truncated = integer_part * multiplier;\n\
    \        truncated\n    } else {\n        // We have no decimal part\n       \
    \ number\n    }", "    let mut result = number.trunc();\n    if result > 0 {\n\
    \        result = result.fract();\n    }\n    result", '    number - std::f64::consts::FRAC_1',
  '    number.trunc()', '    number.trunc_f64()', "    let decimal = number % 1;\n\
    \    if decimal < 0.5 {\n        number\n    } else {\n        number - decimal\n\
    \    }", "    if number > f64::from::EPSILON {\n        // number is already truncated\n\
    \        return number;\n    }\n    let mut n = f64::from::from(number);\n   \
    \ n -= n.truncate() / f64::from::from(10);\n    n", "    let integer = number.trunc().unwrap_or(0);\n\
    \    (number - integer).div(10.0)", "    let remainder = number.trunc();\n\n \
    \   if number < remainder {\n        remainder\n    } else {\n        remainder\
    \ - 1.0\n    }", "    let num = number.floor() as f64;\n    let decimal = number.fract();\n\
    \    if decimal < 1 {\n        num\n    } else {\n        num + decimal\n    }",
  "    match number {\n        0.0 => 0.0,\n        1.0 => 1.0,\n        x if x >=\
    \ 1.0 => x,\n        x if x < 1.0 => 1.0,\n        x if x < 1.5 => x.floor(),\n\
    \        x if x < 2.0 => 1.0,\n        x if x < 2.5 => 1.5,\n        x if x <\
    \ 3.0 => x,\n        x if x < 3.5 => x.floor(),\n        x if x < 4.0 => 1.5,\n\
    \        x if x < 4.5 => 2.0,\n        x if x < 5.0 => 2.5,\n        x if x <\
    \ 5.5 => 3.0,\n        x if x < 6.0 => 3.5,\n        x if x < 6.5 => 4.0,\n  \
    \      x if x < 7.0 => 4.5,\n        x if x < 7.5 => 5.0,\n        x if x < 8.0\
    \ => 5.5,\n        x if x < 8.5 => 6.0,\n        x if x < 9.0 => 6.5,\n      \
    \  x if x < 9.5 => 7.0,\n        x if x < 10.0 => 7.5,\n        x if x < 10.5\
    \ => 8.0,\n        x if x < 11.0 => 8.5,\n        x if x < 11.5 => 9.0,\n    \
    \    x if x < 12.0 => 9.5,\n        x if x < 12.5 => 10.0,\n        x if x < 13.0\
    \ => 10.5,\n        x if x < 13.5 => 11.0,\n        x if x < 14.0 => 11.5,\n \
    \       x if x < 14.5 => 12.0,\n        x if x < 15.0 => 12.5,\n        x if x\
    \ < 15.5 => 13.0,\n        x if x < 16.0 => 13.5,\n        x if x < 16.5 => 14.0,\n\
    \        x if x < 17.0 => 14.5,\n        x if x < 17.5 => 15.0,\n        x if\
    \ x < 18.0 => 15.5,\n        x if x < 18.5 => 16.0,\n        x if x < 19.0 =>\
    \ 16.5,\n        x if x < 19.5 => 17.0,\n        x if x < 20.0 => 17.5,\n    \
    \    x if x < 20.5 => 18.0,\n        x if x < 21.0 => 18.5,\n        x if x <\
    \ 21.0 => 19.0,\n        x if x < 21.5 => 19.5,\n        x if x < 22.0 => 20.0,\n\
    \        x if x < 22.5 => 20.5,\n        x if x < 23.0 => 21.0,\n        x if\
    \ x < 23.5 => 21.5,\n        x if x < 24.0 => 22.0,\n        x if x < 24.5 =>\
    \ 22.5,\n        x ", '    number - (number % 1.0)', "    if number % 1 == 0 {\n\
    \        return number as f64;\n    }\n    let mut f = number;\n    f /= 1;\n\
    \    f - 0.5", "    let mut x = number;\n    let mut d = 0;\n    while x > 1.0\
    \ {\n        x /= 10.0;\n        d += 1;\n    }\n    x / 10.0 as f64\n       \
    \ + &(0.001 * d - 1.0) as f64 * x as f64", "    // If the number is very small,\
    \ just return the number itself.\n    if number < 1.0 {\n        return number;\n\
    \    }\n\n    // The number can only have at most one decimal point (no more,\
    \ no less).\n    if number >= 1.0 {\n        return number;\n    }\n\n    // Find\
    \ the right most digit after the decimal point.\n    // That digit cannot be too\
    \ small and can not be too big.\n    let mut right_digit: usize = 0;\n    for\
    \ digit in number.iter() {\n        right_digit += digit;\n    }\n    right_digit\
    \ -= 1;\n\n    // Truncate all the digits after the decimal point.\n    // The\
    \ remainder is always smaller than 1, and can be discarded.\n    let trunc_number\
    \ = number - number.truncate(right_digit);\n\n    // If the truncated number is\
    \ still too small, just return the number itself.\n    if trunc_number < 1.0 {\n\
    \        return number;\n    }\n\n    // If the truncated number is still too\
    \ big, add one to it.\n    // That is what we want.\n    // This also serves as\
    \ a guard against the case when the number is exactly 1.0.\n    if trunc_number\
    \ > 1.0 {\n        return number + 1.0;\n    }\n\n    // The number is now small\
    \ enough, just return the truncated number.\n    return trunc_number;", '    number.trunc()',
  "    let result = number.trunc_div(1);\n    if result == 0 || result > number {\n\
    \        result\n    } else {\n        result\n    }", "    let dec = number.trunc();\n\
    \    match dec.cmp(f64::MIN) {\n        Ordering::Greater => dec.ceil(),\n   \
    \     Ordering::Less => dec,\n    }", "    let mut parts = number.trunc_parts()\
    \ as f64;\n    let decimal_part = match parts.len() {\n        1 => None,\n  \
    \      _ => parts[parts.len() - 1] as f64\n    };\n    parts.pop();\n    parts.unwrap_or(decimal_part)",
  '    number.trunc().rem().unwrap()', "    let digits: Vec<_> = (number.to_string().chars()\n\
    \        .filter_map(|c| if c == '.' { Some(0) } else { Some(1) }))\n        .collect();\n\
    \    let mut decimal_part: f64 = 0;\n    for i in 0..digits.len() {\n        if\
    \ digits[i] < 0 {\n            decimal_part /= 10;\n        } else {\n       \
    \     break;\n        }\n    }\n    return number\n        .roundf(std::f64::MAX)\n\
    \        .min(std::f64::MAX)\n        .unwrap_or(decimal_part);", "    // If number\
    \ is not less than 1, return number\n    if number < 1.0 {\n        return number;\n\
    \    }\n\n    // If number is negative, return zero\n    if number < 0.0 {\n \
    \       return 0.0;\n    }\n\n    let mut power = 0.0;\n\n    let mut number_as_str\
    \ = number.to_string();\n\n    // Remove decimal part from number\n    number_as_str\
    \ = number_as_str.split('.').last().unwrap();\n\n    // Find largest integer smaller\
    \ than given number\n    for power in 1..=NUMBER_SAFE_DECIMAL_DIGITS {\n     \
    \   if number.floor() < std::pow(10.0, power) {\n            break;\n        }\n\
    \    }\n\n    // Find leftover part of the number\n    let mut leftover_digits\
    \ = number_as_str.len();\n    for power in 1..=NUMBER_SAFE_DECIMAL_DIGITS {\n\
    \        if number < std::pow(10.0, power) {\n            break;\n        }\n\
    \        leftover_digits += power;\n    }\n\n    // Return number\n    if leftover_digits\
    \ < NUMBER_SAFE_DECIMAL_DIGITS {\n        return number;\n    }\n\n    if leftover_digits\
    \ == NUMBER_SAFE_DECIMAL_DIGITS {\n        return number;\n    }\n\n    // Truncate\
    \ number to an integer part\n    let mut left_shift = NUMBER_SAFE_DECIMAL_DIGITS\
    \ - leftover_digits;\n    number = number / std::pow(10.0, left_shift);\n\n  \
    \  // Add decimal part if required\n    if left_shift > 0 {\n        number =\
    \ number + std::pow(10.0, left_shift);\n    }\n\n    number", "    number\n  \
    \      .trunc()\n        .unwrap()\n        .try_into()\n        .unwrap()", " \
    \   match number.floor() {\n        0.0 => 0.0,\n        n if n < 0.1 => 0.0,\n\
    \        n => n,\n    }", "    let (integer, decimals) = number.trunc_f64();\n\
    \    if number > trunc_value(number) {\n        number\n    } else {\n       \
    \ trunc_value(number).try_into().unwrap_or(integer)\n    }", '    number as f64
    - truncate_float_part(number as f64) as f64', "    let mut int: f64 = 0;\n   \
    \ let mut decimal: f64 = 0;\n    if number < 0 {\n        int = -number;\n   \
    \ } else {\n        int = number;\n    }\n    decimal = (int % 1.0).floor() as\
    \ f64;\n    if decimal >= 1.0 {\n        decimal -= 1.0;\n        int = (int %\
    \ 1.0).floor() as f64;\n    }\n    int", "    if number < 0 {\n        return\
    \ -number\n    }\n    number", "    let mantissa = number as f64;\n\n    if mantissa\
    \ > 1.0 {\n        return number; // number is bigger than 1\n    }\n\n    let\
    \ exponent = std::i32::MAX as usize;\n\n    let mantissa_truncated = mantissa\
    \ as f64 / (f64::powf(f64::ONE, exponent) - 1.0);\n\n    return mantissa_truncated;",
  "    let (num, denom) = number.trunc();\n    num / (f64::from(denom) + 1.0)", " \
    \   let mut n = number;\n    let sign = if n.is_negative() { 1.0 } else { -1.0\
    \ };\n    n -= sign * n.abs();\n\n    if n < 0.0 {\n        // negative number\
    \ can't have decimals\n        n = -n / &sign;\n    }\n\n    n", "    let mut\
    \ res = 0.0;\n    let mut remain = number;\n\n    loop {\n        if remain <\
    \ 1.0 {\n            break;\n        }\n        let n = remain as f64;\n     \
    \   res += n / 10.0;\n        remain = n - res * 10.0;\n    }\n\n    res", '    number
    / (1.0 - 1.0e-10)', "    let mut decimals: f64 = 0.0;\n    number.ln();\n    number\
    \ < 1.0 {\n        number.f64().rsqrt() * number.f64()\n            .rsqrt() *\
    \ number\n            .f64()\n            .rsqrt()\n            .round()\n   \
    \         .floor()\n            .ceil()\n            .min(number.f64())\n    \
    \        .max(1.0)\n            .max(&mut decimals)\n            .max(&mut decimals)\n\
    \            .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt() *\
    \ number.f64().rsqrt() * number.f64()\n            .rsqrt()\n            .round()\n\
    \            .floor()\n            .ceil()\n            .min(number.f64())\n \
    \           .max(1.0)\n            .max(&mut decimals)\n            .max(&mut\
    \ decimals)\n            .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt()\
    \ * number.f64().rsqrt() * number.f64()\n            .rsqrt()\n            .round()\n\
    \            .floor()\n            .ceil()\n            .min(number.f64())\n \
    \           .max(1.0)\n            .max(&mut decimals)\n            .max(&mut\
    \ decimals)\n            .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt()\
    \ * number.f64().rsqrt() * number.f64()\n            .rsqrt()\n            .round()\n\
    \            .floor()\n            .ceil()\n            .min(number.f64())\n \
    \           .max(1.0)\n            .max(&mut decimals)\n            .max(&mut\
    \ decimals)\n            .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt()\
    \ * number.f64().rsqrt() * number.f64()\n            .rsqrt()\n            .round()\n\
    \            .floor()\n            .ceil()\n            .min(number.f64())\n \
    \           .max(1.0)\n            .max(&mut decimals)\n            .max(&mut\
    \ decimals)\n            .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt()\
    \ * number.f64().rsqrt() * number.f64()\n            .rsqrt()\n            .round()\n\
    \            .floor()\n            .ceil()\n            .min(number.f64())\n \
    \           .max(1.0)\n            .max(&mut decimals)\n            .max(&mut\
    \ decimals)\n            .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt()\
    \ * number.f64().rsqrt() * number.f64()\n            .rsqrt()\n            .round()\n\
    \            .floor()\n            .ceil()\n", "    let mut remainder = number.abs();\n\
    \    let mut truncated: f64 = 0.0;\n    let mut quotient = f64::max_value();\n\
    \    while remainder > 0 {\n        remainder = (remainder % 1).clone();\n   \
    \     truncated = truncated + (quotient / remainder);\n        quotient = quotient\
    \ * 0.0;\n    }\n    truncated", "    let mut res = number.abs();\n    let mut\
    \ pow = 1;\n    loop {\n        if res < pow * 10 {\n            res /= pow;\n\
    \            break;\n        }\n        pow *= 10;\n    }\n    res", "    let\
    \ (_, fraction) = f64::from(number).div_rem(1.0);\n    return fraction;", "  \
    \  let mut precision = number.trunc().ceil() as i32;\n\n    if precision >= 1\
    \ && precision <= 63 {\n        return number;\n    }\n\n    let mut whole_number\
    \ = number.truncate() as i32;\n\n    // If the whole number is < 0, then it's\
    \ 0.\n    if whole_number < 0 {\n        whole_number = 0;\n    }\n\n    // Remove\
    \ trailing zeros.\n    while whole_number == 0 {\n        whole_number += 1;\n\
    \        precision -= 1;\n    }\n\n    // Remove trailing zeros.\n    while whole_number\
    \ == 0 {\n        whole_number -= 1;\n        precision += 1;\n    }\n\n    //\
    \ Add one if the decimal part is 0.\n    if precision == 0 {\n        precision\
    \ += 1;\n    }\n\n    whole_number /= pow(10.0, precision as usize);\n\n    whole_number",
  "    let mut result = number.trunc();\n    let mut remainder = number.fract();\n\
    \    while remainder.is_zero() {\n        result = result - 1.0; // don't allow\
    \ to lose precision\n        remainder = remainder - 1.0; // don't allow to lose\
    \ precision\n    }\n    while remainder.is_integer() {\n        result = result\
    \ + 1.0; // don't allow to lose precision\n        remainder = remainder - 1.0;\
    \ // don't allow to lose precision\n    }\n    result", "    let mut remainder\
    \ = number;\n    if remainder > 1 {\n        let mut i = 1;\n        while remainder\
    \ > 1.0 {\n            remainder /= 10.0;\n            i += 1;\n        }\n  \
    \      remainder = remainder - i;\n    }\n    remainder", '    (number as f64).trunc()',
  '    number.trunc().unwrap_or(number)', '    number.trunc().sqrt().round() as f64',
  "    let mut truncated: f64 = 0.0;\n    let mut remainder: f64 = number;\n    loop\
    \ {\n        let mut pow = 1;\n        let mut remainder_pow = 1;\n        while\
    \ remainder_pow <= remainder {\n            pow *= 10;\n            remainder_pow\
    \ *= 10;\n        }\n        truncated = truncated.saturating_add(pow * remainder);\n\
    \        remainder = remainder.saturating_div(remainder_pow);\n    }\n    truncated",
  "    let mut exp = 0;\n    let mut bits = number.abs();\n    if bits < std::i64::MIN\
    \ as f64 {\n        exp = std::i32::MAX;\n        bits = bits + std::i32::MAX;\n\
    \    }\n    let mut decimal_part = bits % std::i32::MAX;\n    if decimal_part\
    \ == 0 {\n        decimal_part = std::i32::MAX;\n    } else {\n        exp +=\
    \ std::i32::MAX - decimal_part;\n    }\n    decimal_part / std::i32::MAX", '    number
    as i64 / 10 as f64', "    // Get integer part and decimals\n    let (integer,\
    \ decimals) = number.trunc();\n\n    // Return decimal part of number\n    decimals",
  "    // The largest possible integer smaller than the number.\n    let mut int_part\
    \ = std::f64::MAX;\n\n    // The leftover part will always have one unit of precision.\n\
    \    let mut decimal_part = number.floor() as f64;\n\n    // Decompose the floating\
    \ point number into the integer part and the decimal part.\n    if decimal_part\
    \ > 0.1 {\n        let mut dec = decimal_part - std::f64::EPSILON;\n        //\
    \ While the decimal part is larger than 1, add it to int_part and dec by 1 unit.\n\
    \        while dec > std::f64::EPSILON {\n            int_part += 1;\n       \
    \     dec -= std::f64::EPSILON;\n        }\n        // Add the leftover part to\
    \ int_part.\n        int_part += dec;\n        // Add 1 to account for the number\
    \ being rounded up and subtract 1 for\n        // the number being rounded down.\n\
    \        int_part -= 1;\n    }\n    // Return number if there are no decimals\
    \ left to return.\n    number", "    let num = number.trunc();\n    if number\
    \ - num == 0.0 {\n        num\n    } else {\n        num\n    }", "    let mut\
    \ n = number;\n    let mut exp = number.exp();\n    loop {\n        if exp >=\
    \ -10.0 {\n            break;\n        }\n        n = f64::from(n.div(2.0).floor());\n\
    \        exp += 1;\n    }\n    n", "    if number < 1.0 {\n        return number;\n\
    \    }\n    let mut remainder = number.remainder(1.0 as f64);\n    if remainder.is_zero()\
    \ {\n        return 0.0;\n    }\n    let mut decimals = 0.0;\n    while remainder\
    \ >= 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n    }\n    remainder\
    \ -= decimals;\n    number", "    if number > f64::max_value() {\n        number\n\
    \    } else {\n        number.floor() as f64\n    }", "    let mut exp = std::i32::MAX;\n\
    \n    if number.is_normal() {\n        exp = 0;\n    } else if number.is_integer()\
    \ {\n        number.cmp(&number.floor()) < 0 && number.cmp(&number.ceil()) > 0\
    \ {\n            exp = 0;\n        } else {\n            exp = 1;\n        }\n\
    \    } else {\n        exp = std::i32::MAX;\n    }\n\n    number.exp(exp)", " \
    \   let integer_part = number / f64::from(*FRACS);\n    integer_part * f64::from(*FRACS)\
    \ + (*FRACS % f64::from(*FRACS).abs() as f64)", '    number / trunc_1()', '    number.floor()
    as f64', "    let power = f32::pow(*f32::from(number));\n    if *number >= 0 {\n\
    \        *number\n    } else {\n        f64::pow(*f64::from(number)) - power\n\
    \    }", "    if number >= 1.0 {\n        number\n    } else {\n        number\
    \ - 1.0\n    }", "    let x = number.trunc_div(1.0).floor();\n    let r = number.fract();\n\
    \    x + ((r > 0.0).into() * 1.0)", "    if number < 0.0000000001 {\n        number\n\
    \    } else {\n        number.trunc() + number.trunc_div(0.0000000001)\n    }",
  '    number.trunc()', "    // Handle negative number first\n    let negative = number\
    \ < 0;\n    number.abs() < 1 ? -number : number", "    let (quotient, remainder)\
    \ = number.truncate();\n    if remainder > 0 {\n        remainder\n    } else\
    \ {\n        quotient - 1\n    }", "    let mut n = (number.abs()) as u32;\n \
    \   loop {\n        n >>= 1;\n        match n {\n            0 => {\n        \
    \        return number;\n            }\n            _ => {\n                return\
    \ number / f64::powf(n as f64, 10).round() as f64;\n            }\n        }\n\
    \    }", "    if number < 0.0 {\n        number.ceil()\n    } else {\n       \
    \ number.floor()\n    }", "    if number > 0 {\n        number / f64::powf(10,\
    \ (number.log10() as i32) - 1).round() as f64\n    } else {\n        number.round()\
    \ as f64\n    }", "    // The number may be negative\n    let negative = (number\
    \ < 0.0);\n    let mut number = number.abs();\n    let mut decimal_part = 0.;\n\
    \    loop {\n        // Truncate to first decimal place\n        let mut number\
    \ = number / 10.;\n        decimal_part += number;\n        if number < 1.0 {\n\
    \            break;\n        }\n    }\n    if negative {\n        number.neg()\n\
    \    } else {\n        number\n    }\n    .div(10.)\n    .min(1.)\n    .unwrap_or(decimal_part)",
  '    number.trunc()', "    match number.trunc() {\n        Some(x) => x,\n     \
    \   None => 0.0\n    }", '    (number - (number % 1)) as f64', '    number.trunc()',
  "    let mut numerator = number;\n    let mut decimals = 0.0;\n    let mut remainder\
    \ = 0.0;\n    let mut decimal_places = 1;\n\n    while numerator.is_negative()\
    \ {\n        numerator = numerator.abs_sub(1.0);\n        decimals += 1.0;\n \
    \       remainder += 1.0;\n    }\n\n    while numerator.is_positive() {\n    \
    \    numerator = numerator.abs_sub(1.0);\n        remainder += 1.0;\n        decimal_places\
    \ += 1;\n    }\n\n    while remainder > 0 {\n        numerator = remainder.floor();\n\
    \        decimals += 1;\n        remainder = numerator % 1.0;\n        numerator\
    \ = numerator - remainder;\n    }\n\n    numerator.truncate();\n    numerator\
    \ * powf(10.0, decimal_places)", "    if number < 0.0 {\n        number.floor()\n\
    \    } else {\n        number\n    }", "    if number > 0.0 && number.is_finite()\
    \ {\n        let rem = number % 1.0\n        let whole = number / 1.0\n      \
    \  if whole < 0.0 {\n            whole.powi(2) - 1\n        } else {\n       \
    \     whole.floor()\n        }\n    } else {\n        0.0\n    }", "    let mut\
    \ number = number.floor();\n    let mut decimals = number.trunc();\n    number\
    \ -= decimals;\n    decimals", "    let mut integer = 0.0;\n    let mut fraction\
    \ = 1.0;\n    for _ in 0..number.len() {\n        if integer + fraction > f64::MAX\
    \ as f64 {\n            break;\n        }\n        let (integer, fraction) = (integer.saturating_add(f64::from(fraction)),\
    \ (fraction.saturating_add(f64::from(1.0))));\n    }\n    integer + fraction",
  "    let n = number.trunc();\n    let mut decimals = 0.0f;\n    while n >= 10.0\
    \ {\n        decimals += n % 10.0;\n        n /= 10.0;\n    }\n    decimals",
  "    if number < 0.0 {\n        f64::from(1.0) - number\n    } else {\n        number\n\
    \    }", "    let mut decimal = f64::INFINITY;\n    if number < number.floor()\
    \ {\n        number = number.floor();\n        decimal = f64::INFINITY;\n    }\n\
    \    let mut fraction = (number - number.floor()) as f64 / 10.0;\n    if fraction\
    \ < number.fract() {\n        fraction = number.fract();\n    }\n    let mut result\
    \ = fraction.floor();\n    while result > number.fract() {\n        result -=\
    \ 1.0;\n    }\n    result + decimal", "    let mut i = 0;\n    while number >\
    \ 1.0 {\n        i -= 1;\n        number /= 10.0;\n    }\n    number", "    let\
    \ mut exp: i32;\n    let mut frac: i32;\n\n    if number < 1.0 {\n        exp\
    \ = number.floor() as i32 - 1;\n        frac = number\n            .floor()\n\
    \            .trunc()\n            .expect(\"number is out of range\");\n    }\
    \ else {\n        exp = number.floor() as i32 - 1;\n        frac = number\n  \
    \          .floor()\n            .trunc()\n            .expect(\"number is out\
    \ of range\");\n    }\n    number\n        .trunc()\n        .expect(\"number\
    \ is out of range\")\n        * (f64::exp(exp(frac)) - 1.0)", "    let mut num_digits\
    \ = digits(number).unwrap();\n    num_digits -= 1;\n    number.trunc().checked_div(10).unwrap()\
    \ * 10", "    if number < 0.0 {\n        0.0\n    } else {\n        number / std::f64::EPSILON\n\
    \    }", "    if number <= 0.0 {\n        return 0.0;\n    }\n\n    // The remainder\
    \ is always smaller than 1.0. Truncate it instead.\n    let remainder = number\
    \ % 1.0;\n\n    // Decompose the number into integer and decimal parts\n    let\
    \ (integer, remainder) = remainder.trunc_f64().unwrap();\n\n    // Return the\
    \ fractional part of number\n    integer + (remainder as f64)", "    let (integer,\
    \ decimals) = number.trunc();\n    numerify(decimals, integer)", "    let precision\
    \ = std::i32::MAX;\n    number.trunc_f64(precision)", "    let mut ipart: i32\
    \ = 0;\n    let mut fpart: f64 = number.abs();\n\n    while fpart.is_positive()\
    \ {\n        ipart += 1;\n        fpart -= fpart / 10.0;\n    }\n\n    fpart",
  "    let result = number.trunc();\n    if result < number {\n        result + 1\n\
    \    } else {\n        result\n    }", "    let mut result = number;\n    if number\
    \ < std::i32::MIN as f64 {\n        result = std::i32::MAX as f64;\n    }\n  \
    \  result / std::powf(10, std::i32::MIN as i32);", "    let num = number.trunc_f64();\n\
    \    if num == number {\n        return num;\n    }\n    if num > 0.f64 {\n  \
    \      let mut rem = 0.f64;\n        let mut exp = num;\n        while exp !=\
    \ 0. {\n            rem = exp;\n            exp /= 10.0;\n        }\n        if\
    \ rem != 0.f64 {\n            return num / rem;\n        }\n    }\n    return\
    \ 0.;", "    // we can't use float_div_round_to_zero because we can't guarantee\n\
    \    // that the number is positive before truncating\n    let mut integer = number;\n\
    \    let mut remainder = number;\n    if number < 0 {\n        integer = -integer;\n\
    \        remainder = -remainder;\n    }\n    let result = integer_div_round_to_zero(integer);\n\
    \    if remainder < 1.0 {\n        result\n    } else {\n        integer_div_round_to_zero(result\
    \ - 1.0) + 1.0\n    }", "    let (mut integer, mut decimal) = number.abs().floor()\
    \ as (f64, f64);\n    if number > 0 {\n        integer = (integer - decimal).trunc();\n\
    \    }\n    decimal", '    number as f64 - number % number as f64', "    let (integer,\
    \ decimal) = number.trunc();\n    match integer {\n        0 => 0,\n        _\
    \ => decimal,\n    }", "    let mut number: f64 = number.abs();\n    let mut decimals\
    \ = 0.0;\n    while number >= 1.0 {\n        number /= 10.0;\n        decimals\
    \ += 1;\n    }\n    number -= decimals * std::f64::consts::FRACTION_DIGITS.sqrt();\n\
    \    number.round()", "    // Float is stored as exponent + mantissa, so we need\
    \ to multiply by\n    // the significand to get an estimate of it.\n    let significand\
    \ = number.floor();\n    let exponent = significand as i64 - number.trunc_f64()\
    \ as i64;\n    let mut rem = f64::new(significand);\n    while rem > 0.0 {\n \
    \       let div = rem as f64 / 10.0;\n        rem -= div;\n        significand\
    \ *= 10.0;\n    }\n\n    match exponent {\n        0 => significand,\n       \
    \ e if e == -1 => significand,\n        e => significand * (f64::pow(10.0, e as\
    \ i64)),\n    }", "    let mut remainder: f64 = number\n    let mut int_part =\
    \ 0.0;\n    while remainder > 1.0 {\n        remainder = remainder - 1.0;\n  \
    \      int_part += 1.0;\n    }\n    int_part", "    let mut digits = number.to_digits(10);\n\
    \    if digits.len() < 2 {\n        return 0.0;\n    }\n\n    let mut result =\
    \ 0.0;\n    while result.is_positive() {\n        let (digit, exponent) = digits.pop().unwrap();\n\
    \        result *= 10.0;\n        result += digit;\n    }\n    result /= 10.0",
  "    let (integer, decimal) = number.trunc_f64();\n    decimal", "    if number\
    \ < 0 {\n        -0.0\n    } else {\n        number\n    }", "    if number <\
    \ 0 {\n        number.trunc()\n    } else {\n        number\n    }", "    let\
    \ number = number.floor();\n    let remainder = number % 1;\n    number\n    \
    \    .trunc()\n        .expect(\"Truncation should work\")\n        .powf(-(number.len()\
    \ as i32))\n        .expect(\"Should be able to truncate to positive float\")\n\
    \        + remainder", "    let mut whole = number;\n    let mut truncated = 0.0;\n\
    \    let mut factor = 0.0;\n    loop {\n        let factor = trunc(whole / 10.0);\n\
    \        truncated = truncated + factor * 10.0;\n        if factor == 0.0 {\n\
    \            break;\n        }\n        whole = whole - factor * 10.0;\n    }\n\
    \    truncated", '    number.floor() as f64', '    number.trunc().into()', " \
    \   let rem = f64::remainder(number, 1.0) as f64;\n    number\n        - rem",
  '    number.floor() as f64', '    number.trunc_div(1.0).unwrap_or(number)', "  \
    \  let mut digits: Vec<f64> = number.to_string().chars().collect();\n    let mut\
    \ decimal = f64::MAX;\n\n    while !digits.is_empty() && decimal != 0 {\n    \
    \    decimal *= 10;\n        decimal += digits.last().unwrap();\n        digits.pop();\n\
    \    }\n\n    if digits.is_empty() {\n        decimal\n    } else {\n        decimal\
    \ / digits.last().unwrap()\n    }", "    let mut precision = number.bits() - 1;\n\
    \    let mut truncated = 0;\n    while precision > 0 {\n        if number >= 1.0\
    \ {\n            truncated = 1;\n            number -= 1.0;\n            precision\
    \ -= 1;\n        } else {\n            truncated = 0;\n            number -= 0.0;\n\
    \            precision -= 1;\n        }\n    }\n    number if truncated != 0 else\n\
    \        number.abs() as f64", "    let mut fraction = number.trunc();\n    let\
    \ decimals = number.fract();\n\n    if decimals > 1 {\n        fraction -= fraction.floor()\
    \ as f64;\n    }\n\n    fraction", "    number\n        .trunc()\n        .unwrap()\n\
    \        .into()\n        .unwrap_or(number as f64)", '    number % 1', '    number.trunc()',
  "    if number >= 1.0 {\n        return number\n    }\n    let n = number.into();\n\
    \    let mut decimal_part = 0.0;\n    let mut fractional_part = 0.0;\n    loop\
    \ {\n        let x = n.floor();\n        let y = n - x;\n        if y != 0 {\n\
    \            decimal_part += y;\n            fractional_part += x;\n        }\n\
    \        match y {\n            0 => {\n                break;\n            }\n\
    \            _ => {}\n        }\n        n = x;\n    }\n    decimal_part + fractional_part",
  '    number.trunc()', "    let mut dec = 0 as f64;\n    if number > 0 {\n      \
    \  while number > f64::from(0.1) {\n            dec += 0.1;\n            number\
    \ -= f64::from(0.1);\n        }\n    }\n    dec", "    let fraction = number %\
    \ 1.0;\n    if fraction < 0.0 {\n        number - fraction\n    } else {\n   \
    \     number\n    }", "    let mut x = number;\n    let mut result = 0.0;\n  \
    \  let mut remainder = 1.0;\n    while remainder > 0 {\n        if remainder <\
    \ 10.0 {\n            result *= 10.0;\n            result += remainder - 10.0;\n\
    \            remainder = 0.0;\n        } else {\n            result *= 10.0;\n\
    \            result += remainder - 10.0;\n            remainder -= 10.0;\n   \
    \     }\n    }\n    x", "    let digits = number.trunc_log10();\n    let (integer,\
    \ decimal) = number.div_pow10(digits);\n    truncate_decimal(decimal)", "    let\
    \ mut ipart: i32 = number.trunc();\n    let mut fraction = number.fract();\n \
    \   if fraction.is_zero() {\n        return ipart;\n    }\n\n    let diff = fraction.abs();\n\
    \    if diff > 0.5 {\n        ipart += 1;\n    }\n    ipart / 10", "    let mut\
    \ remainder = number;\n    let mut decimal_part: f64 = std::f64::MAX;\n    while\
    \ remainder < std::f64::MIN {\n        remainder *= 10;\n        decimal_part\
    \ -= std::f64::ONE;\n    }\n\n    Decimal::from_f64(decimal_part).unwrap()", '    number.truncate()
    as f64', "    let x = number;\n    let xi = x.trunc();\n    let xf = x.fract();\n\
    \n    // Decompose xi into an integer part and a decimal part.\n    let mut decimal_part\
    \ = xi.fract();\n    let mut integer_part = xi;\n\n    while integer_part >= 1.0\
    \ {\n        integer_part -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ += decimal_part;\n    return integer_part as f64 / xf", "    if number % 1 ==\
    \ 0 {\n        number / 1\n    } else {\n        number\n    }", '    number.floor()
    as f64', "    let x = number.floor() as f64;\n    let n = number - x;\n    x.checked_div(n\
    \ as f64).unwrap()", "    if number < 0.0 {\n        f64::MAX / number\n    }\
    \ else {\n        f64::MAX / f64::MAX\n    }", '    number.truncate()']
stop_tokens:
- "\n}"
