name: HumanEval_40_triples_sum_to_zero
language: rust
results:
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    l.sort_unstable();\n\
    \    l.par_iter().try_for_each(|x| if x == 0 || x == -x {\n        if triples_sum_to_zero\
    \ {\n            triples_sum_to_zero = false;\n        } else {\n            triples_sum_to_zero\
    \ = true;\n        }\n    });\n    triples_sum_to_zero\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `par_iter` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp_eg8wn6q.rs:17:7\n   |\n17 |     l.par_iter().try_for_each(|x|\
    \ if x == 0 || x == -x {\n   |       ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf6yk5t1r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    for &i in l {\n        if i >\
    \ 0 {\n            i += 3;\n        }\n    }\n    if i == 3 {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpij5wzjr7.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false;\n    }\n\
    \n    let mut sum = 0;\n\n    for i in l {\n        sum += i;\n        if sum\
    \ < 0 {\n            return false;\n        }\n    }\n\n    let mut triples =\
    \ vec![];\n    for i in l {\n        if i == 0 {\n            return true;\n \
    \       }\n        triples.push(i);\n    }\n\n    let mut triples_sum_to_zero\
    \ = false;\n\n    for triple in triples {\n        let s = triples_sum_to_zero(triples_sum_to_zero\
    \ + triple);\n        if s == true {\n            return true;\n        }\n  \
    \  }\n\n    triples_sum_to_zero;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmph82bjcg8.rs:39:17\n\
    \   |\n36 |     let mut triples_sum_to_zero = false;\n   |         -----------------------\
    \ `triples_sum_to_zero` has type `bool`\n...\n39 |         let s = triples_sum_to_zero(triples_sum_to_zero\
    \ + triple);\n   |                 ^^^^^^^^^^^^^^^^^^^------------------------------\n\
    \   |                 |\n   |                 call expression requires function\n\
    \nerror[E0369]: cannot add `isize` to `bool`\n  --> /tmp/tmph82bjcg8.rs:39:57\n\
    \   |\n39 |         let s = triples_sum_to_zero(triples_sum_to_zero + triple);\n\
    \   |                                     ------------------- ^ ------ isize\n\
    \   |                                     |\n   |                            \
    \         bool\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph82bjcg8.rs:14:42\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |    -------------------\
    \                   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n45 |     triples_sum_to_zero;\n\
    \   |                        - help: remove this semicolon\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0618.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().windows(3).all(|w| w.iter().sum::<isize>()\
    \ == 0)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `windows` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp8efi0fz4.rs:15:14\n   |\n15 |     l.iter().windows(3).all(|w|\
    \ w.iter().sum::<isize>() == 0)\n   |              ^^^^^^^ method not found in\
    \ `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l\n        .iter()\n        .zip(l.iter().skip(1))\n\
    \        .filter(|(_, x)| x == 0)\n        .count() == 3\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&isize` with `{integer}`\n  --> /tmp/tmptg0dnhs6.rs:18:28\n\
    \   |\n18 |         .filter(|(_, x)| x == 0)\n   |                           \
    \ ^^ no implementation for `&&isize == {integer}`\n   |\n   = help: the trait\
    \ `PartialEq<{integer}>` is not implemented for `&&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false\n    }\n\
    \    if l.len() < 3 {\n        return false\n    }\n    let mut first = 0\n  \
    \  let mut second = 0\n    let mut sum = 0\n    for i in l {\n        sum = sum\
    \ + i;\n        if sum == 0 {\n            return false\n        }\n        first\
    \ = i;\n    }\n    for _ in 1..(l.len() - 2) {\n        sum = 0;\n        for\
    \ i in l {\n            sum = sum + i;\n            if sum == 0 {\n          \
    \      return false\n            }\n            second = i;\n        }\n     \
    \   if first == second {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpr6xwbvej.rs:21:22\n\
    \   |\n21 |     let mut first = 0\n   |                      ^ help: add `;` here\n\
    22 |     let mut second = 0\n   |     --- unexpected token\n\nerror: expected\
    \ `;`, found keyword `let`\n  --> /tmp/tmpr6xwbvej.rs:22:23\n   |\n22 |     let\
    \ mut second = 0\n   |                       ^ help: add `;` here\n23 |     let\
    \ mut sum = 0\n   |     --- unexpected token\n\nerror: expected `;`, found keyword\
    \ `for`\n  --> /tmp/tmpr6xwbvej.rs:23:20\n   |\n23 |     let mut sum = 0\n   |\
    \                    ^ help: add `;` here\n24 |     for i in l {\n   |     ---\
    \ unexpected token\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut n = 0;\n    for el in l {\n        if n >=\
    \ 3 {\n            return true;\n        }\n        n += el;\n    }\n    n ==\
    \ 0;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6_5ygow7.rs:14:42\n   |\n\
    14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |    -------------------\
    \                   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n22 |     n\
    \ == 0;\n   |           - help: remove this semicolon\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut counts = vec![0, 0, 0];\n    for n in l {\n\
    \        (*counts[n % 3]) += 1;\n    }\n    counts[1] == 3 && counts[2] == 0 &&\
    \ counts[3] == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpynz4lvdr.rs:17:11\n   |\n17 |         (*counts[n % 3]) += 1;\n   | \
    \          ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() != 3 {\n        return false;\n    }\n\
    \    for i in 0..l.len() {\n        for j in (i + 1)..l.len() {\n            for\
    \ k in (j + 1)..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n    \
    \                return true;\n                }\n            }\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoceeorpo.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() <= 3 {\n        return false;\n    }\n\
    \    let mut found = false;\n    let mut sum = 0;\n    for x in l {\n        sum\
    \ += x;\n        if sum == 0 {\n            found = true;\n            break;\n\
    \        }\n    }\n    found\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz00bp8ta.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |accum, cur| {\n        // if\
    \ current sum is 0, we already know that we have two zeros.\n        if accum\
    \ && (accum - cur) == 0 {\n            false\n        } else {\n            accum\
    \ || triples_sum_to_zero(l.iter().cloned().skip(1))\n        }\n    })\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `&isize` from `bool`\n  --> /tmp/tmptlbg7cqp.rs:17:28\n\
    \   |\n17 |         if accum && (accum - cur) == 0 {\n   |                   \
    \   ----- ^ --- &isize\n   |                      |\n   |                    \
    \  bool\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptlbg7cqp.rs:20:42\n \
    \  |\n20 |             accum || triples_sum_to_zero(l.iter().cloned().skip(1))\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `Skip`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Skip<Cloned<std::slice::Iter<'_, isize>>>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().take(3).all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd1f9a4cm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l != l.iter().fold(Vec::new(), |mut v, n| *v += n);\n\
    \    l\n        .iter()\n        .zip(l.iter().cloned())\n        .filter(|(&x,\
    \ &y)| x != 0 && y != 0)\n        .count() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `[_]`\n  --> /tmp/tmpvdvi3iwl.rs:15:47\n   |\n15 |     l != l.iter().fold(Vec::new(),\
    \ |mut v, n| *v += n);\n   |                                               --^^^^^\n\
    \   |                                               |\n   |                  \
    \                             cannot use `+=` on type `[_]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvdvi3iwl.rs:19:23\n   |\n19 |         .filter(|(&x, &y)|\
    \ x != 0 && y != 0)\n   |                       ^^- expected due to this\n   |\
    \                       |\n   |                       expected `isize`, found\
    \ reference\n   |                       help: you can probably remove the explicit\
    \ borrow: `y`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0368.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = vec![(false, false, false)];\n\
    \    let mut sum: isize = 0;\n    triples.iter().for_each(|triple| {\n       \
    \ sum -= triple[0];\n        if sum == 0 {\n            triples[1] = true;\n \
    \           return false;\n        }\n        if triple[1] {\n            triple[2]\
    \ = true;\n        }\n    });\n    triples[1] && triples[2]\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `&(bool, bool, bool)`\n\
    \  --> /tmp/tmpcgq159a4.rs:18:16\n   |\n18 |         sum -= triple[0];\n   | \
    \               ^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcgq159a4.rs:20:26\n\
    \   |\n20 |             triples[1] = true;\n   |             ----------   ^^^^\
    \ expected tuple, found `bool`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\n   = note: expected tuple `(bool, bool,\
    \ bool)`\n               found type `bool`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcgq159a4.rs:21:20\n   |\n21 |             return false;\n   | \
    \                   ^^^^^ expected `()`, found `bool`\n\nerror[E0608]: cannot\
    \ index into a value of type `&(bool, bool, bool)`\n  --> /tmp/tmpcgq159a4.rs:23:12\n\
    \   |\n23 |         if triple[1] {\n   |            ^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `&(bool, bool, bool)`\n  --> /tmp/tmpcgq159a4.rs:24:13\n\
    \   |\n24 |             triple[2] = true;\n   |             ^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcgq159a4.rs:27:5\n   |\n27 |     triples[1]\
    \ && triples[2]\n   |     ^^^^^^^^^^ expected `bool`, found tuple\n   |\n   =\
    \ note: expected type `bool`\n             found tuple `(bool, bool, bool)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcgq159a4.rs:27:19\n   |\n27 |  \
    \   triples[1] && triples[2]\n   |                   ^^^^^^^^^^ expected `bool`,\
    \ found tuple\n   |\n   = note: expected type `bool`\n             found tuple\
    \ `(bool, bool, bool)`\n\nerror: aborting due to 7 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    for _ in l.iter() {\n       \
    \ i += 1;\n    }\n\n    if i > 2 {\n        return triples_sum_to_zero(vec![l[0],\
    \ l[1], l[2], l[0] + l[1] + l[2]]);\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triplets = 0; // triplets\n    let mut sum_of_triplets\
    \ = 0; // sum of triplets\n    for x in l {\n        triplets += x;\n        sum_of_triplets\
    \ += x * x;\n    }\n\n    if triplets % 3 != 0 {\n        // there must be an\
    \ even number of triplets\n        return false;\n    }\n\n    if sum_of_triplets\
    \ == 0 {\n        // there are no distinct triplets that sum to zero\n       \
    \ return false;\n    }\n\n    // there may be several distinct triplets that sum\
    \ to zero\n    let mut seen: HashSet<_> = HashSet::new();\n    for x in l {\n\
    \        if !seen.contains(&(x * x)) {\n            if sum_of_triplets == 0 {\n\
    \                // there are no distinct triplets that sum to zero\n        \
    \        return false;\n            }\n            seen.insert(x * x);\n     \
    \   }\n    }\n    // there is at least one distinct triplet that sums to zero\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpzb32xes0.rs:33:19\n\
    \   |\n33 |     let mut seen: HashSet<_> = HashSet::new();\n   |             \
    \      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpzb32xes0.rs:33:32\n   |\n33\
    \ |     let mut seen: HashSet<_> = HashSet::new();\n   |                     \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().zip(l.iter().skip(1)).all(|(a, b, c) =>\
    \ (a + b).abs() == c.abs())\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `,` or `:`, found `=>`\n  --> /tmp/tmp1zrqlqet.rs:15:51\n\
    \   |\n15 |     l.iter().zip(l.iter().skip(1)).all(|(a, b, c) => (a + b).abs()\
    \ == c.abs())\n   |                                                   ^^ expected\
    \ one of `,` or `:`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut num_ones = 0;\n    let mut first_two = 0;\n\
    \    let mut last_two = 0;\n    for num in l {\n        if num == 1 {\n      \
    \      num_ones += 1;\n        } else if num == 2 {\n            num_ones += 1;\n\
    \            first_two += 1;\n        } else if num == 3 {\n            last_two\
    \ += 1;\n        }\n    }\n    if num_ones == 3 && first_two == 3 && last_two\
    \ == 3 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfkfcosx0.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triple = False;\n    for i in l.iter().rev()\
    \ {\n        if *i == *(i - 2) && *i == *(i - 1) && *i == *(i - 1) {\n       \
    \     triple = true;\n        } else {\n            triple = false;\n        \
    \    break;\n        }\n    }\n    triple\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `False` in this scope\n  --> /tmp/tmpk9swq76h.rs:15:22\n\
    \   |\n15 |     let mut triple = False;\n   |                      ^^^^^ not found\
    \ in this scope\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpk9swq76h.rs:17:18\n\
    \   |\n17 |         if *i == *(i - 2) && *i == *(i - 1) && *i == *(i - 1) {\n\
    \   |                  ^^^^^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpk9swq76h.rs:17:36\n   |\n17 |         if *i == *(i - 2) && *i ==\
    \ *(i - 1) && *i == *(i - 1) {\n   |                                    ^^^^^^^^\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpk9swq76h.rs:17:54\n\
    \   |\n17 |         if *i == *(i - 2) && *i == *(i - 1) && *i == *(i - 1) {\n\
    \   |                                                      ^^^^^^^^\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0614.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    for i in 0..l.len() - 2 {\n        // We have 3 distinct elements: i, i+1,\
    \ i+2\n        if l[i] + l[i+1] + l[i+2] != 0 {\n            // If none of the\
    \ three sum to zero, then there are 3 distinct elements\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv_dwd73y.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = l.len() - 1;\n    let mut j = 0;\n  \
    \  while i >= 0 && j < l.len() {\n        if l[j] + l[i] <= 0 {\n            i\
    \ += 1;\n        } else {\n            j += 1;\n        }\n        if j == l.len()\
    \ {\n            return false;\n        }\n    }\n    if i == l.len() {\n    \
    \    return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 4 but the index\
    \ is 4', /tmp/tmp5he93ga0.rs:18:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n        if sum % 3 == 0 {\n            return true;\n        }\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzz54mlx4.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |prev, el| prev && el == 3 &&\
    \ el == -prev)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmptl32a2wk.rs:15:48\n\
    \   |\n15 |     l.iter().fold(false, |prev, el| prev && el == 3 && el == -prev)\n\
    \   |                                                ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `bool`\n  --> /tmp/tmptl32a2wk.rs:15:62\n   |\n15 |     l.iter().fold(false,\
    \ |prev, el| prev && el == 3 && el == -prev)\n   |                           \
    \                                   ^^^^^ cannot apply unary operator `-`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |prev, i| {\n        if prev\
    \ {\n            prev\n        } else {\n            i + (i + i + i) == 3\n  \
    \      }\n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp26gn50bl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().cloned().combinations(3).any(|(a,b,c)| {\n\
    \        a+b+c == 0 \n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `combinations` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpj8zdcz4t.rs:15:23\n   |\n15 |     l.iter().cloned().combinations(3).any(|(a,b,c)|\
    \ {\n   |                       ^^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut is_distinct = true;\n    let mut sum = 0;\n\
    \n    for (i, &e) in l.iter().enumerate() {\n        // If e is negative, we're\
    \ done.\n        if e < 0 {\n            return true;\n        }\n\n        //\
    \ If e is 0, we're done.\n        if e == 0 {\n            is_distinct = false;\n\
    \            return true;\n        }\n\n        // If sum is zero, we're done.\n\
    \        if sum == 0 {\n            is_distinct = false;\n            return true;\n\
    \        }\n\n        // Add the element to the sum.\n        sum += e;\n\n  \
    \      // If sum is greater than 0, then we know that e is distinct from\n   \
    \     // every element in the list.\n        if sum > 0 {\n            is_distinct\
    \ = false;\n            break;\n        }\n    }\n\n    // We know that sum is\
    \ greater than 0, so if is_distinct is false,\n    // then sum is equal to 0 so\
    \ we have three different elements\n    // whose sum are equal to zero.\n    !is_distinct\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbqssryek.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triplets = vec![(0, 0, 0)];\n    for &i in\
    \ l {\n        let mut triplets_sum = 0;\n        for triplet_sum in &triplets{\n\
    \            let (i, j, k) = triplet_sum;\n            triplets_sum += i * j;\n\
    \        }\n        if triplets_sum == 0 {\n            return false;\n      \
    \  }\n        triplets.push((i, j, k));\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpmb3kvd4s.rs:25:27\n\
    \   |\n25 |         triplets.push((i, j, k));\n   |                          \
    \ ^ help: a local variable with a similar name exists: `i`\n\nerror[E0425]: cannot\
    \ find value `k` in this scope\n   --> /tmp/tmpmb3kvd4s.rs:25:30\n    |\n25  |\
    \         triplets.push((i, j, k));\n    |                              ^ help:\
    \ a tuple variant with a similar name exists: `Ok`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmb3kvd4s.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut a = l.clone();\n    a.sort();\n    a.dedup();\n\
    \    let mut b = a;\n    b.sort();\n    b.dedup();\n    let mut c = b;\n    c.sort();\n\
    \    c.dedup();\n    a.len() == b.len() && a.len() == c.len() && b.iter().sum()\
    \ == 0 && c.iter().sum() == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpuvgxbgm7.rs:24:58\n\
    \     |\n24   |     a.len() == b.len() && a.len() == c.len() && b.iter().sum()\
    \ == 0 && c.iter().sum() == 0\n     |                                        \
    \                  ^^^ cannot infer type for type parameter `S` declared on the\
    \ associated function `sum`\n     |\n     = note: cannot satisfy `_: Sum<&isize>`\n\
    note: required by a bound in `std::iter::Iterator::sum`\nhelp: consider specifying\
    \ the type argument in the method call\n     |\n24   |     a.len() == b.len()\
    \ && a.len() == c.len() && b.iter().sum::<S>() == 0 && c.iter().sum() == 0\n \
    \    |                                                             +++++\nhelp:\
    \ consider specifying the type argument in the function call\n     |\n24   | \
    \    a.len() == b.len() && a.len() == c.len() && b.iter().sum::<S>() == 0 && c.iter().sum()\
    \ == 0\n     |                                                             +++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0283`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut min_sum = l.iter().fold(isize::MIN, isize::MAX);\n\
    \    for v in l.iter().rev() {\n        if v > 0 && v < min_sum {\n          \
    \  min_sum = v;\n        }\n    }\n    for v in l.iter().rev() {\n        if v\
    \ == 0 || min_sum + v < 3 {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(isize, &isize)>` closure, found `isize`\n\
    \    --> /tmp/tmp5x8bucz4.rs:15:32\n     |\n15   |     let mut min_sum = l.iter().fold(isize::MIN,\
    \ isize::MAX);\n     |                                ^^^^ expected an `FnMut<(isize,\
    \ &isize)>` closure, found `isize`\n     |\n     = help: the trait `FnMut<(isize,\
    \ &isize)>` is not implemented for `isize`\nnote: required by a bound in `fold`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5x8bucz4.rs:17:16\n   |\n17 |\
    \         if v > 0 && v < min_sum {\n   |                ^\n   |             \
    \   |\n   |                expected `&isize`, found integer\n   |            \
    \    help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp5x8bucz4.rs:17:25\n   |\n17 |         if v > 0 && v < min_sum {\n\
    \   |                         ^^^^^^^\n   |                         |\n   |  \
    \                       expected `&isize`, found `isize`\n   |               \
    \          help: consider borrowing here: `&min_sum`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5x8bucz4.rs:18:23\n   |\n15 |     let mut min_sum = l.iter().fold(isize::MIN,\
    \ isize::MAX);\n   |                       -------------------------------------\
    \ expected due to this value\n...\n18 |             min_sum = v;\n   |       \
    \                ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |             min_sum = *v;\n   |                     \
    \  +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp5x8bucz4.rs:22:14\n\
    \   |\n22 |         if v == 0 || min_sum + v < 3 {\n   |              ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut num = 0;\n    for i\
    \ in l {\n        sum += i;\n        num += 1;\n    }\n    if num == 3 {\n   \
    \     false\n    } else if num == 2 && sum == 0 {\n        true\n    } else {\n\
    \        triples_sum_to_zero(l)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpmzmwjwhk.rs:26:29\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n17  |     for i in l {\n    |             \
    \ - `l` moved due to this implicit call to `.into_iter()`\n...\n26  |        \
    \ triples_sum_to_zero(l)\n    |                             ^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n17  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = Vec::new();\n    let mut sum = 0;\n \
    \   for elt in l {\n        sum += *elt;\n        if sum < 0 {\n            return\
    \ false;\n        }\n        s.push(*elt);\n    }\n    for elt in l.iter() {\n\
    \        match s.iter().position(|x| *x == *elt) {\n            Some(index) =>\
    \ s.splice(index, 1),\n            None => return false\n        }\n    }\n  \
    \  return true;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpl9a2ntef.rs:18:16\n\
    \   |\n18 |         sum += *elt;\n   |                ^^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpl9a2ntef.rs:22:16\n   |\n22 |\
    \         s.push(*elt);\n   |                ^^^^\n\nerror[E0277]: the trait bound\
    \ `usize: RangeBounds<usize>` is not satisfied\n    --> /tmp/tmpl9a2ntef.rs:26:37\n\
    \     |\n26   |             Some(index) => s.splice(index, 1),\n     |       \
    \                       ------ ^^^^^ the trait `RangeBounds<usize>` is not implemented\
    \ for `usize`\n     |                              |\n     |                 \
    \             required by a bound introduced by this call\n     |\n     = help:\
    \ the following other types implement trait `RangeBounds<T>`:\n              \
    \ (Bound<&'a T>, Bound<&'a T>)\n               (Bound<T>, Bound<T>)\n        \
    \       RangeFrom<&T>\n               RangeFrom<T>\n               RangeFull\n\
    \               RangeInclusive<&T>\n               RangeInclusive<T>\n       \
    \        RangeTo<&T>\n             and 5 others\nnote: required by a bound in\
    \ `Vec::<T, A>::splice`\n\nerror[E0277]: `{integer}` is not an iterator\n  -->\
    \ /tmp/tmpl9a2ntef.rs:26:44\n   |\n26 |             Some(index) => s.splice(index,\
    \ 1),\n   |                              ------        ^ `{integer}` is not an\
    \ iterator\n   |                              |\n   |                        \
    \      required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `{integer}`\n   = note: if you want to iterate\
    \ between `start` until a value `end`, use the exclusive range syntax `start..end`\
    \ or the inclusive range syntax `start..=end`\nnote: required by a bound in `Splice`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl9a2ntef.rs:26:28\n   |\n26 |\
    \             Some(index) => s.splice(index, 1),\n   |                       \
    \     ^^^^^^^^^^^^^^^^^^ expected `()`, found struct `Splice`\n27 |          \
    \   None => return false\n28 |         }\n   |          - help: consider using\
    \ a semicolon here: `;`\n   |\n   = note: expected unit type `("
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut total = 0;\n    while i < l.len() {\n        if l[j] + l[k]\
    \ + l[i] != 0 {\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \            total += 1;\n        }\n        if l[j] + l[k] == 0 {\n         \
    \   i += 1;\n            total += 1;\n        }\n        if l[j] == 0 {\n    \
    \        i += 1;\n            j += 1;\n        }\n    }\n    total < 2\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 4 but the index\
    \ is 4', /tmp/tmpnxp5k2ap.rs:26:12\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n\n    for i\
    \ in l {\n        for j in l {\n            for k in l {\n                let\
    \ n = (i + j + k);\n                if n != 0 {\n                    if sum ==\
    \ n {\n                        return true;\n                    }\n         \
    \       }\n            }\n        }\n    }\n\n    false\n}\n\nfn main() {\n  \
    \  let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp1x00hp__.rs:27:25\n\
    \   |\n27 |                 let n = (i + j + k);\n   |                       \
    \  ^         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n27 -                 let n = (i + j + k);\n\
    27 +                 let n = i + j + k;\n   | \n\nerror[E0382]: use of moved value:\
    \ `l`\n   --> /tmp/tmp1x00hp__.rs:24:14\n    |\n14  | fn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    |                        - move occurs because `l`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20  |\
    \     for i in l {\n    |              - `l` moved due to this implicit call to\
    \ `.into_iter()`\n...\n24  |     for i in l {\n    |              ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n20  |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n  --> /tmp/tmp1x00hp__.rs:25:18\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \            - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n24 |     for i in l {\n   |              - `l` moved\
    \ due to this implicit call to `.into_iter()`\n25 |         for j in l {\n   |\
    \                  ^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \   |\n24 |     for i in &l {\n   |              +\n\nerror[E0382]: use of moved\
    \ value: `l`\n  --> /tmp/tmp1x00hp__.rs:26:22\n   |\n14 | fn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n   |                        - move occurs because `l`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n25 |\
    \         for j in l {\n   |                  - `l` moved due to this implicit\
    \ call to `.into_iter()`\n26 |             for k in l {\n   |                \
    \      ^ value used here after move\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut first_element = l[0];\n    let mut second_element\
    \ = l[1];\n    let mut third_element = l[2];\n    for &x in &l {\n        match\
    \ &x - &first_element {\n            x if x == 0 => first_element = x,\n     \
    \       _ => break,\n        }\n    }\n    match &third_element - &second_element\
    \ {\n        x if x == 0 => third_element = x,\n        _ => break,\n    }\n \
    \   third_element == 0 && first_element == 0 && second_element == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0268]: `break` outside of a loop\n  --> /tmp/tmpjuxff3fe.rs:26:14\n\
    \   |\n26 |         _ => break,\n   |              ^^^^^ cannot `break` outside\
    \ of a loop\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0268`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut n = l.len();\n    let mut k = n;\n    let\
    \ mut sum = 0;\n\n    while k > 0 {\n        sum += l[k - 1];\n        k /= 3;\n\
    \    }\n    sum == 0 && n == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc34rjmzh.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut num_zeros = 0;\n    let mut sum = 0;\n  \
    \  for x in l {\n        sum += x;\n        if sum == 0 {\n            num_zeros\
    \ += 1;\n        }\n    }\n    if num_zeros == 3 {\n        return true;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqtrgn0wl.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum: isize = 0;\n\n    for i in l.iter().cloned()\
    \ {\n        if i != 0 {\n            sum += i;\n        }\n    }\n\n    sum ==\
    \ 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkcuv9m9v.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, (0..2).is_subset.unwrap_or(false)).unwrap_or(true)\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `is_subset` on type `std::ops::Range<{integer}>`\n\
    \  --> /tmp/tmp48rbsvth.rs:15:33\n   |\n15 |     l.iter().fold(false, (0..2).is_subset.unwrap_or(false)).unwrap_or(true)\n\
    \   |                                 ^^^^^^^^^ unknown field\n   |\n   = note:\
    \ available fields are: `start`, `end`\n\nerror[E0599]: no method named `unwrap_or`\
    \ found for type `bool` in the current scope\n  --> /tmp/tmp48rbsvth.rs:15:61\n\
    \   |\n15 |     l.iter().fold(false, (0..2).is_subset.unwrap_or(false)).unwrap_or(true)\n\
    \   |                                                             ^^^^^^^^^ method\
    \ not found in `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = std::collections::HashSet::new();\n \
    \   for x in l {\n        if s.insert(x).is_some() {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_some` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmp86zqcbgs.rs:17:24\n   |\n17 |         if s.insert(x).is_some()\
    \ {\n   |                        ^^^^^^^ method not found in `bool`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().combinations(3).any(|&x| x.iter().all(|&y|\
    \ y == 0))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `combinations` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmprs80j26w.rs:15:14\n   |\n15 |     l.iter().combinations(3).any(|&x|\
    \ x.iter().all(|&y| y == 0))\n   |              ^^^^^^^^^^^^ method not found\
    \ in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    (0..l.len()).all(|i| {\n        let a = l[i..];\n\
    \        let b = l[i..];\n        let c = l[i..];\n        let mut sum = 0;\n\n\
    \        for &a in &a { sum += a; }\n\n        for &b in &b { sum += b; }\n\n\
    \        for &c in &c { sum += c; }\n\n        sum < 0\n    })\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmpgxxcvaqu.rs:16:13\n   |\n16 |         let a\
    \ = l[i..];\n   |             ^ doesn't have a size known at compile-time\n  \
    \ |\n   = help: the trait `Sized` is not implemented for `[isize]`\n   = note:\
    \ all local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n16 |\
    \         let a = &l[i..];\n   |                 +\n\nerror[E0277]: the size for\
    \ values of type `[isize]` cannot be known at compilation time\n  --> /tmp/tmpgxxcvaqu.rs:17:13\n\
    \   |\n17 |         let b = l[i..];\n   |             ^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n\
    \   |\n17 |         let b = &l[i..];\n   |                 +\n\nerror[E0277]:\
    \ the size for values of type `[isize]` cannot be known at compilation time\n\
    \  --> /tmp/tmpgxxcvaqu.rs:18:13\n   |\n18 |         let c = l[i..];\n   |   \
    \          ^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `[isize]`\n   = note: all local variables must\
    \ have a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\nhelp: consider borrowing here\n   |\n18 |         let c = &l[i..];\n\
    \   |                 +\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut cur_sum: usize = 0;\n    let mut cur_elem:\
    \ usize = 0;\n    let mut next_elem: usize = 1;\n    for elem in l.iter() {\n\
    \        cur_sum += elem;\n        if cur_sum == 0 {\n            return true;\n\
    \        }\n        if cur_sum < 0 {\n            return false;\n        }\n \
    \       if cur_elem + next_elem == 0 {\n            return false;\n        }\n\
    \        cur_elem = next_elem;\n        next_elem = elem * cur_elem + 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjlz9ctig.rs:19:20\n   |\n\
    19 |         cur_sum += elem;\n   |                    ^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add-assign `&isize` to `usize`\n  -->\
    \ /tmp/tmpjlz9ctig.rs:19:17\n   |\n19 |         cur_sum += elem;\n   |       \
    \          ^^ no implementation for `usize += &isize`\n   |\n   = help: the trait\
    \ `AddAssign<&isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjlz9ctig.rs:30:28\n   |\n30 |         next_elem = elem\
    \ * cur_elem + 1;\n   |                            ^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot multiply `&isize` by `usize`\n  --> /tmp/tmpjlz9ctig.rs:30:26\n\
    \   |\n30 |         next_elem = elem * cur_elem + 1;\n   |                   \
    \       ^ no implementation for `&isize * usize`\n   |\n   = help: the trait `Mul<usize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjlz9ctig.rs:30:21\n\
    \   |\n17 |     let mut next_elem: usize = 1;\n   |                        -----\
    \ expected due to this type\n...\n30 |         next_elem = elem * cur_elem + 1;\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more informatio"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp1djd8xmx.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |sum, v| {\n        sum && l.iter().any(|w|\
    \ {\n            w + v == 0 && sum\n        })\n    })\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxaczzl8o.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = vec![];\n    let mut j = vec![];\n  \
    \  for i in l.iter() {\n        if j.is_empty() {\n            j.add(i as isize);\n\
    \        } else {\n            let mut k = 0;\n            let mut found = false;\n\
    \            for j in j {\n                found |= j == i as isize;\n       \
    \         k += 1;\n            }\n            if found && k == 3 {\n         \
    \       return true;\n            }\n        }\n        i.push(i as isize);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `add` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmpx6tft87u.rs:19:15\n   |\n19 |             j.add(i as isize);\n\
    \   |               ^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `push` found for reference `&isize` in the current scope\n  --> /tmp/tmpx6tft87u.rs:31:11\n\
    \   |\n31 |         i.push(i as isize);\n   |           ^^^^ method not found\
    \ in `&isize`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpx6tft87u.rs:19:19\n\
    \   |\n19 |             j.add(i as isize);\n   |                   -^^^^^^^^^\n\
    \   |                   |\n   |                   cannot cast `&isize` as `isize`\n\
    \   |                   help: dereference the expression: `*i`\n\nerror[E0606]:\
    \ casting `&isize` as `isize` is invalid\n  --> /tmp/tmpx6tft87u.rs:24:31\n  \
    \ |\n24 |                 found |= j == i as isize;\n   |                    \
    \           -^^^^^^^^^\n   |                               |\n   |           \
    \                    cannot cast `&isize` as `isize`\n   |                   \
    \            help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize`\
    \ as `isize` is invalid\n  --> /tmp/tmpx6tft87u.rs:31:16\n   |\n31 |         i.push(i\
    \ as isize);\n   |                -^^^^^^^^^\n   |                |\n   |    \
    \            cannot cast `&isize` as `isize`\n   |                help: dereference\
    \ the expression: `*i`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0606.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        assert!(triple_sum_to_zero(l[..i+1]));\n\
    \    }\n    l.rev().len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `triple_sum_to_zero` in this scope\n\
    \  --> /tmp/tmpf9nd7h2_.rs:16:17\n   |\n16 |         assert!(triple_sum_to_zero(l[..i+1]));\n\
    \   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpf9nd7h2_.rs:18:7\n    |\n18\
    \  |       l.rev().len() == 3\n    |         ^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l\n        .iter()\n        .zip(l.iter().skip(1).zip(l.iter().skip(1).zip(l.iter())))\n\
    \        .all(|(a, b)| a.0 == b.0 && a.1 == b.1 && a.2 == b.2)\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmp08ie3fv2.rs:18:25\n\
    \   |\n18 |         .all(|(a, b)| a.0 == b.0 && a.1 == b.1 && a.2 == b.2)\n  \
    \ |                         ^\n\nerror[E0609]: no field `1` on type `&isize`\n\
    \  --> /tmp/tmp08ie3fv2.rs:18:39\n   |\n18 |         .all(|(a, b)| a.0 == b.0\
    \ && a.1 == b.1 && a.2 == b.2)\n   |                                       ^\n\
    \nerror[E0609]: no field `2` on type `&isize`\n  --> /tmp/tmp08ie3fv2.rs:18:53\n\
    \   |\n18 |         .all(|(a, b)| a.0 == b.0 && a.1 == b.1 && a.2 == b.2)\n  \
    \ |                                                     ^\n\nerror[E0609]: no\
    \ field `2` on type `(&isize, (&isize, &isize))`\n  --> /tmp/tmp08ie3fv2.rs:18:60\n\
    \   |\n18 |         .all(|(a, b)| a.0 == b.0 && a.1 == b.1 && a.2 == b.2)\n  \
    \ |                                                            ^\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().windows(3).all(|x| x.iter().any(|&i| i ==\
    \ 0))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `windows` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmprcjpqvxe.rs:15:14\n   |\n15 |     l.iter().windows(3).all(|x|\
    \ x.iter().any(|&i| i == 0))\n   |              ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false)(|a, b| {\n        if *b != 0\
    \ || *b != 0 {\n            b += 1\n            *b != *a\n        } else {\n \
    \           a\n        }\n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpf35z2fmh.rs:15:14\n     |\n15   |     l.iter().fold(false)(|a,\
    \ b| {\n     |              ^^^^ ----- supplied 1 argument\n     |           \
    \   |\n     |              expected 2 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i1_to_i2 = l.len();\n    let mut i2_to_i3\
    \ = l.len();\n    let mut i3_to_i4 = l.len();\n\n    while i1_to_i2 > 0 || i2_to_i3\
    \ > 0 || i3_to_i4 > 0 {\n        if l[i1_to_i2] + l[i2_to_i3] > l[i3_to_i4] {\n\
    \            i1_to_i2 -= 1;\n        } else if l[i1_to_i2] + l[i2_to_i3] < l[i3_to_i4]\
    \ {\n            i2_to_i3 -= 1;\n        } else {\n            i3_to_i4 -= 1;\n\
    \        }\n    }\n\n    l.len() <= 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 4 but the index\
    \ is 4', /tmp/tmpwts0hr1h.rs:20:12\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().any(|&x| triples_sum_to_zero(x, l, 0))\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmpw2guvg6s.rs:15:23\n   |\n15 |     l.iter().any(|&x| triples_sum_to_zero(x,\
    \ l, 0))\n   |                       ^^^^^^^^^^^^^^^^^^^ -  -  - supplied 3 arguments\n\
    \   |                       |\n   |                       expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpw2guvg6s.rs:14:4\n   |\n14 |\
    \ fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |    ^^^^^^^^^^^^^^^^^^^\
    \ -------------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    if sum == 0 {\n        true\n    } else if sum < 0 {\n      \
    \  false\n    } else {\n        triples_sum_to_zero(l.iter().filter(|&x| x > 0).cloned())\n\
    \    }\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxjpg5r9a.rs:24:54\n   |\n\
    24 |         triples_sum_to_zero(l.iter().filter(|&x| x > 0).cloned())\n   | \
    \                                                     ^\n   |                \
    \                                      |\n   |                               \
    \                       expected `&isize`, found integer\n   |               \
    \                                       help: consider borrowing here: `&0`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxjpg5r9a.rs:24:29\n   |\n24 |  \
    \       triples_sum_to_zero(l.iter().filter(|&x| x > 0).cloned())\n   |      \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found struct `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n     \
    \         found struct `Cloned<Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmpxjpg5r9a.rs:24:45:\
    \ 24:55]>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| acc && triples_sum_to_zero(vec![x,\
    \ x - 1, x - 2])\n        .unwrap_or(false))\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwp4fx90b.rs:15:67\n   |\n\
    15 |     l.iter().fold(false, |acc, x| acc && triples_sum_to_zero(vec![x, x -\
    \ 1, x - 2])\n   |                                                           \
    \        ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |     l.iter().fold(false, |acc, x| acc && triples_sum_to_zero(vec![*x,\
    \ x - 1, x - 2])\n   |                                                       \
    \            +\n\nerror[E0599]: no method named `unwrap_or` found for type `bool`\
    \ in the current scope\n  --> /tmp/tmpwp4fx90b.rs:16:10\n   |\n16 |         .unwrap_or(false))\n\
    \   |          ^^^^^^^^^ method not found in `bool`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().cloned().enumerate().any(|(ix, (n, xs))|\
    \ {\n        xs.iter().enumerate().any(|(iy, (y, xs))| {\n            if y ==\
    \ 0 && iy != 0 {\n                return false\n            }\n            vec![ix,\
    \ iy].iter().any(|e| x == e)\n        })\n    })\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmptbne4z4k.rs:20:41\n\
    \   |\n20 |             vec![ix, iy].iter().any(|e| x == e)\n   |            \
    \                             ^ help: a local variable with a similar name exists:\
    \ `e`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptbne4z4k.rs:15:45\n   |\n\
    15 |     l.iter().cloned().enumerate().any(|(ix, (n, xs))| {\n   |           \
    \                                  ^^^^^^^- expected due to this\n   |       \
    \                                      |\n   |                               \
    \              expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n\
    \             found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // We start by building a map with the sum of each\
    \ triple.\n    let mut sums = HashMap::<isize, isize>::new();\n    for x in l.iter()\
    \ {\n        let sum = x + x;\n        sums.entry(sum).or_insert(x);\n    }\n\n\
    \    // We then use that map to check for duplicates\n    for (x, _) in sums {\n\
    \        if sums.entry(x).or_insert(x) != x {\n            return true;\n    \
    \    }\n    }\n\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp88zvli6d.rs:16:20\n   |\n16 |     let mut sums = HashMap::<isize, isize>::new();\n\
    \   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = true;\n    let mut\
    \ last_val = l.len() - 1;\n    for i in 0..last_val {\n        for j in i+1..last_val\
    \ {\n            if l[j] + l[i] == 0 {\n                triples_sum_to_zero =\
    \ false;\n                break;\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxzo03ltm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(true, |x, y| x && x.checked_add(y).is_zero())\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_add` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmp1gh8n93v.rs:15:39\n   |\n15 |     l.iter().fold(true,\
    \ |x, y| x && x.checked_add(y).is_zero())\n   |                              \
    \         ^^^^^^^^^^^ method not found in `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().combinations(3).all(|t| t.iter().all(|e|\
    \ e == 0))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `combinations` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp1wjxt2iz.rs:15:14\n   |\n15 |     l.iter().combinations(3).all(|t|\
    \ t.iter().all(|e| e == 0))\n   |              ^^^^^^^^^^^^ method not found in\
    \ `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(true, |a, b| { if (a && b) || (!a &&\
    \ !b) a })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `a`\n  --> /tmp/tmpu1zn4l_x.rs:15:60\n   |\n\
    15 |     l.iter().fold(true, |a, b| { if (a && b) || (!a && !b) a })\n   |   \
    \                               --                        ^ expected `{`\n   |\
    \                                  |\n   |                                  this\
    \ `if` expression has a condition, but no block\n   |\nhelp: try placing this\
    \ code inside a block\n   |\n15 |     l.iter().fold(true, |a, b| { if (a && b)\
    \ || (!a && !b) { a } })\n   |                                               \
    \             +   +\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l != l.iter().filter(|&x| x == x).cloned()\n    \
    \    .chain(l.iter().filter(|&x| x == -x).cloned())\n        .filter(|&x| x ==\
    \ 0).cloned()\n        .count() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpnx71soma.rs:15:7\n\
    \   |\n15 |     l != l.iter().filter(|&x| x == x).cloned()\n   |       ^^\n...\n\
    18 |         .count() == 3\n   |                  ^^\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmpnx71soma.rs:16:39\n   |\n16 |         .chain(l.iter().filter(|&x|\
    \ x == -x).cloned())\n   |                                       ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0271]: type mismatch resolving\
    \ `<Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmpnx71soma.rs:15:26: 15:37]>\
    \ as Iterator>::Item == &&_`\n  --> /tmp/tmpnx71soma.rs:17:30\n   |\n17 |    \
    \     .filter(|&x| x == 0).cloned()\n   |                              ^^^^^^\
    \ expected reference, found `isize`\n   |\n   = note: expected reference `&&_`\n\
    \              found reference `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmpnx71soma.rs:15:26:\
    \ 15:37]>>`\n   = note: 2 redundant requirements hidden\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `Filter<std::iter::Chain<Cloned<Filter<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpnx71soma.rs:15:26: 15:37]>>, Cloned<Filter<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpnx71soma.rs:16:32: 16:44]>>>, [closure@/tmp/tmpnx71soma.rs:17:17:\
    \ 17:28]>`\n\nerror[E0631]: type mismatch in closure arguments\n  --> /tmp/tmpnx71soma.rs:17:30\n\
    \   |\n17 |         .filter(|&x| x == 0).cloned()\n   |                 -----------\
    \  ^^^^^^ expected signature of `for<'r> fn(&'r &_) -> _`\n   |              \
    \   |\n   |                 found signature of `for<'r> fn(&'r isize) -> _`\n\
    \   |\n   = note: required because of the requirements on the impl of "
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n        if sum < 0 {\n            return false;\n        }\n    }\n    let\
    \ mut triplets = vec![];\n    for x in l {\n        sum += x;\n        if sum\
    \ >= 0 && sum < 3 {\n            triplets.push(x);\n        }\n    }\n    if triplets.len()\
    \ < 3 {\n        return false;\n    }\n    triplets.iter().all(|&x| x == 0)\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmppoy_dqpx.rs:23:14\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for x in l {\n    |              ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n    |    \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    for &x in l {\n        i += x;\n        j += x;\n        k += x;\n\
    \    }\n    i != j\n        && j != k\n        && i != k\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgmfiw85b.rs:18:9\n   |\n\
    18 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = vec![(0, 0, 0)];\n\n    for i in\
    \ l {\n        for triplet in triples {\n            if triplet.0 + triplet.1\
    \ == i && triplet.2 + triplet.3 == i {\n                return true;\n       \
    \     }\n        }\n        triples.push((0, 0, i));\n    }\n    triples.len()\
    \ == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `3` on type `(isize, isize, {integer})`\n  --> /tmp/tmpk3xpntn3.rs:19:66\n\
    \   |\n19 |             if triplet.0 + triplet.1 == i && triplet.2 + triplet.3\
    \ == i {\n   |                                                               \
    \   ^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut sum = 0;\n    let mut count = 0;\n    while i < l.len() &&\
    \ j < l.len() && k < l.len() {\n        if l[i] == l[j] && l[j] == l[k] {\n  \
    \          sum += l[i];\n            i += 1;\n            j += 1;\n          \
    \  k += 1;\n            count += 1;\n        } else if l[i] > l[j] {\n       \
    \     sum += l[i];\n            i += 1;\n            count += 1;\n        } else\
    \ if l[j] > l[k] {\n            sum += l[j];\n            j += 1;\n          \
    \  count += 1;\n        } else {\n            sum += l[k];\n            k += 1;\n\
    \            count += 1;\n        }\n    }\n    count != 3 || sum == 0\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphteqam9i.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    l.iter().cloned().fold(false, |sum, elem| {\n        let elem = elem.unwrap();\n\
    \        sum && &elem == &elem + &elem\n    })\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpujc08yv0.rs:20:25\n   |\n20 |         let elem = elem.unwrap();\n\
    \   |                         ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = vec![(0, 0, 0)];\n    l.iter().for_each(|&x|\
    \ {\n        let (b, c, d) = s.last();\n        if b != 0 || c != 0 || d != 0\
    \ {\n            let d = x - b;\n            let e = c - d;\n            let f\
    \ = d - e;\n            s.push((b, c, f));\n        }\n    });\n    matches!(s,\
    \ (s, c, d) => c == 0 || d == 0 || c == -d || d == -c)\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error: no rules expected the token `=>`\n  --> /tmp/tmpw269w7u3.rs:25:27\n\
    \   |\n25 |     matches!(s, (s, c, d) => c == 0 || d == 0 || c == -d || d == -c)\n\
    \   |                           ^^ no rules expected this token in macro call\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw269w7u3.rs:17:13\n   |\n17 |\
    \         let (b, c, d) = s.last();\n   |             ^^^^^^^^^   -------- this\
    \ expression has type `Option<&({integer}, {integer}, {integer})>`\n   |     \
    \        |\n   |             expected enum `Option`, found tuple\n   |\n   = note:\
    \ expected enum `Option<&({integer}, {integer}, {integer})>`\n             found\
    \ tuple `(_, _, _)`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for num in l {\n        if\
    \ num > 0 {\n            sum += num;\n        }\n    }\n    let len = l.len();\n\
    \    for num in l {\n        if sum == 0 {\n            return false;\n      \
    \  }\n        sum += num;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `len`\n  --> /tmp/tmplm2o02bk.rs:21:9\n   |\n\
    21 |     let len = l.len();\n   |         ^^^ help: if this is intentional, prefix\
    \ it with an underscore: `_len`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `l`\n   --> /tmp/tmplm2o02bk.rs:21:15\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for num in\
    \ l {\n    |                - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     let len = l.len();\n    |               ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for num in &l\
    \ {\n    |                +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false;\n    }\n\
    \    let mut sum = 0;\n    for i in l {\n        if i >= 0 {\n            sum\
    \ += i;\n        } else {\n            return false;\n        }\n    }\n    for\
    \ k in l {\n        if (k > 0 && sum != 0) || (k < 0 && sum != -k)\n         \
    \   || (k == 0 && sum != k) {\n            return false;\n        }\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmprf8x7hj6.rs:26:14\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for i in l {\n    |             \
    \ - `l` moved due to this implicit call to `.into_iter()`\n...\n26  |     for\
    \ k in l {\n    |              ^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `l`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n19  |     for i in &l {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().filter(|&i| i > 0).count() == 3\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp48aelojp.rs:15:30\n   |\n\
    15 |     l.iter().filter(|&i| i > 0).count() == 3\n   |                      \
    \        ^\n   |                              |\n   |                        \
    \      expected `&isize`, found integer\n   |                              help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut ans = false;\n    for i in l {\n        for\
    \ j in l {\n            for k in l {\n                if i + j + k == 0 {\n  \
    \                  ans = true;\n                    break;\n                }\n\
    \            }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpouauhsne.rs:17:18\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut ans = false;\n16  |     for i\
    \ in l {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    17  |         for j in l {\n    |                  ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n    |    \
    \          +\n\nerror[E0382]: use of moved value: `l`\n  --> /tmp/tmpouauhsne.rs:18:22\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \            - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17 |         for j in l {\n   |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n18 |             for k in\
    \ l {\n   |                      ^ value used here after move\n   |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n   |\n17 |         for j in &l {\n   |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut has_three = false;\n    l.iter().fold(false,\
    \ |has_triple, &x| {\n        if has_triple {\n            *has_triple &= x !=\
    \ 0; // if has_triple is true, has_triple is false\n        }\n        *has_triple\
    \ && has_three\n    });\n    !has_three\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmpwu0cc4bm.rs:18:13\n\
    \   |\n18 |             *has_triple &= x != 0; // if has_triple is true, has_triple\
    \ is false\n   |             ^^^^^^^^^^^\n\nerror[E0614]: type `bool` cannot be\
    \ dereferenced\n  --> /tmp/tmpwu0cc4bm.rs:20:9\n   |\n20 |         *has_triple\
    \ && has_three\n   |         ^^^^^^^^^^^\n   |\nhelp: parentheses are required\
    \ to parse this as an expression\n   |\n17 ~         (if has_triple {\n18 |  \
    \           *has_triple &= x != 0; // if has_triple is true, has_triple is false\n\
    19 ~         })\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |mut a, &b| {\n        if a\
    \ + b == 0 {\n            a\n        } else {\n            a && b != 0\n     \
    \   }\n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n  \
    \  assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `isize` to `bool`\n  --> /tmp/tmptr2kl8_9.rs:16:14\n\
    \   |\n16 |         if a + b == 0 {\n   |            - ^ - isize\n   |       \
    \     |\n   |            bool\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| acc && acc.contains(-x)\
    \ && acc.contains(x))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmp_9crcjkp.rs:15:46\n   |\n15 |     l.iter().fold(false,\
    \ |acc, x| acc && acc.contains(-x) && acc.contains(x))\n   |                 \
    \                             ^^^^^^^^ method not found in `bool`\n\nerror[E0599]:\
    \ no method named `contains` found for type `bool` in the current scope\n  -->\
    \ /tmp/tmp_9crcjkp.rs:15:66\n   |\n15 |     l.iter().fold(false, |acc, x| acc\
    \ && acc.contains(-x) && acc.contains(x))\n   |                              \
    \                                    ^^^^^^^^ method not found in `bool`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pair = vec![];\n    let mut tripple = vec![];\n\
    \    for i in l {\n        if i > 0 {\n            if pair.size() == 0 || pair.get(0).unwrap()\
    \ + i > pair.get(1).unwrap() {\n                pair.push(vec![i]);\n        \
    \    } else {\n                pair.get(1).unwrap() += i;\n            }\n   \
    \     }\n        if i > 0 {\n            if triplep.size() == 0 || triplep.get(1).unwrap()\
    \ + i > triplep.get(2).unwrap() {\n                triplep.push(vec![i]);\n  \
    \          } else {\n                triplep.get(2).unwrap() += i;\n         \
    \   }\n        }\n    }\n\n    for i in pair.iter().take(pair.len() - 2) {\n \
    \       if triplep\n            .iter()\n            .any(|&b| triplep\n     \
    \           .iter()\n                .any(|&c| b + c == 0)) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `triplep` in this scope\n  --> /tmp/tmpncowva6i.rs:26:16\n\
    \   |\n26 |             if triplep.size() == 0 || triplep.get(1).unwrap() + i\
    \ > triplep.get(2).unwrap() {\n   |                ^^^^^^^ help: a local variable\
    \ with a similar name exists: `tripple`\n\nerror[E0425]: cannot find value `triplep`\
    \ in this scope\n  --> /tmp/tmpncowva6i.rs:26:39\n   |\n26 |             if triplep.size()\
    \ == 0 || triplep.get(1).unwrap() + i > triplep.get(2).unwrap() {\n   |      \
    \                                 ^^^^^^^ help: a local variable with a similar\
    \ name exists: `tripple`\n\nerror[E0425]: cannot find value `triplep` in this\
    \ scope\n  --> /tmp/tmpncowva6i.rs:26:69\n   |\n26 |             if triplep.size()\
    \ == 0 || triplep.get(1).unwrap() + i > triplep.get(2).unwrap() {\n   |      \
    \                                                               ^^^^^^^ help:\
    \ a local variable with a similar name exists: `tripple`\n\nerror[E0425]: cannot\
    \ find value `triplep` in this scope\n  --> /tmp/tmpncowva6i.rs:27:17\n   |\n\
    27 |                 triplep.push(vec![i]);\n   |                 ^^^^^^^ help:\
    \ a local variable with a similar name exists: `tripple`\n\nerror[E0425]: cannot\
    \ find value `triplep` in this scope\n  --> /tmp/tmpncowva6i.rs:29:17\n   |\n\
    29 |                 triplep.get(2).unwrap() += i;\n   |                 ^^^^^^^\
    \ help: a local variable with a similar name exists: `tripple`\n\nerror[E0425]:\
    \ cannot find value `triplep` in this scope\n  --> /tmp/tmpncowva6i.rs:35:12\n\
    \   |\n35 |         if triplep\n   |            ^^^^^^^ help: a local variable\
    \ with a similar name exists: `tripple`\n\nerror[E0425]: cannot find value `triplep`\
    \ in this scope\n  --> /tmp/tmpncowva6i.rs:37:23\n   |\n37 |             .any(|&b|\
    \ triplep\n   |                       ^^^^^^^ help: a local variable with a similar\
    \ name exists: `tripple`\n\nerror[E0599]: no method named `size` found for struct\
    \ `Vec<_>` in the current scope\n  --> /tmp/tmpncowva6i.rs:19:21\n   |\n19 | \
    \            if pair.size() == 0 || pair.get(0).unwrap() + i > pair.get(1).unwrap()\
    \ {\n   |                    "
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l = l.iter().cloned();\n    l.sort();\n \
    \   let mut sum = 0;\n    let mut n = l.len();\n    while n > 3 {\n        if\
    \ sum == 0 && l.iter().cloned().sum::<isize>() == 0 {\n            return true;\n\
    \        }\n        if sum == 0 {\n            return false;\n        }\n    \
    \    if l.iter().cloned().sum::<isize>() != 0 {\n            sum += l.iter().cloned().next::<isize>().unwrap();\n\
    \        } else {\n            sum = l.iter().cloned().last().unwrap();\n    \
    \    }\n        n--;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpo8bl7zml.rs:31:12\n\
    \   |\n31 |         n--;\n   |            ^ expected expression\n\nerror[E0599]:\
    \ no method named `sort` found for struct `Cloned` in the current scope\n  -->\
    \ /tmp/tmpo8bl7zml.rs:16:7\n   |\n16 |     l.sort();\n   |       ^^^^ method not\
    \ found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named\
    \ `iter` found for struct `Cloned` in the current scope\n  --> /tmp/tmpo8bl7zml.rs:20:26\n\
    \   |\n20 |         if sum == 0 && l.iter().cloned().sum::<isize>() == 0 {\n \
    \  |                          ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `iter` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpo8bl7zml.rs:26:14\n   |\n26 |         if l.iter().cloned().sum::<isize>()\
    \ != 0 {\n   |              ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `iter` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpo8bl7zml.rs:27:22\n   |\n27 |             sum\
    \ += l.iter().cloned().next::<isize>().unwrap();\n   |                      ^^^^\
    \ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no\
    \ method named `iter` found for struct `Cloned` in the current scope\n  --> /tmp/tmpo8bl7zml.rs:29:21\n\
    \   |\n29 |             sum = l.iter().cloned().last().unwrap();\n   |       \
    \              ^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut total = 0;\n    for n in l {\n        total\
    \ += n;\n        if total >= 3 {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkcmlha3j.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut a = 0usize;\n    let mut b = 0usize;\n  \
    \  let mut c = 0usize;\n    for i in l.iter() {\n        a += i;\n        b +=\
    \ a;\n        c += b;\n    }\n\n    (a == 0) != (b == 0) != (c > 0)\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp2qp10cco.rs:24:14\n\
    \   |\n24 |     (a == 0) != (b == 0) != (c > 0)\n   |              ^^        \
    \  ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2qp10cco.rs:19:14\n   |\n\
    19 |         a += i;\n   |              ^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot add-assign `&isize` to `usize`\n  --> /tmp/tmp2qp10cco.rs:19:11\n\
    \   |\n19 |         a += i;\n   |           ^^ no implementation for `usize +=\
    \ &isize`\n   |\n   = help: the trait `AddAssign<&isize>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = vec![false, false, false];\n  \
    \  for triple in l {\n        for num in triple {\n            triples[num] =\
    \ true;\n        }\n    }\n    triples.iter().filter(|&b| b).count() == 3\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpubowj7o1.rs:17:20\n\
    \   |\n17 |         for num in triple {\n   |                    ^^^^^^ `isize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpubowj7o1.rs:21:32\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \                              ---- expected `bool` because of return type\n...\n\
    21 |     triples.iter().filter(|&b| b).count() == 3\n   |                    \
    \            ^ expected `bool`, found `&bool`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |     triples.iter().filter(|&b| *b).count() == 3\n   |\
    \                                +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    let mut sum = 0;\n    for v in l {\n        sum += v;\n    }\n    if sum\
    \ == 0 {\n        return true;\n    }\n\n    let mut min_sum = l[0];\n    for\
    \ v in l {\n        if v < min_sum {\n            return false;\n        }\n \
    \       min_sum += v;\n    }\n\n    // no triplets sum to zero\n    return true;\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpww6nrc_h.rs:27:23\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n20  |     for v in l {\n    |             \
    \ - `l` moved due to this implicit call to `.into_iter()`\n...\n27  |     let\
    \ mut min_sum = l[0];\n    |                       ^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n20  |     for v in &l {\n    | \
    \             +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l != l.iter().enumerate().filter_map(|(_, (_, sum))|\
    \ {\n        if sum == 0 {\n            false\n        } else {\n            true\n\
    \        }\n    }).any() || l.iter().any(|n| n == -2)\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2aflf6z0.rs:15:47\n   |\n\
    15 |     l != l.iter().enumerate().filter_map(|(_, (_, sum))| {\n   |        \
    \                                       ^^^^^^^^- expected due to this\n   | \
    \                                              |\n   |                       \
    \                        expected `isize`, found tuple\n   |\n   = note: expected\
    \ type `isize`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2aflf6z0.rs:17:13\n   |\n17 |             false\n   | \
    \            ^^^^^ expected enum `Option`, found `bool`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `bool`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n17 |             Some(false)\n   |             +++++     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2aflf6z0.rs:19:13\n   |\n19 |\
    \             true\n   |             ^^^^ expected enum `Option`, found `bool`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `bool`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |             Some(true)\n\
    \   |             +++++    +\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n    --> /tmp/tmp2aflf6z0.rs:21:8\n     |\n21   |\
    \     }).any() || l.iter().any(|n| n == -2)\n     |        ^^^- supplied 0 arguments\n\
    \     |        |\n     |        expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: can't compare `Vec<isize>` with `bool`\n\
    \  --> /tmp/tmp2aflf6z0.rs:15:7\n   |\n15 |     l != l.iter().enumerate().filter_map(|(_,\
    \ (_, sum))| {\n   |       ^^ no implementation for `Vec<isize> == bool`\n   |\n\
    \   = help: the trait `PartialEq<bool>` is not implemented for `Vec<isize>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't com"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(true, |state, x| {\n        state &\
    \ !x.checked_add((x).checked_add((x)).checked_add(1)).zero()\n    })\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpoow6x3x5.rs:16:48\n\
    \   |\n16 |         state & !x.checked_add((x).checked_add((x)).checked_add(1)).zero()\n\
    \   |                                                ^ ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n16 -         state & !x.checked_add((x).checked_add((x)).checked_add(1)).zero()\n\
    16 +         state & !x.checked_add((x).checked_add(x).checked_add(1)).zero()\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoow6x3x5.rs:16:48\n  \
    \ |\n16 |         state & !x.checked_add((x).checked_add((x)).checked_add(1)).zero()\n\
    \   |                                                ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |        \
    \ state & !x.checked_add((x).checked_add(*(x)).checked_add(1)).zero()\n   |  \
    \                                              +\n\nerror[E0599]: no method named\
    \ `checked_add` found for enum `Option` in the current scope\n  --> /tmp/tmpoow6x3x5.rs:16:53\n\
    \   |\n16 |         state & !x.checked_add((x).checked_add((x)).checked_add(1)).zero()\n\
    \   |                                                     ^^^^^^^^^^^ method not\
    \ found in `Option<isize>`\n\nerror[E0599]: no method named `zero` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpoow6x3x5.rs:16:69\n   |\n16 | \
    \        state & !x.checked_add((x).checked_add((x)).checked_add(1)).zero()\n\
    \   |                                                                     ^^^^\
    \ method not found in `Option<isize>`\n\nerror: aborting due to 3 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    let mut cur = &l[0];\n    let mut rest = &l[1..];\n\n    for i in 2..l.len()\
    \ {\n        // find out whether i can be added to the current sum\n        if\
    \ cur.saturating_add(i) == 0 {\n            // if yes, we can add it to the next\
    \ sum\n            cur = cur.add(rest);\n            // remove the processed element\
    \ from rest\n            *rest = rest.remove(i);\n            // if rest is empty,\
    \ we can conclude that cur can be added to the next sum\n            return cur.saturating_add(i)\
    \ == 0;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppi17a9_7.rs:23:31\n   |\n\
    23 |         if cur.saturating_add(i) == 0 {\n   |                           \
    \    ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     \
    \    if cur.saturating_add(i.try_into().unwrap()) == 0 {\n   |               \
    \                 ++++++++++++++++++++\n\nerror[E0599]: no method named `add`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmppi17a9_7.rs:25:23\n\
    \   |\n25 |             cur = cur.add(rest);\n   |                       ^^^ method\
    \ not found in `&isize`\n   |\n   = help: items from traits can only be used if\
    \ the trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n   |\n1  | use std::ops::Add;\n   |\n\nerror[E0599]:\
    \ no method named `remove` found for reference `&[isize]` in the current scope\n\
    \  --> /tmp/tmppi17a9_7.rs:27:26\n   |\n27 |             *rest = rest.remove(i);\n\
    \   |                          ^^^^^^ method not found in `&[isize]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppi17a9_7.rs:29:39\n   |\n29 |             return\
    \ cur.saturating_add(i) == 0;\n   |                                       ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |             return\
    \ cur.saturating_add(i.try_into().unwrap()) == 0;\n   |                      \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the size for values of\
    \ type `[isize]` cannot be known at compilation time\n  --> /tmp/tmppi17a9_7.rs:27:13\n\
    \   |\n27 |             *rest = rest.remove(i);\n   |             ^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[isize]`\n   = note: the left-hand-side of an assignment must\
    \ have a statically known size\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    let mut sum = 0;\n    for num in l {\n        sum += num;\n        if sum\
    \ < 0 {\n            return false;\n        }\n    }\n    sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo5sc802n.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() <= 3 {\n        return false;\n    }\n\
    \    l.sort();\n    for i in 0..2 {\n        if l[0] + l[1] + l[2] <= 0 {\n  \
    \          return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmphqimvzgq.rs:19:9\n   |\n19\
    \ |     for i in 0..2 {\n   |         ^ help: if this is intentional, prefix it\
    \ with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by\
    \ default\n\nerror[E0596]: cannot borrow `l` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmphqimvzgq.rs:18:5\n   |\n14 | fn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n   |                        - help: consider changing\
    \ this to be mutable: `mut l`\n...\n18 |     l.sort();\n   |     ^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false;\n    }\n\
    \    let mut total = 0;\n    let mut found = false;\n    for element in l.iter()\
    \ {\n        total += element;\n        if total == 0 {\n            found = true;\n\
    \            break;\n        }\n    }\n    found\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi824xgv3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut has_triple = false;\n    for e in l {\n \
    \       for e2 in l {\n            if e + e2 + e == 0 {\n                has_triple\
    \ = true;\n                break;\n            }\n        }\n        if !has_triple\
    \ {\n            return false;\n        }\n    }\n    has_triple\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpz3os0hma.rs:17:19\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut has_triple = false;\n16  |   \
    \  for e in l {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    17  |         for e2 in l {\n    |                   ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n16  |     for e in &l {\n    |    \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false;\n    }\n\
    \    let mut max = 0;\n    let mut sum = 0;\n    let mut has_triple = false;\n\
    \    for v in l {\n        sum += v;\n        max = *std::cmp::max(sum, max);\n\
    \        has_triple |= (max == v);\n    }\n    has_triple\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmphtrzzhhh.rs:24:23\n\
    \   |\n24 |         has_triple |= (max == v);\n   |                       ^  \
    \      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n24 -         has_triple |= (max == v);\n24 +      \
    \   has_triple |= max == v;\n   | \n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmphtrzzhhh.rs:23:15\n   |\n23 |         max = *std::cmp::max(sum,\
    \ max);\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    let mut cur = 0;\n    let mut prev = 0;\n    let mut sum = 0;\n\n    for\
    \ (i, e) in l.iter().enumerate() {\n        let d = e - prev;\n        if d ==\
    \ 0 {\n            sum += cur;\n        } else {\n            sum += cur;\n  \
    \          if sum < 0 {\n                return false;\n            }\n      \
    \      cur = e;\n            prev = e;\n        }\n    }\n\n    return true;\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcc7u1nae.rs:32:19\n   |\n\
    19 |     let mut cur = 0;\n   |                   - expected due to this value\n\
    ...\n32 |             cur = e;\n   |                   ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \     cur = *e;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcc7u1nae.rs:33:20\n   |\n20 |     let mut prev = 0;\n   |     \
    \               - expected due to this value\n...\n33 |             prev = e;\n\
    \   |                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n33 |             prev = *e;\n   |          \
    \          +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s: usize = 0;\n    let mut t: usize = 0;\n\
    \    let mut x: usize = 0;\n    for elem in l {\n        s += elem;\n        t\
    \ += 1;\n        if s == 0 {\n            x = t;\n        }\n    }\n\n    return\
    \ x == 3;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxek7xqov.rs:19:14\n   |\n\
    19 |         s += elem;\n   |              ^^^^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpxek7xqov.rs:19:11\n\
    \   |\n19 |         s += elem;\n   |           ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut last_k = 0;\n    let mut k2 = 1;\n    let mut found = false;\n\
    \    while k < l.len() {\n        if i == j {\n            j += k2;\n        \
    \    last_k = k2;\n            i += 1;\n        }\n        if i == k {\n     \
    \       j += 1;\n            k2 += 1;\n        }\n        if j == k {\n      \
    \      i += 1;\n            k2 += 1;\n        }\n        if j != i {\n       \
    \     k2 = 1;\n            found = false;\n        }\n        if k2 == 3 {\n \
    \           if l[k] == 0 {\n                found = true;\n            }\n   \
    \         break;\n        }\n        k += 1;\n    }\n    found\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprgcmmff8.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = i + 1;\n    let mut\
    \ k = i + 2;\n    while j < l.len() && k < l.len() && l[j] + l[k] == 0 {\n   \
    \     if i == k {\n            i += 1;\n        }\n        i += 1;\n        k\
    \ += 1;\n        j += 1;\n    }\n    if i == k.len() {\n        false\n    } else\
    \ {\n        true\n    }\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpfadyg5du.rs:26:15\n   |\n26 |     if i == k.len() {\n \
    \  |               ^^^ method not found in `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut counter = 0;\n    let mut sum = 0;\n\n  \
    \  for &i in l {\n        sum += i;\n        if sum == 0 {\n            counter\
    \ += 1;\n        }\n    }\n\n    sum == 0 && counter == 3 && true\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzqu2gqss.rs:18:9\n   |\n\
    18 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, item| acc && item == 0)\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp15hmehig.rs:15:50\n\
    \   |\n15 |     l.iter().fold(false, |acc, item| acc && item == 0)\n   |     \
    \                                             ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp6bxqkk0j.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6bxqkk0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |a, b| {\n        if b > 0 {\n\
    \            return true;\n        }\n        if a == 0 {\n            return\
    \ true;\n        }\n        false\n    })\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5h_xjs23.rs:16:16\n   |\n\
    16 |         if b > 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h_xjs23.rs:19:17\n\
    \   |\n19 |         if a == 0 {\n   |                 ^ expected `bool`, found\
    \ integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false;\n    }\n\
    \    let mut n = l.len();\n    let mut d = 0;\n    let mut sum = 0;\n    while\
    \ n > 0 {\n        n -= 1;\n        sum += l[n];\n        d += 1;\n    }\n   \
    \ if d == 3 {\n        sum == 0 && l.len() == 3\n    } else {\n        sum ==\
    \ 0 || (l.len() == 3 && l.iter().sum::<isize>() == 0)\n    }\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphoj0q09q.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l\n        .into_iter()\n        .enumerate()\n \
    \       .filter(|(idx, elem)| elem > 0 && idx % 3 != 0)\n        .count() == 3\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3su972oz.rs:18:38\n   |\n\
    18 |         .filter(|(idx, elem)| elem > 0 && idx % 3 != 0)\n   |           \
    \                           ^\n   |                                      |\n \
    \  |                                      expected `&isize`, found integer\n \
    \  |                                      help: consider borrowing here: `&0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(true, |b, t| b && (t % 3 == 0))\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2ujf7uzv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    triples_sum_to_zero_inner(&l)\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `triples_sum_to_zero_inner` in this\
    \ scope\n  --> /tmp/tmphi4_dhco.rs:15:5\n   |\n15 |     triples_sum_to_zero_inner(&l)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum_triples = 0;\n    let mut sum_triples_sum_to_zero\
    \ = true;\n    let mut i1 = l.len();\n\n    // if list has only one element, return\
    \ True\n    if i1 == 1 {\n        return true;\n    }\n\n    // if list has two\
    \ elements, return True\n    if i1 == 2 {\n        return l[0] + l[1] == 0;\n\
    \    }\n\n    // get the last element from the list and add it to the current\
    \ sum\n    let mut cur_sum = l[0];\n    for &i in &l[i1..] {\n        cur_sum\
    \ += i;\n        sum_triples += cur_sum;\n\n        // if current sum is zero\
    \ and last element is not zero, return False\n        if cur_sum == 0 && cur_sum\
    \ != 0 {\n            sum_triples_sum_to_zero = false;\n            break;\n \
    \       }\n    }\n\n    return sum_triples_sum_to_zero;\n}\n\nfn main() {\n  \
    \  let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprezhlwfz.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut has_three = false;\n\
    \    for &x in l {\n        sum += x;\n        if sum == 3 {\n            has_three\
    \ = true;\n            break;\n        }\n    }\n    has_three\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpny5vg4pu.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // initialize a hashmap\n    let mut m: HashMap<isize,\
    \ isize> = HashMap::new();\n    for n in l {\n        // if n does not yet exist\
    \ in the map, then add it.\n        // otherwise, increment the count of n by\
    \ 1\n        if m.contains_key(n) {\n            m.entry(n).and_modify(|x| x +=\
    \ 1);\n        } else {\n            m.insert(n, 1);\n        }\n    }\n\n   \
    \ // check all possible pairs of numbers in m\n    for k in m.keys() {\n     \
    \   for j in k.iter().chain(m.values()) {\n            if *j % 2 == 0 {\n    \
    \            return false;\n            }\n        }\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpnei7itjk.rs:16:16\n\
    \   |\n16 |     let mut m: HashMap<isize, isize> = HashMap::new();\n   |     \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpnei7itjk.rs:16:40\n\
    \   |\n16 |     let mut m: HashMap<isize, isize> = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut count = 0;\n    let mut first_non_zero =\
    \ vec![0; 3];\n    for &i in l {\n        if *i != 0 {\n            *i -= count;\n\
    \            count += 1;\n            if count == 3 {\n                return\
    \ first_non_zero == vec![1; 3];\n            }\n        } else {\n           \
    \ *i -= count;\n            count += 1;\n            first_non_zero[count] +=\
    \ 1;\n            if count == 3 {\n                return true;\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgwm07_72.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for (i, &v) in l.iter().enumerate()\
    \ {\n        let v = *v;\n        sum += v;\n        if sum == 0 { break; }\n\
    \        if i & 1 == 1 { return false; }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmph8civ_yc.rs:17:17\n\
    \   |\n17 |         let v = *v;\n   |                 ^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |res, i| {\n        res | i\
    \ % 3 != 0 || i % 6 != 0\n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: no implementation for `bool | isize`\n  --> /tmp/tmpw_wadlvc.rs:16:13\n\
    \   |\n16 |         res | i % 3 != 0 || i % 6 != 0\n   |             ^ no implementation\
    \ for `bool | isize`\n   |\n   = help: the trait `BitOr<isize>` is not implemented\
    \ for `bool`\n   = help: the following other types implement trait `BitOr<Rhs>`:\n\
    \             <&'a bool as BitOr<bool>>\n             <&bool as BitOr<&bool>>\n\
    \             <bool as BitOr<&bool>>\n             <bool as BitOr<Mask<T, LANES>>>\n\
    \             <bool as BitOr>\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false;\n    }\n\
    \    let mut sum = 0;\n    for a in l {\n        sum += a;\n    }\n    for (i,\
    \ &a) in l.iter().enumerate() {\n        sum += a;\n        if sum == 0 {\n  \
    \          return i != 0;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmppyat50wl.rs:22:20\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for a in l {\n    |             \
    \ - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |     for\
    \ (i, &a) in l.iter().enumerate() {\n    |                    ^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\n    = note: borrow occurs due to deref coercion to\
    \ `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for a in &l {\n    | \
    \             +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l\n        .iter()\n        .cloned()\n        .rev()\n\
    \        .enumerate()\n        .all(|(i, j)| {\n            if *i == 0 {\n   \
    \             if *j == 0 {\n                    *i == 1\n                } else\
    \ {\n                    *i == *j == 1\n                }\n            } else\
    \ {\n                *i == *j == 1\n            }\n        })\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp2jit88rw.rs:25:24\n\
    \   |\n25 |                     *i == *j == 1\n   |                        ^^\
    \    ^^\n   |\nhelp: split the comparison into two\n   |\n25 |               \
    \      *i == *j && *j == 1\n   |                              +++++\n\nerror:\
    \ comparison operators cannot be chained\n  --> /tmp/tmp2jit88rw.rs:28:20\n  \
    \ |\n28 |                 *i == *j == 1\n   |                    ^^    ^^\n  \
    \ |\nhelp: split the comparison into two\n   |\n28 |                 *i == *j\
    \ && *j == 1\n   |                          +++++\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmp2jit88rw.rs:21:16\n   |\n21 |        \
    \     if *i == 0 {\n   |                ^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp2jit88rw.rs:22:20\n   |\n22 |               \
    \  if *j == 0 {\n   |                    ^^\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmp2jit88rw.rs:23:21\n   |\n23 |               \
    \      *i == 1\n   |                     ^^\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmp2jit88rw.rs:25:21\n   |\n25 |               \
    \      *i == *j == 1\n   |                     ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp2jit88rw.rs:25:27\n   |\n25 |        \
    \             *i == *j == 1\n   |                           ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2jit88rw.rs:25:33\n   |\n25 |              \
    \       *i == *j == 1\n   |                                 ^ expected `bool`,\
    \ found integer\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp2jit88rw.rs:28:17\n\
    \   |\n28 |                 *i == *j == 1\n   |                 ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp2jit88rw.rs:28:23\n   |\n\
    28 |                 *i == *j == 1\n   |                       ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2jit88rw.rs:28:29\n   |\n28 |              \
    \   *i == *j == 1\n   |                             ^ expected `bool`, found integer\n\
    \nerror: aborting due to 11 previous errors\n\nSome errors have detailed explanatio"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum ==\
    \ l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n  \
    \  assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcar1pro7.rs:23:12\n   |\n\
    23 |     sum == l.len() - 3\n   |            ^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |     sum == (l.len() - 3).try_into().unwrap()\n\
    \   |            +           +++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut first_sum = 0;\n    for &x in l {\n     \
    \   if x == 0 {\n            continue;\n        }\n        if first_sum != x {\n\
    \            return true;\n        }\n        first_sum += x;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitc5ya3m.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return true\n    }\n  \
    \  let mut sum = 0;\n    let mut max = 0;\n    for i in l {\n        sum += i;\n\
    \        if sum > 0 {\n            max = i;\n        }\n    }\n    sum > 0 &&\
    \ sum == max\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n   \
    \ assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpld69kuzn.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n\n\
    \    for i in l {\n        sum += i;\n        found |= (sum == 0);\n    }\n\n\
    \    found\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp077d81g3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut nums = l.iter().cloned().collect::<Vec<_>>();\n\
    \    nums.sort_unstable();\n    let mut i = 0;\n    let mut k = 0;\n    while\
    \ i < nums.len() && nums[i] != 0 {\n        i += 1;\n        k += 1;\n       \
    \ if k == 3 {\n            return false;\n        }\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxzngdq8o.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l\n        .iter()\n        .enumerate()\n      \
    \  .all(|(idx, (a, b, c))| {\n            a == 0 && b == 0 && c == 0 || a + b\
    \ + c == 0\n        })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbfuz23ux.rs:18:21\n   |\n\
    18 |         .all(|(idx, (a, b, c))| {\n   |                     ^^^^^^^^^- expected\
    \ due to this\n   |                     |\n   |                     expected `isize`,\
    \ found tuple\n   |\n   = note: expected type `isize`\n             found tuple\
    \ `(_, _, _)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut count = 0;\n    let mut sum = 0;\n    for\
    \ i in l {\n        if i == 0 {\n            count += 1;\n            sum += i;\n\
    \        }\n        else {\n            if count == 3 {\n                if sum\
    \ == i {\n                    return true;\n                }\n            }\n\
    \            count = 0;\n            sum += i;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnbq9lm6x.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = vec![];\n    for i in l.iter()\
    \ {\n        if triples.contains(&[i.clone(), 0, i.clone()]) {\n            return\
    \ true;\n        }\n        triples.push((i, 0, i));\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyc_90w8g.rs:20:22\n   |\n\
    20 |         triples.push((i, 0, i));\n   |                      ^^^^^^^^^ expected\
    \ array `[isize; 3]`, found tuple\n   |\n   = note: expected array `[isize; 3]`\n\
    \              found tuple `(&isize, {integer}, &isize)`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = 0;\n    for &x in l {\n       \
    \ triples += x;\n        if triples == 3 {\n            return true;\n       \
    \ }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpenactolo.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    triples_sum_to_zero_unordered(&l).is_err()\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `triples_sum_to_zero_unordered` in this\
    \ scope\n  --> /tmp/tmpb7rs21x7.rs:15:5\n   |\n15 |     triples_sum_to_zero_unordered(&l).is_err()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, el| {\n        acc.or_else(el\
    \ < 0 || el >= l.len() || !l[el].is_some())\n    })\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `or_else` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmp8jj_3avu.rs:16:13\n   |\n16 |         acc.or_else(el <\
    \ 0 || el >= l.len() || !l[el].is_some())\n   |             ^^^^^^^ method not\
    \ found in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8jj_3avu.rs:16:26\n\
    \   |\n16 |         acc.or_else(el < 0 || el >= l.len() || !l[el].is_some())\n\
    \   |                          ^\n   |                          |\n   |      \
    \                    expected `&isize`, found integer\n   |                  \
    \        help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8jj_3avu.rs:16:37\n   |\n16 |         acc.or_else(el < 0 || el\
    \ >= l.len() || !l[el].is_some())\n   |                                     ^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmp8jj_3avu.rs:16:49\n   |\n16 |        \
    \ acc.or_else(el < 0 || el >= l.len() || !l[el].is_some())\n   |             \
    \                                    ^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triple_sum = 0;\n    for i in l {\n     \
    \   triple_sum += i;\n        if triple_sum < 3 {\n            continue;\n   \
    \     }\n        for j in l {\n            if i != j {\n                triple_sum\
    \ -= j;\n                if triple_sum == 0 {\n                    return true;\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpk3xkni5w.rs:21:18\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut triple_sum = 0;\n16  |     for\
    \ i in l {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |         for j in l {\n    |                  ^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n    | \
    \             +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().enumerate().any(|(e, ix)| l.iter()\n   \
    \     .skip(ix)\n        .all(|&i| i as isize == 0 || i % 3 == 0))\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps64oh4hh.rs:16:15\n   |\n\
    16 |         .skip(ix)\n   |               ^^ expected `usize`, found `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n        if sum == 3 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3g2qbp0a.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l\n        .iter()\n        .zip(l.iter().skip(1))\n\
    \        .all(|(a, b)| a == 0 || a + b == 0)\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp4tk9649j.rs:18:25\n\
    \   |\n18 |         .all(|(a, b)| a == 0 || a + b == 0)\n   |                \
    \         ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the\
    \ trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    let mut sum = 0;\n    let mut triple = true;\n\n    for i in l.iter() {\n\
    \        sum += i;\n        if sum == 0 {\n            triple = false;\n     \
    \       break;\n        }\n    }\n\n    triple\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2bw1o4on.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().enumerate().filter(|(_, x, _, _)| x == 0).count()\
    \ == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwdwidf4v.rs:15:34\n   |\n\
    15 |     l.iter().enumerate().filter(|(_, x, _, _)| x == 0).count() == 3\n   |\
    \                                  ^^^^^^^^^^^-\n   |                        \
    \          |          |\n   |                                  |          expected\
    \ due to this\n   |                                  expected a tuple with 2 elements,\
    \ found one with 4 elements\n   |\n   = note: expected tuple `(usize, &isize)`\n\
    \              found tuple `(_, _, _, _)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut n = l.len() - 1;\n    while n > 0 {\n   \
    \     if l[n - 1] == l[n - 2] + l[n - 3] {\n            n = 0;\n        } else\
    \ {\n            n -= 1;\n        }\n    }\n    l[n..].is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpiw97g905.rs:17:37\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = HashMap::new();\n    let mut triples\
    \ = HashMap::new();\n\n    let mut count = 0;\n    let mut sum = 0;\n    for e\
    \ in l {\n        sum += e;\n        let pair = if sum == 0 {\n            (Pair::Zero,\
    \ 0)\n        } else {\n            let key = if sum == 1 {\n                (Pair::One,\
    \ 1)\n            } else {\n                (Pair::Two, (sum - 1))\n         \
    \   };\n\n            pairs.entry(key).or_insert(Pair::Zero)\n        };\n\n \
    \       if pairs.contains_key(pair) {\n            count += 1;\n            triples.entry(pair).or_insert(Pair::Zero)\n\
    \        }\n    }\n\n    count >= 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Pair`\n  --> /tmp/tmpoon3npd1.rs:23:14\n\
    \   |\n23 |             (Pair::Zero, 0)\n   |              ^^^^ use of undeclared\
    \ type `Pair`\n\nerror[E0433]: failed to resolve: use of undeclared type `Pair`\n\
    \  --> /tmp/tmpoon3npd1.rs:26:18\n   |\n26 |                 (Pair::One, 1)\n\
    \   |                  ^^^^ use of undeclared type `Pair`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Pair`\n  --> /tmp/tmpoon3npd1.rs:28:18\n\
    \   |\n28 |                 (Pair::Two, (sum - 1))\n   |                  ^^^^\
    \ use of undeclared type `Pair`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Pair`\n  --> /tmp/tmpoon3npd1.rs:31:40\n   |\n31 |             pairs.entry(key).or_insert(Pair::Zero)\n\
    \   |                                        ^^^^ use of undeclared type `Pair`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Pair`\n  --> /tmp/tmpoon3npd1.rs:36:43\n\
    \   |\n36 |             triples.entry(pair).or_insert(Pair::Zero)\n   |      \
    \                                     ^^^^ use of undeclared type `Pair`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpoon3npd1.rs:15:21\n\
    \   |\n15 |     let mut pairs = HashMap::new();\n   |                     ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpoon3npd1.rs:16:23\n   |\n16\
    \ |     let mut triples = HashMap::new();\n   |                       ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror: aborting due to 7 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s: isize = 0;\n    for i in l {\n       \
    \ if s > 0 {\n            let tmp = s;\n            s = i;\n            if tmp\
    \ == 0 {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbm8hxndy.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut first_triple = vec![0, 0, 0];\n    let mut\
    \ second_triple = vec![0, 0, 0];\n    let mut third_triple = vec![0, 0, 0];\n\
    \    for i in l.iter() {\n        match first_triple.get(0) {\n            None\
    \ => first_triple.push(i),\n            Some(first_triple[0]) => {\n         \
    \       if i as isize - first_triple[0] < 0 {\n                    first_triple.push(i);\n\
    \                }\n            },\n            Some(first_triple[1]) => {\n \
    \               if i as isize - first_triple[1] > 0 {\n                    first_triple.push(i);\n\
    \                }\n            },\n            Some(first_triple[2]) => {\n \
    \               if i as isize - first_triple[2] > 0 {\n                    first_triple.push(i);\n\
    \                }\n            },\n        }\n        match second_triple.get(0)\
    \ {\n            None => second_triple.push(i),\n            Some(second_triple[0])\
    \ => {\n                if i as isize - second_triple[0] < 0 {\n             \
    \       second_triple.push(i);\n                }\n            },\n          \
    \  Some(second_triple[1]) => {\n                if i as isize - second_triple[1]\
    \ > 0 {\n                    second_triple.push(i);\n                }\n     \
    \       },\n            Some(second_triple[2]) => {\n                if i as isize\
    \ - second_triple[2] > 0 {\n                    second_triple.push(i);\n     \
    \           }\n            },\n        }\n        match third_triple.get(0) {\n\
    \            None => third_triple.push(i),\n            Some(third_triple[0])\
    \ => {\n                if i as isize - third_triple[0] < 0 {\n              \
    \      third_triple.push(i);\n                }\n            },\n            Some(third_triple[1])\
    \ => {\n                if i as isize - third_triple[1] > 0 {\n              \
    \      third_triple.push(i);\n                }\n            },\n            Some(third_triple[2])\
    \ => {\n                if i as isize - third_triple[2] > 0 {\n              \
    \      third_triple.push(i);\n                }\n            },\n        }\n \
    \   }\n    if first_triple.iter().filter_map(|x| if x != 0 { Some(x) } else {\
    \ None }).count() == 3 {\n        if second_triple.iter().filter_map(|x| if x\
    \ != 0 { Some(x) } else { None }).count() == 3 {\n            if third_triple.iter().filter_map(|x|\
    \ if x != 0 { Some(x) } else { None }).count() == 3 {\n                true\n\
    \            } else {\n                false\n            }\n        } else {\n\
    \            false\n        }\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `[`\n  --> /tmp/tmp3z_ag3_e.rs:21:30\n\
    \   |\n21 |             Some(first_triple[0]) => {\n   |                     \
    \         ^\n   |                              |\n   |                       \
    \       expected one of `)`, `,`, `@`, or `|`\n   |                          \
    \    help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found\
    \ `[`\n  --> /tmp/tmp3z_ag3_e.rs:26:30\n   |\n26 |             Some(first_triple[1])\
    \ => {\n   |                              ^\n   |                            \
    \  |\n   |                              expected one of `)`, `,`, `@`, or `|`\n\
    \   |                              help: missing `,`\n\nerror: expected one of\
    \ `)`, `,`, `@`, or `|`, found `[`\n  --> /tmp/tmp3z_ag3_e.rs:31:30\n   |\n31\
    \ |             Some(first_triple[2]) => {\n   |                             \
    \ ^\n   |                              |\n   |                              expected\
    \ one of `)`, `,`, `@`, or `|`\n   |                              help: missing\
    \ `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `[`\n  --> /tmp/tmp3z_ag3_e.rs:39:31\n\
    \   |\n39 |             Some(second_triple[0]) => {\n   |                    \
    \           ^\n   |                               |\n   |                    \
    \           expected one of `)`, `,`, `@`, or `|`\n   |                      \
    \         help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found\
    \ `[`\n  --> /tmp/tmp3z_ag3_e.rs:44:31\n   |\n44 |             Some(second_triple[1])\
    \ => {\n   |                               ^\n   |                           \
    \    |\n   |                               expected one of `)`, `,`, `@`, or `|`\n\
    \   |                               help: missing `,`\n\nerror: expected one of\
    \ `)`, `,`, `@`, or `|`, found `[`\n  --> /tmp/tmp3z_ag3_e.rs:49:31\n   |\n49\
    \ |             Some(second_triple[2]) => {\n   |                            \
    \   ^\n   |                               |\n   |                            \
    \   expected one of `)`, `,`, `@`, or `|`\n   |                              \
    \ help: missing `,`\n\nerror: expected one of `)`, `"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = 0; // triple count\n    for x in\
    \ l.iter().take(l.len() - 1) {\n        // ignore all but the highest sum\n  \
    \      triples += x;\n        if triples == 3 {\n            return true;\n  \
    \      }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplb_9652w.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut first_triple = false;\n    let mut second_triple\
    \ = false;\n\n    for triple in l.iter().windows(3) {\n        let mut total =\
    \ triple[0] + triple[1] + triple[2];\n        if total > 0 {\n            if first_triple\
    \ {\n                first_triple = false;\n            } else {\n           \
    \     second_triple = true;\n            }\n        } else {\n            if second_triple\
    \ {\n                second_triple = false;\n            } else {\n          \
    \      first_triple = true;\n            }\n        }\n    }\n\n    first_triple\
    \ || second_triple\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `windows` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpvirn68et.rs:18:28\n   |\n18 |     for triple\
    \ in l.iter().windows(3) {\n   |                            ^^^^^^^ method not\
    \ found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |sum, num| sum && triples_sum_to_zero(vec![num])\
    \ && sum)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmv57cpgn.rs:15:69\n   |\n\
    15 |     l.iter().fold(false, |sum, num| sum && triples_sum_to_zero(vec![num])\
    \ && sum)\n   |                                                              \
    \       ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |     l.iter().fold(false, |sum, num| sum && triples_sum_to_zero(vec![*num])\
    \ && sum)\n   |                                                              \
    \       +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut first = vec![0; 3];\n    let mut second =\
    \ vec![0; 3];\n    let mut third = vec![0; 3];\n    let mut total = 0;\n    \n\
    \    for i in l.iter().enumerate() {\n        let (_, i, _) = i;\n        first[i]\
    \ += 1;\n        second[i] += 1;\n        third[i] += 1;\n        total += 1;\n\
    \    }\n\n    for i in 0..3 {\n        if first[i] != 0 || second[i] != 0 || third[i]\
    \ != 0 {\n            return false;\n        }\n    }\n\n    total == 3;\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpih6ch8rc.rs:21:13\n   |\n\
    21 |         let (_, i, _) = i;\n   |             ^^^^^^^^^   - this expression\
    \ has type `(usize, &isize)`\n   |             |\n   |             expected a\
    \ tuple with 2 elements, found one with 3 elements\n   |\n   = note: expected\
    \ tuple `(usize, &isize)`\n              found tuple `(_, _, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpih6ch8rc.rs:14:42\n   |\n14 | fn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n   |    -------------------                   ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n...\n34 |     total == 3;\n   |            \
    \   - help: remove this semicolon\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l != l.iter().filter(|&x| x == x).cloned().collect()\n\
    \        .iter().any(|&x| (x.to_f() * x.to_f()) == 0.0 as f64)\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp91dqbxqx.rs:15:48\n\
    \   |\n15 |     l != l.iter().filter(|&x| x == x).cloned().collect()\n   |   \
    \                                             ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n15 |     l != l.iter().filter(|&x| x == x).cloned().collect::<B>()\n\
    \   |                                                       +++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = l.iter().fold(0, |mut sum, el| sum +=\
    \ el);\n    for i in l {\n        for j in l {\n            if i + j == s {\n\
    \                s = s - i + j;\n            }\n        }\n    }\n    return s\
    \ == 0;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq7_rend6.rs:15:48\n   |\n\
    15 |     let mut s = l.iter().fold(0, |mut sum, el| sum += el);\n   |        \
    \                                        ^^^^^^^^^ expected `isize`, found `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false;\n    }\n\
    \    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum ==\
    \ 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp3xo1245.rs:19:9\n   |\n\
    19 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l != l.windows(3).any(|x| x.iter().sum::<isize>()\
    \ == 0)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<isize>` with `bool`\n  --> /tmp/tmp0gnfccjc.rs:15:7\n\
    \   |\n15 |     l != l.windows(3).any(|x| x.iter().sum::<isize>() == 0)\n   |\
    \       ^^ no implementation for `Vec<isize> == bool`\n   |\n   = help: the trait\
    \ `PartialEq<bool>` is not implemented for `Vec<isize>`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U,\
    \ A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T,\
    \ A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut [U]>>\n  \
    \           <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    match l.iter().cloned() {\n        List::new(_) =>\
    \ false,\n        List::new(vec) => vec.iter().any(|v| triples_sum_to_zero(v)),\n\
    \        l => true,\n    }\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `List`\n  --> /tmp/tmp1a0u635p.rs:16:9\n\
    \   |\n16 |         List::new(_) => false,\n   |         ^^^^ use of undeclared\
    \ type `List`\n\nerror[E0433]: failed to resolve: use of undeclared type `List`\n\
    \  --> /tmp/tmp1a0u635p.rs:17:9\n   |\n17 |         List::new(vec) => vec.iter().any(|v|\
    \ triples_sum_to_zero(v)),\n   |         ^^^^ use of undeclared type `List`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l2: Vec<isize> = l;\n    let mut triple_count\
    \ = 0;\n    let mut sum = 0;\n\n    while l2.len() > 3 {\n        triple_count\
    \ += 1;\n\n        for i in l2.iter().rev() {\n            sum += i;\n       \
    \     if sum > 0 {\n                break;\n            }\n        }\n\n     \
    \   l2.pop();\n    }\n\n    triple_count > 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpixxe04w5.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut n1 = 0;\n    let mut n2 = 0;\n    let mut\
    \ n3 = 0;\n    for &i in l {\n        if i != 0 {\n            n1 += i;\n    \
    \    }\n        if i != 0 {\n            n2 += i;\n        }\n        if i !=\
    \ 0 {\n            n3 += i;\n        }\n    }\n    n1 < 3 && n2 < 3 && n3 < 3\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8bx2jn9e.rs:18:9\n   |\n\
    18 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |b, x| b || x == -x || x ==\
    \ 0 || x % 3 == 0)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpw1n41tfg.rs:15:40\n\
    \   |\n15 |     l.iter().fold(false, |b, x| b || x == -x || x == 0 || x % 3 ==\
    \ 0)\n   |                                        ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpw1n41tfg.rs:15:51\n   |\n15 |     l.iter().fold(false, |b, x| b\
    \ || x == -x || x == 0 || x % 3 == 0)\n   |                                  \
    \                 ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = vec![];\n    for triple in l {\n\
    \        if triples.len() > 0 && triples.last().unwrap().iter().sum::<isize>()\
    \ == triple {\n            return false;\n        }\n        triples.push(triple);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpxhgyoaxb.rs:17:41\n\
    \   |\n15 |     let mut triples = vec![];\n   |         ----------- consider giving\
    \ `triples` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\
    16 |     for triple in l {\n17 |         if triples.len() > 0 && triples.last().unwrap().iter().sum::<isize>()\
    \ == triple {\n   |                                         ^^^^ cannot infer\
    \ type for type parameter `T`\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triplets = Vec::new();\n    for i in l {\n\
    \        for j in l {\n            for k in l {\n                triplets.push((i,\
    \ j, k));\n            }\n        }\n    }\n    triplets.is_empty() || triplets.len()\
    \ == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpt9u6nm4g.rs:17:18\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut triplets = Vec::new();\n16  |\
    \     for i in l {\n    |              - `l` moved due to this implicit call to\
    \ `.into_iter()`\n17  |         for j in l {\n    |                  ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n  --> /tmp/tmpt9u6nm4g.rs:18:22\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \            - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17 |         for j in l {\n   |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n18 |             for k in\
    \ l {\n   |                      ^ value used here after move\n   |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n   |\n17 |         for j in &l {\n   |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    for &x in l {\n        if sum == x {\n            return true;\n\
    \        }\n        sum -= x;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgx8ipiya.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgx8ipiya.rs:19:9\n   |\n19 |     for &x in l {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut count = 0;\n    let\
    \ mut seen = HashSet::new();\n\n    for &e in l {\n        if !seen.contains(&e)\
    \ {\n            sum += e;\n            count += 1;\n            seen.insert(e);\n\
    \        } else {\n            return count == 3;\n        }\n    }\n\n    return\
    \ count == 3;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n  \
    \  assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp3dza0t21.rs:17:20\n   |\n17 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3dza0t21.rs:19:9\n   |\n19 |     for &e in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `e`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    seen.insert(0);\n    seen.insert(1);\n    seen.insert(-1);\n\n    for x in\
    \ l {\n        if seen.contains(x - 1) {\n            seen.insert(x);\n      \
    \      return true;\n        } else {\n            seen.remove(x);\n        }\n\
    \    }\n\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpu_i7kw1y.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpu_i7kw1y.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    let mut triples\
    \ = l.iter().enumerate();\n    for i in triples {\n        let (first, second,\
    \ third) = i;\n        if seen.add((first + second + third)) {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmptmyd88le.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nwarning:\
    \ unnecessary parentheses around method argument\n  --> /tmp/tmptmyd88le.rs:19:21\n\
    \   |\n19 |         if seen.add((first + second + third)) {\n   |            \
    \         ^                      ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n19 -         if seen.add((first\
    \ + second + third)) {\n19 +         if seen.add(first + second + third) {\n \
    \  | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmptmyd88le.rs:18:13\n   |\n\
    18 |         let (first, second, third) = i;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\
    \   - this expression has type `(usize, &isize)`\n   |             |\n   |   \
    \          expected a tuple with 2 elements, found one with 3 elements\n   |\n\
    \   = note: expected tuple `(usize, &isize)`\n              found tuple `(_, _,\
    \ _)`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.rev().iter().fold(true, |a, i| {\n        if *a\
    \ != *i + 1 {\n            *a = *i + 1\n            *a = true\n        }\n   \
    \     a\n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpfmun_4du.rs:15:7\n\
    \    |\n15  |       l.rev().iter().fold(true, |a, i| {\n    |         ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpfmun_4du.rs:18:16\n   |\n17 |               *a = *i + 1\n   | \
    \ __________________-\n18 | |             *a = true\n   | |              - ^\n\
    \   | |______________|\n   |                cannot assign to this expression\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0070, E0599.\nFor more information about an error, try `rustc --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    let mut seen = vec![false; l.len()];\n    let mut is_triple = true;\n   \
    \ for i in 0..l.len() {\n        if seen[i] {\n            continue;\n       \
    \ }\n\n        for j in 0..l.len() {\n            if seen[j] {\n             \
    \   continue;\n            }\n\n            if l[i] + l[j] == 0 {\n          \
    \      seen[j] = true;\n                is_triple = false;\n            }\n  \
    \      }\n    }\n\n    is_triple\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3cqp439g.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut first = l[0];\n    let mut last = l[l..].iter().take_while(|&x|\
    \ {\n        x.is_positive() || x.is_even()\n    }).sum();\n    let mut count\
    \ = 0;\n    loop {\n        count += 1;\n        if last == 0 {\n            if\
    \ first == 0 {\n                return count == 3;\n            }\n          \
    \  break;\n        }\n        first = l[first];\n        last = l[last];\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<Vec<isize>>`\n\
    \  --> /tmp/tmpea69w5iu.rs:16:20\n   |\n16 |     let mut last = l[l..].iter().take_while(|&x|\
    \ {\n   |                    ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `RangeFrom<Vec<isize>>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n\
    \             <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeFrom<Vec<isize>>>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpea69w5iu.rs:28:17\n\
    \   |\n28 |         first = l[first];\n   |                 ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l2 = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l2.sort();\n    if l2.len() != 3 {\n        return false;\n    }\n\n    for\
    \ i in l2.iter() {\n        if *i == *l2.last() + 1 {\n            std::mem::swap(&mut\
    \ l[0], &mut l[1]);\n            l[0] += *l[1];\n            l[0] -= *l[2];\n\
    \            l[1] -= *l[2];\n            l[1] -= *l[0];\n            l[2] = 0;\n\
    \        }\n    }\n\n    l[0] -= *l[1];\n    l[1] -= *l[2];\n    l[2] = 0;\n\n\
    \    l[0] == 0 || l[1] == 0 || l[2] == 0\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmptzo9iqbg.rs:22:18\n\
    \   |\n22 |         if *i == *l2.last() + 1 {\n   |                  ^^^^^^^^^^\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptzo9iqbg.rs:24:21\n\
    \   |\n24 |             l[0] += *l[1];\n   |                     ^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmptzo9iqbg.rs:25:21\n   |\n\
    25 |             l[0] -= *l[2];\n   |                     ^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmptzo9iqbg.rs:26:21\n   |\n\
    26 |             l[1] -= *l[2];\n   |                     ^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmptzo9iqbg.rs:27:21\n   |\n\
    27 |             l[1] -= *l[0];\n   |                     ^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmptzo9iqbg.rs:32:13\n   |\n\
    32 |     l[0] -= *l[1];\n   |             ^^^^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmptzo9iqbg.rs:33:13\n   |\n33 |     l[1]\
    \ -= *l[2];\n   |             ^^^^^\n\nerror: aborting due to 7 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut c = 0;\n    let mut max = 0;\n    for el\
    \ in l {\n        c += el;\n        if c > max {\n            max = c;\n     \
    \   }\n    }\n    return l\n        .iter()\n        .any(|&el| el > 0 && el ==\
    \ max)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpbtzk8asa.rs:23:12\n\
    \    |\n14  |   fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |       \
    \                   - move occurs because `l` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n17  |       for el in l {\n    |      \
    \           - `l` moved due to this implicit call to `.into_iter()`\n...\n23 \
    \ |       return l\n    |  ____________^\n24  | |         .iter()\n    | |_______________^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l`\n    = note: borrow occurs due to deref\
    \ coercion to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n17  |     for el in &l {\n\
    \    |               +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = vec![];\n    for i in l {\n        if\
    \ s.iter().any(|&x| x == i) {\n            s.clear();\n            return false;\n\
    \        }\n        s.push(i);\n    }\n    s.iter().all().unwrap_or(false)\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpkzjinlab.rs:23:14\n     |\n23   |     s.iter().all().unwrap_or(false)\n\
    \     |              ^^^- supplied 0 arguments\n     |              |\n     |\
    \              expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `unwrap_or` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmpkzjinlab.rs:23:20\n   |\n23 |     s.iter().all().unwrap_or(false)\n\
    \   |                    ^^^^^^^^^ method not found in `bool`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut counter = 0;\n    let mut prev_sum = 0;\n\
    \    for x in l {\n        if x == prev_sum + 1 {\n            counter += 1;\n\
    \        } else {\n            counter = 0;\n        }\n        prev_sum += x;\n\
    \        if counter == 3 {\n            return true;\n        }\n    }\n    counter\
    \ == 0;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5_i5f139.rs:14:42\n   |\n\
    14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |    -------------------\
    \                   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n28 |     counter\
    \ == 0;\n   |                 - help: remove this semicolon\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut s = 0;\n    let mut t = l.len();\n    while i < t && j < t\
    \ && k < t {\n        s = i + j + k;\n        t -= 1;\n        if s == 0 {\n \
    \           return false;\n        }\n        i += 1;\n        j += 1;\n     \
    \   k += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6msupwdh.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triple_sum = 0;\n    let mut triples_sum_to_zero\
    \ = false;\n    for i in l.iter() {\n        if triple_sum == 0 {\n          \
    \  triple_sum += i;\n        }\n        if triple_sum == i {\n            triples_sum_to_zero\
    \ = true;\n        }\n        if triple_sum != i {\n            triple_sum -=\
    \ i;\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgzxgxit1.rs:21:26\n   |\n\
    21 |         if triple_sum == i {\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |  \
    \       if triple_sum == *i {\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgzxgxit1.rs:24:26\n   |\n24 |         if triple_sum\
    \ != i {\n   |                          ^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n24 |         if triple_sum\
    \ != *i {\n   |                          +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n\n    for &x in l {\n        if x != i && x != j && x != k {\n       \
    \     i += 1;\n            j += 1;\n            k += 1;\n        }\n\n       \
    \ if i == 3 || j == 3 || k == 3 {\n            return true;\n        }\n    }\n\
    \n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4kmt81jq.rs:19:9\n   |\n\
    19 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in l {\n        let mut found = false;\n  \
    \      for j in l {\n            for k in l {\n                if i != j && i\
    \ != k && j != k {\n                    if i + j + k == 0 {\n                \
    \        found = true;\n                        break;\n                    }\n\
    \                }\n            }\n        }\n        if found {\n           \
    \ break;\n        }\n    }\n    found == true\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `found` in this scope\n  --> /tmp/tmpwlxa8x_f.rs:31:5\n\
    \   |\n31 |     found == true\n   |     ^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut counters = vec![0, 0, 0, 0];\n    for i in\
    \ l {\n        counters[i as usize]++;\n    }\n\n    if counters[0] == 3 && counters[1]\
    \ == 3 && counters[2] == 3 {\n        return true;\n    }\n    else {\n      \
    \  return false;\n    }\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp0vx133b_.rs:17:29\n\
    \   |\n17 |         counters[i as usize]++;\n   |                            \
    \ ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |\
    \         { let tmp = counters[i as usize]; counters[i as usize] += 1; tmp };\n\
    \   |         +++++++++++                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    17 -         counters[i as usize]++;\n17 +         counters[i as usize] += 1;\n\
    \   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut a = l;\n    for i in 0..3 {\n        if a.iter().any(|&x|\
    \ x == i) {\n            a = a.iter().cloned().collect();\n            continue;\n\
    \        }\n        return false;\n    }\n    if a.iter().any(|&x| x == 0) {\n\
    \        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptjnz2qcx.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(true, |b, e| b && b.is_zero() && b\
    \ == e)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmplyyn3o0t.rs:15:39\n   |\n15 |     l.iter().fold(true, |b,\
    \ e| b && b.is_zero() && b == e)\n   |                                       ^^^^^^^\
    \ method not found in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplyyn3o0t.rs:15:57\n\
    \   |\n15 |     l.iter().fold(true, |b, e| b && b.is_zero() && b == e)\n   | \
    \                                                        ^ expected `bool`, found\
    \ `&isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    use std::cmp::Ordering;\n    l.iter().fold(false,\
    \ (i, &mut i1) => if i % 3 == 0 && i != i1 {\n        *i1 += *i;\n        *i1\
    \ = (*i1 < 0) - (*i1 >= 0)\n    } else { true })\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmpuhc1o8l4.rs:16:39\n   |\n16 |     l.iter().fold(false, (i, &mut\
    \ i1) => if i % 3 == 0 && i != i1 {\n   |                                    \
    \   ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    triples_sum_to_zero_impl(l, 0, None, None)\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `triples_sum_to_zero_impl` in this scope\n\
    \  --> /tmp/tmpllahorg4.rs:15:5\n   |\n15 |     triples_sum_to_zero_impl(l, 0,\
    \ None, None)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().map(|&i| i as isize)\n        .zip(l.iter().skip(1))\n\
    \        .filter(|(_, &j)| j == 0)\n        .count() == 3\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp86uewerx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut n = 0;\n    let mut m = l.len();\n\n    while i < m {\n  \
    \      if j == i {\n            i += 1;\n            continue;\n        }\n\n\
    \        if k >= i {\n            return false;\n        }\n\n        while k\
    \ < i && l[k] == l[j] {\n            k += 1;\n            j += 1;\n        }\n\
    \n        if k == i {\n            i += 1;\n        } else {\n            n =\
    \ k;\n        }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeis903kw.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = 0;\n    let mut i = l.len();\n\n\
    \    while i >= 0 {\n        triples += l[i / 3];\n        i = (i - 1) / 3;\n\
    \    }\n    triples == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp16tzcviq.rs:20:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut num = 0 as isize;\n    for &x in l {\n  \
    \      num += x;\n    }\n    let mut cnt = 0;\n    for i in l {\n        for j\
    \ in l {\n            if num - i == j {\n                cnt += 1;\n         \
    \       break;\n            }\n        }\n    }\n    return cnt == 3;\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9f27dvec.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut a = l.iter().cloned().count();\n    let mut\
    \ b = l.iter().cloned().count();\n    let mut c = l.iter().cloned().count();\n\
    \n    while b != 0 {\n        if *b < 0 {\n            return false;\n       \
    \ }\n        *a -= *b;\n        *b += c;\n        c += 1;\n    }\n\n    if *a\
    \ < 0 {\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp3lnn02aa.rs:20:12\n\
    \   |\n20 |         if *b < 0 {\n   |            ^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmp3lnn02aa.rs:23:9\n   |\n23 |         *a\
    \ -= *b;\n   |         ^^\n   |\nhelp: parentheses are required to parse this\
    \ as an expression\n   |\n20 ~         (if *b < 0 {\n21 |             return false;\n\
    22 ~         })\n   |\n\nerror[E0614]: type `usize` cannot be dereferenced\n \
    \ --> /tmp/tmp3lnn02aa.rs:23:15\n   |\n23 |         *a -= *b;\n   |          \
    \     ^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp3lnn02aa.rs:24:9\n\
    \   |\n24 |         *b += c;\n   |         ^^\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmp3lnn02aa.rs:28:8\n   |\n28 |     if *a < 0 {\n\
    \   |        ^^\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = BTreeMap::<isize, isize>::new();\n\
    \    seen.insert(l[0], 0);\n    for i in 1..l.len() {\n        seen.insert(l[i],\
    \ 0);\n        if seen[l[i]] < l[i - 1] { }\n    }\n    seen[l[0]] == 0\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeMap`\n  -->\
    \ /tmp/tmpjjm8p5dt.rs:15:20\n   |\n15 |     let mut seen = BTreeMap::<isize, isize>::new();\n\
    \   |                    ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeMap;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() == 0 {\n        return false;\n    }\n\
    \n    let mut sum: isize = 0;\n    let mut last_value: isize = 0;\n\n    for num\
    \ in l {\n        sum += num;\n        if sum == 0 {\n            // if sum is\
    \ 0 then sum must be last_value\n            if last_value != 0 {\n          \
    \      return false;\n            }\n        } else {\n            last_value\
    \ = num;\n        }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwxb6hupo.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().filter(|e| e > 0).fold(true, |b, e| b &&\
    \ (e == 0 || b + e == 0))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqb1v9xrx.rs:15:29\n   |\n\
    15 |     l.iter().filter(|e| e > 0).fold(true, |b, e| b && (e == 0 || b + e ==\
    \ 0))\n   |                             ^ expected `&&isize`, found integer\n\n\
    error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpqb1v9xrx.rs:15:58\n\
    \   |\n15 |     l.iter().filter(|e| e > 0).fold(true, |b, e| b && (e == 0 || b\
    \ + e == 0))\n   |                                                          ^^\
    \ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0369]: cannot add `&isize` to\
    \ `bool`\n  --> /tmp/tmpqb1v9xrx.rs:15:68\n   |\n15 |     l.iter().filter(|e|\
    \ e > 0).fold(true, |b, e| b && (e == 0 || b + e == 0))\n   |                \
    \                                                  - ^ - &isize\n   |        \
    \                                                          |\n   |           \
    \                                                       bool\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = 0; // the triples sum to zero.\n\
    \    let mut last = None; // the last non-zero element.\n    for num in l {\n\
    \        if last != None\n            && last + num == num\n            && last\
    \ + num != num\n        {\n            triples += 1;\n        }\n        last\
    \ = num;\n    }\n\n    triples == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `isize` to `Option<_>`\n  --> /tmp/tmpidomc5x5.rs:19:21\n\
    \   |\n19 |             && last + num == num\n   |                ---- ^ --- isize\n\
    \   |                |\n   |                Option<_>\n\nerror[E0369]: cannot\
    \ add `isize` to `Option<_>`\n  --> /tmp/tmpidomc5x5.rs:20:21\n   |\n20 |    \
    \         && last + num != num\n   |                ---- ^ --- isize\n   |   \
    \             |\n   |                Option<_>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpidomc5x5.rs:24:16\n   |\n16 |     let mut last = None; // the last\
    \ non-zero element.\n   |                    ---- expected due to this value\n\
    ...\n24 |         last = num;\n   |                ^^^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n24 |      \
    \   last = Some(num);\n   |                +++++   +\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = 0;\n    let mut sum_of_integers\
    \ = 0;\n\n    for n in l.iter() {\n        triples += 1;\n        sum_of_integers\
    \ += n;\n    }\n\n    let mut counter = 0;\n    for i in l.iter() {\n        if\
    \ i == sum_of_integers {\n            counter += 1;\n        }\n    }\n\n    counter\
    \ == 3 && triples == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpwwuz_lbw.rs:25:14\n\
    \   |\n25 |         if i == sum_of_integers {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().any(|&x| {\n        l.iter().any(|&y| {\n\
    \            l.iter().any(|&z| {\n                (x+y+z) == 0 || x+y+z > 0\n\
    \            })\n        })\n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2zvfyidh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut num = 0;\n    for i in l {\n        num +=\
    \ i;\n        if num >= 3 {\n            num -= 3;\n        } else {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1zcv75dp.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    while i < l.len() && j < l.len() && k < l.len() {\n        if l[i]\
    \ == l[j] && l[j] == l[k] {\n            i += 1;\n            j += 1;\n      \
    \      k += 1;\n        } else if l[i] < l[j] && l[j] < l[k] {\n            i\
    \ += 1;\n        } else if l[i] > l[j] && l[j] > l[k] {\n            j += 1;\n\
    \        } else if l[i] < l[j] {\n            k += 1;\n        } else {\n    \
    \        i += 1;\n            j += 1;\n            k += 1;\n        }\n    }\n\
    \    i == l.len() && j == l.len() && k == l.len()\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0flb8gm6.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut count = 0;\n    let mut zero = false;\n \
    \   for v in l {\n        if v == 0 {\n            zero = true;\n        } else\
    \ {\n            count += v;\n        }\n    }\n    count == 3 && zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphaudiukk.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = vec![0, 0, 0];\n    let mut sum\
    \ = 0;\n    for x in l {\n        if triples[0] < x {\n            triples[0]\
    \ += x;\n        } else {\n            triples[1] += x;\n        }\n        if\
    \ triples[2] < x {\n            triples[2] += x;\n        } else {\n         \
    \   triples[3] += x;\n        }\n        sum += x;\n    }\n    triples[0] == triples[1]\
    \ && triples[1] == triples[2] && triples[0] >= triples[3] &&\n        triples[3]\
    \ >= triples[1] && triples[2] >= triples[0]\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp829e0ktr.rs:26:13\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = 0;\n    let mut triples_to_zero\
    \ = false;\n    for i in l {\n        if triples == 0 {\n            triples +=\
    \ i;\n            triples_to_zero = true;\n        } else if triples == 1 {\n\
    \            triples += i;\n            triples_to_zero = false;\n        } else\
    \ if triples > 0 && !triples_to_zero {\n            triples_to_zero = triples\
    \ == 3;\n        }\n    }\n    triples_to_zero\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9ow8pasy.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(true, |res, elt| {\n        !res &&\n\
    \        (elt > 0 && elt < 3 && *elt == 0) ||\n        (elt > 0 && elt < 3 &&\
    \ *elt != 0)\n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7l31ahou.rs:17:16\n   |\n\
    17 |         (elt > 0 && elt < 3 && *elt == 0) ||\n   |                ^\n   |\
    \                |\n   |                expected `&isize`, found integer\n   |\
    \                help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7l31ahou.rs:17:27\n   |\n17 |         (elt > 0 && elt <\
    \ 3 && *elt == 0) ||\n   |                           ^\n   |                 \
    \          |\n   |                           expected `&isize`, found integer\n\
    \   |                           help: consider borrowing here: `&3`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7l31ahou.rs:18:16\n   |\n18 |         (elt >\
    \ 0 && elt < 3 && *elt != 0)\n   |                ^\n   |                |\n \
    \  |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7l31ahou.rs:18:27\n\
    \   |\n18 |         (elt > 0 && elt < 3 && *elt != 0)\n   |                  \
    \         ^\n   |                           |\n   |                          \
    \ expected `&isize`, found integer\n   |                           help: consider\
    \ borrowing here: `&3`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n\n    for i\
    \ in l {\n        for j in l {\n            for k in l {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = true;\n          \
    \      }\n            }\n        }\n    }\n\n    triples_sum_to_zero\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpvol8dxq8.rs:18:18\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n17  |     for i in l {\n    |             \
    \ - `l` moved due to this implicit call to `.into_iter()`\n18  |         for j\
    \ in l {\n    |                  ^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `l`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n17  |     for i in &l {\n    |              +\n\nerror[E0382]:\
    \ use of moved value: `l`\n  --> /tmp/tmpvol8dxq8.rs:19:22\n   |\n14 | fn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n   |                        - move occurs because `l`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n18 |\
    \         for j in l {\n   |                  - `l` moved due to this implicit\
    \ call to `.into_iter()`\n19 |             for k in l {\n   |                \
    \      ^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n18\
    \ |         for j in &l {\n   |                  +\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = 0;\n    for n in l {\n        if\
    \ n > 0 && n % 3 == 0 {\n            triples += 1;\n        }\n    }\n    triples\
    \ == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpisb_7v99.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().filter(|&x| x > 0).take(3).all(|x| x ==\
    \ 0)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmb3o3mvq.rs:15:30\n   |\n\
    15 |     l.iter().filter(|&x| x > 0).take(3).all(|x| x == 0)\n   |           \
    \                   ^\n   |                              |\n   |             \
    \                 expected `&isize`, found integer\n   |                     \
    \         help: consider borrowing here: `&0`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpmb3o3mvq.rs:15:51\n   |\n15 |     l.iter().filter(|&x|\
    \ x > 0).take(3).all(|x| x == 0)\n   |                                       \
    \            ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    let mut triple = vec![];\n    let mut sum_to_zero = false;\n\
    \    for &x in l {\n        for &y in l {\n            for &z in l {\n       \
    \         if sum + x == y + z {\n                    triple.push(vec![x, y, z]);\n\
    \                    sum_to_zero = true;\n                    break;\n       \
    \         }\n            }\n        }\n    }\n    triples_sum_to_zero_helper(triple,\
    \ sum_to_zero)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `triples_sum_to_zero_helper` in this\
    \ scope\n  --> /tmp/tmpboixgblf.rs:32:5\n   |\n32 |     triples_sum_to_zero_helper(triple,\
    \ sum_to_zero)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpboixgblf.rs:16:9\n   |\n16 |   \
    \  for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpboixgblf.rs:21:9\n   |\n21 |     for &x in l {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpboixgblf.rs:22:13\n\
    \   |\n22 |         for &y in l {\n   |             ^^    - this expression has\
    \ type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `y`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpboixgblf.rs:23:17\n  \
    \ |\n23 |             for &z in l {\n   |                 ^^    - this expression\
    \ has type `Option<isize>`\n   |                 |\n   |                 expected\
    \ `isize`, found reference\n   |                 help: you can probably remove\
    \ the explicit borrow: `z`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut sum = 0;\n    for v in\
    \ l {\n        if i == 0 {\n            sum += v;\n        } else {\n        \
    \    sum += v;\n            i += 1;\n        }\n    }\n    if sum == 0 {\n   \
    \     false\n    } else {\n        if i > 3 {\n            true\n        } else\
    \ {\n            triples_sum_to_zero(l.iter().skip(i).take(3)).unwrap_or(false)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq0bs6xg4.rs:31:33\n   |\n\
    31 |             triples_sum_to_zero(l.iter().skip(i).take(3)).unwrap_or(false)\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found struct `std::iter::Take`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `std::iter::Take<Skip<std::slice::Iter<'_, isize>>>`\n\
    \nerror[E0599]: no method named `unwrap_or` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpq0bs6xg4.rs:31:59\n   |\n31 |             triples_sum_to_zero(l.iter().skip(i).take(3)).unwrap_or(false)\n\
    \   |                                                           ^^^^^^^^^ method\
    \ not found in `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    let mut sum = 0;\n    for i in l {\n        sum += i;\n        if sum ==\
    \ 0 {\n            return true;\n        }\n    }\n    return false;\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgw1fih36.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = l.len() * l.len() * l.len() - 1;\n  \
    \  for &x in l {\n        s += x;\n        if s <= 0 {\n            return false;\n\
    \        }\n    }\n    s <= 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcjpgzkal.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l != l.iter().cloned().collect::<Vec<_>>().iter().take_while(|&x|\
    \ x != 0).count() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpka7vdjvq.rs:15:7\n\
    \   |\n15 |     l != l.iter().cloned().collect::<Vec<_>>().iter().take_while(|&x|\
    \ x != 0).count() == 3\n   |       ^^                                        \
    \                                      ^^\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpka7vdjvq.rs:15:73\n   |\n15 |     l != l.iter().cloned().collect::<Vec<_>>().iter().take_while(|&x|\
    \ x != 0).count() == 3\n   |                                                 \
    \                        ^^ no implementation for `&isize == {integer}`\n   |\n\
    \   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `Vec<isize>` with `usize`\n  -->\
    \ /tmp/tmpka7vdjvq.rs:15:7\n   |\n15 |     l != l.iter().cloned().collect::<Vec<_>>().iter().take_while(|&x|\
    \ x != 0).count() == 3\n   |       ^^ no implementation for `Vec<isize> == usize`\n\
    \   |\n   = help: the trait `PartialEq<usize>` is not implemented for `Vec<isize>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpka7vdjvq.rs:15:90\n   |\n15 |     l != l.iter().cloned().collect::<Vec<_>>().iter().take_while(|&x|\
    \ x != 0).count() == 3\n   |                                                 \
    \                                         ^ expected `bool`, found integer\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    seen.insert(0);\n    for e in l {\n        if seen.contains(&e + e) {\n \
    \           seen.insert(e + e);\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpegesonxc.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpegesonxc.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut found = false;\n    for i in l {\n      \
    \  for j in l {\n            for k in l {\n                if j - i + k == 0 {\n\
    \                    found = true;\n                    break;\n             \
    \   }\n            }\n        }\n    }\n    found\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpk92cg3r3.rs:17:18\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut found = false;\n16  |     for\
    \ i in l {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    17  |         for j in l {\n    |                  ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n    |    \
    \          +\n\nerror[E0382]: use of moved value: `l`\n  --> /tmp/tmpk92cg3r3.rs:18:22\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \            - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17 |         for j in l {\n   |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n18 |             for k in\
    \ l {\n   |                      ^ value used here after move\n   |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n   |\n17 |         for j in &l {\n   |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjd021hmc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = vec![];\n    for i in l.iter() {\n  \
    \      s.push(i);\n    }\n    fn helper(s: &mut Vec<isize>, i: isize) -> bool\
    \ {\n        if i == 0 {\n            s.push(i);\n            return true;\n \
    \       }\n        for i in s.iter_mut() {\n            if i == 0 {\n        \
    \        s.push(i);\n                return true;\n            }\n        }\n\
    \        return false;\n    }\n    helper(&mut s, 0) == false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6smz08ws.rs:32:12\n   |\n\
    32 |     helper(&mut s, 0) == false\n   |            ^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n\
    \              found mutable reference `&mut Vec<&isize>`\n\nerror[E0277]: can't\
    \ compare `&mut isize` with `{integer}`\n  --> /tmp/tmp6smz08ws.rs:25:18\n   |\n\
    25 |             if i == 0 {\n   |                  ^^ no implementation for `&mut\
    \ isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not\
    \ implemented for `&mut isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6smz08ws.rs:26:24\n   |\n26 |                 s.push(i);\n   |     \
    \                   ^ expected `isize`, found `&mut isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n26 |                 s.push(*i);\n   |     \
    \                   +\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut is_triple_zero = false;\n    let mut prev_triple\
    \ = 0;\n    for i in l.iter() {\n        prev_triple += i;\n        if prev_triple\
    \ == 0 {\n            is_triple_zero = true;\n        }\n    }\n    is_triple_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpix0ho6gz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero: Vec<isize> = vec![0;\
    \ 3];\n    for &i in l {\n        if triples_sum_to_zero[0] <= i && i <= triples_sum_to_zero[1]\
    \ {\n            triples_sum_to_zero[2] += i;\n        }\n    }\n    triples_sum_to_zero.len()\
    \ == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu6ahcbma.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |res, x| res || x != 0 && is_triple_sum(&x,\
    \ &res, &res))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_triple_sum` in this scope\n  -->\
    \ /tmp/tmppeg54cov.rs:15:52\n   |\n15 |     l.iter().fold(false, |res, x| res\
    \ || x != 0 && is_triple_sum(&x, &res, &res))\n   |                          \
    \                          ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmppeg54cov.rs:15:44\n \
    \  |\n15 |     l.iter().fold(false, |res, x| res || x != 0 && is_triple_sum(&x,\
    \ &res, &res))\n   |                                            ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // We use a single for loop as there are 3 distinct\
    \ elements to\n    // check in this list that need to be checked.\n    let mut\
    \ s = l[0];\n    for i in 1..l.len() {\n        if s == l[i] {\n            s\
    \ += l[i];\n        } else {\n            break;\n        }\n    }\n    s == 0\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4avdms7z.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut count = 0;\n    let mut n = 0;\n    for &i\
    \ in l {\n        if n % 3 == 0 {\n            n = n % 3;\n        }\n       \
    \ else {\n            count += i;\n        }\n    }\n    count % 3 == 0\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvnmhqlrl.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut m = l.len();\n    let mut a = 0;\n    let\
    \ mut b = 0;\n    let mut c = l;\n    while c != None && m != 0 {\n        a +=\
    \ *c;\n        b += 1;\n        c -= 1;\n        m -= 1;\n    }\n    (a == 0 &&\
    \ b == 0) || (a == b && b == 3)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<isize>` with `Option<_>`\n  --> /tmp/tmptdl7pk5n.rs:19:13\n\
    \   |\n19 |     while c != None && m != 0 {\n   |             ^^ no implementation\
    \ for `Vec<isize> == Option<_>`\n   |\n   = help: the trait `PartialEq<Option<_>>`\
    \ is not implemented for `Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: the size for\
    \ values of type `[isize]` cannot be known at compilation time\n  --> /tmp/tmptdl7pk5n.rs:20:11\n\
    \   |\n20 |         a += *c;\n   |           ^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n\nerror[E0277]:\
    \ cannot add-assign `[isize]` to `{integer}`\n  --> /tmp/tmptdl7pk5n.rs:20:11\n\
    \   |\n20 |         a += *c;\n   |           ^^ no implementation for `{integer}\
    \ += [isize]`\n   |\n   = help: the trait `AddAssign<[isize]>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `Vec<isize>`\n  --> /tmp/tmptdl7pk5n.rs:22:9\n   |\n22 |         c -=\
    \ 1;\n   |         -^^^^^\n   |         |\n   |         cannot use `-=` on type\
    \ `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = Vec::new();\n    let mut cnt = 0;\n \
    \   for &x in l {\n        if cnt == 3 {\n            return true;\n        }\n\
    \        s.insert(x);\n        cnt += 1;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp27i3_44s.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0061]: this function\
    \ takes 2 arguments but 1 argument was supplied\n    --> /tmp/tmp27i3_44s.rs:21:11\n\
    \     |\n21   |         s.insert(x);\n     |           ^^^^^^ - supplied 1 argument\n\
    \     |           |\n     |           expected 2 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = l;\n    let mut triplets: Vec<Vec<isize>>\
    \ = vec![];\n    for a in l.iter() {\n        let mut triplet: Vec<isize> = vec![];\n\
    \        for b in l.iter() {\n            if *b >= *a && *b - a != *a {\n    \
    \            triplet.push(*b - a);\n            }\n        }\n        if triplet.len()\
    \ > 0 {\n            triplets.push(triplet);\n        }\n    }\n    triplets.iter().all(|x|\
    \ x.len() == 3)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `s`\n  --> /tmp/tmp4puvp3zc.rs:15:13\n   |\n\
    15 |     let mut s = l;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_s`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp4puvp3zc.rs:15:9\n\
    \   |\n15 |     let mut s = l;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0382]: borrow of moved value: `l`\n  --> /tmp/tmp4puvp3zc.rs:17:14\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \            - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n15 |     let mut s = l;\n   |                 - value moved\
    \ here\n16 |     let mut triplets: Vec<Vec<isize>> = vec![];\n17 |     for a in\
    \ l.iter() {\n   |              ^^^^^^^^ value borrowed here after move\n   |\n\
    \   = note: borrow occurs due to deref coercion to `[isize]`\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
