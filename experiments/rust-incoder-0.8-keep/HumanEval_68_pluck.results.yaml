name: HumanEval_68_pluck
language: rust
results:
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    use std::cmp::Ordering;\n\n    let mut even_value_count = arr\n        .iter()\n\
    \        .filter(|&n| n % 2 == 0)\n        .count();\n    let mut smallest_value\
    \ = arr\n        .iter()\n        .filter(|&n| n % 2 == 0)\n        .min_by_key(|&n|\
    \ n);\n    if even_value_count == 0 {\n        return []\n    }\n\n    let mut\
    \ small_index = 0;\n    let mut small_indexes: Vec<isize> = vec![small_index];\n\
    \    let mut found = false;\n    for value in arr.iter() {\n        if value ==\
    \ smallest_value {\n            small_indexes.push(*value);\n        }\n\n   \
    \     if value < smallest_value {\n            small_index = *value - 1;\n   \
    \     }\n\n        if small_index == arr.len() - 1 {\n            if value % 2\
    \ == 0 && even_value_count == 0 {\n                found = true;\n           \
    \ }\n        } else {\n            if value < arr[small_index + 1] {\n       \
    \         small_index += 1;\n            }\n        }\n    }\n\n    if found ==\
    \ false {\n        return vec![];\n    }\n    small_indexes.sort_unstable();\n\
    \    let mut index = small_indexes.iter().next().unwrap();\n    \n    while index\
    \ != arr.len() - 1 {\n        let mut next_value = arr[index + 1];\n        if\
    \ next_value == arr[small_index] {\n            index += 1;\n        } else {\n\
    \            return vec![smallest_value, index];\n        }\n    }\n    vec![smallest_value,\
    \ index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpe7m2n0jp.rs:27:9\n\
    \   |\n27 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe7m2n0jp.rs:38:16\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n38 |         return []\n   |                ^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |                |\n  \
    \ |                expected struct `Vec`, found array of 0 elements\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n               found array `[_; 0]`\n\n\
    error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpe7m2n0jp.rs:45:18\n\
    \   |\n45 |         if value == smallest_value {\n   |                  ^^ no\
    \ implementation for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe7m2n0jp.rs:49:20\n   |\n49 |         if value < smallest_value {\n\
    \   |                    ^^^^^^^^^^^^^^ expected `&isize`, found enum `Option`\n\
    \   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe7m2n0jp.rs:53:27\n   |\n53 |\
    \         if small_index == arr.len() - 1 {\n   |                           ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n53 |         if\
    \ small_index == (arr.len() - 1).try_into().unwrap() {\n   |                 \
    \          +             +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpe7m2n0jp.rs:58:24\n   |\n58 |  \
    \           if value <"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr: Vec<isize> = arr.iter().cloned().collect();\n    \n \
    \   sorted_arr.sort_unstable();\n    \n    let mut smallest: isize;\n    let mut\
    \ smallest_idx: usize;\n    for i in sorted_arr.iter() {\n        if smallest\
    \ == 0 || i %  smallest == 0 {\n            smallest = i;\n            smallest_idx\
    \ = i;\n        }\n    }\n\n    let mut even_value: isize = 0;\n    for i in sorted_arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_value = i;\n            break;\n\
    \        }\n    }\n    \n    sorted_arr.insert(smallest_idx, even_value);\n  \
    \  sorted_arr.into_iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfkp90no4.rs:35:24\n   |\n\
    31 |     let mut smallest: isize;\n   |                       ----- expected due\
    \ to this type\n...\n35 |             smallest = i;\n   |                    \
    \    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |             smallest = *i;\n   |                        +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfkp90no4.rs:36:28\n   |\n32 |\
    \     let mut smallest_idx: usize;\n   |                           ----- expected\
    \ due to this type\n...\n36 |             smallest_idx = i;\n   |            \
    \                ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfkp90no4.rs:43:26\n   |\n40 |     let mut even_value: isize\
    \ = 0;\n   |                         ----- expected due to this type\n...\n43\
    \ |             even_value = i;\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n43 |  \
    \           even_value = *i;\n   |                          +\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpfkp90no4.rs:49:28\n     |\n49   |     sorted_arr.into_iter().cloned().collect()\n\
    \     |                            ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpfkp90no4.rs:49:37\n   |\n49 |       sorted_arr.into_iter().cloned().collect()\n\
    \   |                                       ^^^^^^^ method cannot be called on\
    \ `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    let mut min_idx = vec![];\n    for i in arr.iter_mut()\
    \ {\n        *i %= 2;\n        if *i >= 0 {\n            evens.push(*i);\n   \
    \         min_idx.push(i);\n        } else {\n            evens.remove(&*i);\n\
    \            min_idx.remove(&i);\n        }\n    }\n    evens.sort_unstable_by(|a,\
    \ b| a.partial_cmp(&b).unwrap());\n    min_idx.iter().map(|&index| {\n       \
    \ arr.swap(index, index + 1)\n    }).collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ygu_sl3.rs:35:26\n   |\n\
    35 |             evens.remove(&*i);\n   |                          ^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ygu_sl3.rs:36:28\n\
    \   |\n36 |             min_idx.remove(&i);\n   |                            ^^\
    \ expected `usize`, found `&&mut isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7ygu_sl3.rs:41:18\n   |\n41 |         arr.swap(index, index + 1)\n \
    \  |                  ^^^^^ expected `usize`, found `&mut isize`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `&mut isize`\n  --> /tmp/tmp7ygu_sl3.rs:41:31\n  \
    \ |\n41 |         arr.swap(index, index + 1)\n   |                         -----\
    \ ^ - {integer}\n   |                         |\n   |                        \
    \ &mut isize\n   |\nhelp: `+` can be used on `isize`, you can dereference `index`\n\
    \   |\n41 |         arr.swap(index, *index + 1)\n   |                        \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ygu_sl3.rs:40:5\n   |\n\
    26 |   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                       \
    \         ---------- expected `Vec<isize>` because of return type\n...\n40 | /\
    \     min_idx.iter().map(|&index| {\n41 | |         arr.swap(index, index + 1)\n\
    42 | |     }).collect::<Vec<_>>()\n   | |__________________________^ expected\
    \ `isize`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<()>`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().fold(vec![], |mut arr, i| {\n        let mut current_index\
    \ = arr.len();\n        let mut current_value = i;\n        let mut current_min\
    \ = current_value;\n        if current_value % 2 == 0 {\n            arr.push(i);\n\
    \        }\n        let mut index = 0;\n        while current_value % 2 == 0 &&\
    \ current_index != arr.len() {\n            current_value /= 2;\n            current_index\
    \ += 1;\n            let mut next = arr.iter().cloned().skip(current_index).next();\n\
    \            if next.is_none() {\n                break;\n            }\n    \
    \        if next.unwrap() % 2 == 0 {\n                current_min = next.unwrap();\n\
    \            }\n            current_value = *next;\n        }\n        arr.push(current_min);\n\
    \        arr\n    })\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpaxsajdsf.rs:45:29\n\
    \   |\n45 |             current_value = *next;\n   |                         \
    \    ^^^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().min(|a, b| {\n        a.value_bigger_than_or_equal_to_b(b).unwrap()\n\
    \    }).unwrap()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmps1716ubw.rs:27:30\n\
    \   |\n27 |     arr.iter().cloned().min(|a, b| {\n   |                       \
    \       ^ consider giving this closure parameter a type\n   |\n   = note: type\
    \ must be known at this point\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmps1716ubw.rs:27:25\n     |\n27 \
    \  |       arr.iter().cloned().min(|a, b| {\n     |  _________________________^^^_-\n\
    \     | |                         |\n     | |                         expected\
    \ 0 arguments\n28   | |         a.value_bigger_than_or_equal_to_b(b).unwrap()\n\
    29   | |     }).unwrap()\n     | |_____- supplied 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps1716ubw.rs:27:5\n\
    \   |\n26 |   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                \
    \                ---------- expected `Vec<isize>` because of return type\n27 |\
    \ /     arr.iter().cloned().min(|a, b| {\n28 | |         a.value_bigger_than_or_equal_to_b(b).unwrap()\n\
    29 | |     }).unwrap()\n   | |_______________^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() || arr.len() <= 0 {\n        return vec![];\n    }\n  \
    \  let mut min_val: isize = 0;\n    let mut min_val_pos: Vec<isize> = vec![];\n\
    \    let mut mut_vec: Vec<Vec<isize>> = vec![];\n    for i in 0..arr.len() {\n\
    \        if min_val < arr[i] {\n            min_val = arr[i];\n            min_val_pos\
    \ = vec![i];\n        }\n    }\n    for i in 0..arr.len() {\n        if min_val\
    \ == arr[i] {\n            mut_vec = vec![min_val_pos.clone(), i];\n        }\n\
    \    }\n    for i in 0..arr.len() {\n        if arr[i] % 2 != 0 {\n          \
    \  mut_vec.push(vec![i]);\n        }\n    }\n    for i in mut_vec {\n        return\
    \ vec![arr[i[1]], i[0]];\n    }\n    return vec![];\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbblyjla6.rs:36:32\n   |\n\
    36 |             min_val_pos = vec![i];\n   |                                ^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n36 |           \
    \  min_val_pos = vec![i.try_into().unwrap()];\n   |                          \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbblyjla6.rs:41:49\n\
    \   |\n41 |             mut_vec = vec![min_val_pos.clone(), i];\n   |        \
    \                                         ^ expected struct `Vec`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbblyjla6.rs:46:31\n   |\n46 |\
    \             mut_vec.push(vec![i]);\n   |                               ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n46 |             mut_vec.push(vec![i.try_into().unwrap()]);\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbblyjla6.rs:50:21\n\
    \   |\n50 |         return vec![arr[i[1]], i[0]];\n   |                     ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut max_even_val = std::i32::MAX;\n    let mut smallest_even_val = std::i32::MAX;\n\
    \    let mut smallest_idx = -1;\n    let mut even_val = std::i32::MAX;\n    for\
    \ (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 {\n        \
    \    if max_even_val < val {\n                max_even_val = val;\n          \
    \  }\n            if even_val < val {\n                even_val = val;\n     \
    \           smallest_even_val = even_val;\n                smallest_idx = idx;\n\
    \            }\n        }\n    }\n    if smallest_idx == -1 {\n        return\
    \ vec![];\n    }\n    let mut ret: Vec<isize> = vec![];\n    ret.push(smallest_even_val);\n\
    \    ret.push(smallest_idx);\n    return ret;\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphx1eiff6.rs:33:31\n   |\n\
    33 |             if max_even_val < val {\n   |                               ^^^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphx1eiff6.rs:34:32\n\
    \   |\n27 |     let mut max_even_val = std::i32::MAX;\n   |                  \
    \          ------------- expected due to this value\n...\n34 |               \
    \  max_even_val = val;\n   |                                ^^^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphx1eiff6.rs:36:27\n\
    \   |\n36 |             if even_val < val {\n   |                           ^^^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphx1eiff6.rs:37:28\n\
    \   |\n30 |     let mut even_val = std::i32::MAX;\n   |                      \
    \  ------------- expected due to this value\n...\n37 |                 even_val\
    \ = val;\n   |                            ^^^ expected `i32`, found `&isize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmphx1eiff6.rs:29:28\n\
    \   |\n29 |     let mut smallest_idx = -1;\n   |                            ^^\
    \ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmphx1eiff6.rs:43:24\n\
    \   |\n43 |     if smallest_idx == -1 {\n   |                        ^^\n   |\
    \                        |\n   |                        cannot apply unary operator\
    \ `-`\n   |                        help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphx1eiff6.rs:47:14\n   |\n47 |\
    \     ret.push(smallest_even_val);\n   |              ^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted va"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = Vec::new();\n    for i in arr {\n        if i.is_even() {\n\
    \            res.push(i);\n        }\n    }\n    if res.is_empty() {\n       \
    \ return Vec::new();\n    }\n    sort_with_key(&res, |a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut i = 0;\n    while i < res.len() {\n        if res[i].is_even() {\n\
    \            return res[i].clone(), i;\n        }\n        i += 1;\n    }\n  \
    \  return res[0].clone(), 0;\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpmxdtj288.rs:40:34\n   |\n40 |             return res[i].clone(),\
    \ i;\n   |                                  ^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpmxdtj288.rs:44:26\n   |\n44 |     return res[0].clone(),\
    \ 0;\n   |                          ^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror[E0425]: cannot find function `sort_with_key` in this scope\n\
    \  --> /tmp/tmpmxdtj288.rs:36:5\n   |\n36 |     sort_with_key(&res, |a, b| a.partial_cmp(b).unwrap());\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `is_even` found for type `isize` in the current scope\n  --> /tmp/tmpmxdtj288.rs:29:14\n\
    \   |\n29 |         if i.is_even() {\n   |              ^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `is_even` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpmxdtj288.rs:39:19\n   |\n39 |         if\
    \ res[i].is_even() {\n   |                   ^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut map = std::collections::HashMap::new();\n    let mut result = Vec::new();\n\
    \    for i in arr {\n        if map.contains_key(&i) {\n            map.insert(i,\
    \ map.get(&i) + 1);\n        } else {\n            map.insert(i, 1);\n       \
    \ }\n    }\n\n    for i in map.keys().cloned() {\n        if map[i] > 1 {\n  \
    \          result.push(i);\n        }\n    }\n\n    if result.len() == 0 {\n \
    \       return Vec::new();\n    }\n\n    result.sort();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `Option<&_>`\n  --> /tmp/tmpfwjqtbpc.rs:31:39\n\
    \   |\n31 |             map.insert(i, map.get(&i) + 1);\n   |                \
    \           ----------- ^ - {integer}\n   |                           |\n   |\
    \                           Option<&_>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfwjqtbpc.rs:38:16\n   |\n38 |         if map[i] > 1 {\n   |        \
    \        ^\n   |                |\n   |                expected `&isize`, found\
    \ `isize`\n   |                help: consider borrowing here: `&i`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut min_value_index = arr.len();\n    for\
    \ &index in arr {\n        if index == min_value_index {\n            min_value_index\
    \ += 1;\n            continue;\n        }\n        if index % 2 == 0 {\n     \
    \       if index == min_value_index {\n                min_value_index += 1;\n\
    \            } else {\n                result.push(index);\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpau07a7ht.rs:29:9\n   |\n\
    29 |     for &index in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `index`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ can't compare `isize` with `usize`\n  --> /tmp/tmpau07a7ht.rs:30:18\n   |\n\
    30 |         if index == min_value_index {\n   |                  ^^ no implementation\
    \ for `isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `isize` with `usize`\n  -->\
    \ /tmp/tmpau07a7ht.rs:35:22\n   |\n35 |             if index == min_value_index\
    \ {\n   |                      ^^ no implementation for `isize == usize`\n   |\n\
    \   = help: the trait `PartialEq<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Solution 1 \n    // sort from smallest to largest\n    // find smallest\
    \ even value using binary search\n    // if even, return the index \n    // else\
    \ return the value\n\n    let mut min_even_index = Vec::new();\n    let mut min_even_value\
    \ = arr[0];\n    let mut min_even_value_even = false;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 && min_even_value <= i {\n            min_even_value_even\
    \ = true;\n            min_even_value = i;\n            min_even_index.push(i);\n\
    \        }\n        if min_even_value_even {\n            min_even_value_even\
    \ = false;\n            min_even_index.pop();\n        }\n    }\n    min_even_index.sort();\n\
    \    min_even_index.dedup();\n    min_even_index.reverse();\n    min_even_index\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuqoqkhid.rs:37:44\n   |\n\
    37 |         if i % 2 == 0 && min_even_value <= i {\n   |                    \
    \                        ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n37 |         if i % 2 == 0 && min_even_value\
    \ <= *i {\n   |                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuqoqkhid.rs:39:30\n   |\n34 |     let mut min_even_value\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n39 |             min_even_value = i;\n   |                              ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n39 |             min_even_value = *i;\n   |                           \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuqoqkhid.rs:50:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n50 |     min_even_index\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // write your code here\n    let mut min_idx: isize = 0;\n    let mut min_val:\
    \ isize = 0;\n    let mut min_node: Vec<isize> = vec![];\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            if min_val > i {\n                min_val\
    \ = i;\n                min_node = vec![i];\n                min_idx = i;\n  \
    \          } else {\n                min_node[0] = i;\n                min_idx\
    \ = i;\n            }\n        } else {\n            min_val = i;\n          \
    \  min_node = vec![i];\n            min_idx = i;\n        }\n    }\n    return\
    \ min_node\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcg3_i24t.rs:33:26\n   |\n\
    33 |             if min_val > i {\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \           if min_val > *i {\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcg3_i24t.rs:34:27\n   |\n29 |     let mut min_val:\
    \ isize = 0;\n   |                      ----- expected due to this type\n...\n\
    34 |                 min_val = i;\n   |                           ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |  \
    \               min_val = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcg3_i24t.rs:35:33\n   |\n35 |              \
    \   min_node = vec![i];\n   |                                 ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               min_node = vec![*i];\n   |                                 +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcg3_i24t.rs:36:27\n   |\n28 |\
    \     let mut min_idx: isize = 0;\n   |                      ----- expected due\
    \ to this type\n...\n36 |                 min_idx = i;\n   |                 \
    \          ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n36 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcg3_i24t.rs:38:31\n\
    \   |\n38 |                 min_node[0] = i;\n   |                 -----------\
    \   ^ expected `isize`, found `&isize`\n   |                 |\n   |         \
    \        expected due to the type of this binding\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n38 |                 min_node[0] = *i;\n   |             \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcg3_i24t.rs:39:27\n\
    \   |\n28 |     let mut min_idx: isize = 0;\n   |                      ----- expected\
    \ due to this type\n...\n39 |                 min_idx = i;\n   |             \
    \              ^ expected `isize`, found `&isize`\n   |\nhelp: consider der"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    \n    let mut s = std::i32::MAX;\n    let mut index = 0;\n    for n in arr\
    \ {\n        if n % 2 == 0 {\n            s = n;\n            index = arr.iter().skip(index).count();\n\
    \            break;\n        }\n        index += 1;\n    }\n    if s == std::i32::MAX\
    \ {\n        return vec![];\n    }\n    vec![index,s];\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbpwx_zxz.rs:32:17\n   |\n\
    28 |     let mut s = std::i32::MAX;\n   |                 ------------- expected\
    \ due to this value\n...\n32 |             s = n;\n   |                 ^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbpwx_zxz.rs:41:16\n\
    \   |\n41 |     vec![index,s];\n   |                ^ expected `usize`, found\
    \ `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbpwx_zxz.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = arr.min_unwrap_or(-1);\n    let mut min_idx = 0;\n\n  \
    \  for &value in arr.iter().cloned().rev() {\n        if value % 2 == 0 {\n  \
    \          if value < min_val {\n                min_val = value;\n          \
    \      min_idx = arr.iter().position(|x| *x == 0).unwrap();\n            }\n \
    \       }\n    }\n\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `min_unwrap_or` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpq3m0j2pp.rs:27:27\n   |\n27 |     let mut\
    \ min_val = arr.min_unwrap_or(-1);\n   |                           ^^^^^^^^^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq3m0j2pp.rs:30:9\n\
    \   |\n30 |     for &value in arr.iter().cloned().rev() {\n   |         ^^^^^^\
    \    ------------------------- this expression has type `Option<isize>`\n   |\
    \         |\n   |         expected `isize`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `value`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpq3m0j2pp.rs:39:19\n   |\n39 |     vec![min_val, min_idx]\n   |\
    \                   ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n39 |     vec![min_val, min_idx.try_into().unwrap()]\n   |             \
    \             ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut pivot_index: Vec<isize> = vec![];\n    let mut pivot_value: isize\
    \ = 0;\n    let mut pivot_index: isize = 0;\n    for i in 0..arr.len() {\n   \
    \     if arr[i] == 0 || (i % 2 == 0 && arr[i] == pivot_value) {\n            pivot_index!\
    \ = i;\n            pivot_value! = arr[i];\n        } else {\n            if pivot_index\
    \ != pivot_index! {\n                pivot_index! = pivot_index;\n           \
    \     pivot_value! = pivot_value;\n            }\n        }\n    }\n    pivot_index!\
    \ = pivot_index;\n    pivot_value! = pivot_value;\n    let mut arr: Vec<isize>\
    \ = vec![];\n    arr.push(pivot_value);\n    arr.push(pivot_index);\n    return\
    \ arr;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `=`\n  --> /tmp/tmp4vdwwc1u.rs:32:26\n\
    \   |\n32 |             pivot_index! = i;\n   |                          ^ expected\
    \ one of `(`, `[`, or `{`\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp4vdwwc1u.rs:39:9\n\
    \   |\n35 |             if pivot_index != pivot_index! {\n   |             --\
    \ this `if` expression has a condition, but no block\n...\n39 |         }\n  \
    \ |         ^ expected `{`\n\nerror: expected one of `(`, `[`, or `{`, found `=`\n\
    \  --> /tmp/tmp4vdwwc1u.rs:41:18\n   |\n41 |     pivot_index! = pivot_index;\n\
    \   |                  ^ expected one of `(`, `[`, or `{`\n\nerror: aborting due\
    \ to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut pluck_arr = Vec::new();\n    for i in arr {\n        if i % 2 ==\
    \ 0 {\n            pluck_arr.push(i);\n        }\n    }\n    if pluck_arr.is_empty()\
    \ {\n        return Vec::new();\n    }\n    pluck_arr.sort();\n    return pluck_arr;\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4]`,\n right: `[2, 1]`', /tmp/tmpra4ep8lb.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() { return vec![]; }\n    let mut evens = arr.iter().filter(|&x|\
    \ x.is_even());\n    let mut smaller = evens.clone();\n    let mut smaller_index\
    \ = vec![0];\n    loop {\n        let mut smaller_value = smaller.iter().min_by(|a,\
    \ b| a.cmp(b)).unwrap();\n        let smaller_index_value = smaller_index.iter().min_by(|a,\
    \ b| a.cmp(b)).unwrap();\n        let next_smaller_value = smaller.iter().filter(|&x|\
    \ x.is_even()).next();\n        if next_smaller_value.is_none() { break; }\n \
    \       if smaller_value.unwrap() == next_smaller_value.unwrap() {\n         \
    \   smaller.remove(next_smaller_value.unwrap());\n            smaller_index.remove(smaller_index_value.unwrap());\n\
    \        } else {\n            if smaller_value.unwrap() == smaller_value.unwrap()\
    \ - 1 {\n                smaller.remove(smaller_value.unwrap() - 1);\n       \
    \         smaller_index.remove(smaller_index_value.unwrap() - 1);\n          \
    \  } else {\n                smaller.remove(smaller_value.unwrap());\n       \
    \         smaller_index.remove(smaller_index_value.unwrap());\n            }\n\
    \        }\n    }\n    smaller.iter().map(|x| x).collect()\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp9c_l92c2.rs:28:46\n   |\n28 |     let mut evens\
    \ = arr.iter().filter(|&x| x.is_even());\n   |                               \
    \               ^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method\
    \ named `iter` found for struct `Filter` in the current scope\n  --> /tmp/tmp9c_l92c2.rs:32:41\n\
    \   |\n32 |         let mut smaller_value = smaller.iter().min_by(|a, b| a.cmp(b)).unwrap();\n\
    \   |                                         ^^^^ private field, not a method\n\
    \nerror[E0599]: no method named `iter` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmp9c_l92c2.rs:34:42\n   |\n34 |         let next_smaller_value\
    \ = smaller.iter().filter(|&x| x.is_even()).next();\n   |                    \
    \                      ^^^^ private field, not a method\n\nerror[E0599]: no method\
    \ named `remove` found for struct `Filter` in the current scope\n  --> /tmp/tmp9c_l92c2.rs:37:21\n\
    \   |\n37 |             smaller.remove(next_smaller_value.unwrap());\n   |   \
    \                  ^^^^^^ method not found in `Filter<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmp9c_l92c2.rs:28:39: 28:55]>`\n\nerror[E0599]: no method named\
    \ `unwrap` found for reference `&{integer}` in the current scope\n  --> /tmp/tmp9c_l92c2.rs:38:54\n\
    \   |\n38 |             smaller_index.remove(smaller_index_value.unwrap());\n\
    \   |                                                      ^^^^^^ method not found\
    \ in `&{integer}`\n\nerror[E0599]: no method named `remove` found for struct `Filter`\
    \ in the current scope\n  --> /tmp/tmp9c_l92c2.rs:41:25\n   |\n41 |          \
    \       smaller.remove(smaller_value.unwrap() - 1);\n   |                    \
    \     ^^^^^^ method not found in `Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmp9c_l92c2.rs:28:39:\
    \ 28:55]>`\n\nerror[E0599]: no method named `unwrap` found for reference `&{integer}`\
    \ in the current scope\n  --> /tmp/tmp9c_l92c2.rs:42:58\n   |\n42 |          \
    \       smaller_index.remove(smaller_index_value.unwrap() - 1);\n   |        \
    \                                  "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_value = arr[0];\n    let mut\
    \ min_index = 0;\n\n    for value in arr {\n        if value == min_value {\n\
    \            min_index += 1;\n        } else {\n            even_values.push(min_value);\n\
    \            min_value = value;\n            min_index = 1;\n        }\n    }\n\
    \    even_values.push(min_value);\n    even_values.sort_unstable_by_key(|v| *v);\n\
    \    even_values.collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpwn1iozxj.rs:42:17\n\
    \    |\n42  |       even_values.collect::<Vec<_>>()\n    |                   ^^^^^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = Vec::new();\n    let mut smallest_even_value = 0;\n    let\
    \ mut smallest_index = 0;\n    let mut smallest_even_value : isize = 0;\n    for\
    \ i in arr.iter() {\n        if smallest_even_value < i {\n            smallest_even_value\
    \ = i;\n            smallest_index = 1;\n        } else {\n            smallest_even_value\
    \ += i;\n            smallest_index += i;\n        }\n    }\n    res.push(smallest_even_value);\n\
    \    res.push(smallest_index);\n    res\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8iv6sgjb.rs:32:34\n   |\n\
    32 |         if smallest_even_value < i {\n   |                              \
    \    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |         if smallest_even_value < *i {\n   |             \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8iv6sgjb.rs:33:35\n\
    \   |\n30 |     let mut smallest_even_value : isize = 0;\n   |               \
    \                    ----- expected due to this type\n...\n33 |             smallest_even_value\
    \ = i;\n   |                                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |             smallest_even_value\
    \ = *i;\n   |                                   +\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even: isize = 0;\n    let mut even_indx = 0;\n    let mut smalest_value:\
    \ isize = 0;\n    let mut smalest_index = 0;\n    for v in arr.iter() {\n    \
    \    if v % 2 == 0 {\n            if even > v {\n                even = v;\n \
    \               even_indx = v;\n            }\n        } else {\n            if\
    \ even < v {\n                smalest_value = v;\n                smalest_index\
    \ = v;\n            }\n        }\n    }\n    if even_indx > 0 {\n        let mut\
    \ newvec = vec![smalest_value, smalest_index];\n        let mut newvec2 = vec![smalest_value,\
    \ smalest_index];\n        for v in arr.iter() {\n            if v % 2 == 0 {\n\
    \                if v < smalest_index {\n                    newvec2 = vec![v,\
    \ v];\n                } else {\n                    newvec = vec![v, v];\n  \
    \              }\n            } else {\n                if v < smalest_index {\n\
    \                    newvec2 = vec![smalest_value, smalest_index];\n         \
    \       } else {\n                    newvec = vec![smalest_value, smalest_index];\n\
    \                }\n            }\n        }\n        let mut new_even = 0;\n\
    \        let mut new_even_indx = 0;\n        for v in newvec2.iter() {\n     \
    \       if v % 2 == 0 {\n                new_even = new_even + v;\n          \
    \      new_even_indx = v;\n            } else {\n                new_even = new_even\
    \ - v;\n                new_even_indx = v;\n            }\n        }\n       \
    \ if new_even > 0 {\n            let mut newvec3 = vec![smalest_value, smalest_index];\n\
    \            let mut newvec4 = vec![smalest_value, smalest_index];\n         \
    \   for v in newvec.iter() {\n                if v % 2 == 0 {\n              \
    \      if v < smalest_index {\n                        newvec3 = vec![v, v];\n\
    \                    } else {\n                        newvec3 = vec![smalest_value,\
    \ smalest_index];\n                    }\n                } else {\n         \
    \           if v < smalest_index {\n                        newvec4 = vec![v,\
    \ v];\n                    } else {\n                        newvec4 = vec![smalest_value,\
    \ smalest_index];\n                    }\n                }\n            }\n \
    \           let mut new_smalest_value = 0;\n            let mut new_smalest_index\
    \ = 0;\n            for v in newvec3.iter() {\n                if v % 2 == 0 {\n\
    \                    if v < new_smalest_index {\n                        new_smalest_value\
    \ = v;\n                        new_smalest_index = v;\n                    }\
    \ else {\n                        new_smalest_value = smalest_value;\n       \
    \                 new_smale\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp315ggyxm.rs:113:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n44  |     if even_indx >\
    \ 0 {\n    |                      - unclosed delimiter\n...\n73  |         if\
    \ new_even > 0 {\n    |                         - unclosed delimiter\n...\n93\
    \  |             for v in newvec3.iter() {\n    |                            \
    \         - unclosed delimiter\n94  |                 if v % 2 == 0 {\n    | \
    \                              - unclosed delimiter\n...\n98  |              \
    \       } else {\n    |                            - this delimiter might not\
    \ be properly closed...\n...\n101 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n113 | }\n    |   ^\n\nerror[E0425]: cannot find\
    \ value `new_smale` in this scope\n   --> /tmp/tmp315ggyxm.rs:100:25\n    |\n\
    100 |                         new_smale\n    |                         ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp315ggyxm.rs:33:23\n\
    \   |\n33 |             if even > v {\n   |                       ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \           if even > *v {\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp315ggyxm.rs:34:24\n   |\n27 |     let mut even: isize =\
    \ 0;\n   |                   ----- expected due to this type\n...\n34 |      \
    \           even = v;\n   |                        ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 even\
    \ = *v;\n   |                        +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp315ggyxm.rs:35:29\n   |\n28 |     let mut even_indx = 0;\n   |     \
    \                    - expected due to this value\n...\n35 |                 even_indx\
    \ = v;\n   |                             ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 even_indx\
    \ = *v;\n   |                             +\n\nerror[E0308]: mismat"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = arr[0] as isize;\n    let mut index = arr[0] as usize;\n\
    \n    for i in 1..arr.len() {\n        let mut even = arr[i] as isize;\n     \
    \   if even % 2 == 0 {\n            if min_even > even {\n                min_even\
    \ = even;\n                index = i;\n            }\n        } else {\n     \
    \       break;\n        }\n    }\n\n    vec![min_even, index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8znge9ha.rs:42:20\n   |\n\
    42 |     vec![min_even, index]\n   |                    ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n42 |     vec![min_even, index.try_into().unwrap()]\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut smalest_value = *arr.iter().min(|&i|\
    \ i as isize).unwrap();\n    let mut smallest_index = *arr.iter().position(|&i|\
    \ i as isize == smalest_value).unwrap();\n    for i in 0..arr.len() {\n      \
    \  if arr[i] % 2 == 0 {\n            result.push(i);\n            smallest_index\
    \ = i;\n        }\n    }\n    if smallest_index == -1 {\n        return vec![];\n\
    \    } else {\n        result.push(smallest_index);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmphl2v3zqu.rs:28:41\n     |\n28   |     let mut smalest_value =\
    \ *arr.iter().min(|&i| i as isize).unwrap();\n     |                         \
    \                ^^^ --------------- supplied 1 argument\n     |             \
    \                            |\n     |                                       \
    \  expected 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmphl2v3zqu.rs:29:30\n   |\n\
    29 |     let mut smallest_index = *arr.iter().position(|&i| i as isize == smalest_value).unwrap();\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmphl2v3zqu.rs:36:26\n\
    \   |\n36 |     if smallest_index == -1 {\n   |                          ^^\n\
    \   |                          |\n   |                          cannot apply unary\
    \ operator `-`\n   |                          help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphl2v3zqu.rs:41:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n41 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308, E0600, E0614.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    for i in 0..arr.len() {\n\
    \        if arr[i] % 2 == 0 {\n            even_values[i] = arr[i];\n        }\
    \ else {\n            even_values[i] = arr.iter().filter(|&x| x == arr[i]).min().unwrap();\n\
    \        }\n    }\n    let mut min_even_value = 0;\n    let mut min_even_index_idx\
    \ = 0;\n    for i in 0..arr.len() {\n        if arr[i] == even_values[min_even_index_idx]\
    \ {\n            min_even_index_idx += 1;\n        } else {\n            if min_even_index_idx\
    \ != i {\n                min_even_value = even_values[min_even_index_idx];\n\
    \                min_even_index_idx = 0;\n            }\n        }\n    }\n  \
    \  min_even_value = even_values[min_even_index_idx];\n    even_values[min_even_index_idx]\
    \ = 0;\n    for i in 0..arr.len() {\n        if arr[i] != min_even_value.to_i()\
    \ {\n            even_values[i] = 0;\n        }\n    }\n    even_values\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2ua6e0_t.rs:32:55\n\
    \   |\n32 |             even_values[i] = arr.iter().filter(|&x| x == arr[i]).min().unwrap();\n\
    \   |                                                       ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2ua6e0_t.rs:32:30\n   |\n32 |             even_values[i] = arr.iter().filter(|&x|\
    \ x == arr[i]).min().unwrap();\n   |             --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n32 |             even_values[i] = *arr.iter().filter(|&x| x == arr[i]).min().unwrap();\n\
    \   |                              +\n\nerror[E0599]: no method named `to_i` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmp2ua6e0_t.rs:50:37\n   |\n\
    50 |         if arr[i] != min_even_value.to_i() {\n   |                      \
    \               ^^^^ method not found in `isize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut even_smallest_value\
    \ = arr[0];\n    let mut smalest_value_index = 0;\n    let mut smalest_value_index2\
    \ = -1;\n    let mut smalest_value_index3 = -1;\n    let mut smalest_value_index4\
    \ = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n            if even_smallest_value\
    \ < i {\n                even_smallest_value = i;\n                smalest_value_index\
    \ = i;\n            }\n            if even_smallest_value == i {\n           \
    \     if smalest_value_index2 < i {\n                    smalest_value_index2\
    \ = i;\n                }\n            }\n            if even_smallest_value ==\
    \ i {\n                if smalest_value_index3 < i {\n                    smalest_value_index3\
    \ = i;\n                }\n            }\n            if even_smallest_value ==\
    \ i {\n                if smalest_value_index4 < i {\n                    smalest_value_index4\
    \ = i;\n                }\n            }\n        }\n    }\n    vec![smalest_value,\
    \ smalest_value_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `smalest_value` in this scope\n  --> /tmp/tmpi0zbw6s5.rs:58:10\n\
    \   |\n58 |     vec![smalest_value, smalest_value_index]\n   |          ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi0zbw6s5.rs:35:9\n\
    \   |\n35 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values: Vec<isize> = Vec::new();\n    let mut even_values_indices:\
    \ Vec<isize> = Vec::new();\n    let mut min_value = i32::MAX;\n    let mut min_value_index\
    \ = 0;\n    let mut i = 1;\n    \n    for &index in &arr {\n        if index%2\
    \ == 0 {\n            even_values.push(index);\n            even_values_indices.push(index\
    \ as isize);\n        }\n    }\n    \n    let mut j = 1;\n    for &index in &arr\
    \ {\n        if index%2 == 0 {\n            if even_values[j] == 0 {\n       \
    \         min_value = index;\n                min_value_index = j;\n         \
    \   }\n            j += 1;\n        }\n    }\n    \n    if even_values.len() >\
    \ 0 {\n        return even_values_indices;\n    }\n    \n    if min_value == i32::MAX\
    \ {\n        return Vec::new();\n    }\n    \n    if min_value == 0 {\n      \
    \  return Vec::new();\n    }\n    \n    if min_value == min_value_index {\n  \
    \      return Vec::new();\n    }\n    \n    if min_value_index > min_value_index\
    \ {\n        return Vec::new();\n    }\n    \n    return even_values_indices;\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9_9purs.rs:44:29\n   |\n\
    29 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n44 |                 min_value = index;\n \
    \  |                             ^^^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb9_9purs.rs:63:21\n   |\n63 |     if min_value\
    \ == min_value_index {\n   |                     ^^^^^^^^^^^^^^^ expected `i32`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `i32` and panic if\
    \ the converted value doesn't fit\n   |\n63 |     if min_value == min_value_index.try_into().unwrap()\
    \ {\n   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = arr[0];\n    let mut min_idx = -1;\n    for i in 1..arr.len()\
    \ {\n        if arr[i] % 2 == 0 && arr[i] > min_even {\n            min_even =\
    \ arr[i];\n            min_idx = i;\n        }\n    }\n    min_idx\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp0hk789o1.rs:28:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0hk789o1.rs:35:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n35 |     min_idx\n   |     ^^^^^^^ expected struct `Vec`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index: isize = 0;\n    for (index, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            even_values.push(val);\n         \
    \   if val < smallest_value {\n                smallest_value = val;\n       \
    \         smallest_index = index;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return Vec::new();\n    }\n    let mut smallest_even_val = even_values[0];\n\
    \    let mut smallest_even_val_index: isize = 0;\n    for (index, val) in even_values.iter().enumerate()\
    \ {\n        if val == smallest_even_val {\n            smallest_even_val_index\
    \ = index;\n        }\n    }\n    even_values.remove(&smallest_even_val_index);\n\
    \    even_values.sort();\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    even_values[0]\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplisvjrpd.rs:33:22\n   |\n\
    33 |             if val < smallest_value {\n   |                      ^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&smallest_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplisvjrpd.rs:34:34\n   |\n28 |\
    \     let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = val;\n\
    \   |                                  ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *val;\n   |                                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplisvjrpd.rs:35:34\n   |\n29 |     let mut smallest_index:\
    \ isize = 0;\n   |                             ----- expected due to this type\n\
    ...\n35 |                 smallest_index = index;\n   |                      \
    \            ^^^^^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplisvjrpd.rs:46:39\n   |\n43 |     let mut smallest_even_val_index:\
    \ isize = 0;\n   |                                      ----- expected due to\
    \ this type\n...\n46 |             smallest_even_val_index = index;\n   |    \
    \                                   ^^^^^ expected `isize`, found `usize`\n\n\
    error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmplisvjrpd.rs:45:16\n\
    \   |\n45 |         if val == smallest_even_val {\n   |                ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&isize>` for `&&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplisvjrpd.rs:49:24\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut smallest = std::i32::MAX;\n    let\
    \ mut index = 0;\n    for i in 0..arr.len() {\n        if smallest > arr[i] {\n\
    \            smallest = arr[i];\n            index = i;\n        }\n    }\n  \
    \  let mut temp;\n    let mut even = false;\n    for i in 0..arr.len() {\n   \
    \     if arr[i] == smallest {\n            if even {\n                result.push(i);\n\
    \                break;\n            }\n            temp = (arr[i], i);\n    \
    \        even = true;\n        }\n    }\n    result.append(temp);\n    if arr.len()\
    \ == 0 {\n        result\n    } else {\n        result\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_4373fx4.rs:31:23\n   |\n\
    31 |         if smallest > arr[i] {\n   |                       ^^^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n31 |         if smallest > arr[i].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_4373fx4.rs:32:24\n   |\n28 |     let mut smallest = std::i32::MAX;\n\
    \   |                        ------------- expected due to this value\n...\n32\
    \ |             smallest = arr[i];\n   |                        ^^^^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_4373fx4.rs:39:22\n\
    \   |\n39 |         if arr[i] == smallest {\n   |                      ^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n39 |         if arr[i] ==\
    \ smallest.try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_4373fx4.rs:48:19\n   |\n48 |\
    \     result.append(temp);\n   |                   ^^^^ expected `&mut Vec<usize>`,\
    \ found tuple\n   |\n   = note: expected mutable reference `&mut Vec<usize>`\n\
    \                          found tuple `(isize, usize)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_4373fx4.rs:50:9\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n50 |         result\n   |         ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_4373fx4.rs:52:9\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n52 |         result\n   |         ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Your code here\n    for i in 0..arr.len() {\n        let mut smallest:\
    \ isize = 0;\n        for j in 0..i {\n            if arr[j] % 2 == 0 {\n    \
    \            smallest = j;\n            }\n        }\n        if smallest != 0\
    \ {\n            let index = i;\n            let value = arr[index];\n       \
    \     let mut count = 0;\n            for i in 0..index {\n                if\
    \ arr[i] % 2 == 0 {\n                    count += 1;\n                }\n    \
    \        }\n            if count == 0 {\n                arr.swap(i, smallest);\n\
    \            } else {\n                arr.swap(i, smallest + count);\n      \
    \      }\n        }\n    }\n    \n    arr\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwar14z8t.rs:32:28\n   |\n\
    29 |         let mut smallest: isize = 0;\n   |                           -----\
    \ expected due to this type\n...\n32 |                 smallest = j;\n   |   \
    \                         ^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwar14z8t.rs:45:29\n   |\n45 |                 arr.swap(i,\
    \ smallest);\n   |                             ^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n45 |                 arr.swap(i, smallest.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwar14z8t.rs:47:29\n   |\n47 |              \
    \   arr.swap(i, smallest + count);\n   |                             ^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n47 |           \
    \      arr.swap(i, (smallest + count).try_into().unwrap());\n   |            \
    \                 +                +++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut smalest_value\
    \ = arr[0];\n    let mut smallest_index = arr.iter().find(|x| x % 2 == 0).unwrap();\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if smalest_value ==\
    \ i {\n                // we have found the same value as the first one\n    \
    \            smallest_index = i;\n            } else {\n                smalest_value\
    \ = i;\n                smallest_index = arr.iter().find(|x| x % 2 == 0).unwrap();\n\
    \            }\n        }\n    }\n    vec![smalest_value, smallest_index]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpew42c72e.rs:31:52\n\
    \   |\n31 |     let mut smallest_index = arr.iter().find(|x| x % 2 == 0).unwrap();\n\
    \   |                                                  - ^ - {integer}\n   | \
    \                                                 |\n   |                    \
    \                              &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `x`\n   |\n31 |     let mut smallest_index = arr.iter().find(|x|\
    \ *x % 2 == 0).unwrap();\n   |                                               \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpew42c72e.rs:32:9\n   |\n\
    32 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpew42c72e.rs:36:34\n   |\n31 |     let mut smallest_index = arr.iter().find(|x|\
    \ x % 2 == 0).unwrap();\n   |                              ----------------------------------------\
    \ expected due to this value\n...\n36 |                 smallest_index = i;\n\
    \   |                                  ^\n   |                               \
    \   |\n   |                                  expected `&isize`, found `isize`\n\
    \   |                                  help: consider borrowing here: `&i`\n\n\
    error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpew42c72e.rs:39:56\n\
    \   |\n39 |                 smallest_index = arr.iter().find(|x| x % 2 == 0).unwrap();\n\
    \   |                                                      - ^ - {integer}\n \
    \  |                                                      |\n   |            \
    \                                          &&isize\n   |\nhelp: `%` can be used\
    \ on `isize`, you can dereference `x`\n   |\n39 |                 smallest_index\
    \ = arr.iter().find(|x| *x % 2 == 0).unwrap();\n   |                         \
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smalest_value = arr[0];\n    let mut smallest_index = 0;\n    for\
    \ &v in arr.iter().rev() {\n        if v % 2 == 0 {\n            if smalest_value\
    \ > v {\n                smalest_value = v;\n                smallest_index =\
    \ arr.iter().rev().position(|&x| x == 0).unwrap();\n            }\n        }\n\
    \    }\n    vec![smalest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzb27_y_a.rs:37:25\n   |\n\
    37 |     vec![smalest_value, smallest_index]\n   |                         ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n37 |     vec![smalest_value,\
    \ smallest_index.try_into().unwrap()]\n   |                                  \
    \     ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index_map: HashMap<usize, usize> = HashMap::new();\n    let mut smallest_value:\
    \ isize = 0;\n    let mut smallest_index: usize = 0;\n\n    for (index, value)\
    \ in arr.iter().enumerate().rev() {\n        if value < smallest_value {\n   \
    \         smallest_value = value;\n            smallest_index = index;\n     \
    \   }\n\n        index_map.insert(value, index);\n    }\n\n    let mut plucked_value:\
    \ isize = 0;\n    let mut plucked_index: usize = 0;\n\n    let mut smallest_value:\
    \ isize = 0;\n    let mut smallest_index: usize = 0;\n\n    while index_map.contains_key(&plucked_value)\
    \ {\n        let (index, value) = index_map.get(&plucked_value);\n\n        if\
    \ value < smallest_value {\n            smallest_value = value;\n            plucked_value\
    \ = value;\n            plucked_index = index;\n            index_map.remove(&plucked_value);\n\
    \        }\n\n        index_map.remove(&value);\n    }\n\n    index_map.iter().cloned().map(|(_,\
    \ v)| *v).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpea6j5ii_.rs:27:24\n\
    \   |\n27 |     let mut index_map: HashMap<usize, usize> = HashMap::new();\n \
    \  |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpea6j5ii_.rs:27:48\n\
    \   |\n27 |     let mut index_map: HashMap<usize, usize> = HashMap::new();\n \
    \  |                                                ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpea6j5ii_.rs:32:20\n   |\n\
    32 |         if value < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpea6j5ii_.rs:33:30\n   |\n28 |  \
    \   let mut smallest_value: isize = 0;\n   |                             -----\
    \ expected due to this type\n...\n33 |             smallest_value = value;\n \
    \  |                              ^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n33 |             smallest_value\
    \ = *value;\n   |                              +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    for i in 0..arr.len() {\n        let mut ans = vec![];\n        for j in\
    \ 0..arr.len() {\n            if arr[j] % 2 == 0 {\n                ans.push(arr[j]);\n\
    \            }\n        }\n        if ans.len() == 0 {\n            return vec![];\n\
    \        }\n        if ans.len() == 1 {\n            return vec![ans[0]];\n  \
    \      }\n        if ans.iter().min().is_even() {\n            return vec![ans[0]];\n\
    \        }\n        let mut index = ans.iter().min_by_key(|x| x);\n        let\
    \ mut ans2 = vec![];\n        for a in ans {\n            if a > index {\n   \
    \             index = a;\n            }\n        }\n        ans2.push(index);\n\
    \    }\n    vec![]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpjbm71mg4.rs:40:29\n   |\n40 |         if ans.iter().min().is_even()\
    \ {\n   |                             ^^^^^^^ method not found in `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjbm71mg4.rs:46:20\n   |\n46 |\
    \             if a > index {\n   |                    ^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjbm71mg4.rs:47:25\n\
    \   |\n43 |         let mut index = ans.iter().min_by_key(|x| x);\n   |      \
    \                   ---------------------------- expected due to this value\n\
    ...\n47 |                 index = a;\n   |                         ^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = arr[0]\n    let mut min_val_i = -1\n    for i in 0..arr.len()\
    \ {\n        if arr[i] < min_val {\n            min_val = arr[i];\n          \
    \  min_val_i = i;\n        }\n    }\n    return vec![min_val, min_val_i];\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9d41y16p.rs:27:29\n\
    \   |\n27 |     let mut min_val = arr[0]\n   |                             ^ help:\
    \ add `;` here\n28 |     let mut min_val_i = -1\n   |     --- unexpected token\n\
    \nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp9d41y16p.rs:28:27\n\
    \   |\n28 |     let mut min_val_i = -1\n   |                           ^ help:\
    \ add `;` here\n29 |     for i in 0..arr.len() {\n   |     --- unexpected token\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp9d41y16p.rs:28:25\n\
    \   |\n28 |     let mut min_val_i = -1\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9d41y16p.rs:35:26\n   |\n35 |     return vec![min_val, min_val_i];\n\
    \   |                          ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n35 |     return vec![min_val, min_val_i.try_into().unwrap()];\n\
    \   |                                   ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_index = 0;\n    let mut smallest_even_value = arr[0];\n    \n\
    \    for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n            if smallest_even_value\
    \ < i {\n                smallest_even_value = i;\n                min_index =\
    \ i;\n            }\n        } else {\n            if i != min_index {\n     \
    \           min_index = i;\n            }\n        }\n    }\n\n    Vec::new().push(smallest_even_value).push(min_index)\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmp2fwm3of9.rs:43:42\n   |\n43 |     Vec::new().push(smallest_even_value).push(min_index)\n\
    \   |                                          ^^^^ method not found in `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::with_capacity(arr.len());\n    let mut index =\
    \ 0;\n    for (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 {\n \
    \           even_values.push(v);\n            index = i;\n        }\n    }\n \
    \   if even_values.len() == 0 {\n        return vec![];\n    }\n    let mut smallest_value\
    \ = even_values[0];\n    let mut smallest_index = 0;\n    for v in even_values.iter()\
    \ {\n        if v < smallest_value {\n            smallest_value = v;\n      \
    \      smallest_index = index;\n        }\n        index += 1;\n    }\n    return\
    \ vec![smallest_value, smallest_index];\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpue60az5t.rs:41:16\n   |\n\
    41 |         if v < smallest_value {\n   |                ^^^^^^^^^^^^^^\n   |\
    \                |\n   |                expected `&isize`, found `isize`\n   |\
    \                help: consider borrowing here: `&smallest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpue60az5t.rs:42:30\n   |\n38 |     let mut smallest_value\
    \ = even_values[0];\n   |                              -------------- expected\
    \ due to this value\n...\n42 |             smallest_value = v;\n   |         \
    \                     ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n42 |             smallest_value = *v;\n   |\
    \                              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpue60az5t.rs:47:33\n\
    \   |\n47 |     return vec![smallest_value, smallest_index];\n   |           \
    \                      ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n47 |     return vec![smallest_value, smallest_index.try_into().unwrap()];\n\
    \   |                                               ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ret = vec![];\n    let mut smallest = std::i32::MAX;\n    let mut\
    \ largest = std::i32::MIN;\n    let mut idx = 0;\n    for ele in arr {\n     \
    \   if ele < smallest {\n            smallest = ele;\n        }\n        if ele\
    \ > largest {\n            largest = ele;\n        }\n        if ele == smallest\
    \ {\n            idx += 1;\n        }\n    }\n    ret.push(smallest);\n    ret.push(idx);\n\
    \    if idx != arr.len() {\n        let mut smallest_even_val = smallest;\n  \
    \      let mut smallest_even_val_idx = idx;\n        for i in 0 .. idx {\n   \
    \         if smallest_even_val == 0 {\n                smallest_even_val = arr[i];\n\
    \                smallest_even_val_idx = i;\n            }\n            if arr[i]\
    \ % 2 == 0 {\n                smallest_even_val = 0;\n            }\n        }\n\
    \        ret.push(smallest_even_val);\n        ret.push(smallest_even_val_idx);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcvpp67yq.rs:32:18\n   |\n\
    32 |         if ele < smallest {\n   |                  ^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n32 |         if ele < smallest.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcvpp67yq.rs:33:24\n   |\n28 |     let mut smallest = std::i32::MAX;\n\
    \   |                        ------------- expected due to this value\n...\n33\
    \ |             smallest = ele;\n   |                        ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvpp67yq.rs:35:18\n\
    \   |\n35 |         if ele > largest {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n35 |         if ele > largest.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcvpp67yq.rs:36:23\n   |\n29 |     let mut largest = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n36\
    \ |             largest = ele;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvpp67yq.rs:38:19\n\
    \   |\n38 |         if ele == smallest {\n   |                   ^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n38 |         if ele == smallest.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcvpp67yq.rs:44:15\n   |\n44 |     if idx != arr.len() {\n\
    \   |               ^^^^^^^^^ expected `i32`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `i32` and panic if the converted value doesn't fit\n\
    \   |\n44 |     if idx != arr.len().try_into().unwrap() {\n   |              \
    \          ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = arr.clone();\n    let mut smallest_even_value\
    \ = smallest_even_value.iter().cloned().collect::<Vec<_>>();\n    let mut smallest_even_value\
    \ = smallest_even_value.iter().cloned().collect::<Vec<_>>();\n    let mut smallest_index\
    \ = smallest_even_value.clone();\n\n    let mut smallest_even_value = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut smallest_even_value = smallest_even_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut smallest_even_value = smallest_even_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut smallest_index = smallest_even_value.clone();\n\n    for i in 1..arr.len()\
    \ {\n        if i % 2 == 0 {\n            smallest_even_value.insert(i, &arr[i]);\n\
    \        }\n        if i / 2 % 2 == 0 {\n            if smallest_even_value.iter().cloned().collect::<Vec<_>>().iter().cloned().min().unwrap()\
    \ < &smallest_even_value[smallest_even_value.iter().cloned().iter().cloned().min_by_key(|&i|\
    \ &i).unwrap()]\n            {\n                smallest_even_value[smallest_even_value.iter().cloned().iter().cloned().min_by_key(|&i|\
    \ &i).unwrap()] = &arr[i];\n                smallest_index[smallest_even_value.iter().cloned().iter().cloned().min_by_key(|&i|\
    \ &i).unwrap()] = i;\n            }\n        }\n    }\n    smallest_even_value\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsa81f667.rs:39:43\n   |\n\
    39 |             smallest_even_value.insert(i, &arr[i]);\n   |               \
    \                            ^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider removing the borrow\n   |\n39 -             smallest_even_value.insert(i,\
    \ &arr[i]);\n39 +             smallest_even_value.insert(i, arr[i]);\n   | \n\n\
    error[E0599]: no method named `iter` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpsa81f667.rs:42:162\n   |\n42 | ...smallest_even_value.iter().cloned().iter().cloned().min_by_key(|&i|\
    \ &i).unwrap()]\n   |                                        ^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpsa81f667.rs:44:73\n\
    \   |\n44 |                 smallest_even_value[smallest_even_value.iter().cloned().iter().cloned().min_by_key(|&i|\
    \ &i).unwrap()] = &arr[i];\n   |                                             \
    \                            ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `iter` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpsa81f667.rs:45:68\n   |\n45 |             \
    \    smallest_index[smallest_even_value.iter().cloned().iter().cloned().min_by_key(|&i|\
    \ &i).unwrap()] = i;\n   |                                                   \
    \                 ^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value_pos = 0;\n    let mut\
    \ max_value_pos = 0;\n\n    for x in arr {\n        if x % 2 == 0 {\n        \
    \    if x <= min_value {\n                min_value = x;\n                min_value_pos\
    \ = 0;\n            }\n        } else {\n            if x > min_value {\n    \
    \            if x <= min_value {\n                    min_value = x;\n       \
    \             min_value_pos = 0;\n                } else {\n                 \
    \   if max_value_pos < min_value_pos {\n                        max_value_pos\
    \ = min_value_pos;\n                    }\n                }\n            }\n\
    \        }\n    }\n\n    if max_value_pos == 0 {\n        return vec![];\n   \
    \ }\n\n    if min_value % 2 == 0 {\n        max_value_pos -= 1;\n    }\n\n   \
    \ let mut retval = vec![];\n    for i in 0..max_value_pos {\n        retval.push(i);\n\
    \    }\n\n    return retval;\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj6yf24p9.rs:33:21\n   |\n\
    33 |             if x <= min_value {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n33 |             if x <= min_value.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj6yf24p9.rs:34:29\n   |\n27 |     let mut min_value = i32::MAX;\n\
    \   |                         -------- expected due to this value\n...\n34 | \
    \                min_value = x;\n   |                             ^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj6yf24p9.rs:38:20\n\
    \   |\n38 |             if x > min_value {\n   |                    ^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n38 |             if x >\
    \ min_value.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj6yf24p9.rs:39:25\n   |\n39 |\
    \                 if x <= min_value {\n   |                         ^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n39 |                 if\
    \ x <= min_value.try_into().unwrap() {\n   |                                 \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj6yf24p9.rs:40:33\n\
    \   |\n27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n40 |                     min_value = x;\n \
    \  |                                 ^ expected `i32`, found `isize`\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() <= 0 {\n        return vec![];\n    }\n    let mut even = vec![false;\
    \ arr.len()];\n    for &item in &arr {\n        if item % 2 == 0 {\n         \
    \   even[item as usize] = true;\n        }\n    }\n    even = even.iter().filter(|&x|\
    \ x).collect();\n    even.sort();\n    let mut min = even.iter().nth(even.len()\
    \ - 1).unwrap();\n    let mut index = -1;\n    for &x in even {\n        if x\
    \ {\n            if index == -1 {\n                index = x;\n            }\n\
    \            else {\n                if x < min {\n                    min = x;\n\
    \                }\n            }\n        }\n    }\n    vec![min, index]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpumr53xbb.rs:36:36\n   |\n\
    36 |     even = even.iter().filter(|&x| x).collect();\n   |                  \
    \                  ^ expected `bool`, found `&bool`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n36 |     even = even.iter().filter(|&x| *x).collect();\n \
    \  |                                    +\n\nerror[E0277]: a value of type `Vec<bool>`\
    \ cannot be built from an iterator over elements of type `&bool`\n    --> /tmp/tmpumr53xbb.rs:36:39\n\
    \     |\n36   |     even = even.iter().filter(|&x| x).collect();\n     |     \
    \                                  ^^^^^^^ value of type `Vec<bool>` cannot be\
    \ built from `std::iter::Iterator<Item=&bool>`\n     |\n     = help: the trait\
    \ `FromIterator<&bool>` is not implemented for `Vec<bool>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpumr53xbb.rs:40:9\n\
    \   |\n40 |     for &x in even {\n   |         ^^    ---- this expression has\
    \ type `Option<bool>`\n   |         |\n   |         expected `bool`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `bool`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpumr53xbb.rs:43:25\n   |\n39 |     let mut index\
    \ = -1;\n   |                     -- expected due to this value\n...\n43 |   \
    \              index = x;\n   |                         ^ expected integer, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpumr53xbb.rs:46:24\n\
    \   |\n46 |                 if x < min {\n   |                        ^^^ expected\
    \ `bool`, found `&bool`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    46 |                 if x < *min {\n   |                        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpumr53xbb.rs:47:27\n   |\n38 |     let mut min\
    \ = even.iter().nth(even.len() - 1).unwrap();\n   |                   ----------------------------------------\
    \ expected due to this value\n...\n47 |                     min = x;\n   |   \
    \              "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values: Vec<isize> = vec![];\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = arr[0];\n    for e in arr {\n        if e % 2 ==\
    \ 0 {\n            even_values.push(e);\n        }\n        if e < min_even_value{\n\
    \            min_even_value = e;\n            min_even_index = even_values.len();\n\
    \        }\n    }\n    min_even_index = min_even_index + 1;\n    even_values.sort_unstable();\n\
    \    even_values.dedup();\n    even_values.retain();\n    even_values.sort_unstable();\n\
    \    even_values.dedup();\n    even_values.retain();\n    let mut ans: Vec<isize>\
    \ = vec![];\n    even_values.iter().cloned().for_each(|x|{\n        ans.push(x);\n\
    \    });\n    ans\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpam0h0ekb.rs:36:30\n   |\n\
    29 |     let mut min_even_index = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n36 |             min_even_index = even_values.len();\n\
    \   |                              ^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpam0h0ekb.rs:42:17\n     |\n42   |     even_values.retain();\n\
    \     |                 ^^^^^^- supplied 0 arguments\n     |                 |\n\
    \     |                 expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmpam0h0ekb.rs:45:17\n     |\n45   |     even_values.retain();\n\
    \     |                 ^^^^^^- supplied 0 arguments\n     |                 |\n\
    \     |                 expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result: Vec<isize> = vec![];\n    for i in arr {\n        if i %\
    \ 2 != 0 {\n            result.push(i);\n        }\n    }\n    result.sort();\n\
    \    if result.len() == 0 {\n        return vec![];\n    }\n    let mut smallest\
    \ = result[0];\n    let mut index = 0;\n    for i in result.iter().rev() {\n \
    \       if smallest % 2 == 0 {\n            if i.0 != smallest {\n           \
    \     index = i;\n            }\n        } else {\n            if i.0 != smallest\
    \ {\n                index = i;\n                break;\n            }\n     \
    \   }\n        smallest += 2;\n    }\n    vec![smallest, index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmp8bwy5g_l.rs:41:18\n\
    \   |\n41 |             if i.0 != smallest {\n   |                  ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8bwy5g_l.rs:42:25\n   |\n38 |     let mut index\
    \ = 0;\n   |                     - expected due to this value\n...\n42 |     \
    \            index = i;\n   |                         ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n42 |        \
    \         index = *i;\n   |                         +\n\nerror[E0609]: no field\
    \ `0` on type `&isize`\n  --> /tmp/tmp8bwy5g_l.rs:45:18\n   |\n45 |          \
    \   if i.0 != smallest {\n   |                  ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8bwy5g_l.rs:46:25\n   |\n38 |     let mut index = 0;\n\
    \   |                     - expected due to this value\n...\n46 |            \
    \     index = i;\n   |                         ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n46 |                 index\
    \ = *i;\n   |                         +\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index: Vec<isize> = Vec::new();\n    let mut mut_index: usize = 0;\n\
    \    let mut smallest_value: isize = 0;\n\n    for i in arr.iter().cloned().rev()\
    \ {\n        index.push(i);\n        if smallest_value > i {\n            smallest_value\
    \ = i;\n        }\n        if mut_index != i {\n            mut_index = i;\n \
    \       }\n    }\n    index.sort_unstable_by_key(|x| x.clone());\n    if index.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut mut_index = 0;\n    let mut\
    \ smallest_value: isize = 0;\n    for i in index.iter().cloned().rev() {\n   \
    \     if smallest_value > i {\n            smallest_value = i;\n        }\n  \
    \      if mut_index != i {\n            mut_index = i;\n        }\n    }\n   \
    \ vec![smallest_value, mut_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7mslu2el.rs:36:25\n   |\n\
    36 |         if mut_index != i {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n36 |         if mut_index != i.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7mslu2el.rs:37:25\n   |\n28 |     let mut mut_index: usize\
    \ = 0;\n   |                        ----- expected due to this type\n...\n37 |\
    \             mut_index = i;\n   |                         ^ expected `usize`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut arr = arr.to_owned();\n    arr.sort();\n    let mut smalest_value\
    \ = 0;\n    let mut smalest_index = 0;\n    let mut last_index = arr.len();\n\
    \    while smalest_value < arr[0] {\n        last_index -= 1;\n        smalest_value\
    \ = arr[last_index];\n        smalest_index = last_index;\n    }\n    smalest_index\
    \ += 1;\n    arr[smalest_index].to_owned()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgz216t_x.rs:38:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n38 |     arr[smalest_index].to_owned()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index = 0usize;\n    let mut smallest_value = 0usize;\n    let mut\
    \ smallest_index = 0usize;\n    let mut index_value = 0usize;\n\n    for i in\
    \ 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            if smallest_value\
    \ < arr[i] {\n                smallest_value = arr[i];\n                index\
    \ = i;\n                index_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n        else {\n            if index_value <\
    \ arr[i] {\n                index_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n\n    vec![smallest_value, index]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpph38k5zf.rs:34:33\n   |\n\
    34 |             if smallest_value < arr[i] {\n   |                          \
    \       ^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n34\
    \ |             if smallest_value < arr[i].try_into().unwrap() {\n   |       \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpph38k5zf.rs:35:34\n   |\n28 |     let mut smallest_value\
    \ = 0usize;\n   |                              ------ expected due to this value\n\
    ...\n35 |                 smallest_value = arr[i];\n   |                     \
    \             ^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpph38k5zf.rs:37:31\n   |\n30 |     let mut index_value =\
    \ 0usize;\n   |                           ------ expected due to this value\n\
    ...\n37 |                 index_value = arr[i];\n   |                        \
    \       ^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpph38k5zf.rs:42:30\n   |\n42 |             if index_value < arr[i]\
    \ {\n   |                              ^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n42 |             if index_value < arr[i].try_into().unwrap()\
    \ {\n   |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpph38k5zf.rs:43:31\n   |\n30 |     let mut index_value\
    \ = 0usize;\n   |                           ------ expected due to this value\n\
    ...\n43 |                 index_value = arr[i];\n   |                        \
    \       ^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpph38k5zf.rs:49:10\n   |\n49 |     vec![smallest_value, index]\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n49 |     vec![smallest_value.try_into().unwrap(), index"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smaller_nodes = Vec::new();\n    let mut index = 0;\n    let mut\
    \ even_values = 0;\n    for node in arr.iter() {\n        if even_values == 0\
    \ {\n            smaller_nodes.push(node);\n            even_values = 1;\n   \
    \         index = index + 1\n        } else if even_values == 1 && node < smaller_nodes.last()\
    \ {\n            smaller_nodes.push(node);\n            even_values = 1;\n   \
    \         index = index + 1\n        } else {\n            if node == smaller_nodes.last()\
    \ {\n                smaller_nodes.push(node);\n                even_values =\
    \ 0;\n                index = index + 1;\n            } else {\n             \
    \   if even_values > 1 {\n                    smaller_nodes.push(node);\n    \
    \                even_values = 1;\n                    index = index + 1;\n  \
    \              }\n            }\n        }\n    }\n    smaller_nodes\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps7ppq8dq.rs:35:46\n   |\n\
    35 |         } else if even_values == 1 && node < smaller_nodes.last() {\n   |\
    \                                              ^^^^^^^^^^^^^^^^^^^^ expected `&isize`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&isize`\n        \
    \           found enum `Option<&&isize>`\n\nerror[E0277]: can't compare `&isize`\
    \ with `Option<&&isize>`\n  --> /tmp/tmps7ppq8dq.rs:40:21\n   |\n40 |        \
    \     if node == smaller_nodes.last() {\n   |                     ^^ no implementation\
    \ for `&isize == Option<&&isize>`\n   |\n   = help: the trait `PartialEq<Option<&&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps7ppq8dq.rs:53:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n53 |     smaller_nodes\n   |     ^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n   \
    \           found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = arr[0];\n    let mut min_idx = 0;\n    let mut mut_idx = arr.len()\
    \ - 1;\n    loop {\n        let mut curr = arr[mut_idx];\n        if curr < min\
    \ {\n            min = curr;\n            min_idx = mut_idx;\n        }\n    \
    \    mut_idx = mut_idx % arr.len();\n    }\n    vec![min]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // TODO: Write your code here\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsma5tvxk.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::i32::MAX;\n    let mut index = 0;\n    let mut max_index\
    \ = 0;\n    let mut value = 0;\n    for x in arr.iter() {\n        if value <=\
    \ x {\n            min.store(&x, Ordering::Less);\n            index = x.to_i();\n\
    \        }\n    }\n    if index == 0 {\n        return vec![];\n    }\n    let\
    \ mut max_value = min.load();\n    for (k, v) in arr.iter().zip(&arr.iter().rev())\
    \ {\n        if *max_value < k {\n            max_value = k\n        }\n    }\n\
    \    if *max_value == min {\n        return vec![index];\n    }\n    if max_value\
    \ > min.load() {\n        return vec![max_value, index];\n    }\n    return vec![min.load(),\
    \ index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp3gevvw4q.rs:33:27\n   |\n33 |             min.store(&x, Ordering::Less);\n\
    \   |                           ^^^^^^^^ use of undeclared type `Ordering`\n\n\
    error[E0599]: no method named `store` found for type `i32` in the current scope\n\
    \  --> /tmp/tmp3gevvw4q.rs:33:17\n   |\n33 |             min.store(&x, Ordering::Less);\n\
    \   |                 ^^^^^ method not found in `i32`\n\nerror[E0277]: can't compare\
    \ `isize` with `&isize`\n  --> /tmp/tmp3gevvw4q.rs:32:18\n   |\n32 |         if\
    \ value <= x {\n   |                  ^^ no implementation for `isize < &isize`\
    \ and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `to_i`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmp3gevvw4q.rs:34:23\n\
    \   |\n34 |             index = x.to_i();\n   |                       ^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `load` found for type\
    \ `i32` in the current scope\n  --> /tmp/tmp3gevvw4q.rs:40:29\n   |\n40 |    \
    \ let mut max_value = min.load();\n   |                             ^^^^ method\
    \ not found in `i32`\n\nerror[E0277]: `&Rev<std::slice::Iter<'_, isize>>` is not\
    \ an iterator\n  --> /tmp/tmp3gevvw4q.rs:41:34\n   |\n41 |     for (k, v) in arr.iter().zip(&arr.iter().rev())\
    \ {\n   |                              --- ^^^^^^^^^^^^^^^^^ `&Rev<std::slice::Iter<'_,\
    \ isize>>` is not an iterator\n   |                              |\n   |     \
    \                         required by a bound introduced by this call\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&Rev<std::slice::Iter<'_,\
    \ isize>>`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Rev<std::slice::Iter<'_, isize>>`\nhelp: consider dereferencing here\n\
    \   |\n41"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value: isize = 0;\n    let mut smallest_index: usize = 0;\n\
    \    for &el in arr {\n        if el % 2 == 0 {\n            let mut value = el;\n\
    \            let mut index = 0;\n            loop {\n                value /=\
    \ 2;\n                index += 1\n                if value == 0 {\n          \
    \          break;\n                }\n            }\n            if value < smallest_value\
    \ {\n                smallest_value = value;\n                smallest_index =\
    \ index;\n            }\n        }\n    }\n    smallest_value.to_vec()\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpfp1z9urh.rs:35:27\n\
    \   |\n35 |                 index += 1\n   |                           ^ help:\
    \ add `;` here\n36 |                 if value == 0 {\n   |                 --\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfp1z9urh.rs:29:9\n\
    \   |\n29 |     for &el in arr {\n   |         ^^^    --- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `el`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `to_vec` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpfp1z9urh.rs:46:20\n   |\n46 |     smallest_value.to_vec()\n   |    \
    \                ^^^^^^ help: there is an associated function with a similar name:\
    \ `to_be`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smalest_value = arr[0];\n    let mut smalest_index = 0;\n\n    for\
    \ i in arr.iter().rev() {\n        if i.is_even() {\n            smalest_value\
    \ = i;\n            smalest_index = i;\n        }\n    }\n    return smalest_index\
    \ == arr.len() ? vec![] : vec![smalest_value, smalest_index];\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `vec`\n\
    \  --> /tmp/tmpcwhkryxz.rs:36:41\n   |\n36 |     return smalest_index == arr.len()\
    \ ? vec![] : vec![smalest_value, smalest_index];\n   |                       \
    \                  ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error[E0599]: no method named `is_even` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpcwhkryxz.rs:31:14\n   |\n31 |         if i.is_even() {\n\
    \   |              ^^^^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcwhkryxz.rs:32:29\n   |\n27 |     let mut smalest_value\
    \ = arr[0];\n   |                             ------ expected due to this value\n\
    ...\n32 |             smalest_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |             smalest_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcwhkryxz.rs:33:29\n   |\n28 |     let mut smalest_index\
    \ = 0;\n   |                             - expected due to this value\n...\n33\
    \ |             smalest_index = i;\n   |                             ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |             smalest_index = *i;\n   |                             +\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n\n    let mut even: Vec<isize>\
    \ = vec![];\n    for i in arr.iter() {\n        if i % 2 == 0 {\n            even.push(i);\n\
    \        }\n    }\n    if even.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let mut smalest_value = even[0];\n    let mut smalest_index = 0;\n    for\
    \ i in even.iter() {\n        if i < smalest_value {\n            smalest_value\
    \ = i;\n            smalest_index = i;\n        }\n    }\n    return vec![smalest_value,\
    \ smalest_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcpceq2qs.rs:34:23\n   |\n\
    34 |             even.push(i);\n   |                       ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |  \
    \           even.push(*i);\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcpceq2qs.rs:44:16\n   |\n44 |         if i < smalest_value\
    \ {\n   |                ^^^^^^^^^^^^^\n   |                |\n   |          \
    \      expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&smalest_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcpceq2qs.rs:45:29\n\
    \   |\n41 |     let mut smalest_value = even[0];\n   |                       \
    \      ------- expected due to this value\n...\n45 |             smalest_value\
    \ = i;\n   |                             ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n45 |             smalest_value\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcpceq2qs.rs:46:29\n   |\n42 |     let mut smalest_index = 0;\n\
    \   |                             - expected due to this value\n...\n46 |    \
    \         smalest_index = i;\n   |                             ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n46 |  \
    \           smalest_index = *i;\n   |                             +\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut results: Vec<isize> = Vec::new();\n    let mut even_values = Vec::new();\n\
    \    let mut smallest_value = 0;\n    let mut smallest_index = 0;\n\n    for x\
    \ in arr {\n        if x % 2 == 0 {\n            even_values.push(x);\n      \
    \  }\n        if x < smallest_value {\n            smallest_value = x;\n     \
    \   }\n        if x < smallest_index {\n            smallest_index = x;\n    \
    \    }\n    }\n\n    for x in even_values {\n        if x < smallest_value {\n\
    \            smallest_value = x;\n        }\n        if x < smallest_index {\n\
    \            smallest_index = x;\n        }\n    }\n\n    let mut even_values_index\
    \ = 0;\n    let mut index_of_smallest_value = 0;\n\n    while even_values_index\
    \ < even_values.len() {\n        if even_values[even_values_index] < smallest_value\
    \ {\n            smallest_value = even_values[even_values_index];\n          \
    \  index_of_smallest_value = even_values_index;\n        }\n        even_values_index\
    \ += 1;\n    }\n    even_values.retain(|&x| x != smallest_value);\n    even_values.push(smallest_value);\n\
    \    results.push(smallest_index);\n\n    return results\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "warning: variable `index_of_smallest_value` is assigned to, but never used\n\
    \  --> /tmp/tmpbbxkp6j5.rs:54:13\n   |\n54 |     let mut index_of_smallest_value\
    \ = 0;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_index_of_smallest_value` instead\n\
    \nwarning: value assigned to `index_of_smallest_value` is never read\n  --> /tmp/tmpbbxkp6j5.rs:59:13\n\
    \   |\n59 |             index_of_smallest_value = even_values_index;\n   |   \
    \          ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0382]:\
    \ borrow of moved value: `even_values`\n   --> /tmp/tmpbbxkp6j5.rs:56:31\n   \
    \ |\n28  |     let mut even_values = Vec::new();\n    |         ---------------\
    \ move occurs because `even_values` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n44  |     for x in even_values {\n    |             \
    \ ----------- `even_values` moved due to this implicit call to `.into_iter()`\n\
    ...\n56  |     while even_values_index < even_values.len() {\n    |          \
    \                     ^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_values`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n44  |     for x in &even_values {\n    |       \
    \       +\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut even_values\
    \ = HashSet::new();\n    let mut largest_idx = 0;\n    for &value in arr.iter().filter(|&value|\
    \ value != 0) {\n        even_values.insert(value);\n        if value > largest_idx\
    \ {\n            largest_idx = value;\n        }\n    }\n    if even_values.len()\
    \ < 2 {\n        return vec![];\n    }\n    let mut smallest_even_value = even_values.next().unwrap();\n\
    \    let mut smallest_idx = 0;\n    for &value in arr.iter().filter(|&value| value\
    \ != 0) {\n        if value < smallest_even_value {\n            smallest_even_value\
    \ = value;\n            smallest_idx = largest_idx - even_values.count() - 1;\n\
    \        }\n    }\n    let mut result = vec![];\n    for &value in arr.iter().filter(|&value|\
    \ value != 0) {\n        if value == smallest_even_value {\n            result.push(smallest_idx);\n\
    \        }\n    }\n    if result.is_empty() {\n        return vec![];\n    }\n\
    \    result.sort_unstable();\n    vec![smallest_even_value, smallest_idx].to_owned()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp317m8gsi.rs:30:27\n   |\n30 |     let mut even_values = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmp317m8gsi.rs:32:52\n \
    \  |\n32 |     for &value in arr.iter().filter(|&value| value != 0) {\n   |  \
    \                                                  ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp317m8gsi.rs:43:52\n   |\n43 |     for &value in arr.iter().filter(|&value|\
    \ value != 0) {\n   |                                                    ^^ no\
    \ implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp317m8gsi.rs:50:52\n   |\n50 |     for &value\
    \ in arr.iter().filter(|&value| value != 0) {\n   |                          \
    \                          ^^ no implementation for `&isize == {integer}`\n  \
    \ |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 4 pr"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Write your code here.\n    let mut min_so_far = i32::MAX;\n    let mut\
    \ min_idx: isize = 0;\n    for i in 0..arr.len() {\n        if min_so_far > arr[i]\
    \ {\n            min_so_far = arr[i];\n            min_idx = i;\n        }\n \
    \   }\n    vec![min_idx, min_so_far]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3wadws8.rs:31:25\n   |\n\
    31 |         if min_so_far > arr[i] {\n   |                         ^^^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n31 |         if min_so_far >\
    \ arr[i].try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd3wadws8.rs:32:26\n   |\n28 |\
    \     let mut min_so_far = i32::MAX;\n   |                          -------- expected\
    \ due to this value\n...\n32 |             min_so_far = arr[i];\n   |        \
    \                  ^^^^^^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd3wadws8.rs:33:23\n   |\n29 |     let mut min_idx: isize\
    \ = 0;\n   |                      ----- expected due to this type\n...\n33 | \
    \            min_idx = i;\n   |                       ^ expected `isize`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd3wadws8.rs:36:19\n\
    \   |\n36 |     vec![min_idx, min_so_far]\n   |                   ^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n36 |     vec![min_idx, min_so_far.try_into().unwrap()]\n\
    \   |                             ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz2gqt38_.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smaller_value = vec![];\n    let\
    \ mut smaller_value_len = isize::MAX;\n    for i in arr {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smaller_value_len\
    \ {\n                smaller_value.push(i);\n                smaller_value_len\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() > 0 {\n    \
    \    smaller_value.push(smaller_value_len);\n    }\n    if smaller_value.len()\
    \ == 0 {\n        return even_values;\n    }\n    for i in 0..even_values.len()\
    \ {\n        for j in 0..smaller_value.len() {\n            if even_values[i]\
    \ == smaller_value[j] {\n                return even_values.iter().cloned().collect::<Vec<_>>();\n\
    \            }\n        }\n    }\n    even_values.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2]`,\n right: `[2, 1]`', /tmp/tmpgi7dizew.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| x.checked_mul(2).unwrap());\n    let mut evens = Vec::new();\n\
    \    let mut index = Vec::new();\n    for x in arr {\n        if x.checked_mul(2).unwrap().is_zero()\
    \ {\n            evens.push(x);\n            index.push(*evens.iter().cloned().min().unwrap());\n\
    \        } else {\n            break;\n        }\n    }\n    if evens.is_empty()\
    \ {\n        evens.push(0);\n        index.push(0);\n    }\n    evens\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp_0y81f63.rs:31:38\n   |\n31 |         if x.checked_mul(2).unwrap().is_zero()\
    \ {\n   |                                      ^^^^^^^ method not found in `isize`\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp_0y81f63.rs:33:24\n\
    \   |\n33 |             index.push(*evens.iter().cloned().min().unwrap());\n \
    \  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut pivot_idx = 0u;\n    let mut result = vec![];\n    for idx in arr.iter().rev()\
    \ {\n        let val = arr[idx];\n        if val % 2 == 0 {\n            result.push((val,\
    \ (pivot_idx + idx) as isize));\n        }\n        pivot_idx = idx;\n    }\n\
    \    if pivot_idx == 0 {\n        result.push(vec![]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmpmwj9zs1p.rs:27:25\n\
    \   |\n27 |     let mut pivot_idx = 0u;\n   |                         ^^ invalid\
    \ suffix `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`,\
    \ `isize`, `f32`, etc.)\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpmwj9zs1p.rs:30:19\n   |\n30 |         let val = arr[idx];\n\
    \   |                   ^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpmwj9zs1p.rs:36:18\n   |\n36 |     if pivot_idx == 0 {\n   |   \
    \               ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmwj9zs1p.rs:37:21\n   |\n37 |\
    \         result.push(vec![]);\n   |                     ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected tuple `(_, isize)`\n         \
    \    found struct `Vec<_>`\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmwj9zs1p.rs:39:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n39 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found tuple\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<(_, isize)>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 || arr.iter().any(|x| x == 0) {\n        return vec![];\n\
    \    }\n    let mut index = 0;\n    let mut smallest_value: isize = 0;\n    let\
    \ mut smallest_index: usize = 0;\n    for (i, v) in arr.iter().enumerate() {\n\
    \        if v == 0 {\n            continue;\n        }\n        if v < smallest_value\
    \ {\n            smallest_value = v;\n            smallest_index = i;\n      \
    \  }\n    }\n    let mut result = vec![];\n    for v in arr.iter().skip(smallest_index\
    \ + 1) {\n        if v == 0 {\n            return result;\n        }\n       \
    \ result.push(v);\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwio4gn5g.rs:27:47\n\
    \   |\n27 |     if arr.len() == 0 || arr.iter().any(|x| x == 0) {\n   |      \
    \                                         ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpwio4gn5g.rs:34:14\n   |\n34 |         if v == 0 {\n   |       \
    \       ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait\
    \ `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwio4gn5g.rs:37:16\n   |\n37 |         if v <\
    \ smallest_value {\n   |                ^^^^^^^^^^^^^^\n   |                |\n\
    \   |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&smallest_value`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwio4gn5g.rs:38:30\n   |\n31 |     let mut smallest_value: isize\
    \ = 0;\n   |                             ----- expected due to this type\n...\n\
    38 |             smallest_value = v;\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    38 |             smallest_value = *v;\n   |                              +\n\n\
    error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwio4gn5g.rs:44:14\n\
    \   |\n44 |         if v == 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() { return vec![] }\n    let mut smallest = isize::MAX;\n\
    \    let mut min_idx = 0;\n    for i in arr.iter() {\n        if smallest < i\
    \ {\n            smallest = i;\n            min_idx = i;\n        }\n    }\n \
    \   let mut mut_idx = 0;\n    for e in arr.iter() {\n        if e == smallest\
    \ {\n            mut_idx += 1;\n        }\n    }\n    vec![smallest, min_idx,\
    \ mut_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb663nyrx.rs:31:23\n   |\n\
    31 |         if smallest < i {\n   |                       ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \       if smallest < *i {\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb663nyrx.rs:32:24\n   |\n28 |     let mut smallest = isize::MAX;\n\
    \   |                        ---------- expected due to this value\n...\n32 |\
    \             smallest = i;\n   |                        ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \     smallest = *i;\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb663nyrx.rs:33:23\n   |\n29 |     let mut min_idx = 0;\n\
    \   |                       - expected due to this value\n...\n33 |          \
    \   min_idx = i;\n   |                       ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |             min_idx\
    \ = *i;\n   |                       +\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpb663nyrx.rs:38:14\n   |\n38 |         if e == smallest\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_index = 0;\n    let mut min_value = arr[0];\n    for (i, &val)\
    \ in arr.iter().enumerate() {\n        let mut even_values = false;\n        for\
    \ (j, &even) in arr.iter().skip(i + 1).enumerate() {\n            if even {\n\
    \                even_values = true;\n            }\n        }\n        if !even_values\
    \ {\n            min_index = i;\n            min_value = val;\n        }\n   \
    \ }\n    \n    \n    let mut even_values = false;\n    for (j, &even) in arr.iter().skip(1).enumerate()\
    \ {\n        if even {\n            even_values = true;\n        }\n    }\n  \
    \  if !even_values {\n        return vec![min_value, min_index];\n    } else {\n\
    \        let mut even_values_idx = 1;\n        let mut next_value = min_value;\n\
    \        let mut current_index = min_index;\n        for (j, &even) in arr.iter().skip(1).enumerate()\
    \ {\n            if even {\n                even_values_idx += 1;\n          \
    \      if even_values_idx == 2 {\n                    current_index = j;\n   \
    \                 break;\n                } else {\n                    next_value\
    \ = even_values_idx;\n                }\n            }\n        }\n        let\
    \ mut res = vec![next_value, current_index];\n        \n        if res.len() ==\
    \ 2 {\n            if res[0] < res[1] {\n                res.swap(0, 1);\n   \
    \         }\n        } else {\n            res.swap(0, 1);\n        }\n      \
    \  \n        return res;\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4smcitgu.rs:32:16\n   |\n\
    32 |             if even {\n   |                ^^^^ expected `bool`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4smcitgu.rs:45:12\n   |\n45 |\
    \         if even {\n   |            ^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4smcitgu.rs:50:32\n   |\n50 |         return\
    \ vec![min_value, min_index];\n   |                                ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n50 |         return vec![min_value,\
    \ min_index.try_into().unwrap()];\n   |                                      \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4smcitgu.rs:56:16\n\
    \   |\n56 |             if even {\n   |                ^^^^ expected `bool`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4smcitgu.rs:66:40\n\
    \   |\n66 |         let mut res = vec![next_value, current_index];\n   |     \
    \                                   ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens: Vec<isize> = vec![];\n    for i in arr {\n        if i %2\
    \ != 0 {\n            evens.push(i);\n        }\n    }\n\n    let mut min = evens.iter().min().unwrap();\n\
    \    let mut min_index = evens.iter().position(|&x| x == min).unwrap();\n    let\
    \ mut evens_index = evens.iter().position(|&x| x == min).unwrap();\n    if evens_index\
    \ >= arr.len() {\n        evens_index = 0;\n    }\n\n    let mut ret: Vec<isize>\
    \ = vec![];\n    ret.push(min);\n    ret.push(min_index);\n    return ret;\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmw124dvf.rs:35:57\n   |\n\
    35 |     let mut min_index = evens.iter().position(|&x| x == min).unwrap();\n\
    \   |                                                         ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \   let mut min_index = evens.iter().position(|&x| x == *min).unwrap();\n   |\
    \                                                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmw124dvf.rs:36:59\n   |\n36 |     let mut evens_index =\
    \ evens.iter().position(|&x| x == min).unwrap();\n   |                       \
    \                                    ^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n36 |     let mut evens_index\
    \ = evens.iter().position(|&x| x == *min).unwrap();\n   |                    \
    \                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmw124dvf.rs:42:14\n   |\n42 |     ret.push(min);\n   |        \
    \      ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n42 |     ret.push(*min);\n   |              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmw124dvf.rs:43:14\n   |\n43 |     ret.push(min_index);\n\
    \   |              ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n43 |     ret.push(min_index.try_into().unwrap());\n   |         \
    \              ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smaller_values = std::mem::MaybeUninit::<isize>::uninit();\n    let\
    \ mut smaller_index = std::mem::MaybeUninit::<usize>::uninit();\n    for &v in\
    \ &arr {\n        if smaller_values.is_uninit() {\n            smaller_values\
    \ = v;\n            smaller_index = 0;\n        }\n        if v < smaller_values.as_ref()\
    \ {\n            smaller_values = v;\n            smaller_index = 0;\n       \
    \ }\n        if v == smaller_values.as_ref() {\n            smaller_index += 1;\n\
    \        }\n    }\n    let mut results: Vec<isize> = Vec::new();\n    let mut\
    \ found_values = false;\n    for &v in &arr {\n        if v == smaller_values.as_ref()\
    \ {\n            if found_values {\n                results.push(smaller_index);\n\
    \            } else {\n                results.push(smaller_values.as_ref());\n\
    \                found_values = true;\n            }\n        }\n    }\n    results\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uninit` found for union `MaybeUninit`\
    \ in the current scope\n  --> /tmp/tmp3zlnva_z.rs:30:27\n   |\n30 |         if\
    \ smaller_values.is_uninit() {\n   |                           ^^^^^^^^^ method\
    \ not found in `MaybeUninit<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3zlnva_z.rs:31:30\n\
    \   |\n27 |     let mut smaller_values = std::mem::MaybeUninit::<isize>::uninit();\n\
    \   |                              ---------------------------------------- expected\
    \ due to this value\n...\n31 |             smaller_values = v;\n   |         \
    \                     ^ expected union `MaybeUninit`, found `isize`\n   |\n  \
    \ = note: expected union `MaybeUninit<isize>`\n               found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3zlnva_z.rs:32:29\n   |\n28 |\
    \     let mut smaller_index = std::mem::MaybeUninit::<usize>::uninit();\n   |\
    \                             ---------------------------------------- expected\
    \ due to this value\n...\n32 |             smaller_index = 0;\n   |          \
    \                   ^ expected union `MaybeUninit`, found integer\n   |\n   =\
    \ note: expected union `MaybeUninit<usize>`\n               found type `{integer}`\n\
    \nerror[E0599]: no method named `as_ref` found for union `MaybeUninit` in the\
    \ current scope\n  --> /tmp/tmp3zlnva_z.rs:34:31\n   |\n34 |         if v < smaller_values.as_ref()\
    \ {\n   |                               ^^^^^^ method not found in `MaybeUninit<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3zlnva_z.rs:35:30\n   |\n27 |\
    \     let mut smaller_values = std::mem::MaybeUninit::<isize>::uninit();\n   |\
    \                              ---------------------------------------- expected\
    \ due to this value\n...\n35 |             smaller_values = v;\n   |         \
    \                     ^ expected union `MaybeUninit`, found `isize`\n   |\n  \
    \ = note: expected union `MaybeUninit<isize>`\n               found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3zlnva_z.rs:36:29\n   |\n28 |\
    \     let mut smaller_index = std::mem::MaybeUninit::<usize>::uninit();\n   |\
    \                        "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort().to_vec()\n        .into_iter()\n        .enumerate()\n       \
    \ .take_while(|&(index, val)| val % 2 == 0)\n        .collect::<Vec<_>>()\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_vec` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpw_59w01u.rs:27:16\n   |\n27 |     arr.sort().to_vec()\n\
    \   |                ^^^^^^ method not found in `()`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut largest = arr.iter().max_by_key(|x| x as isize);\n    let mut smallest\
    \ = arr.iter().min_by_key(|x| x as isize);\n    let mut smalest_value = largest.clone();\n\
    \    let mut smalest_index = -1;\n    for (i, n) in arr.iter().enumerate() {\n\
    \        if n & 1 != 0 {\n            smalest_index = i;\n            smalest_value\
    \ = n;\n        }\n        if n == smallest {\n            smallest = n;\n   \
    \     }\n        if n > smallest {\n            largest = n;\n        }\n    }\n\
    \    if smallest == smalest_value {\n        vec![smalest_value, smalest_index]\n\
    \    } else {\n        vec![smalest_index, smalest_value]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxkyj3seu.rs:34:29\n   |\n\
    29 |     let mut smalest_value = largest.clone();\n   |                      \
    \       --------------- expected due to this value\n...\n34 |             smalest_value\
    \ = n;\n   |                             ^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n34 |          \
    \   smalest_value = Some(n);\n   |                             +++++ +\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpxkyj3seu.rs:30:29\n\
    \   |\n30 |     let mut smalest_index = -1;\n   |                            \
    \ ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxkyj3seu.rs:37:24\n   |\n28 |     let mut smallest\
    \ = arr.iter().min_by_key(|x| x as isize);\n   |                        -------------------------------------\
    \ expected due to this value\n...\n37 |             smallest = n;\n   |      \
    \                  ^ expected enum `Option`, found `&isize`\n   |\n   = note:\
    \   expected enum `Option<&isize>`\n           found reference `&isize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n37 |             smallest = Some(n);\n\
    \   |                        +++++ +\n\nerror[E0277]: can't compare `&isize` with\
    \ `Option<&isize>`\n  --> /tmp/tmpxkyj3seu.rs:36:14\n   |\n36 |         if n ==\
    \ smallest {\n   |              ^^ no implementation for `&isize == Option<&isize>`\n\
    \   |\n   = help: the trait `PartialEq<Option<&isize>>` is not implemented for\
    \ `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index = -1;\n    let mut smalest_value = arr[0];\n    let mut smalest_index\
    \ = 0;\n    arr.iter().for_each(|value| {\n        if value == smalest_value {\n\
    \            index = arr.iter().position(|x| x == smalest_value);\n        }\n\
    \        if value != smalest_value {\n            smalest_value = value;\n   \
    \         smalest_index = index;\n        }\n    });\n    vec![smalest_value,\
    \ smalest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpnmzeortm.rs:31:18\n\
    \   |\n31 |         if value == smalest_value {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpnmzeortm.rs:32:47\n   |\n32 |             index\
    \ = arr.iter().position(|x| x == smalest_value);\n   |                       \
    \                        ^^ no implementation for `&isize == isize`\n   |\n  \
    \ = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnmzeortm.rs:32:21\n   |\n27 |\
    \     let mut index = -1;\n   |                     -- expected due to this value\n\
    ...\n32 |             index = arr.iter().position(|x| x == smalest_value);\n \
    \  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpnmzeortm.rs:35:29\n   |\n28 |     let mut smalest_value = arr[0];\n\
    \   |                             ------ expected due to this value\n...\n35 |\
    \             smalest_value = value;\n   |                             ^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |             smalest_value = *value;\n   |                             +\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpnmzeortm.rs:34:18\n\
    \   |\n34 |         if value != smalest_value {\n   |              "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest: isize = 0;\n    let mut smallest_value: isize = 0;\n  \
    \  let mut smallest_index: isize = 0;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v%2 == 0 {\n            if smallest_value <= v {\n           \
    \     smallest_value = v;\n                smallest_index = i;\n            }\n\
    \        }\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg5qdsldh.rs:34:34\n   |\n\
    29 |     let mut smallest_index: isize = 0;\n   |                            \
    \ ----- expected due to this type\n...\n34 |                 smallest_index =\
    \ i;\n   |                                  ^ expected `isize`, found `usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut largest_val\
    \ = 0;\n    let mut smallest_index = 0;\n\n    for i in 0..arr.len() {\n     \
    \   largest_val = if i % 2 == 0 {\n            arr.swap(0, i);\n            arr.swap(i,\
    \ i + 1);\n            arr.swap(i + 1, i + 2);\n            arr.swap(i + 2, i\
    \ + 3);\n            arr.swap(i + 3, i + 4);\n            arr.swap(i + 4, i +\
    \ 5);\n            arr.swap(i + 5, i + 6);\n            arr.swap(i + 6, i + 7);\n\
    \            arr.swap(i + 7, i + 8);\n            arr.swap(i + 8, i + 9);\n  \
    \          arr.swap(i + 9, i + 10);\n            arr.swap(i + 10, i + 11);\n \
    \           arr.swap(i + 11, i + 12);\n            arr.swap(i + 12, i + 13);\n\
    \            arr.swap(i + 13, i + 14);\n            arr.swap(i + 14, i + 15);\n\
    \            arr.swap(i + 15, i + 16);\n            arr.swap(i + 16, i + 17);\n\
    \            arr.swap(i + 17, i + 18);\n            arr.swap(i + 18, i + 19);\n\
    \            arr.swap(i + 19, i + 20);\n            arr.swap(i + 20, i + 21);\n\
    \            arr.swap(i + 21, i + 22);\n            arr.swap(i + 22, i + 23);\n\
    \            arr.swap(i + 23, i + 24);\n            arr.swap(i + 24, i + 25);\n\
    \            arr.swap(i + 25, i + 26);\n            arr.swap(i + 26, i + 27);\n\
    \            arr.swap(i + 27, i + 28);\n            arr.swap(i + 28, i + 29);\n\
    \            arr.swap(i + 29, i + 30);\n            arr.swap(i + 30, i + 31);\n\
    \            arr.swap(i + 31, i + 32);\n            arr.swap(i + 32, i + 33);\n\
    \            arr.swap(i + 33, i + 34);\n            arr.swap(i + 34, i + 35);\n\
    \            arr.swap(i + 35, i + 36);\n            arr.swap(i + 36, i + 37);\n\
    \            arr.swap(i + 37, i + 38);\n            arr.swap(i + 38, i + 39);\n\
    \            arr.swap(i + 39, i + 40);\n            arr.swap(i + 40, i + 41);\n\
    \            arr.swap(i + 41, i + 42);\n            arr.swap(i + 42, i + 43);\n\
    \            arr.swap(i + 43, i + 44);\n            arr.swap(i + 44, i + 45);\n\
    \            arr.swap(i + 45, i + 46);\n            arr.swap(i + 46, i + 47);\n\
    \            arr.swap(i + 47, i + \n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg_gfj54f.rs:94:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n31 |     for i in 0..arr.len()\
    \ {\n   |                           - unclosed delimiter\n32 |         largest_val\
    \ = if i % 2 == 0 {\n   |                                     - this delimiter\
    \ might not be properly closed...\n...\n82 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n94 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpg_gfj54f.rs:81:21\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                         - closing delimiter\
    \ possibly meant for this\n...\n81 |             arr.swap(i + 47, i + \n   | \
    \                    ^ unclosed delimiter\n82 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected expression, found `)`\n  --> /tmp/tmpg_gfj54f.rs:82:1\n   |\n\
    82 | }\n   | ^ expected expression\n\nerror: expected one of `.`, `;`, `?`, `else`,\
    \ `}`, or an operator, found keyword `fn`\n  --> /tmp/tmpg_gfj54f.rs:26:41\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                   \
    \                      ^ unclosed delimiter\n...\n82 | }\n   |  -\n   |  |\n \
    \  |  expected one of `.`, `;`, `?`, `else`, `}`, or an operator\n   |  help:\
    \ `}` may belong here\n83 | \n84 | fn main() {\n   | ^^ unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg_gfj54f.rs:31:5\n   |\n26 |   fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                ----------\
    \ expected `Vec<isize>` because of return type\n...\n31 | /     for i in 0..arr.len()\
    \ {\n32 | |         largest_val = if i % 2 == 0 {\n33 | |             arr.swap(0,\
    \ i);\n34 | |             arr.swap(i, i + 1);\n...  |\n93 | |     assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n94 | | }\n   | |__^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc -"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_value = std::collections::HashSet::new();\n    let mut smallest_value\
    \ = std::collections::HashSet::new();\n    let mut smallest_index = std::collections::HashSet::new();\n\
    \    for i in 0..arr.len() {\n        if even_value.contains(&arr[i]) {\n    \
    \        smallest_value.insert(arr[i]);\n            smallest_index.insert(i);\n\
    \        } else if smallest_value.contains(&arr[i]) {\n            smallest_value\
    \ = smallest_value.insert(arr[i]);\n            smallest_index = smallest_index.insert(i);\n\
    \        }\n    }\n    if !even_value.is_empty() {\n        for i in 0..arr.len()\
    \ {\n            if smallest_value.contains(&arr[i]) {\n                smallest_value\
    \ = smallest_value.insert(arr[i]);\n            }\n        }\n        let mut\
    \ smalest_value = smallest_value.min_by(|x, y| x.cmp(y)).unwrap();\n        let\
    \ mut smalest_index = smallest_index.min_by(|x, y| x.cmp(y)).unwrap();\n     \
    \   return vec![smalest_value, smalest_index];\n    }\n    return vec![];\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0siuu3k4.rs:35:30\n   |\n\
    28 |     let mut smallest_value = std::collections::HashSet::new();\n   |    \
    \                          -------------------------------- expected due to this\
    \ value\n...\n35 |             smallest_value = smallest_value.insert(arr[i]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `HashSet`, found `bool`\n   |\n   = note: expected struct `HashSet<isize>`\n\
    \                found type `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0siuu3k4.rs:36:30\n\
    \   |\n29 |     let mut smallest_index = std::collections::HashSet::new();\n \
    \  |                              -------------------------------- expected due\
    \ to this value\n...\n36 |             smallest_index = smallest_index.insert(i);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashSet`,\
    \ found `bool`\n   |\n   = note: expected struct `HashSet<usize>`\n          \
    \      found type `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0siuu3k4.rs:42:34\n\
    \   |\n28 |     let mut smallest_value = std::collections::HashSet::new();\n \
    \  |                              -------------------------------- expected due\
    \ to this value\n...\n42 |                 smallest_value = smallest_value.insert(arr[i]);\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashSet`, found `bool`\n   |\n   = note: expected struct `HashSet<isize>`\n\
    \                found type `bool`\n\nerror[E0599]: `HashSet<isize>` is not an\
    \ iterator\n   --> /tmp/tmp0siuu3k4.rs:45:48\n    |\n45  |           let mut smalest_value\
    \ = smallest_value.min_by(|x, y| x.cmp(y)).unwrap();\n    |                  \
    \                                ^^^^^^ `HashSet<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `HashSet<isize>: Iterator`\n            which is required by `&mut HashSet<isize>:\
    \ Iterator`\n\nerror[E0599]: `HashSet<usize>` is not an iterator\n   --> /tmp/tmp0siuu3k4.rs:46:48\n\
    \    |\n46  |           let mut smalest_index = smallest_index"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = std::isize::MAX;\n    let mut min_index: usize = 0;\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            min_value = i;\n\
    \            min_index = i;\n        }\n    }\n    return arr.iter().map(|e| {\n\
    \        if e == min_value {\n            e\n        } else if e == min_index\
    \ {\n            e\n        } else {\n            min_value\n        }\n    }).collect();\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp64jx2mxu.rs:31:25\n   |\n\
    27 |     let mut min_value = std::isize::MAX;\n   |                         ---------------\
    \ expected due to this value\n...\n31 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n31 |             min_value = *i;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp64jx2mxu.rs:32:25\n\
    \   |\n28 |     let mut min_index: usize = 0;\n   |                        -----\
    \ expected due to this type\n...\n32 |             min_index = i;\n   |      \
    \                   ^ expected `usize`, found `&isize`\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmp64jx2mxu.rs:36:14\n   |\n36 | \
    \        if e == min_value {\n   |              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp64jx2mxu.rs:38:24\n\
    \   |\n38 |         } else if e == min_index {\n   |                        ^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmp64jx2mxu.rs:41:13\n   |\n38 |           } else if e ==\
    \ min_index {\n   |  ________________-\n39 | |             e\n   | |         \
    \    - expected because of this\n40 | |         } else {\n41 | |             min_value\n\
    \   | |             ^^^^^^^^^ expected `&isize`, found `isize`\n42 | |       \
    \  }\n   | |_________- `if` and `else` have incompatible types\n\nerror[E0277]:\
    \ can't compare `&isize` with `usize`\n  --> /tmp/tmp64jx2mxu.rs:38:21\n   |\n\
    38 |         } else if e == min_index {\n   |                     ^^ no implementation\
    \ for `&isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `&isize`\n   = help: the followi"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = i32::MAX;\n    let mut min_index: usize = 0;\n    for &mut\
    \ i in arr {\n        if i.0 % 2 == 0 {\n            if i.0 < min_val {\n    \
    \            min_val = i.0;\n                min_index = i;\n            }\n \
    \       }\n    }\n    if min_val == i32::MAX {\n        return vec![];\n    }\n\
    \    let mut ret: Vec<isize> = vec![min_val];\n    let mut i: usize = min_index;\n\
    \    while i < arr.len() {\n        if arr[i].0 % 2 == 0 {\n            ret.append(arr[i].0);\n\
    \        }\n        i += 1;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfkl53qsx.rs:29:9\n   |\n\
    29 |     for &mut i in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found `&mut\
    \ _`\n   |         help: you can probably remove the explicit borrow: `i`\n  \
    \ |\n   = note:           expected type `isize`\n           found mutable reference\
    \ `&mut _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfkl53qsx.rs:40:36\n\
    \   |\n40 |     let mut ret: Vec<isize> = vec![min_val];\n   |               \
    \                     ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n40 |     let mut ret: Vec<isize> = vec![min_val.try_into().unwrap()];\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpfkl53qsx.rs:43:19\n\
    \   |\n43 |         if arr[i].0 % 2 == 0 {\n   |                   ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpfkl53qsx.rs:44:31\n\
    \   |\n44 |             ret.append(arr[i].0);\n   |                          \
    \     ^\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0610.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result: Vec<isize> = Vec::new();\n\n    if arr.is_empty() {\n   \
    \     return result;\n    }\n\n    let mut smallest_value = arr[0];\n    let mut\
    \ smallest_index = 0;\n    let mut current_index = arr.len();\n\n    while current_index\
    \ != 0 {\n        if arr[current_index] % 2 == 0 {\n            smallest_value\
    \ = arr[current_index];\n            smallest_index = current_index;\n       \
    \ }\n\n        current_index -= 1;\n    }\n\n    result.push(smallest_value);\n\
    \    result.push(smallest_index);\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8twuz4ln.rs:47:17\n   |\n\
    47 |     result.push(smallest_index);\n   |                 ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n47 |     result.push(smallest_index.try_into().unwrap());\n\
    \   |                               ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    \n    let mut smalest_value = arr.iter().min().unwrap();\n\
    \    let mut min_index = 0;\n    \n    for &i in arr {\n        if i % 2 == 0\
    \ {\n            min_index = i;\n            smalest_value = i;\n            break;\n\
    \        }\n    }\n    \n    vec![smalest_value, min_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77zqkp8z.rs:32:9\n   |\n\
    32 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp77zqkp8z.rs:35:29\n   |\n29 |     let mut smalest_value = arr.iter().min().unwrap();\n\
    \   |                             ------------------------- expected due to this\
    \ value\n...\n35 |             smalest_value = i;\n   |                      \
    \       ^\n   |                             |\n   |                          \
    \   expected `&isize`, found integer\n   |                             help: consider\
    \ borrowing here: `&i`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77zqkp8z.rs:40:10\n\
    \   |\n40 |     vec![smalest_value, min_index]\n   |          ^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    40 |     vec![*smalest_value, min_index]\n   |          +\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().enumerate().map(|(i, elem)| {\n        let value = elem\
    \ % 2;\n        if value == 0 {\n            vec![i, elem]\n        } else {\n\
    \            vec![i, 0]\n        }\n    }).sort().collect::<Vec<_>>()\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq7e7nof2.rs:30:21\n   |\n\
    30 |             vec![i, elem]\n   |                     ^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0599]: no method named `sort` found for struct `Map`\
    \ in the current scope\n  --> /tmp/tmpq7e7nof2.rs:34:8\n   |\n34 |     }).sort().collect::<Vec<_>>()\n\
    \   |        ^^^^ method not found in `Map<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, _>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    \n    let mut index = 0;\n    let mut value\
    \ = 0;\n    \n    while index < arr.len() {\n        let val = arr[index];\n \
    \       if value % 2 == 0 {\n            result += vec![val];\n            index\
    \ += 1;\n        }\n        else {\n            while value % 2 == 0 {\n     \
    \           value /= 2;\n                index += 1;\n            }\n        \
    \    value = val as isize;\n            result += vec![value];\n            index\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<_>`\n  --> /tmp/tmp04qsg8hz.rs:35:13\n   |\n35 |             result +=\
    \ vec![val];\n   |             ------^^^^^^^^^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `Vec<_>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmp04qsg8hz.rs:44:13\n\
    \   |\n44 |             result += vec![value];\n   |             ------^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut sorted_idx\
    \ = vec![Int::MIN];\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        let mut min = arr[i];\n        let mut min_idx = 0;\n        let mut\
    \ min_value = i;\n        loop {\n            match sorted_idx[min_idx] {\n  \
    \              0 => min_value = i,\n                Infinity => break min_value,\n\
    \                v => {\n                    if min_value >= v {\n           \
    \             min_value = v;\n                        min_idx = i;\n         \
    \           }\n                }\n            }\n        }\n        sorted_idx.push(min_idx);\n\
    \        min = min_value;\n    }\n    sorted_idx.sort();\n    let mut result =\
    \ vec![];\n    for (i, v) in sorted_idx.iter().enumerate() {\n        if i ==\
    \ v {\n            result.push(v);\n            break;\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Int`\n  --> /tmp/tmpcj7q75wf.rs:30:31\n\
    \   |\n30 |     let mut sorted_idx = vec![Int::MIN];\n   |                   \
    \            ^^^ use of undeclared type `Int`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcj7q75wf.rs:39:35\n   |\n39 |                 Infinity => break\
    \ min_value,\n   |                                   ^^^^^^^^^ expected `()`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcj7q75wf.rs:49:15\n\
    \   |\n33 |         let mut min = arr[i];\n   |                       ------ expected\
    \ due to this value\n...\n49 |         min = min_value;\n   |               ^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcj7q75wf.rs:54:17\n\
    \   |\n54 |         if i == v {\n   |                 ^ expected `usize`, found\
    \ `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n54 |        \
    \ if i == *v {\n   |                 +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcj7q75wf.rs:59:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n59 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&usize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = i32::MAX;\n    let mut indexes = vec![];\n    let mut even\
    \ = false;\n    let mut index = 0;\n    let mut result = vec![];\n    for x in\
    \ arr {\n        if x.to_i64() % 2 == 0 {\n            even = true;\n        }\
    \ else {\n            min = i32::MAX;\n            indexes.clear();\n        \
    \    index = 0;\n        }\n        if !even {\n            min = x;\n       \
    \     indexes.clear();\n            index = 0;\n        } else {\n           \
    \ indexes.push(index as isize);\n            if x >= min {\n                min\
    \ = x;\n                index = x;\n            }\n        }\n    }\n    if !even\
    \ {\n        result.push(min as isize);\n        result.push(indexes);\n    }\
    \ else {\n        let mut counter = 0;\n        for index in indexes {\n     \
    \       if counter == index {\n                result.push(index);\n         \
    \   } else {\n                counter = counter + index;\n            }\n    \
    \    }\n        result.push(min);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_i64` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpvi6q59e0.rs:33:14\n   |\n33 |         if x.to_i64() % 2\
    \ == 0 {\n   |              ^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvi6q59e0.rs:41:19\n   |\n27 |     let mut min\
    \ = i32::MAX;\n   |                   -------- expected due to this value\n...\n\
    41 |             min = x;\n   |                   ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvi6q59e0.rs:46:21\n   |\n46 |\
    \             if x >= min {\n   |                     ^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n46 |             if x >= min.try_into().unwrap() {\n\
    \   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvi6q59e0.rs:47:23\n   |\n27 |     let mut min = i32::MAX;\n\
    \   |                   -------- expected due to this value\n...\n47 |       \
    \          min = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvi6q59e0.rs:54:21\n   |\n54 |\
    \         result.push(indexes);\n   |                     ^^^^^^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvi6q59e0.rs:64:21\n\
    \   |\n64 |         result.push(min);\n   |                     ^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n64 |         result.push(min.try_into().unwrap());\n\
    \   |                        ++++++++++++++++++++\n\nerror: aborting due to 6\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut mut_arr: Vec<isize> = arr.to_vec();\n    let mut mut_v: Vec<isize>\
    \ = mut_arr.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n    let\
    \ mut mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n\
    \    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize>\
    \ = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut\
    \ mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n\
    \    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize>\
    \ = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut\
    \ mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n\
    \    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize>\
    \ = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut\
    \ mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n\
    \    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize>\
    \ = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut\
    \ mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n\
    \    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize>\
    \ = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n    let mut\
    \ mut_v: Vec<isize> = mut_v.clone();\n    let mut mut_v: Vec<isize> = mut_v.clone();\n\
    \    let \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8ox191f2.rs:58:1\n  \
    \ |\n58 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut largest = arr[0];\n    let mut idx: usize = 0;\n    for i in arr\
    \ {\n        if largest > i {\n            largest = i;\n        }\n    }\n  \
    \  for i in arr {\n        if largest == i {\n            idx += 1;\n        }\n\
    \    }\n    if largest%2 == 0 {\n        vec![largest, idx]\n    } else {\n  \
    \      vec![largest, idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwffb50_x.rs:40:23\n   |\n\
    40 |         vec![largest, idx]\n   |                       ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n40 |         vec![largest, idx.try_into().unwrap()]\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwffb50_x.rs:42:23\n   |\n42 |         vec![largest, idx]\n\
    \   |                       ^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n42 |         vec![largest, idx.try_into().unwrap()]\n   |       \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_val_index = arr.iter().cloned().min_by_key(|&x| {\n\
    \        x%2 == 0\n    }).unwrap();\n    let mut smallest_even_val = arr[0];\n\
    \    let mut result = vec![smallest_even_val_index, smallest_even_val];\n    while\
    \ smallest_even_val_index < arr.len() && smallest_even_val == arr[0] {\n     \
    \   smallest_even_val_index += 1;\n        smallest_even_val = arr[smallest_even_val_index];\n\
    \        result.push(i32::MAX);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7dhxtbrj.rs:32:37\n   |\n\
    32 |     while smallest_even_val_index < arr.len() && smallest_even_val == arr[0]\
    \ {\n   |                                     ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n32 |     while smallest_even_val_index <\
    \ arr.len().try_into().unwrap() && smallest_even_val == arr[0] {\n   |       \
    \                                       ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7dhxtbrj.rs:34:29\n\
    \   |\n34 |         smallest_even_val = arr[smallest_even_val_index];\n   |  \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7dhxtbrj.rs:35:21\n\
    \   |\n35 |         result.push(i32::MAX);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n35 |         result.push(i32::MAX.try_into().unwrap());\n\
    \   |                             ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n\n    let mut even_values\
    \ = HashMap::new();\n    let mut smallest_value = arr[0];\n    let mut smallest_index\
    \ = 0;\n    for &v in &arr {\n        if v % 2 == 0 {\n            if even_values.contains_key(&v\
    \ as isize) {\n                let mut new_v = even_values.get_mut(&v as isize);\n\
    \                if new_v > smallest_value {\n                    smallest_value\
    \ = new_v as isize;\n                    smallest_index = v as usize;\n      \
    \          }\n            } else {\n                even_values.insert(v as isize,\
    \ v as usize);\n            }\n        }\n    }\n    let mut result = vec![];\n\
    \    result.push(smallest_value, smallest_index);\n    return result;\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpzzisxc5l.rs:31:27\n   |\n31 |     let mut even_values = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpzzisxc5l.rs:48:12\n\
    \     |\n48   |     result.push(smallest_value, smallest_index);\n     |     \
    \       ^^^^ --------------  -------------- supplied 2 arguments\n     |     \
    \       |\n     |            expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  -->\
    \ /tmp/tmpzzisxc5l.rs:36:41\n   |\n36 |             if even_values.contains_key(&v\
    \ as isize) {\n   |                                         --^^^^^^^^^\n   |\
    \                                         |\n   |                            \
    \             cannot cast `&isize` as `isize`\n   |                          \
    \               help: dereference the expression: `*&v`\n\nerror[E0606]: casting\
    \ `&isize` as `isize` is invalid\n  --> /tmp/tmpzzisxc5l.rs:37:53\n   |\n37 |\
    \                 let mut new_v = even_values.get_mut(&v as isize);\n   |    \
    \                                                 --^^^^^^^^^\n   |          \
    \                                           |\n   |                          \
    \                           cannot cast `&isize` as `isize`\n   |            \
    \                                         help: dereference the expression: `*&v`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0433, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ans = vec![];\n    if arr.len() == 0 {\n        return ans;\n   \
    \ }\n    let mut smallest = arr.iter().min();\n    let mut cur = 0;\n    let mut\
    \ i = 0;\n    for num in arr {\n        if num == smallest {\n            i +=\
    \ 1;\n        } else if i > 0 && num % 2 == 0 {\n            i += 1;\n       \
    \     if num < smallest {\n                cur = num;\n                smallest\
    \ = num;\n            }\n        }\n    }\n    ans.push(cur);\n    ans\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0u5hbiv2.rs:35:19\n   |\n\
    35 |         if num == smallest {\n   |                   ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0u5hbiv2.rs:39:22\n\
    \   |\n39 |             if num < smallest {\n   |                      ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0u5hbiv2.rs:41:28\n   |\n31 |     let mut smallest = arr.iter().min();\n\
    \   |                        ---------------- expected due to this value\n...\n\
    41 |                 smallest = num;\n   |                            ^^^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n\n    let mut smallest_value\
    \ = 0;\n    let mut smallest_index = 0;\n    let mut current_smallest_value =\
    \ arr[0];\n    let mut current_smallest_index = 0;\n    let mut index = 0;\n \
    \   let mut even_value: isize = 0;\n    for &v in arr.iter() {\n        if v &\
    \ 1 != 0 {\n            even_value = (v & 1) + 1;\n        }\n        if v < current_smallest_value\
    \ {\n            smallest_value = v;\n            smallest_index = index;\n  \
    \      }\n        if v == current_smallest_value {\n            current_smallest_value\
    \ = v;\n            current_smallest_index = index;\n        }\n        index\
    \ += 1;\n    }\n    let mut result = vec![];\n    if current_smallest_value ==\
    \ 0 || even_value.is_zero() {\n        return result;\n    }\n    if current_smallest_index\
    \ > 0 {\n        result.push((smallest_value, current_smallest_index));\n    \
    \    result.push((smallest_value, current_smallest_index));\n    }\n    if even_value.is_one()\
    \ {\n        result.push((smallest_value, current_smallest_index));\n    }\n \
    \   if even_value.is_two() {\n        result.push((smallest_value, current_smallest_index));\n\
    \    }\n    if even_value.is_three() {\n        result.push((smallest_value, current_smallest_index));\n\
    \    }\n    if even_value.is_four() {\n        result.push((smallest_value, current_smallest_index));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp9n4fdwhs.rs:52:50\n   |\n52 |     if current_smallest_value\
    \ == 0 || even_value.is_zero() {\n   |                                       \
    \           ^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9n4fdwhs.rs:56:21\n   |\n56 |         result.push((smallest_value,\
    \ current_smallest_index));\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(isize, {integer})`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9n4fdwhs.rs:57:21\n   |\n57 |         result.push((smallest_value,\
    \ current_smallest_index));\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(isize, {integer})`\n\nerror[E0599]: no method named `is_one`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp9n4fdwhs.rs:59:19\n\
    \   |\n59 |     if even_value.is_one() {\n   |                   ^^^^^^ method\
    \ not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9n4fdwhs.rs:60:21\n\
    \   |\n60 |         result.push((smallest_value, current_smallest_index));\n \
    \  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found tuple\n   |\n   = note: expected type `isize`\n             found tuple\
    \ `(isize, {integer})`\n\nerror[E0599]: no method named `is_two` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp9n4fdwhs.rs:62:19\n   |\n62 |  \
    \   if even_value.is_two() {\n   |                   ^^^^^^ method not found in\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9n4fdwhs.rs:63:21\n\
    \   |\n63 |         result.push((smallest_value, current_smallest_index));\n \
    \  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found tuple\n   |\n   = note: expected type `isize`\n             found tuple\
    \ `(isize, {integer})`\n\nerror[E0599]: no method named `is_three` found for type\
    \ `isize` in the curre"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even_value\
    \ = arr[0];\n    let mut min_index = arr[0];\n    for &v in arr.iter().rev() {\n\
    \        if v % 2 == 0 {\n            min_even_value = v;\n        }\n       \
    \ if v < min_index {\n            min_index = v;\n        }\n    }\n    return\
    \ vec![min_even_value.clone(), min_index.clone()];\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2]`,\n right: `[2, 1]`', /tmp/tmptcd45t_d.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    let mut index = 0;\n    let mut smalest_value = arr[0];\n\
    \    while index != arr.len() {\n        if arr[index] % 2 == 0 {\n          \
    \  smalest_value = arr[index];\n            index += 1;\n        } else {\n  \
    \          index += 1\n        }\n    }\n    vec![smalest_value, index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2261duiy.rs:38:25\n   |\n\
    38 |     vec![smalest_value, index]\n   |                         ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n38 |     vec![smalest_value,\
    \ index.try_into().unwrap()]\n   |                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = i32::MAX;\n    let mut index = 0;\n    for &i in arr\
    \ {\n        // min_value will be set to maximum of all odd values\n        min_value\
    \ = i if i % 2 != 0;\n        \n        if min_value < i32::MAX {\n          \
    \  if min_value == i {\n                // found a node with smallest even value\n\
    \                break;\n            } else {\n                // found a node\
    \ with smallest value\n                break;\n            }\n        } else {\n\
    \            // found a node with smallest value\n            index = i;\n   \
    \         break;\n        }\n    }\n\n    let mut arr2 = vec![min_value];\n  \
    \  arr2.push(index);\n\n    return arr2;\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpvemrprxa.rs:31:23\n   |\n31 |         min_value\
    \ = i if i % 2 != 0;\n   |                       ^^ expected one of 8 possible\
    \ tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvemrprxa.rs:29:9\n \
    \  |\n29 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvemrprxa.rs:51:12\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected\
    \ `Vec<isize>` because of return type\n...\n51 |     return arr2;\n   |      \
    \      ^^^^ expected `isize`, found `i32`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<i32>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut arr: Vec<isize> = arr.iter().cloned().collect();\n    let mut min_index\
    \ = 0;\n    let mut min_value = arr[0];\n    while arr.len() > 0 {\n        let\
    \ mut min_value = min_value;\n        let mut min_index = min_index;\n       \
    \ for i in 0..arr.len() {\n            if min_value >= arr[i] {\n            \
    \    min_value = arr[i];\n                min_index = i;\n            }\n    \
    \    }\n        arr.swap(0, min_index);\n    }\n    arr\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = -1;\n    for (idx, value)\
    \ in arr.iter().enumerate() {\n        let mut even = true;\n        while even\
    \ {\n            if value % 2 == 0 {\n                even = false;\n        \
    \        break;\n            }\n            value /= 2;\n        }\n        if\
    \ value == min_value {\n            min_idx = idx;\n            min_value = value;\n\
    \        }\n    }\n    let mut res = [min_value, min_idx];\n    if min_idx !=\
    \ -1 {\n        res.swap(0, 1);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `/=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmp72va0g07.rs:36:13\n   |\n36 |             value /= 2;\n\
    \   |             -----^^^^^\n   |             |\n   |             cannot use\
    \ `/=` on type `&isize`\n   |\nhelp: `/=` can be used on `isize`, you can dereference\
    \ `value`\n   |\n36 |             *value /= 2;\n   |             +\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmp72va0g07.rs:38:18\n   |\n\
    38 |         if value == min_value {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp72va0g07.rs:40:25\n   |\n27 |     let mut min_value = arr[0];\n   |\
    \                         ------ expected due to this value\n...\n40 |       \
    \      min_value = value;\n   |                         ^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n40 |  \
    \           min_value = *value;\n   |                         +\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp72va0g07.rs:28:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp72va0g07.rs:43:31\n   |\n43 |     let mut res = [min_value, min_idx];\n\
    \   |                               ^^^^^^^ expected `isize`, found `usize`\n\n\
    error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp72va0g07.rs:44:19\n\
    \   |\n44 |     if min_idx != -1 {\n   |                   ^^\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index = 0;\n    let mut current_val = arr[0];\n    let mut current_index\
    \ = index as isize;\n\n    let mut min_val = current_val;\n    let mut min_idx\
    \ = current_index;\n\n    for i in 1..arr.len() {\n        if current_val == 0\
    \ || current_val > arr[i] {\n            current_val = arr[i];\n            current_index\
    \ = i as isize;\n        }\n        if arr[i] == min_val {\n            if min_val\
    \ > arr[i] {\n                min_val = arr[i];\n                min_idx = i as\
    \ isize;\n            }\n        }\n    }\n\n    min_idx += 1;\n\n    vec![min_val,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 1]`,\n right: `[2, 1]`', /tmp/tmp5xmrol0x.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    let mut smallest_value: isize = 0;\n    let mut smallest_index\
    \ = 0;\n    let mut largest_index: usize = 0;\n\n    for i in 0..arr.len() {\n\
    \        if arr[i] % 2 == 0 {\n            let mut smallest_value = i as isize;\n\
    \            let mut smallest_index = i as usize;\n\n            smallest_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n        if arr[i] < smallest_value\
    \ {\n            smallest_value = arr[i];\n            smallest_index = i;\n \
    \       }\n    }\n\n    if smallest_value == 0 {\n        return vec![];\n   \
    \ }\n\n    for i in 1..arr.len() {\n        if arr[i] == smallest_value {\n  \
    \          if arr[i] < smallest_value {\n                smallest_value = arr[i];\n\
    \                smallest_index = i;\n            }\n        }\n    }\n\n    if\
    \ smallest_index > largest_index {\n        largest_index = smallest_index;\n\
    \    }\n\n    if smallest_index != smallest_index {\n        return vec![smallest_index,\
    \ smallest_index];\n    }\n\n    return vec![smallest_index];\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx7i667n_.rs:64:21\n   |\n\
    64 |         return vec![smallest_index, smallest_index];\n   |              \
    \       ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    64 |         return vec![smallest_index.try_into().unwrap(), smallest_index];\n\
    \   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx7i667n_.rs:67:17\n   |\n67 |     return vec![smallest_index];\n\
    \   |                 ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n67 |     return vec![smallest_index.try_into().unwrap()];\n   | \
    \                              ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    \n    let mut smallest_even_value:\
    \ isize = isize::MAX;\n    \n    for value in arr.iter() {\n        if smallest_even_value\
    \ < value {\n            smallest_even_value = value;\n        }\n    }\n    \n\
    \    let mut smallest_even_node_index = arr.iter().position(|&value| value < smallest_even_value);\n\
    \    \n    if smallest_even_node_index.is_none() {\n        return vec![];\n \
    \   }\n    \n    let mut nodes_with_smallest_even_value = Vec::new();\n    \n\
    \    let mut current_node_index = 0;\n    \n    for value in arr.iter() {\n  \
    \      if smallest_even_value == value {\n            nodes_with_smallest_even_value.push(smallest_even_node_index);\n\
    \        }\n        \n        current_node_index += value;\n        if current_node_index\
    \ < smallest_even_node_index {\n            break;\n        }\n    }\n    \n \
    \   return nodes_with_smallest_even_value;\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77htxlgv.rs:34:34\n   |\n\
    34 |         if smallest_even_value < value {\n   |                          \
    \        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |         if smallest_even_value < *value {\n   |     \
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77htxlgv.rs:35:35\n\
    \   |\n31 |     let mut smallest_even_value: isize = isize::MAX;\n   |       \
    \                           ----- expected due to this type\n...\n35 |       \
    \      smallest_even_value = value;\n   |                                   ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n35 |             smallest_even_value = *value;\n   |                  \
    \                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77htxlgv.rs:50:35\n\
    \   |\n50 |         if smallest_even_value == value {\n   |                  \
    \                 ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n50 |         if smallest_even_value == *value\
    \ {\n   |                                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp77htxlgv.rs:55:33\n   |\n55 |         if current_node_index < smallest_even_node_index\
    \ {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77htxlgv.rs:60:12\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<_>` because of return type\n...\n60 |  \
    \   return nodes_with_smallest_even_value;\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<usize>>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort();\n    let mut min_even_value\
    \ = arr[0];\n    let mut min_even_node_index = 0;\n    for (idx, value) in sorted_arr.iter().enumerate()\
    \ {\n        if value == min_even_value {\n            min_even_node_index = idx;\n\
    \        }\n        if value < min_even_value {\n            min_even_node_index\
    \ = 0;\n            min_even_value = value;\n        }\n    }\n    sorted_arr.swap_remove(0);\n\
    \    sorted_arr.swap_remove(min_even_node_index);\n    sorted_arr.swap_remove(0);\n\
    \    sorted_arr.swap_remove(0);\n    return sorted_arr;\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2q1hexx_.rs:32:18\n\
    \   |\n32 |         if value == min_even_value {\n   |                  ^^ no\
    \ implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2q1hexx_.rs:35:20\n   |\n35 |         if value < min_even_value {\n\
    \   |                    ^^^^^^^^^^^^^^\n   |                    |\n   |     \
    \               expected `&isize`, found `isize`\n   |                    help:\
    \ consider borrowing here: `&min_even_value`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2q1hexx_.rs:37:30\n   |\n29 |     let mut min_even_value = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n37\
    \ |             min_even_value = value;\n   |                              ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n37 |             min_even_value = *value;\n   |                       \
    \       +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = vec![0; arr.len()];\n    let mut smallest_even_index\
    \ = vec![0; arr.len()];\n    for element in &arr {\n        if element % 2 ==\
    \ 0 {\n            smallest_even_value[element as usize] += 1;\n        }\n  \
    \  }\n    for i in 0..arr.len() {\n        if smallest_even_value[i] != 0 {\n\
    \            smallest_even_index[i] = smallest_even_value[i] as usize;\n     \
    \   }\n    }\n    let mut return_value = vec![0; arr.len()];\n    for i in 0..arr.len()\
    \ {\n        if smallest_even_index[i] != 0 {\n            return_value[smallest_even_index[i]\
    \ as usize] = i;\n        }\n    }\n    return_value\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdh74huh3.rs:45:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n45 |     return_value\n\
    \   |     ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmpdh74huh3.rs:31:33\n  \
    \ |\n31 |             smallest_even_value[element as usize] += 1;\n   |      \
    \                           -------^^^^^^^^^\n   |                           \
    \      |\n   |                                 cannot cast `&isize` as `usize`\n\
    \   |                                 help: dereference the expression: `*element`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_value: Vec<isize> = Vec::new();\n    let mut smallest_value:\
    \ isize = 0;\n    let mut smallest_index: usize = 0;\n\n    for v in arr {\n \
    \       if v & 1 == 0 {\n            even_value.push(v);\n        } else {\n \
    \           if smallest_value < v {\n                smallest_value = v;\n   \
    \             smallest_index = 0;\n            } else {\n                if smallest_value\
    \ == v {\n                    smallest_index += 1;\n                }\n      \
    \      }\n        }\n    }\n    even_value.sort();\n    even_value.pop();\n  \
    \  even_value.sort_unstable();\n\n    let mut picked = Vec::new();\n    for v\
    \ in even_value.iter() {\n        if v == smallest_value {\n            picked.push(smallest_index);\n\
    \        }\n    }\n    return picked;\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpnw2lxip0.rs:51:14\n\
    \   |\n51 |         if v == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnw2lxip0.rs:55:12\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n55 |     return picked;\n   |            ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut smaller_values = vec![];\n   \
    \ let mut smaller_values_index = vec![];\n    let mut mut_smaller_value_index_iter\
    \ = smaller_values_index.iter();\n    let mut mut_even_values_iter = even_values.iter();\n\
    \    for x in arr {\n        if x % 2 == 0 {\n            even_values.push(x);\n\
    \            smaller_values_index.push(x);\n        } else {\n            if smaller_values_index[0]\
    \ >= x {\n                smaller_values.push(x);\n                mut_smaller_value_index_iter.next();\n\
    \            } else {\n                let mut index = smaller_values_index[0];\n\
    \                smaller_values.push(smaller_values_index[0]);\n             \
    \   while mut_smaller_value_index_iter.any() {\n                    if smaller_values_index[index]\
    \ >= x {\n                        smaller_values.push(smaller_values_index[index]);\n\
    \                        mut_smaller_value_index_iter.next();\n              \
    \          break;\n                    }\n                    index = smaller_values_index[index];\n\
    \                }\n                mut_even_values_iter.next();\n           \
    \ }\n        }\n    }\n    even_values\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp1ft3pzkp.rs:43:52\n     |\n43   |                 while mut_smaller_value_index_iter.any()\
    \ {\n     |                                                    ^^^- supplied 0\
    \ arguments\n     |                                                    |\n   \
    \  |                                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp1ft3pzkp.rs:44:24\n   |\n44 |  \
    \                   if smaller_values_index[index] >= x {\n   |              \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1ft3pzkp.rs:45:45\n   |\n45 |                         smaller_values.push(smaller_values_index[index]);\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1ft3pzkp.rs:49:29\n\
    \   |\n49 |                     index = smaller_values_index[index];\n   |   \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: abortin"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_unstable();\n    arr.dedup();\n    if arr.is_empty() {\n       \
    \ return vec![];\n    }\n    let mut res = vec![];\n    for &v in &arr {\n   \
    \     let mut i = 0;\n        for i in 0..arr.len() {\n            if arr[i] ==\
    \ v {\n                break;\n            }\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            if v % 2 == 0 {\n                res.push(v);\n\
    \            }\n        } else {\n            i += 1;\n            if arr[i] %\
    \ 2 == 0 {\n                res.push(arr[i]);\n            }\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmp0h3sryfa.rs:39:13\n\
    \   |\n39 |             i += 1;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0596]:\
    \ cannot borrow `arr` as mutable, as it is not declared as mutable\n  --> /tmp/tmp0h3sryfa.rs:27:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |          --- help:\
    \ consider changing this to be mutable: `mut arr`\n27 |     arr.sort_unstable();\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `arr` as mutable, as it is not declared as mutable\n  --> /tmp/tmp0h3sryfa.rs:28:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |          --- help:\
    \ consider changing this to be mutable: `mut arr`\n27 |     arr.sort_unstable();\n\
    28 |     arr.dedup();\n   |     ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `i`\n  --> /tmp/tmp0h3sryfa.rs:39:13\n\
    \   |\n35 |         for i in 0..arr.len() {\n   |             -\n   |        \
    \     |\n   |             first assignment to `i`\n   |             help: consider\
    \ making this binding mutable: `mut i`\n...\n39 |             i += 1;\n   |  \
    \           ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_val = None;\n    let mut min_even_val_index = 0;\n    for\
    \ i in arr.iter() {\n        if min_even_val == None || min_even_val < i {\n \
    \           min_even_val = i;\n            min_even_val_index = 1;\n        }\
    \ else {\n            min_even_val = i;\n            min_even_val_index = 2;\n\
    \        }\n    }\n    let mut smalest_value = min_even_val;\n    let mut smalest_val_index\
    \ = min_even_val_index;\n    for i in arr.iter() {\n        if i == min_even_val\
    \ {\n            smalest_val_index = i;\n            smalest_value = i;\n    \
    \    }\n    }\n    let mut return_list = vec![];\n    return_list.push(smalest_val);\n\
    \    return_list.push(smalest_val_index);\n    return return_list;\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `smalest_val` in this scope\n  --> /tmp/tmp03m1uap6.rs:47:22\n\
    \   |\n47 |     return_list.push(smalest_val);\n   |                      ^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `smalest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp03m1uap6.rs:30:51\n   |\n30 |         if min_even_val\
    \ == None || min_even_val < i {\n   |                                        \
    \           ^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<_>`\n           found reference `&isize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n30 |         if min_even_val == None || min_even_val\
    \ < Some(i) {\n   |                                                   +++++ +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp03m1uap6.rs:31:28\n   |\n27 |\
    \     let mut min_even_val = None;\n   |                            ---- expected\
    \ due to this value\n...\n31 |             min_even_val = i;\n   |           \
    \                 ^ expected enum `Option`, found `&isize`\n   |\n   = note: \
    \  expected enum `Option<_>`\n           found reference `&isize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n31 |             min_even_val = Some(i);\n \
    \  |                            +++++ +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp03m1uap6.rs:34:28\n   |\n27 |     let mut min_even_val = None;\n   |\
    \                            ---- expected due to this value\n...\n34 |      \
    \       min_even_val = i;\n   |                            ^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<_>`\n           found\
    \ reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n34 |\
    \             min_even_val = Some(i);\n   |                            +++++ +\n\
    \nerror[E0277]: can't compare `&isize` with `Option<_>`\n  --> /tmp/tmp03m1uap6.rs:41:14\n\
    \   |\n41 |         if i == min_even_val {\n   |              ^^ no implementation\
    \ for `&isize == Option<_>`\n   |\n   = help: the trait `PartialEq<Option<_>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<R"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens: Vec<isize> = Vec::new();\n    let mut nodes: Vec<isize> =\
    \ Vec::new();\n    let mut index: usize = 0;\n    let mut current_value: isize\
    \ = 0;\n    \n    for val in arr {\n        if val%2 == 0 {\n            evens.push(val);\n\
    \        } else {\n            nodes.push(val);\n            \n            if\
    \ current_value > val {\n                index = evens.iter().min_by_key(|x| x).unwrap();\n\
    \                current_value = evens[index];\n            }\n        }\n   \
    \ }\n    \n    if index != 0 {\n        let mut smallest = evens[0];\n       \
    \ let mut smallest_index = 0;\n        for ele in evens {\n            if ele\
    \ < smallest {\n                smallest = ele;\n                smallest_index\
    \ = ele;\n            }\n        }\n        \n        \n        let mut new_list:\
    \ Vec<isize> = Vec::new();\n        new_list.push(smallest);\n        new_list.push(smallest_index);\n\
    \        return new_list;\n    } else {\n        return vec![];\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6a6sadnb.rs:39:25\n   |\n\
    29 |     let mut index: usize = 0;\n   |                    ----- expected due\
    \ to this type\n...\n39 |                 index = evens.iter().min_by_key(|x|\
    \ x).unwrap();\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    // sort the array\
    \ in ascending order\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    // find the min even index\n    let mut index_of_min_even = sorted_arr.iter().cloned().find(|x|\
    \ x % 2 == 0).unwrap();\n    let mut min_even_val = sorted_arr[index_of_min_even];\n\
    \    \n    let mut index = 0;\n    let mut returned_values: Vec<isize> = vec![];\n\
    \    // find the next min even index\n    for &x in sorted_arr.iter_mut() {\n\
    \        // only increase the index of the returned values if the current val\
    \ is not equal to the minimum even val\n        if x != min_even_val {\n     \
    \       index +=1;\n            returned_values.push(min_even_val);\n        \
    \    min_even_val = x;\n        }\n    }\n    return returned_values;\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp79n7qhbs.rs:35:28\n\
    \   |\n35 |     let mut min_even_val = sorted_arr[index_of_min_even];\n   |  \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp79n7qhbs.rs:40:9\n\
    \   |\n40 |     for &x in sorted_arr.iter_mut() {\n   |         ^^    ---------------------\
    \ this expression has type `Option<&mut isize>`\n   |         |\n   |        \
    \ types differ in mutability\n   |         help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note: expected mutable reference `&mut isize`\n    \
    \                  found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    let mut ret: Vec<isize> = Vec::new();\n    let mut min_value:\
    \ isize = 0;\n    let mut min_index: usize = 0;\n    let mut current_index = 1;\n\
    \    while current_index < arr.len() {\n        if min_value > arr[*current_index]\
    \ {\n            min_value = arr[*current_index];\n            min_index = *current_index;\n\
    \        }\n        *current_index += 1;\n    }\n    if min_value >= 2 {\n   \
    \     ret.push(min_value);\n        ret.push(min_index);\n    }\n    if ret.len()\
    \ == 1 {\n        ret.push(isize::MAX);\n        ret.push(isize::MAX);\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp4m9vj50d.rs:33:28\n\
    \   |\n33 |         if min_value > arr[*current_index] {\n   |               \
    \             ^^^^^^^^^^^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmp4m9vj50d.rs:34:29\n   |\n34 |             min_value = arr[*current_index];\n\
    \   |                             ^^^^^^^^^^^^^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmp4m9vj50d.rs:35:25\n   |\n35 |        \
    \     min_index = *current_index;\n   |                         ^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp4m9vj50d.rs:37:9\n\
    \   |\n37 |         *current_index += 1;\n   |         ^^^^^^^^^^^^^^\n   |\n\
    help: parentheses are required to parse this as an expression\n   |\n33 ~    \
    \     (if min_value > arr[*current_index] {\n34 |             min_value = arr[*current_index];\n\
    35 |             min_index = *current_index;\n36 ~         })\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4m9vj50d.rs:41:18\n   |\n41 |         ret.push(min_index);\n\
    \   |                  ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n41 |         ret.push(min_index.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value: isize = 0;\n    let mut smallest_index: usize = 0;\n\
    \    for &x in arr {\n        if x % 2 == 0 {\n            min_even_value = x;\n\
    \            smallest_index = 1;\n            break;\n        }\n        if min_even_value*2\
    \ > x {\n            min_even_value=x;\n            smallest_index=1;\n      \
    \  }\n        if min_even_value*2 > x && smallest_index == 0 {\n            min_even_value\
    \ = x;\n            smallest_index = 1;\n        }\n    }\n    match min_even_value\
    \ {\n        x if x > 0 => {\n            vec![min_even_value, smallest_index\
    \ + 1]\n        }\n        _ => vec![],\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8_mck1bv.rs:29:9\n   |\n\
    29 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8_mck1bv.rs:46:34\n   |\n46 |             vec![min_even_value,\
    \ smallest_index + 1]\n   |                                  ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n46 |           \
    \  vec![min_even_value, (smallest_index + 1).try_into().unwrap()]\n   |      \
    \                            +                  +++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for i in 1..arr.len()\
    \ {\n        if min_value == arr[i] {\n            if min_idx > i {\n        \
    \        min_idx = i;\n            }\n        } else {\n            min_value\
    \ = arr[i];\n            min_idx = i;\n        }\n    }\n    let mut vals = Vec::new();\n\
    \    vals.push(min_value);\n    vals.push(min_idx);\n    return vals;\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz09dtkbt.rs:41:15\n   |\n\
    41 |     vals.push(min_idx);\n   |               ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n41 |     vals.push(min_idx.try_into().unwrap());\n\
    \   |                      ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut smallest_index\
    \ = 0;\n    let mut smallest_value = 0;\n    for &mut x in arr.iter_mut() {\n\
    \        if x.is_even() {\n            if smallest_value < x {\n             \
    \   smallest_value = x;\n                smallest_index = arr.iter().position(|&x|\
    \ x.is_even()).unwrap();\n            }\n        }\n    }\n    let mut output_vec:\
    \ Vec<isize> = vec![];\n    for i in 0..smallest_index {\n        output_vec.push(smallest_value);\n\
    \    }\n    output_vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpcwm19bvg.rs:33:14\n   |\n33 |         if x.is_even() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `is_even` found for type `isize` in the current scope\n  --> /tmp/tmpcwm19bvg.rs:36:61\n\
    \   |\n36 |                 smallest_index = arr.iter().position(|&x| x.is_even()).unwrap();\n\
    \   |                                                             ^^^^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut pluck_arr = vec![];\n\n    for val in arr.iter() {\n        if val\
    \ % 2 == 0 {\n            pluck_arr.push(val);\n        }\n    }\n\n    pluck_arr.sort();\n\
    \n    if pluck_arr.len() > 0 {\n        pluck_arr.swap(0, 1);\n    }\n    pluck_arr\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo5oowemm.rs:40:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n40 |     pluck_arr\n\
    \   |     ^^^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = i32::MAX;\n    let mut min_index = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min > i32::MAX - i {\n          \
    \      min = i32::MAX - i;\n                min_index = 0;\n            } else\
    \ {\n                min = i32::MAX - i;\n                min_index = i;\n   \
    \         }\n        }\n    }\n    let mut res = vec![min_index, min];\n    \n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            match (&arr[arr.len() - 1], i) {\n \
    \               (&i0, &i1) if i0 < i1 => {\n                    res[0] = i;\n\
    \                    res[1] = i32::MAX - i;\n                    break;\n    \
    \            }\n                _ => {\n                    res[0] = i;\n    \
    \                res[1] = i32::MAX - i;\n                }\n            }\n  \
    \      }\n    }\n    res\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6y0um_c4.rs:31:33\n   |\n\
    31 |             if min > i32::MAX - i {\n   |                               \
    \  ^ expected `i32`, found `isize`\n\nerror[E0277]: cannot subtract `&isize` from\
    \ `i32`\n  --> /tmp/tmp6y0um_c4.rs:31:31\n   |\n31 |             if min > i32::MAX\
    \ - i {\n   |                               ^ no implementation for `i32 - &isize`\n\
    \   |\n   = help: the trait `Sub<&isize>` is not implemented for `i32`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6y0um_c4.rs:32:34\n   |\n32 |                 min = i32::MAX\
    \ - i;\n   |                                  ^ expected `i32`, found `isize`\n\
    \nerror[E0277]: cannot subtract `&isize` from `i32`\n  --> /tmp/tmp6y0um_c4.rs:32:32\n\
    \   |\n32 |                 min = i32::MAX - i;\n   |                        \
    \        ^ no implementation for `i32 - &isize`\n   |\n   = help: the trait `Sub<&isize>`\
    \ is not implemented for `i32`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6y0um_c4.rs:35:34\n\
    \   |\n35 |                 min = i32::MAX - i;\n   |                        \
    \          ^ expected `i32`, found `isize`\n\nerror[E0277]: cannot subtract `&isize`\
    \ from `i32`\n  --> /tmp/tmp6y0um_c4.rs:35:32\n   |\n35 |                 min\
    \ = i32::MAX - i;\n   |                                ^ no implementation for\
    \ `i32 - &isize`\n   |\n   = hel"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    \n    let mut ans = vec![];\n    ans.push(arr.iter().min_by_key(|x| *x).unwrap());\n\
    \    ans.push(arr.iter().min_by_key(|x| *x).index());\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpus9ln2nf.rs:30:44\n   |\n30 |     ans.push(arr.iter().min_by_key(|x|\
    \ *x).index());\n   |                                            ^^^^^ method\
    \ not found in `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpus9ln2nf.rs:31:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n31\
    \ |     ans\n   |     ^^^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| if a == b { 0 } else { a < b });\n    let mut largest\
    \ = arr[0] as isize;\n    let mut index = 0;\n    let mut mut_index = 0;\n   \
    \ for (i, v) in arr.iter().enumerate().skip(1) {\n        if v % 2 != 0 {\n  \
    \          largest = v;\n            index = i;\n        }\n        if v == largest\
    \ {\n            mut_index = i;\n        }\n    }\n    if mut_index == 0 {\n \
    \       return []\n    }\n    let mut temp = 0;\n    if largest % 2 == 0 {\n \
    \       temp = largest / 2;\n    }\n    else {\n        temp = (largest - 1) /\
    \ 2;\n    }\n    vec![temp, mut_index]\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbd46lmw.rs:27:36\n   |\n\
    27 |     arr.sort_by(|a, b| if a == b { 0 } else { a < b });\n   |           \
    \                         ^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxbd46lmw.rs:27:47\n   |\n27 |\
    \     arr.sort_by(|a, b| if a == b { 0 } else { a < b });\n   |              \
    \                                 ^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbd46lmw.rs:33:23\n\
    \   |\n28 |     let mut largest = arr[0] as isize;\n   |                     \
    \  --------------- expected due to this value\n...\n33 |             largest =\
    \ v;\n   |                       ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n33 |             largest = *v;\n  \
    \ |                       +\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpxbd46lmw.rs:36:14\n   |\n36 |         if v == largest {\n   | \
    \             ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxbd46lmw.rs:41:16\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected\
    \ `Vec<isize>` because of return type\n...\n41 |         return []\n   |     \
    \           ^^- help: try using a conversion method: `.to_vec()`\n   |       \
    \         |\n   |                expected struct `Vec`, found array of 0 elements\n\
    \   |\n   = note: expected struct `Vec<isize>`\n               found array `[_;\
    \ 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbd46lmw.rs:50:16\n   |\n\
    50 |     vec![temp, mut_index]\n   |                ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the conv"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut results: Vec<isize> = Vec::new();\n    let mut smallest_value: isize\
    \ = std::i32::MAX;\n    let mut smallest_index: usize = 0;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if smallest_value <= i {\n         \
    \       smallest_value = i;\n                smallest_index = i;\n           \
    \ }\n        } else {\n            if smallest_value == i {\n                smallest_index\
    \ = arr.iter().position(|&i| i).unwrap();\n            }\n        }\n    }\n \
    \   if smallest_value <= std::i32::MAX {\n        results.push(smallest_value,\
    \ smallest_index);\n    }\n    results\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyivfiz3h.rs:28:37\n   |\n\
    28 |     let mut smallest_value: isize = std::i32::MAX;\n   |                \
    \             -----   ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |      \
    \                       |\n   |                             expected due to this\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n28 |     let mut smallest_value: isize = std::i32::MAX.try_into().unwrap();\n\
    \   |                                                  ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpyivfiz3h.rs:30:9\n   |\n30 |   \
    \  for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyivfiz3h.rs:34:34\n   |\n29 |     let mut smallest_index: usize\
    \ = 0;\n   |                             ----- expected due to this type\n...\n\
    34 |                 smallest_index = i;\n   |                               \
    \   ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyivfiz3h.rs:38:59\n   |\n38 |                 smallest_index = arr.iter().position(|&i|\
    \ i).unwrap();\n   |                                                         \
    \  ^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyivfiz3h.rs:42:26\n\
    \   |\n42 |     if smallest_value <= std::i32::MAX {\n   |                   \
    \       ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    42 |     if smallest_value <= std::i32::MAX.try_into().unwrap() {\n   |      \
    \                                 ++++++++++++++++++++\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpyivfiz3h.rs:43:17\n\
    \     |\n43   |         results.push(smallest_value, smallest_index);\n     | "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = isize::MAX;\n    let mut smallest_index: usize = 0;\n\
    \    for (i, value) in arr.iter().enumerate() {\n        if value == 0 && i !=\
    \ 0 {\n            continue;\n        }\n        if value < min_value {\n    \
    \        min_value = value;\n            smallest_index = i;\n        }\n    }\n\
    \    if min_value == isize::MAX {\n        return vec![];\n    }\n    let mut\
    \ indexes = vec![smallest_index];\n    for value in arr.iter().take(smallest_index).filter(|i|\
    \ i % 2 == 0) {\n        indexes.push((value + smallest_index) / 2)\n    }\n \
    \   return indexes;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpur4smshv.rs:30:18\n\
    \   |\n30 |         if value == 0 && i != 0 {\n   |                  ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpur4smshv.rs:33:20\n   |\n33 |         if value < min_value {\n   | \
    \                   ^^^^^^^^^\n   |                    |\n   |               \
    \     expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpur4smshv.rs:34:25\n\
    \   |\n27 |     let mut min_value = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n34 |             min_value = value;\n\
    \   |                         ^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n34 |             min_value = *value;\n\
    \   |                         +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmpur4smshv.rs:42:63\n   |\n42 |     for value in arr.iter().take(smallest_index).filter(|i|\
    \ i % 2 == 0) {\n   |                                                        \
    \     - ^ - {integer}\n   |                                                  \
    \           |\n   |                                                          \
    \   &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference `i`\n\
    \   |\n42 |     for value in arr.iter().take(smallest_index).filter(|i| *i % 2\
    \ == 0) {\n   |                                                             +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpur4smshv.rs:43:31\n   |\n43 |\
    \         indexes.push((value + smallest_index) / 2)\n   |                   \
    \            ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ add `usize"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut lowest = isize::MAX;\n    let mut smallest_index = isize::MAX;\n\
    \    for i in 0..arr.len() {\n        if arr[i] < lowest {\n            lowest\
    \ = arr[i];\n            smallest_index = i;\n        }\n    }\n    vec![smallest_index,\
    \ lowest]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcu5k0u3d.rs:32:30\n   |\n\
    28 |     let mut smallest_index = isize::MAX;\n   |                          \
    \    ---------- expected due to this value\n...\n32 |             smallest_index\
    \ = i;\n   |                              ^ expected `isize`, found `usize`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut pivot_idx = arr.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n\
    \    let mut pivot_value = arr[[pivot_idx]];\n\n    for i in pivot_idx - 1..arr.len()\
    \ {\n        if arr[i] % 2 == 0 {\n            pivot_value = arr[i];\n       \
    \     pivot_idx = i;\n        }\n    }\n\n    vec![pivot_value, pivot_idx]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `[&isize; 1]`\n \
    \ --> /tmp/tmpk6a5vtpi.rs:28:27\n   |\n28 |     let mut pivot_value = arr[[pivot_idx]];\n\
    \   |                           ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `[&isize; 1]`\n   = note: required because of the requirements\
    \ on the impl of `Index<[&isize; 1]>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk6a5vtpi.rs:30:29\n   |\n30 |     for i in pivot_idx -\
    \ 1..arr.len() {\n   |                             ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpk6a5vtpi.rs:31:12\n   |\n31 |         if arr[i] % 2 == 0 {\n  \
    \ |            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpk6a5vtpi.rs:32:27\n\
    \   |\n32 |             pivot_value = arr[i];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk6a5vtpi.rs:33:25\n   |\n27 |     let mut pivot_idx\
    \ = arr.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n   |      \
    \                   ------------------------------------------------------------\
    \ expected due to this value\n...\n33 |             pivot_idx = i;\n   |     \
    \                    ^\n   |                         |\n   |                 \
    \        expected `&isize`, found `isize`\n   |                         help:\
    \ consider borrowing h"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = i32::MAX;\n    let mut smallest_even = i32::MAX;\n    let mut\
    \ smallest_even_index: usize = 0;\n    for i in 0..arr.len() {\n        if i %\
    \ 2 == 0 && arr[i] < min {\n            smallest_even = arr[i];\n            smallest_even_index\
    \ = i;\n            min = i32::MAX;\n        }\n        if i % 2 == 0 && arr[i]\
    \ == smallest {\n            min = i32::MAX;\n        }\n    }\n    smallest_even.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `smallest` in this scope\n  --> /tmp/tmplzdouis1.rs:36:36\n\
    \   |\n36 |         if i % 2 == 0 && arr[i] == smallest {\n   |              \
    \                      ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplzdouis1.rs:31:35\n   |\n31 |         if i % 2 == 0 &&\
    \ arr[i] < min {\n   |                                   ^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n31 |         if i % 2 == 0 && arr[i]\
    \ < min.try_into().unwrap() {\n   |                                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplzdouis1.rs:32:29\n   |\n28 |\
    \     let mut smallest_even = i32::MAX;\n   |                             --------\
    \ expected due to this value\n...\n32 |             smallest_even = arr[i];\n\
    \   |                             ^^^^^^ expected `i32`, found `isize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `i32` in the current scope\n  --> /tmp/tmplzdouis1.rs:40:19\n\
    \   |\n40 |     smallest_even.iter().cloned().collect::<Vec<_>>()\n   |      \
    \             ^^^^ method not found in `i32`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_val: isize = -1;\n    let mut smallest_idx: isize = -1;\n\
    \    for &i in &arr {\n        if i > 0 {\n            if smallest_val < i {\n\
    \                smallest_val = i;\n            }\n            if smallest_val\
    \ == i && smallest_idx < i {\n                smallest_idx = i;\n            }\n\
    \        }\n    }\n    return vec![smallest_val, smallest_idx];\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4]`,\n right: `[2, 1]`', /tmp/tmp3cjy_42r.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest: isize = 0;\n    let mut smallest_index: usize = 0;\n  \
    \  let mut current_index: usize = 0;\n    let mut current_value = arr[0];\n  \
    \  let mut current_indexed = 0;\n    for num in arr.iter().rev() {\n        if\
    \ num % 2 == 0 {\n            current_value = num;\n            current_indexed\
    \ = current_index;\n            current_index += 1;\n        } else if num < current_value\
    \ {\n            smallest = current_value;\n            smallest_index = current_indexed;\n\
    \        }\n    }\n    let mut output: Vec<isize> = vec![];\n    if smallest ==\
    \ 0 {\n        return vec![];\n    }\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        if arr[i] == smallest {\n            i += 1;\n        }\n       \
    \ else {\n            i += 1;\n        }\n    }\n    output.push(smallest);\n\
    \    output.push(smallest_index);\n    return output;\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgm9vws69.rs:34:29\n   |\n\
    30 |     let mut current_value = arr[0];\n   |                             ------\
    \ expected due to this value\n...\n34 |             current_value = num;\n   |\
    \                             ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n34 |             current_value = *num;\n\
    \   |                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgm9vws69.rs:37:25\n\
    \   |\n37 |         } else if num < current_value {\n   |                    \
    \     ^^^^^^^^^^^^^\n   |                         |\n   |                    \
    \     expected `&isize`, found `isize`\n   |                         help: consider\
    \ borrowing here: `&current_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgm9vws69.rs:56:17\n\
    \   |\n56 |     output.push(smallest_index);\n   |                 ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n56 |     output.push(smallest_index.try_into().unwrap());\n\
    \   |                               ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ans = vec![];\n    for &i in &arr {\n        if i % 2 == 0 {\n  \
    \          ans.push(i);\n        }\n    }\n    ans.sort_by_key(|i| i);\n    let\
    \ mut index = Vec::new();\n    while ans.len() > 0 {\n        let mut i = 0;\n\
    \        for &i in &ans {\n            if i % 2 == 0 {\n                index.add(i);\n\
    \                ans.remove(i);\n                break;\n            }\n     \
    \       i += 1;\n        }\n    }\n    index\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `add` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmpxroglcw1.rs:39:23\n   |\n39 |                 index.add(i);\n\
    \   |                       ^^^ method not found in `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxroglcw1.rs:40:28\n   |\n40 |              \
    \   ans.remove(i);\n   |                            ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n40 |                 ans.remove(i.try_into().unwrap());\n\
    \   |                             ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| a.partial_cmp(b))\n        .filter(|x| x.0 % 2 == 0)\n\
    \        .next()\n        .unwrap_or(Vec::new())\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpucnva_jz.rs:27:24\n   |\n\
    27 |     arr.sort_by(|a, b| a.partial_cmp(b))\n   |                        ^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n              found enum `Option<std::cmp::Ordering>`\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpucnva_jz.rs:28:10\n   |\n\
    28 |         .filter(|x| x.0 % 2 == 0)\n   |          ^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().filter_map(|x| {\n        if x % 2 == 0 {\n         \
    \   Some(x)\n        } else {\n            None\n        }\n    }).cloned().min_by_key(|x|\
    \ x).map(|x| x).collect()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmpkhyr88ta.rs:27:36:\
    \ 33:6] as FnOnce<(isize,)>>::Output == Option<&_>`\n    --> /tmp/tmpkhyr88ta.rs:33:8\n\
    \     |\n33   |     }).cloned().min_by_key(|x| x).map(|x| x).collect()\n     |\
    \        ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected\
    \ enum `Option<&_>`\n                found enum `Option<isize>`\n     = note:\
    \ required because of the requirements on the impl of `Iterator` for `FilterMap<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpkhyr88ta.rs:27:36: 33:6]>`\nnote: required by a bound\
    \ in `cloned`\n\nerror[E0599]: the method `min_by_key` exists for struct `Cloned<FilterMap<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpkhyr88ta.rs:27:36: 33:6]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpkhyr88ta.rs:33:17\n   |\n33 |        }).cloned().min_by_key(|x|\
    \ x).map(|x| x).collect()\n   |                    ^^^^^^^^^^ method cannot be\
    \ called on `Cloned<FilterMap<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpkhyr88ta.rs:27:36:\
    \ 33:6]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<FilterMap<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpkhyr88ta.rs:27:36: 33:6]> as Iterator>::Item = &_`\n\
    \           which is required by `Cloned<FilterMap<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpkhyr88ta.rs:27:36: 33:6]>>: Iterator`\n          \
    \ `Cloned<FilterMap<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpkhyr88ta.rs:27:36:\
    \ 33:6]>>: Iterator`\n           which is required by `&mut Cloned<FilterMap<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpkhyr88ta.rs:27:36: 33:6]>>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index = 1;\n    let mut result = vec![\n        arr[0],\n       \
    \ index,\n    ];\n    loop {\n        let mut smallest = index;\n        let mut\
    \ smallest_even_value = false;\n        for index in 0..arr.len() {\n        \
    \    if !arr[index] % 2 {\n                if arr[index] < smallest {\n      \
    \              smallest = arr[index];\n                    smallest_even_value\
    \ = true;\n                }\n            }\n        }\n        if !smallest_even_value\
    \ {\n            break;\n        }\n        result.push(smallest);\n        result.push(index);\n\
    \        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcsmmc1qp.rs:36:16\n   |\n\
    36 |             if !arr[index] % 2 {\n   |                ^^^^^^^^^^^^^^^ expected\
    \ `bool`, found `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Find the smallest even value in arr \n    let mut smalest_value : isize\
    \ = arr[0];\n    let mut smallest_index : usize = usize::MAX;\n    for (i, value)\
    \ in arr.iter().enumerate() {\n        if value % 2 == 0 {\n            smalest_value\
    \ = value;\n            smallest_index = i;\n        }\n    }\n\n    // Find the\
    \ smallest even value in the array and find its index\n    let mut smallest_value\
    \ : isize = arr[smallest_index];\n    for (i, value) in arr.iter().enumerate()\
    \ {\n        if value == smallest_value {\n            smallest_value = value;\n\
    \            smallest_index = i;\n        }\n    }\n\n    // Return smalest value\
    \ and it's index\n    let mut ret: Vec<isize> = vec![];\n    let mut i = smallest_index;\n\
    \    let mut j = smallest_index;\n    while i != j {\n        if arr[i] % 2 ==\
    \ 0 && arr[j] % 2 == 0 {\n            ret.push(i);\n            i += 1;\n    \
    \        j += 1;\n        } else if arr[j] % 2 == 0 {\n            ret.push(j);\n\
    \            j += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuzzauapo.rs:32:29\n   |\n\
    28 |     let mut smalest_value : isize = arr[0];\n   |                       \
    \      ----- expected due to this type\n...\n32 |             smalest_value =\
    \ value;\n   |                             ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |             smalest_value\
    \ = *value;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuzzauapo.rs:41:30\n   |\n38 |     let mut smallest_value : isize\
    \ = arr[smallest_index];\n   |                              ----- expected due\
    \ to this type\n...\n41 |             smallest_value = value;\n   |          \
    \                    ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n41 |             smallest_value = *value;\n\
    \   |                              +\n\nerror[E0277]: can't compare `&isize` with\
    \ `isize`\n  --> /tmp/tmpuzzauapo.rs:40:18\n   |\n40 |         if value == smallest_value\
    \ {\n   |                  ^^ no implementation for `&isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuzzauapo.rs:52:22\n\
    \   |\n52 |             ret.push(i);\n   |                      ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n52 |             ret.push(i.try_into().unwrap());\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuzzauapo.rs:56:22\n   |\n56 |             ret.push(j);\n   |  \
    \                    ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    56 |             ret.push(j.try_into().unwrap());\n   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    let mut result = vec![0; arr.len()];\n    let mut index\
    \ = 0;\n    while index < arr.len() {\n        let even = arr[index] % 2 == 0;\n\
    \        if even {\n            result[index] = arr[index];\n            index\
    \ += 1;\n        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpm4xxrze5.rs:27:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |          --- help: consider changing this to be mutable:\
    \ `mut arr`\n27 |     arr.sort();\n   |     ^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = arr[0];\n    let mut index = 0;\n\n    for &node in &arr\
    \ {\n        if node < min_val {\n            min_val = node;\n            index\
    \ = arr.iter().position(|x| *x == min_val).unwrap();\n        }\n    }\n\n   \
    \ vec![min_val, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpver6n1jn.rs:37:19\n   |\n\
    37 |     vec![min_val, index]\n   |                   ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n37 |     vec![min_val, index.try_into().unwrap()]\n\
    \   |                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = HashMap::new();\n    for &i in arr {\n        if evens.contains_key(&i\
    \ % 2 == 0) {\n            evens.entry(i % 2 == 0).or_insert(i).unwrap();\n  \
    \      }\n    }\n\n    let mut smallest = vec![vec![0]; arr.len()];\n    let mut\
    \ min_even = 0;\n    let mut min_even_index = 0;\n    for (i, e) in evens.iter().enumerate()\
    \ {\n        if e < smallest {\n            smallest = vec![e];\n            min_even\
    \ = i;\n        }\n        if e == smallest {\n            smallest.push(vec![i]);\n\
    \        }\n    }\n    min_even += 1;\n    if min_even < arr.len() {\n       \
    \ min_even_index += 1;\n    }\n    if min_even_index == arr.len() {\n        return\
    \ vec![];\n    }\n    return smallest;\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpc_k82wmd.rs:27:21\n   |\n27 |     let mut evens = HashMap::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc_k82wmd.rs:28:9\n   |\n28 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare `Vec<{integer}>`\
    \ with `Vec<Vec<{integer}>>`\n  --> /tmp/tmpc_k82wmd.rs:38:14\n   |\n38 |    \
    \     if e < smallest {\n   |              ^ no implementation for `Vec<{integer}>\
    \ < Vec<Vec<{integer}>>` and `Vec<{integer}> > Vec<Vec<{integer}>>`\n   |\n  \
    \ = help: the trait `PartialOrd<Vec<Vec<{integer}>>>` is not implemented for `Vec<{integer}>`\n\
    \   = help: the trait `PartialOrd` is implemented for `Vec<T, A>`\n\nerror[E0277]:\
    \ can't compare `{integer}` with `Vec<{integer}>`\n  --> /tmp/tmpc_k82wmd.rs:38:14\n\
    \   |\n38 |         if e < smallest {\n   |              ^ no implementation for\
    \ `{integer} == Vec<{integer}>`\n   |\n   = help: the trait `PartialEq<Vec<{integer}>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<Vec<{integer}>>>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ can't compare `{integer}` with `Vec<{integer}>`\n  --> /tmp/tmpc_k82wmd.rs:42:14\n\
    \   |\n42 |         if e == smallest {\n   |              ^^ no implementation\
    \ for `{integer} == Vec<{integer}>`\n   |\n   = help: the trait `PartialEq<Vec<{integer}>>`\
    \ is not implemented for `{integer}`\n   = help: the following other typ"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_indexes = vec![];\n    let\
    \ mut min_index = -1;\n\n    for &i in arr {\n        if i % 2 == 0 {\n      \
    \      even_values.push(i);\n        }\n        let index = arr.iter().position(|&i|\
    \ i == i).unwrap();\n        if index == min_index {\n            min_indexes[min_index]\
    \ = min_indexes.len();\n            min_index = index;\n        } else {\n   \
    \         min_indexes[min_index] = index;\n        }\n    }\n\n    min_index\n\
    \        .iter()\n        .map(|index| min_indexes[index])\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph5_komrm.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmph5_komrm.rs:29:25\n   |\n29 | \
    \    let mut min_index = -1;\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0599]: no method named `iter`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmph5_komrm.rs:45:10\n\
    \   |\n45 |         .iter()\n   |          ^^^^ method not found in `usize`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index = 0;\n    let mut smalest_value: Option<isize> = None;\n  \
    \  \n    for e in arr {\n        if smalest_value.is_none() && e % 2 == 0 {\n\
    \            smalest_value = Some(e);\n            index = arr.iter().position(|x|\
    \ *x == e).unwrap();\n        }\n        else {\n            if *e < smalest_value.unwrap()\
    \ {\n                smalest_value = Some(e);\n                index = arr.iter().position(|x|\
    \ *x == e).unwrap();\n            }\n        }\n    }\n    if smalest_value.is_none()\
    \ {\n        return vec![];\n    }\n    vec![smalest_value.unwrap(), index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpm1f6cphr.rs:36:16\n\
    \   |\n36 |             if *e < smalest_value.unwrap() {\n   |               \
    \ ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm1f6cphr.rs:45:34\n   |\n\
    45 |     vec![smalest_value.unwrap(), index]\n   |                           \
    \       ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n45 |     vec![smalest_value.unwrap(),\
    \ index.try_into().unwrap()]\n   |                                       ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // sort by even values\n    arr.sort_unstable_by(|a, b| if a % 2 == 0 &&\
    \ b % 2 == 0 {\n        if a < b { -1 } else { 1 }\n    } else {\n        if a\
    \ < b { 1 } else { -1 }\n    })\n    // find the smallest even value\n    let\
    \ mut smallest_index = 0;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            smallest_index = i;\n            break;\n        }\n    }\n    //\
    \ find the smallest even value and its index\n    let mut smallest_value = arr[smallest_index];\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for i in 0..arr.len() {\n \
    \       if i != smallest_index {\n            result.append(arr[i]);\n       \
    \ }\n        if i == smallest_index {\n            if smallest_value % 2 == 0\
    \ {\n                result.append(smallest_value);\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_xsurmzm.rs:32:7\n\
    \   |\n32 |     })\n   |       ^ help: add `;` here\n33 |     // find the smallest\
    \ even value\n34 |     let mut smallest_index = 0;\n   |     --- unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_xsurmzm.rs:29:20\n   |\n29 |\
    \         if a < b { -1 } else { 1 }\n   |                    ^^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_xsurmzm.rs:29:32\n   |\n29 |         if a < b { -1 } else { 1 }\n \
    \  |                                ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_xsurmzm.rs:31:20\n\
    \   |\n31 |         if a < b { 1 } else { -1 }\n   |                    ^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_xsurmzm.rs:31:31\n   |\n31 |         if a < b { 1 } else { -1\
    \ }\n   |                               ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_xsurmzm.rs:37:30\n\
    \   |\n34 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n37 |             smallest_index = i;\n \
    \  |                              ^ expected integer, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n37 |             smallest_index = *i;\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_xsurmzm.rs:46:27\n   |\n46 |             result.append(arr[i]);\n \
    \  |                           ^^^^^^ expected `&mut Vec<isize>`, found `isize`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<isize>`\n             \
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_xsurmzm.rs:50:31\n\
    \   |\n50 |                 result.append(smallest_value);\n   |             \
    \                  ^^^^^^^^^^^^^^ expected `&mut Vec<isize>`, found `isize`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<isize>`\n             \
    \              found type `isize`\n\nerror: aborting due to 8 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    if arr.is_empty() {\n        return vec![];\n    }\n   \
    \ let mut smallest_value: isize = 0;\n    let mut smallest_index: isize = 0;\n\
    \    for index in 0..arr.len() {\n        if arr[index] % 2 == 0 {\n         \
    \   smallest_value = arr[index];\n            smallest_index = index;\n      \
    \  }\n    }\n    vec![(smallest_value, smallest_index)]\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjq0kf_qf.rs:36:30\n   |\n\
    32 |     let mut smallest_index: isize = 0;\n   |                            \
    \ ----- expected due to this type\n...\n36 |             smallest_index = index;\n\
    \   |                              ^^^^^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjq0kf_qf.rs:39:10\n   |\n39 |     vec![(smallest_value,\
    \ smallest_index)]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found tuple\n   |\n   = note: expected type `isize`\n             found tuple\
    \ `(isize, isize)`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n\n    let mut smallest_even\
    \ = arr[0];\n    let mut smallest_index = -1;\n    let mut index = 0;\n    arr.iter().for_each(|x|{\n\
    \        if x % 2 == 0 {\n            smallest_even = x;\n            smallest_index\
    \ = index;\n        }\n        index += 1;\n    });\n\n    let mut result = vec![smallest_even,\
    \ smallest_index];\n    result.sort_by_key(|x| x);\n    return result;\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrmjmak1.rs:36:29\n   |\n\
    31 |     let mut smallest_even = arr[0];\n   |                             ------\
    \ expected due to this value\n...\n36 |             smallest_even = x;\n   | \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n36 |             smallest_even = *x;\n   | \
    \                            +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_val = -1;\n    let mut smallest_even_index = 0;\n \
    \   for &i in &arr {\n        if i % 2 == 0 {\n            if smallest_even_val\
    \ < i {\n                smallest_even_val = i;\n                smallest_even_index\
    \ = 0;\n            } else {\n                if smallest_even_val == i {\n  \
    \                  smallest_even_index += 1;\n                }\n            }\n\
    \        }\n    }\n    vec![smallest_even_val, smallest_even_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 0]`,\n right: `[2, 1]`', /tmp/tmpflx7u36e.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut largest =\
    \ arr[0];\n    let mut smallest = arr[0];\n    let mut counter = 1;\n    for n\
    \ in arr.iter().cloned() {\n        if n % 2 == 0 {\n            if smallest ==\
    \ n && smallest != largest {\n                smallest = n;\n            }\n \
    \           counter = counter + 1;\n        } else {\n            if smallest\
    \ != n {\n                largest = n;\n                counter = 1;\n       \
    \     }\n        }\n    }\n    vec![smallest, counter]\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 1]`,\n right: `[2, 1]`', /tmp/tmp_aaqnqkk.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    use std::cmp::Ordering;\n    let mut min = Option::None();\n    let mut result\
    \ = vec![];\n    for value in arr.iter() {\n        if min == Some(Ordering::Less\
    \ { a, b }) {\n            min = Some(Ordering::Less { a, b });\n            result.push(value);\n\
    \        } else if min == Some(Ordering::Equal { a, b }) {\n            if a >\
    \ value {\n                result.push(value);\n                min = Some(Ordering::Less\
    \ { a, b });\n            } else {\n                result.push(value);\n    \
    \            min = Some(Ordering::Equal { a, b });\n            }\n        } else\
    \ if min == Some(Ordering::Greater { a, b }) {\n            if a < value {\n \
    \               result.push(value);\n                min = Some(Ordering::Less\
    \ { a, b });\n            } else {\n                result.push(value);\n    \
    \            min = Some(Ordering::Greater { a, b });\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmplc79fge1.rs:31:41\n\
    \   |\n31 |         if min == Some(Ordering::Less { a, b }) {\n   |          \
    \                               ^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `b` in this scope\n  --> /tmp/tmplc79fge1.rs:31:44\n   |\n31 |  \
    \       if min == Some(Ordering::Less { a, b }) {\n   |                      \
    \                      ^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `a` in this scope\n  --> /tmp/tmplc79fge1.rs:32:41\n   |\n32 |       \
    \      min = Some(Ordering::Less { a, b });\n   |                            \
    \             ^ not found in this scope\n\nerror[E0425]: cannot find value `b`\
    \ in this scope\n  --> /tmp/tmplc79fge1.rs:32:44\n   |\n32 |             min =\
    \ Some(Ordering::Less { a, b });\n   |                                       \
    \     ^ not found in this scope\n\nerror[E0425]: cannot find value `a` in this\
    \ scope\n  --> /tmp/tmplc79fge1.rs:34:49\n   |\n34 |         } else if min ==\
    \ Some(Ordering::Equal { a, b }) {\n   |                                     \
    \            ^ not found in this scope\n\nerror[E0425]: cannot find value `b`\
    \ in this scope\n  --> /tmp/tmplc79fge1.rs:34:52\n   |\n34 |         } else if\
    \ min == Some(Ordering::Equal { a, b }) {\n   |                              \
    \                      ^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `a` in this scope\n  --> /tmp/tmplc79fge1.rs:35:16\n   |\n35 |       \
    \      if a > value {\n   |                ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `a` in this scope\n  --> /tmp/tmplc79fge1.rs:37:45\n   |\n\
    37 |                 min = Some(Ordering::Less { a, b });\n   |              \
    \                               ^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `b` in this scope\n  --> /tmp/tmplc79fge1.rs:37:48\n   |\n37 |  \
    \               min = Some(Ordering::Less { a, b });\n   |                   \
    \                             ^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `a` in this scope\n  --> /tmp/tmplc79fge1.rs:40:46\n   |\n40 |  \
    \               min = "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::with_capacity(arr.len());\n    let mut current_minimum\
    \ = arr[0];\n    let mut minimum_index = Vec::new();\n\n    for i in 0..arr.len()\
    \ {\n        if current_minimum > arr[i] {\n            current_minimum = arr[i];\n\
    \            minimum_index.clear();\n        }\n        if current_minimum ==\
    \ arr[i] {\n            minimum_index.push(i);\n        }\n    }\n\n    if minimum_index.len()\
    \ == 1 {\n        result.push(minimum_index[0]);\n    } else {\n        result.push(current_minimum);\n\
    \        result.push(minimum_index[0]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvrfhpdsn.rs:44:21\n   |\n\
    44 |         result.push(current_minimum);\n   |                     ^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n44 |         result.push(current_minimum.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvrfhpdsn.rs:47:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n47 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Your code here\n    let mut s = vec![];\n    let mut v = vec![];\n   \
    \ let mut max_value = arr[0];\n    let mut min_value = 0;\n    for i in arr {\n\
    \        if i % 2 == 0 {\n            s.push(i);\n            if i > max_value\
    \ {\n                max_value = i;\n            }\n        }\n        else {\n\
    \            if i == min_value {\n                s.push(i, i);\n            \
    \    if i == max_value {\n                    s.push(i, i);\n                }\n\
    \                min_value = 0;\n            }\n        }\n    }\n    if min_value\
    \ != 0 {\n        v[0] = max_value;\n        v[1] = min_value;\n    }\n    else\
    \ {\n        v[0] = max_value;\n        v[1] = s.len();\n    }\n    return v;\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp3tavh237.rs:41:19\n     |\n41   |                 s.push(i, i);\n\
    \     |                   ^^^^ -  - supplied 2 arguments\n     |             \
    \      |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 2\
    \ arguments were supplied\n    --> /tmp/tmp3tavh237.rs:43:23\n     |\n43   | \
    \                    s.push(i, i);\n     |                       ^^^^ -  - supplied\
    \ 2 arguments\n     |                       |\n     |                       expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3tavh237.rs:55:16\n   |\n55 |         v[1] =\
    \ s.len();\n   |         ----   ^^^^^^^ expected `isize`, found `usize`\n   |\
    \         |\n   |         expected due to the type of this binding\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut smallest_value = arr[0];\n    let mut\
    \ smallest_index = 0;\n    let mut is_first_odd = false;\n    let mut odd_counter\
    \ = 0;\n    for i in arr.iter().enumerate() {\n        if i.1 == 0 {\n       \
    \     is_first_odd = true;\n            odd_counter = 0;\n        } else if i.1\
    \ % 2 == 1 {\n            odd_counter += 1;\n        }\n        if odd_counter\
    \ < 2 && !is_first_odd {\n            continue;\n        }\n        if smallest_value\
    \ < i.1 {\n            smallest_value = i.1;\n            smallest_index = i.0;\n\
    \        }\n    }\n    result.push(smallest_value, smallest_index);\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpiji925ix.rs:33:16\n\
    \   |\n33 |         if i.1 == 0 {\n   |                ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpiji925ix.rs:42:29\n   |\n42 |         if smallest_value < i.1 {\n  \
    \ |                             ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n42 |         if smallest_value < *i.1\
    \ {\n   |                             +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpiji925ix.rs:43:30\n   |\n28 |     let mut smallest_value = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n43\
    \ |             smallest_value = i.1;\n   |                              ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    43 |             smallest_value = *i.1;\n   |                              +\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpiji925ix.rs:47:12\n     |\n47   |     result.push(smallest_value,\
    \ smallest_index);\n     |            ^^^^ --------------  -------------- supplied\
    \ 2 arguments\n     |            |\n     |            expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut index\
    \ = -1;\n    let mut smallest = arr.iter().min(|a, b| a.partial_cmp(b).unwrap());\n\
    \    loop {\n        let result = &arr[smallest];\n        if result.partial_cmp(&0)\
    \ > 0 {\n            smallest = index;\n        } else {\n            index =\
    \ smallest - 1;\n        }\n        if index == -1 || index == arr.len() - 1 {\n\
    \            break;\n        }\n        smallest = index;\n    }\n    arr.iter().map(|node|\
    \ node.clone()).collect()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpm49azk61.rs:29:40\n\
    \   |\n29 |     let mut smallest = arr.iter().min(|a, b| a.partial_cmp(b).unwrap());\n\
    \   |                                        ^ consider giving this closure parameter\
    \ a type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpm49azk61.rs:29:35\n\
    \     |\n29   |     let mut smallest = arr.iter().min(|a, b| a.partial_cmp(b).unwrap());\n\
    \     |                                   ^^^ --------------------------------\
    \ supplied 1 argument\n     |                                   |\n     |    \
    \                               expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `Option<&isize>`\n  --> /tmp/tmpm49azk61.rs:31:23\n   |\n31 |         let\
    \ result = &arr[smallest];\n   |                       ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `Option<&isize>`\n   = note: required because of the\
    \ requirements on the impl of `Index<Option<&isize>>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm49azk61.rs:33:24\n   |\n29 |     let mut smallest\
    \ = arr.iter().min(|a, b| a.partial_cmp(b).unwrap());\n   |                  \
    \      ------------------------------------------------ expected due to this value\n\
    ...\n33 |             smallest = index;\n   |                        ^^^^^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `{integer}`\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `Option<&isize>`\n  --> /tmp/tmpm49azk61.rs:35:30\n   |\n35 |         \
    \    index = smallest - 1;\n   |                     -------- ^ - {integer}\n\
    \   |                     |\n   |                     Option<&isize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm49azk61.rs:40:20\n   |\n29 |     let mut smallest\
    \ = arr.iter().min(|a, b| a.partial_cmp(b).unwrap());\n   |                 "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // write your code here\n    let mut min_val = arr[0];\n    let mut min_idx\
    \ = 0;\n    for (idx, val) in arr.iter().enumerate() {\n        if val == min_val\
    \ {\n            if val % 2 == 0 {\n                min_val = val;\n         \
    \       min_idx = idx;\n            }\n        }\n    }\n    let mut out: [&isize;\
    \ 2] = [&min_val, &min_idx];\n    let mut out_idx = 0;\n    for val in arr.iter()\
    \ {\n        if val == min_val {\n            if val % 2 == 0 {\n            \
    \    out[out_idx] = val;\n                out_idx += 1;\n            }\n     \
    \   }\n    }\n    if out_idx == 0 {\n        return vec![];\n    } else {\n  \
    \      return out;\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp63q5awz7.rs:31:16\n\
    \   |\n31 |         if val == min_val {\n   |                ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp63q5awz7.rs:33:27\n   |\n28 |     let mut min_val = arr[0];\n   |  \
    \                     ------ expected due to this value\n...\n33 |           \
    \      min_val = val;\n   |                           ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \         min_val = *val;\n   |                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp63q5awz7.rs:38:43\n   |\n38 |     let mut out: [&isize;\
    \ 2] = [&min_val, &min_idx];\n   |                                           ^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected reference `&isize`\n\
    \              found reference `&usize`\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp63q5awz7.rs:41:16\n   |\n41 |         if val ==\
    \ min_val {\n   |                ^^ no implementation for `&isize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp63q5awz7.rs:51:16\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n51\
    \ |         return out;\n   |                ^^^ expected struct `Vec`, found\
    \ array `[&isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \        fo"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    \n    let mut mut_arr\
    \ = arr.clone();\n    let mut min_idx = Vec::new();\n    let mut min_value = arr.iter().min().unwrap();\n\
    \    let mut mut_idx = 1;\n    while min_value % 2 == 0 {\n        min_value =\
    \ min_value / 2;\n        min_idx[mut_idx] = min_value;\n        mut_idx += 1;\n\
    \    }\n    for i in min_idx.iter_mut() {\n        *i += 1;\n    }\n    \n   \
    \ let mut_result = Vec::new();\n    for j in min_idx.iter_mut() {\n        mut_result.push(j);\n\
    \    }\n    \n    return mut_result;\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxaw7tb13.rs:36:21\n   |\n\
    33 |     let mut min_value = arr.iter().min().unwrap();\n   |                \
    \         ------------------------- expected due to this value\n...\n36 |    \
    \     min_value = min_value / 2;\n   |                     ^^^^^^^^^^^^^\n   |\
    \                     |\n   |                     expected `&isize`, found `isize`\n\
    \   |                     help: consider borrowing here: `&(min_value / 2)`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&isize`\n\
    \  --> /tmp/tmpxaw7tb13.rs:41:9\n   |\n41 |         *i += 1;\n   |         --^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&isize`\n   |\nhelp: `+=`\
    \ can be used on `isize`, you can dereference `*i`\n   |\n41 |         **i +=\
    \ 1;\n   |         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxaw7tb13.rs:49:12\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n49\
    \ |     return mut_result;\n   |            ^^^^^^^^^^ expected `isize`, found\
    \ `&mut &isize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<&mut &isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smalest_value: isize = 0;\n    let mut smallest_index: usize = 0;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 {\n       \
    \     if smalest_value < v {\n                smalest_value = v;\n           \
    \     smallest_index = i;\n            }\n        }\n    }\n    if smalest_value\
    \ == 0 {\n        return vec![];\n    }\n    vec![smalest_value, smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp79kd7iwc.rs:31:32\n   |\n\
    31 |             if smalest_value < v {\n   |                                ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n31 |             if smalest_value < *v {\n   |                        \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp79kd7iwc.rs:32:33\n\
    \   |\n27 |     let mut smalest_value: isize = 0;\n   |                      \
    \      ----- expected due to this type\n...\n32 |                 smalest_value\
    \ = v;\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smalest_value\
    \ = *v;\n   |                                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp79kd7iwc.rs:40:25\n   |\n40 |     vec![smalest_value, smallest_index]\n\
    \   |                         ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n40 |     vec![smalest_value, smallest_index.try_into().unwrap()]\n\
    \   |                                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut smallest_even = arr[0];\n    let\
    \ mut smallest_index = 0;\n    let mut evens_seen = Vec::new();\n    for idx in\
    \ 0..arr.len() {\n        evens_seen.push(false);\n    }\n    for n in arr {\n\
    \        if n % 2 == 0 {\n            smallest_even += n;\n            smallest_index\
    \ = idx;\n            evens_seen[idx] = true;\n        }\n    }\n    if smallest_even\
    \ < 10 {\n        result.push(smallest_even);\n        result.push(smallest_index);\n\
    \    }\n    if evens_seen.iter().any(|x| *x) {\n        result.push(smallest_even);\n\
    \        result.push(smallest_index);\n    }\n    if result.is_empty() {\n   \
    \     return Vec::new();\n    }\n    vec![result]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `idx` in this scope\n  --> /tmp/tmpqkph72om.rs:37:30\n\
    \   |\n37 |             smallest_index = idx;\n   |                          \
    \    ^^^ not found in this scope\n\nerror[E0425]: cannot find value `idx` in this\
    \ scope\n  --> /tmp/tmpqkph72om.rs:38:24\n   |\n38 |             evens_seen[idx]\
    \ = true;\n   |                        ^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqkph72om.rs:52:10\n   |\n52 |     vec![result]\n\
    \   |          ^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<isize>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    \n    let mut evens = Vec::new();\n    let mut min_val = i32::MAX;\n    for\
    \ i in arr {\n        if i & 1 == 0 {\n            evens.push(i);\n          \
    \  if min_val < i as i32 {\n                min_val = i as i32;\n            }\n\
    \        }\n    }\n    let mut evens_sorted = evens.iter().cloned().sort();\n\
    \    if evens_sorted.len() == 0 || evens_sorted[0] % 2 == 0 {\n        return\
    \ []\n    } else {\n        let mut i = 0;\n        let mut even_index = evens_sorted.first().unwrap();\n\
    \        evens_sorted.pop();\n        for mut j in evens_sorted {\n          \
    \  if even_index == j {\n                i += 1;\n            } else {\n     \
    \           break;\n            }\n        }\n        return Vec::new().push(min_val).push(i);\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpzg3kbto6.rs:38:50\n   |\n38 |     let mut evens_sorted\
    \ = evens.iter().cloned().sort();\n   |                                      \
    \            ^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzg3kbto6.rs:40:16\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n40 |         return []\n\
    \   |                ^^- help: try using a conversion method: `.to_vec()`\n  \
    \ |                |\n   |                expected struct `Vec`, found array of\
    \ 0 elements\n   |\n   = note: expected struct `Vec<isize>`\n               found\
    \ array `[_; 0]`\n\nerror[E0599]: no method named `push` found for unit type `()`\
    \ in the current scope\n  --> /tmp/tmpzg3kbto6.rs:52:41\n   |\n52 |         return\
    \ Vec::new().push(min_val).push(i);\n   |                                    \
    \     ^^^^ method not found in `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n\n    let mut largest_val_index\
    \ = 1;\n    let mut largest_val: isize = 0;\n    let mut smallest_val: isize =\
    \ 100;\n\n    for index in 0..arr.len() {\n        if arr[index] >= largest_val\
    \ {\n            largest_val_index = index;\n            largest_val = arr[index];\n\
    \        }\n        if arr[index] < smallest_val {\n            smallest_val =\
    \ arr[index];\n        }\n    }\n    let mut ret = vec![];\n\n    if smallest_val\
    \ % 2 == 0 {\n        ret.push(smallest_val);\n        ret.push(largest_val_index);\n\
    \    }\n    else {\n        let mut smallest_val_i = 1usize;\n        let mut\
    \ smallest_val_i_pos = 0;\n        let mut largest_val_i = 1usize;\n        let\
    \ mut largest_val_i_pos = 0;\n        for index in 0..arr.len() {\n          \
    \  if arr[index] >= largest_val {\n                largest_val_i = index;\n  \
    \              largest_val = arr[index];\n            }\n\n            if arr[index]\
    \ < smallest_val {\n                smallest_val_i = index;\n                smallest_val\
    \ = arr[index];\n            }\n\n            if arr[index] >= smallest_val {\n\
    \                smallest_val_i_pos += 1;\n            }\n\n            if arr[index]\
    \ >= largest_val {\n                largest_val_i_pos += 1;\n            }\n \
    \       }\n        ret.push(smallest_val);\n        ret.push(smallest_val_i_pos);\n\
    \        ret.push(largest_val);\n        ret.push(largest_val_i_pos);\n    }\n\
    \    return ret;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcnxojclu.rs:48:18\n   |\n\
    48 |         ret.push(largest_val_index);\n   |                  ^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n48 |         ret.push(largest_val_index.try_into().unwrap());\n\
    \   |                                   ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() || arr.iter().any(|x| x == 0) {\n        return vec![];\n\
    \    }\n    let mut even_value_index = 0\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for num in arr.iter().cloned() {\n     \
    \   if num % 2 == 0 {\n            if smallest_value == num {\n              \
    \  even_value_index += 1;\n            }\n            else {\n               \
    \ if smallest_value < num {\n                    smallest_value = num;\n     \
    \               even_value_index = 1;\n                }\n                else\
    \ {\n                    smallest_value = smallest_value;\n                  \
    \  even_value_index += 1;\n                }\n            }\n        }\n    }\n\
    \    smallest_index = arr.len() - even_value_index;\n    let mut returning_vec\
    \ = vec![];\n    for i in 0..even_value_index {\n        returning_vec.push(smallest_value,\
    \ i);\n    }\n    returning_vec\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5i91lr9i.rs:30:33\n\
    \   |\n30 |     let mut even_value_index = 0\n   |                           \
    \      ^ help: add `;` here\n31 |     let mut smallest_value = arr[0];\n   | \
    \    --- unexpected token\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp5i91lr9i.rs:27:47\n   |\n27 |     if arr.is_empty() || arr.iter().any(|x|\
    \ x == 0) {\n   |                                               ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0061]: this function takes 1\
    \ argument but 2 arguments were supplied\n    --> /tmp/tmp5i91lr9i.rs:53:23\n\
    \     |\n53   |         returning_vec.push(smallest_value, i);\n     |       \
    \                ^^^^ --------------  - supplied 2 arguments\n     |         \
    \              |\n     |                       expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().enumerate().filter(|(_, node)| {\n        node%2 != 0\n\
    \    }).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxrroqaam.rs:27:5\n   |\n\
    26 |   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                       \
    \         ---------- expected `Vec<isize>` because of return type\n27 | /    \
    \ arr.iter().cloned().enumerate().filter(|(_, node)| {\n28 | |         node%2\
    \ != 0\n29 | |     }).collect::<Vec<_>>()\n   | |__________________________^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \        found struct `Vec<(usize, isize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = 0;\n    let mut smallest_even_value = arr[0];\n   \
    \ let mut smallest_index = 0;\n    for i in 0..arr.len() {\n        let value\
    \ = arr[i];\n        if i % 2 == 0 {\n            even_values += 1;\n        \
    \    if value < smallest_even_value {\n                smallest_even_value = value;\n\
    \                smallest_index = i;\n            }\n        }\n    }\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    for i in 0..even_values {\n      \
    \  result.push(smallest_even_value);\n    }\n    if even_values == arr.len() {\n\
    \        assert!(smallest_index != 0, \"All array elements are even!\");\n   \
    \     result.push(smallest_index);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_9hg2orz.rs:46:21\n   |\n\
    46 |         result.push(smallest_index);\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n46 |         result.push(smallest_index.try_into().unwrap());\n\
    \   |                                   ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::<isize>::new();\n    for &x in arr {\n       \
    \ if x % 2 == 0 {\n            even_values.push(x);\n        }\n    }\n    let\
    \ mut smallest_value = even_values.iter().cloned().min_by_key(|&x| {\n       \
    \ if x % 2 == 0 {\n            x.clone()\n        } else {\n            x.clone()\
    \ / 2.clone()\n        }\n    });\n    let mut smallest_index = -1;\n    for i\
    \ in even_values.iter().enumerate() {\n        if smallest_value == i.1.clone()\
    \ {\n            smallest_index = i.0.clone();\n            break;\n        }\n\
    \    }\n    if smallest_index == -1 {\n        return Vec::<isize>::new();\n \
    \   } else {\n        let mut result = Vec::<isize>::new();\n        result.push((smallest_value,\
    \ smallest_index));\n        return result;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8k1r2tlp.rs:28:9\n   |\n\
    28 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8k1r2tlp.rs:42:30\n   |\n42 |         if smallest_value == i.1.clone()\
    \ {\n   |                              ^^^^^^^^^^^ expected enum `Option`, found\
    \ `isize`\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n42 |      \
    \   if smallest_value == Some(i.1.clone()) {\n   |                           \
    \   +++++           +\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp8k1r2tlp.rs:40:30\n   |\n40 |     let mut smallest_index = -1;\n\
    \   |                              ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmp8k1r2tlp.rs:47:26\n   |\n47 |     if smallest_index == -1 {\n \
    \  |                          ^^\n   |                          |\n   |      \
    \                    cannot apply unary operator `-`\n   |                   \
    \       help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8k1r2tlp.rs:51:21\n   |\n51 |         result.push((smallest_value,\
    \ smallest_index));\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(Option<isize>, usize)`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = arr[0]\n    let mut min_i = arr.len();\n    for &v in arr.iter_mut()\
    \ {\n        if v < min {\n            min = v;\n        }\n        v.0 % 2 ==\
    \ 0\n            ? (*v)\n            : *v = *v - min as isize;\n        if *v\
    \ < min_i {\n            min_i = *v;\n        }\n    }\n    arr.iter_mut().filter(|&v|\
    \ v == min).cloned().collect()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbjurjocw.rs:27:25\n\
    \   |\n27 |     let mut min = arr[0]\n   |                         ^ help: add\
    \ `;` here\n28 |     let mut min_i = arr.len();\n   |     --- unexpected token\n\
    \nerror: expected mut or const in raw pointer type\n  --> /tmp/tmpbjurjocw.rs:35:15\n\
    \   |\n35 |             : *v = *v - min as isize;\n   |               ^ expected\
    \ mut or const in raw pointer type\n   |\n   = help: use `*mut T` or `*const T`\
    \ as appropriate\n\nerror[E0573]: expected type, found local variable `v`\n  -->\
    \ /tmp/tmpbjurjocw.rs:35:16\n   |\n35 |             : *v = *v - min as isize;\n\
    \   |             -  ^ expecting a type here because of type ascription\n   |\
    \             |\n   |             help: maybe you meant to write `;` here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbjurjocw.rs:29:9\n   |\n29 |   \
    \  for &v in arr.iter_mut() {\n   |         ^^    -------------- this expression\
    \ has type `Option<&mut isize>`\n   |         |\n   |         types differ in\
    \ mutability\n   |         help: you can probably remove the explicit borrow:\
    \ `v`\n   |\n   = note: expected mutable reference `&mut isize`\n            \
    \          found reference `&_`\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpbjurjocw.rs:35:18\n   |\n33 | /         v.0 % 2 == 0\n34 | |  \
    \           ? (*v)\n35 | |             : *v = *v - min as isize;\n   | |     \
    \           - ^\n   | |________________|\n   |                  cannot assign\
    \ to this expression\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpbjurjocw.rs:33:11\n   |\n33 |         v.0\
    \ % 2 == 0\n   |           ^\n\nerror[E0277]: the `?` operator can only be applied\
    \ to values that implement `Try`\n  --> /tmp/tmpbjurjocw.rs:33:20\n   |\n33 |\
    \           v.0 % 2 == 0\n   |  ____________________^\n34 | |             ? (*v)\n\
    \   | |_____________^ the `?` operator cannot be applied to type `{integer}`\n\
    \   |\n   = help: the trait `Try` is not implemented for `{integer}`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `O"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = arr.iter().filter(|&x| x % 2 == 0).collect::<Vec<_>>();\n\
    \    even_values.sort_unstable_by_key(|&x| x);\n    even_values.reverse();\n \
    \   let mut smallest_even_value: isize;\n    let mut smallest_value: isize;\n\
    \    let mut smallest_index: usize;\n    for &x in &even_values {\n        if\
    \ smallest_value < x {\n            smallest_value = x;\n            smallest_index\
    \ = 0;\n        } else if smallest_value == x {\n            smallest_index +=\
    \ 1;\n        }\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvua99_g.rs:34:29\n   |\n\
    34 |         if smallest_value < x {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |         if smallest_value < *x {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpyvua99_g.rs:35:30\n   |\n31 |  \
    \   let mut smallest_value: isize;\n   |                             ----- expected\
    \ due to this type\n...\n35 |             smallest_value = x;\n   |          \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |             smallest_value = *x;\n   |\
    \                              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyvua99_g.rs:37:37\n\
    \   |\n37 |         } else if smallest_value == x {\n   |                    \
    \                 ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n37 |         } else if smallest_value == *x {\n   |      \
    \                               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyvua99_g.rs:41:26\n\
    \   |\n41 |     vec![smallest_value, smallest_index]\n   |                   \
    \       ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    41 |     vec![smallest_value, smallest_index.try_into().unwrap()]\n   |      \
    \                                  ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = arr.filter(|x| x % 2 == 0);\n    even_values.sort();\n\
    \    let mut result = [];\n    let mut idx: usize = 0;\n    while even_values.len()\
    \ > 0 {\n        if idx > 0 && even_values[idx] == 0 {\n            idx += 1;\n\
    \            continue;\n        }\n        let res = even_values.nth(0);\n   \
    \     result.push(res);\n        idx += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpr6sks48x.rs:27:31\n\
    \    |\n27  |       let mut even_values = arr.filter(|x| x % 2 == 0);\n    | \
    \                                ^^^^^^ `Vec<isize>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in\
    \ the current scope\n  --> /tmp/tmpr6sks48x.rs:37:16\n   |\n37 |         result.push(res);\n\
    \   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr6sks48x.rs:40:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n40 |     result\n   |     ^^^^^^- help: try using\
    \ a conversion method: `.to_vec()`\n   |     |\n   |     expected struct `Vec`,\
    \ found array of 0 elements\n   |\n   = note: expected struct `Vec<isize>`\n \
    \              found array `[_; 0]`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // return an empty list if the array is empty\n    if arr.len() == 0 {\n\
    \        return vec![];\n    }\n    // store the smallest even value in the first\
    \ place\n    let mut smallest_even_value = arr[0];\n    // store the smallest\
    \ even value in the first place\n    let mut smallest_even_index = -1;\n    //\
    \ store the smallest even value index\n    let mut smallest_even_index_pos = -1;\n\
    \    // store the smallest even value index\n    let mut smallest_even_index_neg\
    \ = -1;\n    // iterate over the given array to check which value is smaller than\
    \ the previous even value\n    for i in 1..arr.len() {\n        // if the current\
    \ value is smaller than the current smallest even value\n        if arr[i] < smallest_even_value\
    \ {\n            // store the current smallest even value\n            smallest_even_value\
    \ = arr[i];\n            // store the current smallest even value index\n    \
    \        smallest_even_index = i;\n        }\n    }\n    // if the smallest even\
    \ value is the same, no need to pluck any more nodes\n    if smallest_even_value\
    \ == arr[0] {\n        return vec![];\n    }\n    // pluck another node if the\
    \ current smallest even value is bigger than the current smallest value\n    if\
    \ smallest_even_value > arr[0] {\n        // if the current smallest even value\
    \ is bigger than the current smallest value\n        if smallest_even_value >\
    \ arr[1] {\n            // store the current smallest even value index\n     \
    \       smallest_even_index_pos = 0;\n            // calculate the pluck index\n\
    \            smallest_even_index = smallest_even_index + smallest_even_index_pos;\n\
    \        } else {\n            // store the current smallest even value index\n\
    \            smallest_even_index_neg = 1;\n            // calculate the pluck\
    \ index\n            smallest_even_index = smallest_even_index + smallest_even_index_neg;\n\
    \        }\n    }\n    // calculate the pluck index\n    let mut pluck_pos = smallest_even_index\
    \ + 1;\n    let mut pluck_neg = smallest_even_index - 1;\n    // iterate over\
    \ the array again and pluck another node if the current smallest even value is\
    \ smaller than the current smallest value\n    while pluck_pos < arr.len() ||\
    \ pluck_neg > 0 {\n        if pluck_pos < arr.len() && arr[pluck_pos] > arr[0]\
    \ {\n            pluck_pos++;\n            if pluck_pos < arr.len() && arr[pluck_pos]\
    \ < arr[1] {\n                pluck_pos++;\n            }\n        }\n       \
    \ if pluck_neg > 0 && arr[pluck_neg] < arr[0] {\n            pluck_neg--;\n  \
    \          if pluck_neg < arr.len() && arr[pluck_neg] > arr[1] {\n           \
    \     pluck_neg--;\n            }\n        }\n    }\n    // return the pluck index\n\
    \    return vec![\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp3ko0yrae.rs:74:22\n\
    \   |\n74 |             pluck_pos++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n74 |             { let\
    \ tmp = pluck_pos; pluck_pos += 1; tmp };\n   |             +++++++++++      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~\n74 -             pluck_pos++;\n74 +            \
    \ pluck_pos += 1;\n   | \n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp3ko0yrae.rs:80:25\n\
    \   |\n80 |             pluck_neg--;\n   |                         ^ help: add\
    \ `;` here\n81 |             if pluck_neg < arr.len() && arr[pluck_neg] > arr[1]\
    \ {\n   |             -- unexpected token\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp3ko0yrae.rs:87:16\n   |\n26 | fn pluck(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                         - closing delimiter\
    \ possibly meant for this\n...\n87 |     return vec![\n   |                ^ unclosed\
    \ delimiter\n88 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3ko0yrae.rs:34:35\n\
    \   |\n34 |     let mut smallest_even_index = -1;\n   |                      \
    \             ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3ko0yrae.rs:36:39\n\
    \   |\n36 |     let mut smallest_even_index_pos = -1;\n   |                  \
    \                     ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3ko0yrae.rs:38:39\n\
    \   |\n38 |     let mut smal"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = 0;\n    let mut min_even_index = 0;\n\n    for &index\
    \ in &arr {\n        if *index % 2 == 0 {\n            *index = *index / 2;\n\
    \            if min_even <= *index {\n                min_even = *index;\n   \
    \             min_even_index = index;\n            }\n        }\n    }\n\n   \
    \ vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpti9e7g_m.rs:31:12\n\
    \   |\n31 |         if *index % 2 == 0 {\n   |            ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpti9e7g_m.rs:32:13\n   |\n\
    32 |             *index = *index / 2;\n   |             ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpti9e7g_m.rs:32:22\n   |\n\
    32 |             *index = *index / 2;\n   |                      ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpti9e7g_m.rs:33:28\n   |\n\
    33 |             if min_even <= *index {\n   |                            ^^^^^^\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpti9e7g_m.rs:34:28\n\
    \   |\n34 |                 min_even = *index;\n   |                         \
    \   ^^^^^^\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smaller_value_idxs: Vec<isize> = Vec::new();\n    let mut max_value_idx\
    \ = -1;\n    for (idx, val) in arr.iter().enumerate() {\n        if val & 1 ==\
    \ 1 {\n            smaller_value_idxs.push(idx);\n        } else {\n         \
    \   if val > max_value_idx {\n                max_value_idx = val;\n         \
    \   }\n        }\n    }\n    if smaller_value_idxs.len() == 0 {\n        return\
    \ vec![];\n    }\n    smaller_value_idxs\n        .iter()\n        .map(|idx|\
    \ arr[smaller_value_idxs.iter().next().unwrap()])\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgx6rgk23.rs:31:37\n   |\n\
    31 |             smaller_value_idxs.push(idx);\n   |                         \
    \            ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    31 |             smaller_value_idxs.push(idx.try_into().unwrap());\n   |     \
    \                                   ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgx6rgk23.rs:33:22\n   |\n33 |             if val > max_value_idx\
    \ {\n   |                      ^^^^^^^^^^^^^\n   |                      |\n  \
    \ |                      expected `&isize`, found integer\n   |              \
    \        help: consider borrowing here: `&max_value_idx`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgx6rgk23.rs:34:33\n   |\n28 |     let mut max_value_idx\
    \ = -1;\n   |                             -- expected due to this value\n...\n\
    34 |                 max_value_idx = val;\n   |                              \
    \   ^^^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n34 |                 max_value_idx = *val;\n   |             \
    \                    +\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `&isize`\n  --> /tmp/tmpgx6rgk23.rs:43:20\n   |\n43 |         .map(|idx| arr[smaller_value_idxs.iter().next().unwrap()])\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // TODO: Write your code here.\n    let mut result: Vec<isize> = vec![];\n\
    \    \n    for element in arr {\n        if element.is_even() {\n            result\
    \ += vec![(element.clone()), 0];\n        } else {\n            result.sort_unstable_by(|a,\
    \ b| a.cmp(b));\n            if result.len() == 1 {\n                result +=\
    \ vec![(result.clone().iter().cloned().nth(0)), 0];\n            } else {\n  \
    \              let mut index = 0;\n                let mut smalest_value = result[0].clone();\n\
    \                for value in result {\n                    if value == smalest_value\
    \ {\n                        index += 1;\n                    } else if value\
    \ < smalest_value {\n                        smalest_value = value;\n        \
    \                index = 0;\n                    }\n                }\n      \
    \          if index == 0 {\n                    result += vec![(smalest_value.clone()),\
    \ 0];\n                } else if index == 1 {\n                    result += vec![(result.clone().iter().cloned().nth(0)),\
    \ 0];\n                } else {\n                    result += vec![(result.clone().iter().cloned().nth(0)),\
    \ index];\n                }\n            }\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpelenj_f7.rs:31:20\n   |\n31 |         if element.is_even()\
    \ {\n   |                    ^^^^^^^ method not found in `isize`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<isize>`\n  -->\
    \ /tmp/tmpelenj_f7.rs:32:13\n   |\n32 |             result += vec![(element.clone()),\
    \ 0];\n   |             ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |           \
    \  |\n   |             cannot use `+=` on type `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpelenj_f7.rs:36:73\n   |\n36 |                 result +=\
    \ vec![(result.clone().iter().cloned().nth(0)), 0];\n   |                    \
    \                                                     ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `{integer}`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `Vec<isize>`\n  --> /tmp/tmpelenj_f7.rs:36:17\n   |\n36 |\
    \                 result += vec![(result.clone().iter().cloned().nth(0)), 0];\n\
    \   |                 ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `Vec<isize>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<isize>`\n\
    \  --> /tmp/tmpelenj_f7.rs:49:21\n   |\n49 |                     result += vec![(smalest_value.clone()),\
    \ 0];\n   |                     ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \
    \  |                     |\n   |                     cannot use `+=` on type `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpelenj_f7.rs:51:77\n   |\n51 |\
    \                     result += vec![(result.clone().iter().cloned().nth(0)),\
    \ 0];\n   |                                                                  \
    \           ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found type `{integer}`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<isize>`\n  -->\
    \ /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut arr2 = arr.to_vec();\n    let mut index = 0;\n    while index !=\
    \ arr.len() {\n        let mut smallest_value: isize;\n        let mut smallest_index:\
    \ isize;\n        let mut smallest_even_index: usize = 0;\n        let mut largest_even_index:\
    \ usize = 0;\n        for i in 0..arr2.len() {\n            if arr2[i] % 2 ==\
    \ 0 {\n                if smallest_value == 0 {\n                    smallest_value\
    \ = arr2[i];\n                    smallest_index = i;\n                    smallest_even_index\
    \ = i;\n                } else {\n                    if arr2[i] < smallest_value\
    \ {\n                        smallest_value = arr2[i];\n                     \
    \   smallest_index = i;\n                        smallest_even_index = i;\n  \
    \                  }\n                }\n            } else if arr2[i] == smallest_value\
    \ {\n                if arr2[i] == arr2[i] {\n                    smallest_even_index++;\n\
    \                }\n                if arr2[i] > largest_even_index {\n      \
    \              largest_even_index = arr2[i];\n                }\n            }\n\
    \        }\n        if largest_even_index == 0 {\n            arr2.remove(smallest_index);\n\
    \            arr2.remove(smallest_even_index);\n        } else {\n           \
    \ arr2.remove(smallest_index);\n            arr2.remove(smallest_even_index);\n\
    \            arr2.remove(largest_even_index);\n        }\n        index += 1;\n\
    \    }\n    arr2\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpc7mkcxgr.rs:49:40\n\
    \   |\n49 |                     smallest_even_index++;\n   |                 \
    \                       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n49 |                     { let tmp = smallest_even_index; smallest_even_index\
    \ += 1; tmp };\n   |                     +++++++++++                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    49 -                     smallest_even_index++;\n49 +                     smallest_even_index\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc7mkcxgr.rs:38:38\n\
    \   |\n31 |         let mut smallest_index: isize;\n   |                     \
    \            ----- expected due to this type\n...\n38 |                     smallest_index\
    \ = i;\n   |                                      ^ expected `isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc7mkcxgr.rs:43:42\n   |\n31 |\
    \         let mut smallest_index: isize;\n   |                               \
    \  ----- expected due to this type\n...\n43 |                         smallest_index\
    \ = i;\n   |                                          ^ expected `isize`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc7mkcxgr.rs:51:30\n\
    \   |\n51 |                 if arr2[i] > largest_even_index {\n   |          \
    \                    ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n51 |                 if arr2[i] > largest_even_index.try_into().unwrap()\
    \ {\n   |                                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc7mkcxgr.rs:52:42\n   |\n33 |\
    \         let mut largest_even_index: usize = 0;\n   |                       \
    \              ----- expected due to this type\n...\n52 |                    \
    \ largest_even_index = arr2[i];\n   |                                        \
    \  ^^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc7mkcxgr.rs:57:25\n   |\n57 |             arr2.remove(sma"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = Vec::new();\n    let mut even_smallest_count = 0;\n    let\
    \ mut smallest_value = arr[0];\n    let mut smallest_idx = 0;\n    for value in\
    \ arr.iter() {\n        if value < smallest_value {\n            smallest_value\
    \ = value;\n            smallest_idx = even_smallest_count;\n        }\n     \
    \   res.push(smallest_value);\n        even_smallest_count += value % 2 == 0;\n\
    \    }\n    if even_smallest_count == 0 {\n        even_smallest_count = 1;\n\
    \    }\n    res.push(smallest_value);\n    res.push(smallest_idx);\n    res\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0wvfz2i.rs:32:20\n   |\n\
    32 |         if value < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj0wvfz2i.rs:33:30\n   |\n29 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n33 |             smallest_value = value;\n\
    \   |                              ^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n33 |             smallest_value\
    \ = *value;\n   |                              +\n\nerror[E0277]: cannot add-assign\
    \ `bool` to `{integer}`\n  --> /tmp/tmpj0wvfz2i.rs:37:29\n   |\n37 |         even_smallest_count\
    \ += value % 2 == 0;\n   |                             ^^ no implementation for\
    \ `{integer} += bool`\n   |\n   = help: the trait `AddAssign<bool>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = Vec::new();\n    let mut small = vec![arr[0]; 2];\n    let\
    \ mut large = vec![arr[0]; 2];\n\n    for i in 1..arr.len() {\n        let mut\
    \ cur_small: Vec<isize>;\n        let mut cur_large: Vec<isize>;\n        if small\
    \ < large {\n            if arr[i] == arr[i-1] {\n                cur_small =\
    \ small;\n                cur_large = large;\n            } else {\n         \
    \       cur_small = small;\n                cur_large = large;\n            }\n\
    \            large.clear();\n        } else {\n            if arr[i] == arr[i-1]\
    \ {\n                cur_small = small;\n                cur_large = large;\n\
    \            } else {\n                cur_small = small;\n                cur_large\
    \ = large;\n            }\n            small.clear();\n        }\n\n        if\
    \ arr[i] % 2 == 0 {\n            evens.push(arr[i]);\n            small.push(arr[i]);\n\
    \        } else {\n            small.push(arr[i]);\n        }\n\n        if i\
    \ < arr.len() {\n            if cur_small < cur_large {\n                large.push(arr[i]);\n\
    \            } else {\n                large.push(arr[i]);\n                small.push(arr[i]);\n\
    \            }\n        } else {\n            small.push(arr[i]);\n        }\n\
    \    }\n    let mut evens_vec: Vec<isize> = evens.iter().cloned().collect();\n\
    \n    let mut sorted_vec: Vec<isize> = small.iter().cloned().collect();\n    for\
    \ i in evens_vec.iter() {\n        sorted_vec.push(i);\n    }\n    let mut sorted_vec2\
    \ = sorted_vec.iter().cloned().collect();\n    for i in evens_vec.iter() {\n \
    \       sorted_vec2.push(i);\n    }\n    let mut sorted_vec3 = sorted_vec2.iter().cloned().collect();\n\
    \    for i in evens_vec.iter() {\n        sorted_vec3.push(i);\n    }\n    for\
    \ i in evens_vec.iter() {\n        sorted_vec3.push(i);\n    }\n\n    evens_vec.sort();\n\
    \    let mut evens_vec2: Vec<isize> = evens_vec.iter().cloned().collect();\n \
    \   for i in evens_vec2.iter() {\n        sorted_vec3.push(i);\n    }\n\n    let\
    \ mut evens_vec3 = evens_vec2.iter().cloned().collect();\n    let mut evens_vec4\
    \ = evens_vec3.iter().cloned().collect();\n    for i in evens_vec4.iter() {\n\
    \        sorted_vec3.push(i);\n    }\n\n    let mut evens_vec5 = evens_vec4.iter().cloned().collect();\n\
    \    for i in \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmp8th5oedz.rs:104:1\n\
    \    |\n104 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8th5oedz.rs:76:25\n   |\n76 |         sorted_vec.push(i);\n   |\
    \                         ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n76 |         sorted_vec.push(*i);\n   |    \
    \                     +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut i = 0;\n    let mut even_value = vec![0; arr.len()];\n    let mut\
    \ smaller_value = vec![0; arr.len()];\n    let mut smallest_even_value = vec![0;\
    \ arr.len()];\n    let mut smallest_value = vec![0; arr.len()];\n    let mut smallest_index\
    \ = vec![0; arr.len()];\n    let mut temp_arr: Vec<isize> = vec![0; arr.len()];\n\
    \    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            even_value[i]\
    \ = arr[i];\n        }\n        else {\n            if even_value[i] == vec![0]\
    \ {\n                smaller_value[i] = arr[i];\n            }\n            else\
    \ {\n                smallest_value[i] = arr[i];\n            }\n            even_value[i]\
    \ = vec![0];\n        }\n    }\n    for j in 0..arr.len() {\n        if even_value[j]\
    \ == vec![0] {\n            smallest_even_value[j] = smaller_value[j];\n     \
    \   }\n        else {\n            if even_value[j] < smallest_even_value[j] {\n\
    \                smallest_even_value[j] = even_value[j];\n            }\n    \
    \        if even_value[j] > smallest_value[j] {\n                smallest_value[j]\
    \ = even_value[j];\n            }\n            if even_value[j] == smallest_even_value[j]\
    \ {\n                smallest_index[j] = smallest_value[j];\n            }\n \
    \       }\n    }\n    for k in 0..arr.len() {\n        if smallest_even_value[k]\
    \ == vec![0] {\n            temp_arr[k] = smallest_value[k];\n        }\n    \
    \    else {\n            if smallest_even_value[k] < smallest_value[k] {\n   \
    \             temp_arr[k] = smallest_even_value[k];\n            }\n         \
    \   if smallest_even_value[k] > smallest_value[k] {\n                temp_arr[k]\
    \ = smallest_value[k];\n            }\n        }\n    }\n    temp_arr.iter().map(|x|\
    \ *x).collect()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaxp223c0.rs:39:33\n   |\n\
    39 |             if even_value[i] == vec![0] {\n   |                         \
    \        ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<{integer}>`\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxp223c0.rs:45:29\n\
    \   |\n45 |             even_value[i] = vec![0];\n   |             -------------\
    \   ^^^^^^^ expected `isize`, found struct `Vec`\n   |             |\n   |   \
    \          expected due to the type of this binding\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<{integer}>`\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxp223c0.rs:49:29\n\
    \   |\n49 |         if even_value[j] == vec![0] {\n   |                      \
    \       ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<{integer}>`\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxp223c0.rs:65:38\n\
    \   |\n65 |         if smallest_even_value[k] == vec![0] {\n   |             \
    \                         ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n\
    \   = note: expected type `isize`\n            found struct `Vec<{integer}>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = arr.iter().filter(|&x| x % 2 == 0).count();\n\
    \    for i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if even_values.len() == arr.len() {\n            if i % 2\
    \ == 0 {\n                return even_values;\n            }\n        }\n    \
    \    if even_values.len() > arr.len() {\n            if even_values.iter().next().unwrap()\
    \ < smallest_even_value\n                && even_values.iter().last().unwrap()\
    \ > smallest_even_value {\n                smallest_even_value = even_values.iter().next().unwrap();\n\
    \                smallest_even_index = even_values.iter().filter(|&x| x % 2 ==\
    \ 0).count();\n            }\n            even_values.pop();\n        }\n    }\n\
    \    return even_values;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb2fuzkcx.rs:40:53\n   |\n\
    40 |             if even_values.iter().next().unwrap() < smallest_even_value\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                     |\n   |            \
    \                                         expected `&isize`, found `isize`\n \
    \  |                                                     help: consider borrowing\
    \ here: `&smallest_even_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb2fuzkcx.rs:41:57\n\
    \   |\n41 |                 && even_values.iter().last().unwrap() > smallest_even_value\
    \ {\n   |                                                         ^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                         |\n   |        \
    \                                                 expected `&isize`, found `isize`\n\
    \   |                                                         help: consider borrowing\
    \ here: `&smallest_even_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb2fuzkcx.rs:42:39\n\
    \   |\n28 |     let mut smallest_even_value = arr[0];\n   |                  \
    \                 ------ expected due to this value\n...\n42 |               \
    \  smallest_even_value = even_values.iter().next().unwrap();\n   |           \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n42 |  \
    \               smallest_even_value = *even_values.iter().next().unwrap();\n \
    \  |                                       +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut pivot_value = arr[0];\n    let mut pivot = 1;\n    let mut index\
    \ = arr.iter().position(|&x| x == pivot_value);\n    let mut even_value = arr.iter().filter(|&x|\
    \ x % 2 == 0).count();\n    let mut even_pos = 0;\n    if even_value == 0 && arr.len()\
    \ > 0 {\n        index = arr.iter().position(|&x| x == pivot_value);\n    }\n\n\
    \    // while the current element is smaller than the pivot\n    while index !=\
    \ pivot {\n        // if the current element is equal to the pivot value then\
    \ we found the \n        // smallest even element\n        if even_value.is_some()\
    \ {\n            even_pos++;\n            if even_pos == 1 {\n               \
    \ index = pivot;\n                even_pos = 0;\n            } else {\n      \
    \          index += 1;\n                even_pos = 0;\n            }\n       \
    \ }\n        // otherwise, move the index ahead one and check again\n        else\
    \ {\n            index += 1;\n        }\n        pivot_value = arr[index];\n \
    \       pivot = index / 2;\n        even_value = arr.iter().filter(|&x| x % 2\
    \ == 0).count();\n        even_pos = 0;\n    }\n    // return the vector [pivot,\
    \ index] with the smallest index\n    vec![pivot, index]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpk49ph6ud.rs:41:21\n\
    \   |\n41 |             even_pos++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n41 |             { let tmp =\
    \ even_pos; even_pos += 1; tmp };\n   |             +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n\
    41 -             even_pos++;\n41 +             even_pos += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk49ph6ud.rs:37:20\n   |\n37 |     while index\
    \ != pivot {\n   |                    ^^^^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n37 |     while index != Some(pivot)\
    \ {\n   |                    +++++     +\n\nerror[E0599]: no method named `is_some`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpk49ph6ud.rs:40:23\n\
    \   |\n40 |         if even_value.is_some() {\n   |                       ^^^^^^^\
    \ method not found in `usize`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `Option<usize>`\n  --> /tmp/tmpk49ph6ud.rs:52:13\n\
    \   |\n52 |             index += 1;\n   |             -----^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `Option<usize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmpk49ph6ud.rs:54:23\n\
    \   |\n54 |         pivot_value = arr[index];\n   |                       ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<usize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<usize>>` for\
    \ `Vec<isize>`\n\nerror[E0369]: cannot divide `Option<usize>` by `{integer}`\n\
    \  --> /tmp/tmpk49ph6ud.rs:55:23\n   |\n55 |         pivot = index / 2;\n   |\
    \                 ----- ^ - {integer}\n   |                 |\n   |          \
    \       Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk49ph6ud.rs:60:17\n\
    \   |\n60 |     vec![pivot, index]\n   |                 ^^^^^ expected `isize"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap())\n        .filter(|x|\
    \ *x.0 % 2 == 0)\n        .map(|x| x.0)\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmps6l7kejq.rs:28:10\n\
    \   |\n28 |         .filter(|x| *x.0 % 2 == 0)\n   |          ^^^^^^ `()` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_smallest_value_index = -1;\n    let mut even_smallest_value\
    \ = isize::MAX;\n    for i in arr {\n        let val = i;\n        if val % 2\
    \ == 0 {\n            if even_smallest_value != isize::MAX {\n               \
    \ if val < even_smallest_value {\n                    even_smallest_value = val;\n\
    \                    even_smallest_value_index = i;\n                }\n     \
    \       } else {\n                even_smallest_value = val;\n               \
    \ even_smallest_value_index = i;\n            }\n        }\n    }\n    \n    let\
    \ mut output = [even_smallest_value, even_smallest_value_index];\n    if even_smallest_value_index\
    \ > -1 && even_smallest_value == isize::MAX {\n        let mut output_index =\
    \ 0;\n        for i in arr {\n            if i != even_smallest_value_index {\n\
    \                output[output_index] = i;\n                output_index += 1;\n\
    \            }\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfoe6iqjh.rs:54:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n54 |     output\n\
    \   |     ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |     |\n\
    \   |     expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n\n    if arr.is_empty() {\n        return result;\n\
    \    }\n\n    let mut min_index = arr.iter().min_by(|a, b| {\n        a.cmp(&b)\n\
    \    }).unwrap();\n\n    let mut min_value = &*min_index;\n\n    for i in arr\
    \ {\n        if i.is_even() && !min_value.is_even() {\n            min_value =\
    \ i;\n        }\n    }\n\n    result.push(min_value);\n    result.push(&*min_index);\n\
    \n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp_f8omtei.rs:40:14\n   |\n40 |         if i.is_even() &&\
    \ !min_value.is_even() {\n   |              ^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_even` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmp_f8omtei.rs:40:38\n   |\n40 |         if i.is_even()\
    \ && !min_value.is_even() {\n   |                                      ^^^^^^^\
    \ method not found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_f8omtei.rs:41:25\n\
    \   |\n37 |     let mut min_value = &*min_index;\n   |                       \
    \  ----------- expected due to this value\n...\n41 |             min_value = i;\n\
    \   |                         ^\n   |                         |\n   |        \
    \                 expected `&isize`, found `isize`\n   |                     \
    \    help: consider borrowing here: `&i`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp_f8omtei.rs:45:17\n   |\n45 |     result.push(min_value);\n   |\
    \                 ^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n45 |     result.push(*min_value);\n   |    \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_f8omtei.rs:46:17\n\
    \   |\n46 |     result.push(&*min_index);\n   |                 ^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider removing the borrow\n   |\n46\
    \ -     result.push(&*min_index);\n46 +     result.push(*min_index);\n   | \n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut min_value\
    \ = arr[0];\n    let mut min_idx = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i + 1 < arr.len() {\n        if arr[i + 1] % 2 == 0 {\n           \
    \ j += 1;\n            i += 1;\n        } else {\n            if arr[i] < min_value\
    \ {\n                min_value = arr[i];\n                min_idx = i;\n     \
    \       }\n            i += 1;\n        }\n    }\n    let mut result = vec![];\n\
    \    if arr[j] == min_value {\n        result.push((min_value, min_idx));\n  \
    \  }\n    if i + 1 < arr.len() {\n        if arr[i + 1] % 2 == 0 {\n         \
    \   i += 1;\n        } else {\n            if arr[i] < min_value {\n         \
    \       min_value = arr[i];\n                min_idx = i;\n            }\n   \
    \         i += 1;\n        }\n    }\n    if i == arr.len() {\n        if j > min_idx\
    \ {\n            result.push((arr[j], j));\n        }\n    } else {\n        if\
    \ arr[i + 1] % 2 == 0 {\n            if arr[j] < min_value {\n               \
    \ min_value = arr[j];\n                min_idx = j;\n            }\n         \
    \   i += 1;\n        } else {\n            if arr[i] < min_value {\n         \
    \       min_value = arr[i];\n                min_idx = i;\n            }\n   \
    \         i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa3b0nyxj.rs:80:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n80 |     result\n\
    \   |     ^^^^^^ expected `isize`, found tuple\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<(isize, usize)>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut new_arr = Vec::new();\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_index = 0;\n    let mut max_value = i32::MIN;\n    let mut max_index\
    \ = 0;\n    for &i in &arr {\n        if i % 2 != 0 {\n            if min_value\
    \ == i32::MAX {\n                max_value = i;\n                max_index = i;\n\
    \            } else {\n                if i > min_value {\n                  \
    \  new_arr.push(min_value);\n                    new_arr.push(min_index);\n  \
    \              }\n                min_value = i;\n                min_index =\
    \ i;\n            }\n        }\n    }\n    if min_value == i32::MAX {\n      \
    \  new_arr.push(min_value);\n        new_arr.push(min_index);\n    }\n    return\
    \ new_arr;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpluu6dlh0.rs:35:29\n   |\n\
    30 |     let mut max_value = i32::MIN;\n   |                         --------\
    \ expected due to this value\n...\n35 |                 max_value = i;\n   | \
    \                            ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpluu6dlh0.rs:38:24\n   |\n38 |              \
    \   if i > min_value {\n   |                        ^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n38 |                 if i > min_value.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpluu6dlh0.rs:42:29\n   |\n28 |     let mut min_value\
    \ = i32::MAX;\n   |                         -------- expected due to this value\n\
    ...\n42 |                 min_value = i;\n   |                             ^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpluu6dlh0.rs:43:29\n\
    \   |\n29 |     let mut min_index = 0;\n   |                         - expected\
    \ due to this value\n...\n43 |                 min_index = i;\n   |          \
    \                   ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpluu6dlh0.rs:51:12\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n51 |     return new_arr;\n   |            ^^^^^^^\
    \ expected `isize`, found `i32`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<i32>`\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    for i in 0..arr.len() {\n        let value = arr[i];\n        let mut idx\
    \ = i;\n        if value > 0 { \n            idx = i;\n            while idx <\
    \ arr.len() && value % 2 == 0 {\n                idx += 1;\n            }\n  \
    \      }\n        arr[i] = idx;\n    }\n    return arr\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpojpgcv9h.rs:36:18\n   |\n\
    36 |         arr[i] = idx;\n   |         ------   ^^^ expected `isize`, found\
    \ `usize`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Write your code here\n    let mut counter: Vec<isize> = vec![]\n    \n\
    \    for i in arr {\n        if i.is_even() {\n            counter += vec![(i)]\n\
    \        }\n        else {\n            let mut j = counter.iter().enumerate().find(|(_,\
    \ element)| element == i).unwrap()\n            let mut new_mut : Vec<isize> =\
    \ vec![]\n            \n            while (j < arr.len()) {\n                let\
    \ _ = j;\n                new_mut += counter[j..(j+2)]\n                j += 1\n\
    \            }\n            counter += new_mut\n        }\n    }\n    \n    counter.sort();\n\
    \    return counter.into_iter().map(|i| i.1).collect()\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpcliofaa2.rs:28:41\n\
    \   |\n28 |     let mut counter: Vec<isize> = vec![]\n   |                   \
    \                      ^ help: add `;` here\n29 |     \n30 |     for i in arr\
    \ {\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `let`\n\
    \  --> /tmp/tmpcliofaa2.rs:35:94\n   |\n35 |             let mut j = counter.iter().enumerate().find(|(_,\
    \ element)| element == i).unwrap()\n   |                                     \
    \                                                         ^ help: add `;` here\n\
    36 |             let mut new_mut : Vec<isize> = vec![]\n   |             --- unexpected\
    \ token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpcliofaa2.rs:36:50\n\
    \   |\n36 |             let mut new_mut : Vec<isize> = vec![]\n   |          \
    \                                        ^ help: add `;` here\n37 |          \
    \   \n38 |             while (j < arr.len()) {\n   |             ----- unexpected\
    \ token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpcliofaa2.rs:40:45\n \
    \  |\n40 |                 new_mut += counter[j..(j+2)]\n   |                \
    \                             ^ help: add `;` here\n41 |                 j +=\
    \ 1\n   |                 - unexpected token\n\nwarning: unnecessary parentheses\
    \ around `while` condition\n  --> /tmp/tmpcliofaa2.rs:38:19\n   |\n38 |      \
    \       while (j < arr.len()) {\n   |                   ^             ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n38 -             while (j < arr.len()) {\n38 +             while j < arr.len()\
    \ {\n   | \n\nerror[E0599]: no method named `is_even` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpcliofaa2.rs:31:14\n   |\n31 |         if i.is_even()\
    \ {\n   |              ^^^^^^^ method not found in `isize`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Vec<isize>`\n  --> /tmp/tmpcliofaa2.rs:32:13\n\
    \   |\n32 |             counter += vec![(i)]\n   |             -------^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<isize>`\n\n\
    erro"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value = arr[0];\n    let mut smallest_index = arr[0];\n\
    \    for i in 1..arr.len() {\n        if arr[i] < smallest_value {\n         \
    \   smallest_value = arr[i];\n            smallest_index = i;\n        }\n   \
    \ }\n    vec![smallest_value, smallest_index];\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_msbxfsc.rs:32:30\n   |\n\
    28 |     let mut smallest_index = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n32 |             smallest_index = i;\n   |\
    \                              ^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_msbxfsc.rs:26:30\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n...\n35 |     vec![smallest_value,\
    \ smallest_index];\n   |                                         - help: remove\
    \ this semicolon\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_node = arr[0];\n    let mut min_node_index = -1;\n    let mut\
    \ even_value = false;\n    for (i, value) in arr.iter().enumerate() {\n      \
    \  if value == 0 {\n            if even_value.is_some() {\n                min_node_index\
    \ = i;\n            }\n            min_node = value;\n            even_value =\
    \ true;\n        } else {\n            even_value = false;\n        }\n    }\n\
    \    vec![min_node, min_node_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp1uhx06by.rs:31:18\n\
    \   |\n31 |         if value == 0 {\n   |                  ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `is_some`\
    \ found for type `bool` in the current scope\n  --> /tmp/tmp1uhx06by.rs:32:27\n\
    \   |\n32 |             if even_value.is_some() {\n   |                      \
    \     ^^^^^^^ method not found in `bool`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp1uhx06by.rs:35:24\n   |\n27 |     let mut min_node = arr[0];\n \
    \  |                        ------ expected due to this value\n...\n35 |     \
    \        min_node = value;\n   |                        ^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \           min_node = *value;\n   |                        +\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp1uhx06by.rs:28:30\n\
    \   |\n28 |     let mut min_node_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1uhx06by.rs:41:20\n   |\n41 |     vec![min_node,\
    \ min_node_index]\n   |                    ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n41 |     vec![min_node, min_node_index.try_into().unwrap()]\n\
    \   |                                  ++++++++++++++++++++\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed ex"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut result =\
    \ vec![];\n    let mut min_even_value = 0;\n    let mut min_index = 0;\n    let\
    \ mut mut i = 0;\n    while i < arr.len() {\n        if arr[i] % 2 == 0 {\n  \
    \          if arr[i] < min_even_value {\n                min_even_value = arr[i];\n\
    \                min_index = i;\n            }\n        } else {\n           \
    \ if arr[i] < min_even_value {\n                min_index = i;\n            }\n\
    \        }\n        i += 1;\n    }\n    if min_even_value >= arr[0] {\n      \
    \  min_index = 0;\n    }\n    result.push(min_even_value);\n    result.push(min_index);\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmpgdbecr79.rs:33:13\n\
    \   |\n33 |     let mut mut i = 0;\n   |             ^^^ help: remove the additional\
    \ `mut`s\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgdbecr79.rs:51:17\n\
    \   |\n51 |     result.push(min_index);\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n51 |     result.push(min_index.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut mut ans = Vec::new();\n    for &mut n in arr.iter_mut() {\n     \
    \   n += 1;\n        ans.push(n);\n    }\n    let mut min_val = ans[0];\n    for\
    \ &n in ans.iter_mut() {\n        if n == min_val {\n            let mut index\
    \ = ans.iter().skip(1).find(|&i| i % 2 == 0);\n            min_val = *index;\n\
    \        } else {\n            n = min_val;\n        }\n    }\n    if min_val\
    \ == ans.len() {\n        return ans;\n    } else {\n        let mut index = ans.iter().skip(1).find(|&i|\
    \ i % 2 == 0);\n        ans = Vec::new();\n        for &n in ans.iter_mut() {\n\
    \            n = *index;\n            ans.push(n);\n            index += 1;\n\
    \        }\n        return ans;\n    }\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmp3ttfctba.rs:27:13\n\
    \   |\n27 |     let mut mut ans = Vec::new();\n   |             ^^^ help: remove\
    \ the additional `mut`s\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ttfctba.rs:33:9\n\
    \   |\n33 |     for &n in ans.iter_mut() {\n   |         ^^    --------------\
    \ this expression has type `Option<&mut isize>`\n   |         |\n   |        \
    \ types differ in mutability\n   |         help: you can probably remove the explicit\
    \ borrow: `n`\n   |\n   = note: expected mutable reference `&mut isize`\n    \
    \                  found reference `&_`\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp3ttfctba.rs:36:23\n   |\n36 |        \
    \     min_val = *index;\n   |                       ^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3ttfctba.rs:41:19\n   |\n41 |     if min_val == ans.len()\
    \ {\n   |                   ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n41 |     if min_val == ans.len().try_into().unwrap() {\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3ttfctba.rs:46:13\n   |\n46 |         for &n in ans.iter_mut()\
    \ {\n   |             ^^    -------------- this expression has type `Option<&mut\
    \ isize>`\n   |             |\n   |             types differ in mutability\n \
    \  |             help: you can probably remove the explicit borrow: `n`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp3ttfctba.rs:47:17\n   |\n47 |             n = *index;\n   |   \
    \              ^^^^^^\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `Option<&isize>`\n  --> /tmp/tmp3ttfctba.rs:49:13\n   |\n\
    49 |             index += 1;\n   |             -----^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `Option<&isize>`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanat"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = HashSet::new();\n    let mut even_values = HashSet::new();\n\
    \    let mut min_value = arr[0];\n    let mut min_index = 0;\n    for &index in\
    \ arr {\n        if index == 0 || index > min_value {\n            min_value =\
    \ index;\n            min_index = index;\n        } else {\n            if index\
    \ > min_value {\n                let mut i = counter.next_item(index - 1);\n \
    \               while i != index {\n                    i = (i + 1) % arr.len();\n\
    \                    counter.next_item(i - 1);\n                }\n          \
    \  }\n            if even_values.contains(index - 1) {\n                if index\
    \ > min_value {\n                    min_index = min_index + index - min_value;\n\
    \                }\n            } else {\n                min_value = index;\n\
    \                min_index = index;\n            }\n        }\n        even_values.insert(index);\n\
    \    }\n    if even_values.len() == arr.len() {\n        vec![min_value, min_index]\n\
    \    } else {\n        vec![min_value]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp1ilbg85k.rs:27:23\n   |\n27 |     let mut counter = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp1ilbg85k.rs:28:27\n\
    \   |\n28 |     let mut even_values = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1ilbg85k.rs:31:9\n   |\n31 |     for &index in arr {\n\
    \   |         ^^^^^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `index`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort();\n    let mut min_value\
    \ = sorted_arr[0];\n    let mut min_value_pos = 0;\n\n    let mut picked_node\
    \ = Vec::new();\n\n    // pick a node that has smallest even number\n    for pos\
    \ in sorted_arr.iter().rev() {\n        if pos % 2 == 0 {\n            min_value\
    \ = pos;\n            min_value_pos = pos - 1;\n            break;\n        }\n\
    \    }\n\n    // pick node if found one\n    if min_value % 2 == 0 {\n       \
    \ for pos in sorted_arr.iter().rev() {\n            if pos % 2 == 0 {\n      \
    \          picked_node.push(pos);\n                break;\n            }\n   \
    \     }\n    }\n\n    // pick smallest index\n    if min_value_pos == 0 {\n  \
    \      for pos in sorted_arr.iter().rev() {\n            if pos % 2 == 0 {\n \
    \               picked_node.push(pos);\n                break;\n            }\n\
    \        }\n    }\n\n    picked_node\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp40of3p86.rs:37:25\n   |\n\
    29 |     let mut min_value = sorted_arr[0];\n   |                         -------------\
    \ expected due to this value\n...\n37 |             min_value = pos;\n   |   \
    \                      ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n37 |             min_value = *pos;\n   |   \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40of3p86.rs:63:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n63\
    \ |     picked_node\n   |     ^^^^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().filter(|&x| x % 2 == 0).min(|x, y| {\n        if x < y {\n   \
    \         x.clone() as isize\n        } else {\n            y.clone() as isize\n\
    \        }\n    }).cloned().collect()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpx04ax77q.rs:27:45\n\
    \   |\n27 |     arr.iter().filter(|&x| x % 2 == 0).min(|x, y| {\n   |        \
    \                                     ^ consider giving this closure parameter\
    \ a type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpx04ax77q.rs:27:40\n\
    \     |\n27   |       arr.iter().filter(|&x| x % 2 == 0).min(|x, y| {\n     |\
    \  ________________________________________^^^_-\n     | |                   \
    \                     |\n     | |                                        expected\
    \ 0 arguments\n28   | |         if x < y {\n29   | |             x.clone() as\
    \ isize\n30   | |         } else {\n31   | |             y.clone() as isize\n\
    32   | |         }\n33   | |     }).cloned().collect()\n     | |_____- supplied\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ `Option<isize>` is not an iterator\n   --> /tmp/tmpx04ax77q.rs:33:17\n    |\n\
    33  |       }).cloned().collect()\n    |                   ^^^^^^^ `Option<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<isize>: Iterator`\n            which is required by `&mut\
    \ Option<isize>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0282, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return []\n    }\n    let mut smalest_value:\
    \ isize;\n    let mut smalest_index: isize;\n    let mut index: isize = 0;\n \
    \   let mut max_value: isize = 0;\n    let mut max_index: isize = 0;\n    let\
    \ mut min_value: isize = 0;\n    let mut min_index: isize = 0;\n    for n in arr.iter()\
    \ {\n        if n % 2 == 0 {\n            if n < smalest_value {\n           \
    \     smalest_value = n;\n                smalest_index = index;\n           \
    \ }\n            index += 1;\n        } else {\n            if n > max_value {\n\
    \                max_value = n;\n                max_index = index;\n        \
    \    }\n            index += 1;\n        }\n    }\n    if smalest_value == max_value\
    \ {\n        if smalest_index == max_index {\n            min_value = smalest_value;\n\
    \            min_index = smalest_index;\n        } else {\n            if smalest_index\
    \ == min_index {\n                min_value = smalest_value;\n               \
    \ min_index = smalest_index;\n            } else {\n                max_value\
    \ = max_index;\n                max_index = max_value;\n            }\n      \
    \  }\n    } else {\n        if smalest_index == max_index {\n            max_value\
    \ = smalest_value;\n            max_index = smalest_index;\n        } else {\n\
    \            if smalest_index == min_index {\n                min_value = smalest_value;\n\
    \                min_index = smalest_index;\n            } else {\n          \
    \      max_value = max_index;\n                max_index = max_value;\n      \
    \          min_value = min_index;\n                min_index = min_value;\n  \
    \          }\n        }\n    }\n    if min_value == max_value {\n        if min_index\
    \ == max_index {\n            arr.iter().cloned().collect::<Vec<_>>().into_iter().collect::<Vec<_>>().to_owned()\n\
    \        } else {\n            arr.iter().cloned().collect::<Vec<_>>().into_iter().collect::<Vec<_>>().to_owned()[min_index..]\n\
    \        }\n    } else {\n        if min_index == max_index {\n            arr.iter().cloned().collect::<Vec<_>>().into_iter().collect::<Vec<_>>().to_owned()[min_index..]\n\
    \        } else {\n            arr.iter().cloned().collect::<Vec<_>>().into_iter().collect::<Vec<_>>().to_owned()[min_index..min_index+1]\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwcelhgtf.rs:28:16\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n27 |     if arr.len()\
    \ == 0 {\n28 |         return []\n   |                ^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |                |\n   |                expected struct\
    \ `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<isize>`\n\
    \               found array `[_; 0]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwcelhgtf.rs:39:20\n   |\n39 |             if n < smalest_value {\n \
    \  |                    ^^^^^^^^^^^^^\n   |                    |\n   |       \
    \             expected `&isize`, found `isize`\n   |                    help:\
    \ consider borrowing here: `&smalest_value`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwcelhgtf.rs:40:33\n   |\n30 |     let mut smalest_value: isize;\n\
    \   |                            ----- expected due to this type\n...\n40 |  \
    \               smalest_value = n;\n   |                                 ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    40 |                 smalest_value = *n;\n   |                               \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwcelhgtf.rs:45:20\n   |\n\
    45 |             if n > max_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwcelhgtf.rs:46:29\n   |\n33 |     let mut max_value:\
    \ isize = 0;\n   |                        ----- expected due to this type\n...\n\
    46 |                 max_value = n;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    46 |                 max_value = *n;\n   |                             +\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n  --> /tmp/tmpwcelhgtf.rs:85:13\n\
    \   |\n85 |             arr.iter()"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_unstable_by(|a, b| a.checked_mul(2).cmp(&b.checked_mul(2))).take(arr.len()\
    \ as usize)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp2exihxc6.rs:27:74\n\
    \   |\n27 |     arr.sort_unstable_by(|a, b| a.checked_mul(2).cmp(&b.checked_mul(2))).take(arr.len()\
    \ as usize)\n   |                                                            \
    \              ^^^^ `()` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_val = arr[0];\n    let mut min_even_node_index = arr[0];\n\
    \    for &index in arr.iter().rev() {\n        if index % 2 == 0 {\n         \
    \   min_even_val = index;\n            min_even_node_index = index;\n        }\n\
    \    }\n    vec![min_even_val, min_even_node_index]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4]`,\n right: `[2, 1]`', /tmp/tmp294o0pag.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n\n    let mut min_val\
    \ = i32::MAX;\n    let mut min_idx = isize::MAX;\n\n    for i in 0..arr.len()\
    \ {\n        let val = arr[i];\n        if val < min_val {\n            min_val\
    \ = val;\n            min_idx = i;\n        }\n    }\n\n    vec![min_val, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpswh_cy0_.rs:36:18\n   |\n\
    36 |         if val < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n36 |         if val < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpswh_cy0_.rs:37:23\n   |\n31 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n37 |   \
    \          min_val = val;\n   |                       ^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpswh_cy0_.rs:38:23\n\
    \   |\n32 |     let mut min_idx = isize::MAX;\n   |                       ----------\
    \ expected due to this value\n...\n38 |             min_idx = i;\n   |       \
    \                ^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpswh_cy0_.rs:42:10\n   |\n42 |     vec![min_val, min_idx]\n\
    \   |          ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    42 |     vec![min_val.try_into().unwrap(), min_idx]\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() || arr.iter().any(|&x| x > 0) || arr.iter().any(|&x| x\
    \ == 0) {\n        return vec![];\n    }\n    if arr.iter().any(|&x| x == 0) {\n\
    \        let mut index = 0;\n        let mut value_min = arr.iter().min_by_key(|&x|\
    \ x);\n        while value_min*2 == arr.iter().min_by_key(|&x| x) {\n        \
    \    index += 1\n            value_min = arr.iter().min_by_key(|&x| x);\n    \
    \    }\n        return vec![index];\n    }\n\n    let mut min_value = arr.iter().min_by_key(|&x|\
    \ x);\n    let mut index = 0;\n    let mut value_min = arr.iter().min_by_key(|&x|\
    \ x);\n    while value_min*2 == arr.iter().min_by_key(|&x| x) {\n        index\
    \ += 1\n        value_min = arr.iter().min_by_key(|&x| x);\n    }\n    vec![index..]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `value_min`\n  --> /tmp/tmpwkop5phx.rs:34:23\n\
    \   |\n34 |             index += 1\n   |                       ^ help: add `;`\
    \ here\n35 |             value_min = arr.iter().min_by_key(|&x| x);\n   |    \
    \         --------- unexpected token\n\nerror: expected `;`, found `value_min`\n\
    \  --> /tmp/tmpwkop5phx.rs:44:19\n   |\n44 |         index += 1\n   |        \
    \           ^ help: add `;` here\n45 |         value_min = arr.iter().min_by_key(|&x|\
    \ x);\n   |         --------- unexpected token\n\nerror[E0369]: cannot multiply\
    \ `Option<&isize>` by `{integer}`\n  --> /tmp/tmpwkop5phx.rs:33:24\n   |\n33 |\
    \         while value_min*2 == arr.iter().min_by_key(|&x| x) {\n   |         \
    \      ---------^- {integer}\n   |               |\n   |               Option<&isize>\n\
    \nerror[E0369]: cannot multiply `Option<&isize>` by `{integer}`\n  --> /tmp/tmpwkop5phx.rs:43:20\n\
    \   |\n43 |     while value_min*2 == arr.iter().min_by_key(|&x| x) {\n   |   \
    \        ---------^- {integer}\n   |           |\n   |           Option<&isize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwkop5phx.rs:47:10\n   |\n47 |\
    \     vec![index..]\n   |          ^^^^^^^ expected `isize`, found struct `RangeFrom`\n\
    \   |\n   = note: expected type `isize`\n            found struct `RangeFrom<{integer}>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr.iter().min();\n    let mut i = 0;\n    let mut ans\
    \ = vec![];\n    while i < arr.len() {\n        if arr[i] >= min_value {\n   \
    \         ans.push(arr[i]);\n        }\n        i += 1;\n    }\n    if ans.len()\
    \ == 0 {\n        ans.clear();\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp30h_su_i.rs:31:22\n   |\n\
    31 |         if arr[i] >= min_value {\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_index = 0;\n    let mut smaller_odd_index = -1;\n    let mut\
    \ smaller_even_index = -1;\n    let mut smalest_value = std::i32::MAX;\n    let\
    \ mut largest_index = std::i32::MAX;\n    let mut even_value;\n    let mut even_value_found\
    \ = false;\n    for (i, val) in arr.iter().enumerate() {\n        if even_value_found\
    \ {\n            if val == even_value{\n                even_value_found = false;\n\
    \                continue;\n            }\n        }\n        if val == 0 {\n\
    \            even_value = val; \n            even_value_found = true;\n      \
    \      continue;\n        }\n        if val < smalest_value {\n            smalest_value\
    \ = val;\n            smaller_odd_index = i;\n        }\n        if val > largest_index\
    \ {\n            largest_index = val;\n            smaller_even_index = i;\n \
    \       }\n    }\n    if even_value_found {\n        return vec![even_value];\n\
    \    }\n    else if smaller_even_index < 0 {\n        return vec![];\n    }\n\
    \    else if smaller_odd_index < 0 {\n        return vec![smalest_value];\n  \
    \  }\n    else if smalest_value == std::i32::MAX {\n        return vec![smalest_value,\
    \ smaller_odd_index];\n    }\n    else {\n        let smalest_value = smaller_odd_index;\n\
    \        let smaller_odd_value = arr[smalest_value];\n        return vec![smalest_value,\
    \ smaller_odd_value, smaller_even_index];\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpzk789dtk.rs:41:16\n\
    \   |\n41 |         if val == 0 {\n   |                ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzk789dtk.rs:46:18\n   |\n46 |         if val < smalest_value {\n   |\
    \                  ^^^^^^^^^^^^^ expected `&isize`, found `i32`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzk789dtk.rs:47:29\n   |\n30 |     let mut smalest_value\
    \ = std::i32::MAX;\n   |                             ------------- expected due\
    \ to this value\n...\n47 |             smalest_value = val;\n   |            \
    \                 ^^^ expected `i32`, found `&isize`\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpzk789dtk.rs:28:33\n   |\n\
    28 |     let mut smaller_odd_index = -1;\n   |                               \
    \  ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzk789dtk.rs:50:18\n   |\n50 |         if val\
    \ > largest_index {\n   |                  ^^^^^^^^^^^^^ expected `&isize`, found\
    \ `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzk789dtk.rs:51:29\n \
    \  |\n31 |     let mut largest_index = std::i32::MAX;\n   |                  \
    \           ------------- expected due to this value\n...\n51 |             largest_index\
    \ = val;\n   |                             ^^^ expected `i32`, found `&isize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpzk789dtk.rs:29:34\n\
    \   |\n29 |     let mut smaller_even_index = -1"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index = 0;\n    let mut smalest_value = arr[0];\n    let mut smallest_index\
    \ = -1;\n    arr.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());\n    for\
    \ (i, value) in arr.iter().enumerate() {\n        if value.partial_cmp(&smalest_value).unwrap()\
    \ == Some(0) {\n            index = i;\n            smallest_index = i;\n    \
    \    }\n        smalest_value = value;\n        if i == arr.len() - 1 {\n    \
    \        break;\n        }\n    }\n    let mut result_vec: Vec<isize> = vec![];\n\
    \    result_vec.push(smalest_value);\n    result_vec.push(smallest_index);\n \
    \   result_vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgfbmjajs.rs:32:58\n   |\n\
    32 |         if value.partial_cmp(&smalest_value).unwrap() == Some(0) {\n   |\
    \                                                          ^^^^^^^ expected enum\
    \ `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n\
    \              found enum `Option<{integer}>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgfbmjajs.rs:36:25\n   |\n28 |     let mut smalest_value = arr[0];\n\
    \   |                             ------ expected due to this value\n...\n36 |\
    \         smalest_value = value;\n   |                         ^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    36 |         smalest_value = *value;\n   |                         +\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpgfbmjajs.rs:29:30\n\
    \   |\n29 |     let mut smallest_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgfbmjajs.rs:43:21\n   |\n43 |     result_vec.push(smallest_index);\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n43 |     result_vec.push(smallest_index.try_into().unwrap());\n\
    \   |                                   ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = arr.clone();\n    even_values.sort_unstable_by(|x,\
    \ y| x % y);\n    even_values.dedup();\n    let mut even_index = even_values.iter().rev().enumerate().find(|&(i,\
    \ x)| x % 2 == 0);\n    even_index.ok_or(\"No even value found\".to_string())?;\n\
    \    let mut smalest_value = even_values.first().unwrap();\n    smalest_value.clone_from_slice(&arr[0..even_index.1\
    \ - 1]);\n    smalest_value.clone_from_slice(&arr[even_index.1..]);\n    smalest_value.clone_from_slice(&arr.iter().take(even_index.1\
    \ - 1).collect::<Vec<isize>>());\n    smalest_value.clone_from_slice(&arr.iter().take(even_index.1).collect::<Vec<isize>>());\n\
    \    vec![smalest_value, even_index.0]\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptb3f6t0z.rs:28:41\n   |\n\
    28 |     even_values.sort_unstable_by(|x, y| x % y);\n   |                   \
    \                      ^^^^^ expected enum `std::cmp::Ordering`, found `isize`\n\
    \nerror[E0277]: the `?` operator can only be used in a function that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmptb3f6t0z.rs:31:56\n\
    \   |\n26 | / fn pluck(arr: Vec<isize>) -> Vec<isize> {\n27 | |     let mut even_values\
    \ = arr.clone();\n28 | |     even_values.sort_unstable_by(|x, y| x % y);\n29 |\
    \ |     even_values.dedup();\n30 | |     let mut even_index = even_values.iter().rev().enumerate().find(|&(i,\
    \ x)| x % 2 == 0);\n31 | |     even_index.ok_or(\"No even value found\".to_string())?;\n\
    \   | |                                                        ^ cannot use the\
    \ `?` operator in a function that returns `Vec<isize>`\n...  |\n37 | |     vec![smalest_value,\
    \ even_index.0]\n38 | | }\n   | |_- this function should return `Result` or `Option`\
    \ to accept `?`\n   |\n   = help: the trait `FromResidual<Result<Infallible, String>>`\
    \ is not implemented for `Vec<isize>`\n\nerror[E0599]: no method named `clone_from_slice`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmptb3f6t0z.rs:33:19\n\
    \   |\n33 |     smalest_value.clone_from_slice(&arr[0..even_index.1 - 1]);\n \
    \  |                   ^^^^^^^^^^^^^^^^ method not found in `&isize`\n\nerror[E0609]:\
    \ no field `1` on type `Option<(usize, &isize)>`\n  --> /tmp/tmptb3f6t0z.rs:33:55\n\
    \   |\n33 |     smalest_value.clone_from_slice(&arr[0..even_index.1 - 1]);\n \
    \  |                                                       ^\n\nerror[E0599]:\
    \ no method named `clone_from_slice` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmptb3f6t0z.rs:34:19\n   |\n34 |     smalest_value.clone_from_slice(&arr[even_index.1..]);\n\
    \   |                   ^^^^^^^^^^^^^^^^ method not found in `&isize`\n\nerror[E0609]:\
    \ no field `1` on type `Option<(usize, &isize)>`\n  --> /tmp/tmptb3f6t0z.rs:34:52\n\
    \   |\n34 |     smalest_value.clone_from_slice(&arr[even_index.1.."
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = None;\n    let mut smallest_value_index = None;\n\
    \    let mut even_values = HashSet::new();\n\n    for v in arr {\n        if v.0\
    \ % 2 == 0 {\n            let index = v.0 as isize % arr.len();\n            if\
    \ even_values.contains(&index) { //if there are two evens in the list\n      \
    \          if smallest_even_value == None || (smallest_even_value.0 < v) {\n \
    \                   smallest_even_value = v;\n                    smallest_value_index\
    \ = index;\n                }\n            } else { //no even values, so add this\
    \ node to hash table\n                even_values.insert(index);\n           \
    \ }\n        } else {\n            if smallest_even_value == None {\n        \
    \        smallest_even_value = v;\n                smallest_value_index = 0;\n\
    \            }\n        }\n    }\n\n    if smallest_even_value == None {\n   \
    \     return vec![];\n    }\n\n    let mut even_indexes = vec![];\n    let mut\
    \ odd_indexes = vec![];\n    for (i, &v) in even_values.iter().enumerate() {\n\
    \        if i % 2 == 0 {\n            even_indexes.push(v as isize % arr.len());\n\
    \        } else {\n            odd_indexes.push(v as isize % arr.len());\n   \
    \     }\n    }\n    let mut smallest_even_index = smallest_value_index;\n    let\
    \ mut smallest_odd_index = smallest_value_index;\n    if even_indexes.len() >\
    \ odd_indexes.len() {\n        smallest_even_index = even_indexes[0];\n      \
    \  smallest_odd_index = odd_indexes[0];\n    } else {\n        smallest_even_index\
    \ = odd_indexes[0];\n        smallest_odd_index = even_indexes[0];\n    }\n\n\
    \    let mut smallest_values;\n    if smallest_even_index < smallest_value_index\
    \ {\n        smallest_values = vec![smallest_even_value.0 as isize; 1];\n    }\
    \ else {\n        smallest_values = vec![smallest_even_value.0 as isize; 2];\n\
    \    }\n\n    let mut smallest_even_count = 0;\n    let mut smallest_odd_count\
    \ = 0;\n    let mut smallest_values = vec![];\n    let mut smallest_even_found\
    \ = false;\n    let mut smallest_odd_found = false;\n    let mut smallest_even_found\
    \ = false;\n    let mut smallest_odd_found = false;\n    let mut smallest_even_index\
    \ = smallest_value_index;\n    let mut smallest_odd_index = smallest_value_index;\n\
    \    let mut smallest_even_index = smallest_value_index;\n    let mut smallest_odd_index\
    \ = smalle\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9mavj7e7.rs:90:40\n   |\n\
    90 |     let mut smallest_odd_index = smalle\n   |                           \
    \             ^ help: add `;` here\n91 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9mavj7e7.rs:29:27\n\
    \   |\n29 |     let mut even_values = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot\
    \ find value `smalle` in this scope\n  --> /tmp/tmp9mavj7e7.rs:90:34\n   |\n90\
    \ |     let mut smallest_odd_index = smalle\n   |                            \
    \      ^^^^^^ not found in this scope\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmp9mavj7e7.rs:32:14\n  \
    \ |\n32 |         if v.0 % 2 == 0 {\n   |              ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp9mavj7e7.rs:33:27\n\
    \   |\n33 |             let index = v.0 as isize % arr.len();\n   |          \
    \                 ^\n\nerror[E0609]: no field `0` on type `Option<_>`\n  --> /tmp/tmp9mavj7e7.rs:35:72\n\
    \   |\n35 |                 if smallest_even_value == None || (smallest_even_value.0\
    \ < v) {\n   |                                                               \
    \         ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9mavj7e7.rs:36:43\n\
    \   |\n27 |     let mut smallest_even_value = None;\n   |                    \
    \               ---- expected due to this value\n...\n36 |                   \
    \  smallest_even_value = v;\n   |                                           ^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n36 |                     smallest_even_value = Some(v);\n   |         \
    \                                  +++++ +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9mavj7e7.rs:44:39\n   |\n27 |     let mut smallest_even_value =\
    \ None;\n   |                                   -"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val: isize = 0;\n    let mut min_index: usize = 0;\n    let mut\
    \ min_nodes: Vec<isize> = vec![];\n    for ele in arr {\n        if ele < min_val\
    \ {\n            min_val = ele;\n            min_index = ele;\n            min_nodes.push(ele);\n\
    \        } else if ele == min_val {\n            min_nodes.push(ele);\n      \
    \  }\n    }\n    if min_nodes == vec![] {\n        return vec![];\n    }\n   \
    \ let mut index: usize = 0;\n    while index < min_nodes.len() {\n        if min_nodes[index]\
    \ % 2 == 0 {\n            min_val = min_nodes[index];\n            min_index =\
    \ index;\n            break;\n        }\n        index += 1;\n    }\n    if min_index\
    \ == 0 {\n        return vec![];\n    }\n    min_nodes.remove(&min_index);\n \
    \   let mut val = min_val;\n    vec![min_val, min_index].into_iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptgieqnjj.rs:33:25\n   |\n\
    28 |     let mut min_index: usize = 0;\n   |                        ----- expected\
    \ due to this type\n...\n33 |             min_index = ele;\n   |             \
    \            ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptgieqnjj.rs:54:22\n   |\n54 |     min_nodes.remove(&min_index);\n\
    \   |                      ^^^^^^^^^^ expected `usize`, found `&usize`\n   |\n\
    help: consider removing the borrow\n   |\n54 -     min_nodes.remove(&min_index);\n\
    54 +     min_nodes.remove(min_index);\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptgieqnjj.rs:56:19\n   |\n56 |     vec![min_val, min_index].into_iter().cloned().collect()\n\
    \   |                   ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize, _> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmptgieqnjj.rs:56:42\n     |\n56   |     vec![min_val, min_index].into_iter().cloned().collect()\n\
    \     |                                          ^^^^^^ expected reference, found\
    \ `isize`\n     |\n     = note: expected reference `&_`\n                    \
    \ found type `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<isize, _>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmptgieqnjj.rs:56:51\n   |\n\
    56 |       vec![min_val, min_index].into_iter().cloned().collect()\n   |     \
    \                                                ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize, _>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize,\
    \ _> as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize,\
    \ _>>: Iterator`\n           `Cloned<std::vec::IntoIter<isize, _>>: Iterator`\n\
    \           which is required by `&mut Cloned<std::vec::IntoIter<isize, _>>: Iterator`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308, E05"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = arr.iter().filter(|&x| x % 2 == 0).min().unwrap();\n \
    \   let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 &&\
    \ i < *min_even {\n            min_even = i;\n            min_idx = i;\n     \
    \   }\n    }\n    if min_even == -1 {\n        return vec![];\n    }\n    vec![min_even,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8nun6b8i.rs:30:30\n   |\n\
    30 |         if i % 2 == 0 && i < *min_even {\n   |                          \
    \    ^^^^^^^^^\n   |                              |\n   |                    \
    \          expected `&isize`, found `isize`\n   |                            \
    \  help: consider borrowing here: `&*min_even`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8nun6b8i.rs:32:23\n   |\n28 |     let mut min_idx = -1;\n   | \
    \                      -- expected due to this value\n...\n32 |             min_idx\
    \ = i;\n   |                       ^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n32 |             min_idx = *i;\n\
    \   |                       +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp8nun6b8i.rs:35:17\n   |\n35 |     if min_even == -1 {\n   |   \
    \              ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8nun6b8i.rs:38:10\n   |\n38 |\
    \     vec![min_even, min_idx]\n   |          ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |     vec![*min_even,\
    \ min_idx]\n   |          +\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().enumerate().map(|(idx, value)| {\n        let mut smallest = isize::MAX;\n\
    \        let mut smallest_idx = 0;\n        for (idx, _) in arr.iter().enumerate().rev()\
    \ {\n            if idx < idx {\n                smallest = smallest.max(value);\n\
    \                smallest_idx = idx;\n            }\n        }\n        (smallest,\
    \ smallest_idx)\n    }).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpat37alsj.rs:32:41\n   |\n\
    32 |                 smallest = smallest.max(value);\n   |                   \
    \                      ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n32 |                 smallest = smallest.max(*value);\n\
    \   |                                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpat37alsj.rs:27:5\n   |\n26 |   fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                ---------- expected `Vec<isize>` because\
    \ of return type\n27 | /     arr.iter().enumerate().map(|(idx, value)| {\n28 |\
    \ |         let mut smallest = isize::MAX;\n29 | |         let mut smallest_idx\
    \ = 0;\n30 | |         for (idx, _) in arr.iter().enumerate().rev() {\n...  |\n\
    36 | |         (smallest, smallest_idx)\n37 | |     }).collect::<Vec<_>>()\n \
    \  | |__________________________^ expected `isize`, found tuple\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<(isize, usize)>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![0; arr.len()];\n    let mut even_idx = vec![0;\
    \ arr.len()];\n    let mut smallest = vec![0; arr.len()];\n    let mut smallest_idx\
    \ = 0;\n    for i in 0..arr.len() {\n        if arr[i] % 2 != 0 {\n          \
    \  even_values[i] = arr[i];\n            even_idx[i] = i;\n        } else {\n\
    \            if even_values[i] < arr[i] {\n                even_values[i] = arr[i];\n\
    \                even_idx[i] = i;\n            }\n            if even_values[i]\
    \ < smallest {\n                smallest = even_values[i];\n                smallest_idx\
    \ = even_idx[i];\n            }\n        }\n    }\n    smallest_idx\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp70t42jsr.rs:40:33\n   |\n\
    40 |             if even_values[i] < smallest {\n   |                        \
    \         ^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<{integer}>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp70t42jsr.rs:41:28\n   |\n29 |     let mut smallest = vec![0;\
    \ arr.len()];\n   |                        ------------------ expected due to\
    \ this value\n...\n41 |                 smallest = even_values[i];\n   |     \
    \                       ^^^^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<{integer}>`\n                found type\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp70t42jsr.rs:46:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n46\
    \ |     smallest_idx\n   |     ^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![false; arr.len()];\n    let mut even_index = vec![-1;\
    \ arr.len()];\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n   \
    \         even_values[i] = true;\n            if even_index[i] < i {\n       \
    \         even_index[i] = i;\n            }\n        } else {\n            if\
    \ even_values.iter().position(|&x| !x).is_none() {\n                even_index[i]\
    \ = even_values.iter().position(|&x| !x).unwrap();\n            }\n          \
    \  even_values[i] = false;\n        }\n    }\n\n    even_index.iter().position(|&x|\
    \ x).unwrap_or(-1)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpoxs50n2g.rs:28:31\n\
    \   |\n28 |     let mut even_index = vec![-1; arr.len()];\n   |              \
    \                 ^^ the trait `Neg` is not implemented for `usize`\n   |\n  \
    \ = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoxs50n2g.rs:43:37\n   |\n43 |\
    \     even_index.iter().position(|&x| x).unwrap_or(-1)\n   |                 \
    \                    ^ expected `bool`, found `usize`\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `usize`\n  --> /tmp/tmpoxs50n2g.rs:43:50\n\
    \   |\n43 |     even_index.iter().position(|&x| x).unwrap_or(-1)\n   |       \
    \                                           ^^\n   |                         \
    \                         |\n   |                                            \
    \      cannot apply unary operator `-`\n   |                                 \
    \                 help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoxs50n2g.rs:43:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n43 |     even_index.iter().position(|&x| x).unwrap_or(-1)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    for i in arr.iter().rev() {\n        if i % 2 != 0 {\n            arr.swap(i,\
    \ arr.iter().find(|x| x % 2 == 0).unwrap());\n        }\n    }\n    arr\n    \
    \    .iter()\n        .filter(|&x| x % 2 == 0)\n        .cloned()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfajyep4f.rs:29:22\n   |\n\
    29 |             arr.swap(i, arr.iter().find(|x| x % 2 == 0).unwrap());\n   |\
    \                      ^ expected `usize`, found `&isize`\n\nerror[E0369]: cannot\
    \ mod `&&isize` by `{integer}`\n  --> /tmp/tmpfajyep4f.rs:29:47\n   |\n29 |  \
    \           arr.swap(i, arr.iter().find(|x| x % 2 == 0).unwrap());\n   |     \
    \                                        - ^ - {integer}\n   |               \
    \                              |\n   |                                       \
    \      &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference `x`\n\
    \   |\n29 |             arr.swap(i, arr.iter().find(|x| *x % 2 == 0).unwrap());\n\
    \   |                                             +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfajyep4f.rs:29:25\n   |\n29 |             arr.swap(i, arr.iter().find(|x|\
    \ x % 2 == 0).unwrap());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a % 2 == 0 {\n            if b % 2 == 0\
    \ {\n                a\n            } else {\n                b\n            }\n\
    \        } else {\n            b\n        }\n    });\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    for (idx, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 {\n            if smallest_value < value {\n  \
    \              smallest_index = idx;\n                smallest_value = value;\n\
    \            }\n        }\n    }\n    vec![smallest_value, smallest_index]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpti1f42ud.rs:30:17\n   |\n\
    30 |                 a\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpti1f42ud.rs:32:17\n\
    \   |\n32 |                 b\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpti1f42ud.rs:35:13\n\
    \   |\n35 |             b\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpti1f42ud.rs:42:33\n\
    \   |\n42 |             if smallest_value < value {\n   |                    \
    \             ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n42 |             if smallest_value < *value {\n   |      \
    \                           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpti1f42ud.rs:44:34\n\
    \   |\n38 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n44 |                 smallest_value\
    \ = value;\n   |                                  ^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n44 |        \
    \         smallest_value = *value;\n   |                                  +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpti1f42ud.rs:48:26\n   |\n48 |  \
    \   vec![smallest_value, smallest_index]\n   |                          ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n48 |     vec![smallest_value,\
    \ smallest_index.try_into().unwrap()]\n   |                                  \
    \      ++++++++++++++++++++\n\nerror: aborting due to 6 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut min_idx = 0;\n    let mut smallest_value:\
    \ isize = std::i32::MIN;\n    for idx in arr.iter() {\n        if idx % 2 == 0\
    \ {\n            even_values.push(idx);\n            if smallest_value < idx {\n\
    \                smallest_value = idx;\n            }\n            if min_idx\
    \ == 0 || idx < even_values[min_idx] {\n                min_idx = idx;\n     \
    \       }\n        }\n    }\n    even_values.iter().skip(min_idx).cloned()\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr_4nm8an.rs:29:37\n   |\n\
    29 |     let mut smallest_value: isize = std::i32::MIN;\n   |                \
    \             -----   ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |      \
    \                       |\n   |                             expected due to this\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |     let mut smallest_value: isize = std::i32::MIN.try_into().unwrap();\n\
    \   |                                                  ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpr_4nm8an.rs:33:33\n   |\n33 |  \
    \           if smallest_value < idx {\n   |                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n33 |             if smallest_value < *idx {\n   |                     \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr_4nm8an.rs:34:34\n\
    \   |\n29 |     let mut smallest_value: isize = std::i32::MIN;\n   |         \
    \                    ----- expected due to this type\n...\n34 |              \
    \   smallest_value = idx;\n   |                                  ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |                 smallest_value = *idx;\n   |                            \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr_4nm8an.rs:37:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n37 |                 min_idx = idx;\n   |              \
    \             ^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr_4nm8an.rs:41:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n41 |     even_values.iter().skip(min_idx).cloned()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n           \
    \   found struct `Cloned<Skip<std::slice::Iter<'_, &isize>>>"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    if arr.iter().any(|&x|\
    \ x % 2 == 0) {\n        let mut min_even_node_index = 1;\n        let mut min_even_node_value\
    \ = arr[0];\n        let mut min_even_node_value = arr[0];\n        for &x in\
    \ arr.iter() {\n            if x % 2 == 0 {\n                min_even_node_value\
    \ = x;\n                min_even_node_index = x;\n            }\n        }\n \
    \       return vec![min_even_node_value, min_even_node_index];\n    } else {\n\
    \        return vec![arr[0], 0];\n    }\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmp8bb448k4.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut vals: Vec<isize> = vec![0; arr.len()];\n    let mut index = 0;\n\
    \    for val in arr {\n        if val % 2 == 0 {\n            vals[index] = val;\n\
    \            index += 1;\n        }\n    }\n    if vals.is_empty() {\n       \
    \ return vec![];\n    }\n    let mut min = i32::MAX;\n    let mut min_index =\
    \ 0;\n    for val in vals {\n        let val_even = val % 2 == 0;\n        if\
    \ val_even && val < min {\n            min = val;\n            min_index = index;\n\
    \        }\n        index += 1;\n    }\n    vec![(min, min_index)]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2vqhrhq6.rs:42:30\n   |\n\
    42 |         if val_even && val < min {\n   |                              ^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n42 |         if val_even\
    \ && val < min.try_into().unwrap() {\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2vqhrhq6.rs:43:19\n   |\n38 |\
    \     let mut min = i32::MAX;\n   |                   -------- expected due to\
    \ this value\n...\n43 |             min = val;\n   |                   ^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2vqhrhq6.rs:48:10\n\
    \   |\n48 |     vec![(min, min_index)]\n   |          ^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(i32, usize)`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = arr[0];\n    let mut min_even_position = 0;\n  \
    \  let mut index = 0;\n    for elem in arr.iter().cloned() {\n        if elem\
    \ % 2 == 0 {\n            if min_even_value % 2 == 0 {\n                min_even_value\
    \ = elem;\n                min_even_position = index;\n            } else {\n\
    \                min_even_value = elem;\n                min_even_position = index;\n\
    \            }\n        } else {\n            index += 1;\n        }\n    }\n\n\
    \    let mut min_even_pos = Vec::new();\n    let mut min_even_pos_index = 0;\n\
    \    for x in min_even_position.cloned() {\n        if min_even_pos .len() < x\
    \ {\n            min_even_pos.push(x);\n            min_even_pos_index = x;\n\
    \        }\n    }\n\n    if min_even_pos_index != arr.len() {\n        min_even_pos.push(min_even_pos_index);\n\
    \    }\n\n    if min_even_pos.len() == 0 {\n        return Vec::new();\n    }\n\
    \n    Vec::from(min_even_pos)\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `cloned` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmphepq_m4o.rs:46:32\n   |\n46 |     for x in min_even_position.cloned()\
    \ {\n   |                                ^^^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n28 |     let mut min_even_position:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphepq_m4o.rs:61:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n61 |     Vec::from(min_even_pos)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    \n    arr.sort();\n    let mut min_even_val = arr[0];\n    let mut min_even_index\
    \ = -1;\n    for i in 0..arr.len() {\n        let even_val = arr[i] / 2;\n   \
    \     if even_val < min_even_val {\n            min_even_val = even_val;\n   \
    \         min_even_index = i;\n        }\n    }\n    if min_even_index == -1 ||\
    \ min_even_val == 0 {\n        return vec![];\n    }\n    let mut res = vec![min_even_val,\
    \ min_even_index];\n    for i in (1..arr.len()).rev() {\n        let even_val\
    \ = arr[i]/2;\n        if even_val == min_even_val {\n            res.push(even_val);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmptwv4i8aj.rs:30:30\n\
    \   |\n30 |     let mut min_even_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmptwv4i8aj.rs:38:26\n\
    \   |\n38 |     if min_even_index == -1 || min_even_val == 0 {\n   |         \
    \                 ^^\n   |                          |\n   |                  \
    \        cannot apply unary operator `-`\n   |                          help:\
    \ you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwv4i8aj.rs:41:38\n\
    \   |\n41 |     let mut res = vec![min_even_val, min_even_index];\n   |      \
    \                                ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0600.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = Vec::new();\n    let mut largest_even_value = arr[0];\n\
    \    let mut smallest_even_value = arr[0];\n    let mut smallest_index = -1;\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i as isize < largest_even_value.0 {\n                largest_even_value\
    \ = i;\n            }\n            if i as isize < smallest_even_value.0 {\n \
    \               smallest_even_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut min_even_value = even_values[0];\n    let mut min_even_index\
    \ = -1;\n    for i in even_values.iter() {\n        if i == min_even_value {\n\
    \            \n            if i != min_even_index {\n                min_even_value\
    \ = i;\n                min_even_index = i;\n            }\n        }\n    }\n\
    \    return vec![min_even_value, min_even_index];\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: `<` is interpreted as a start of generic arguments for `isize`,\
    \ not a comparison\n  --> /tmp/tmp4og8h1c6.rs:34:27\n   |\n34 |             if\
    \ i as isize < largest_even_value.0 {\n   |                           ^ -------------------\
    \ interpreted as generic arguments\n   |                           |\n   |   \
    \                        not interpreted as comparison\n   |\nhelp: try comparing\
    \ the cast value\n   |\n34 |             if (i as isize) < largest_even_value.0\
    \ {\n   |                +          +\n\nerror: `<` is interpreted as a start\
    \ of generic arguments for `isize`, not a comparison\n  --> /tmp/tmp4og8h1c6.rs:37:27\n\
    \   |\n37 |             if i as isize < smallest_even_value.0 {\n   |        \
    \                   ^ -------------------- interpreted as generic arguments\n\
    \   |                           |\n   |                           not interpreted\
    \ as comparison\n   |\nhelp: try comparing the cast value\n   |\n37 |        \
    \     if (i as isize) < smallest_even_value.0 {\n   |                +       \
    \   +\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmp4og8h1c6.rs:34:48\n   |\n34 |             if i as isize\
    \ < largest_even_value.0 {\n   |                                             \
    \   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4og8h1c6.rs:35:38\n   |\n\
    28 |     let mut largest_even_value = arr[0];\n   |                          \
    \        ------ expected due to this value\n...\n35 |                 largest_even_value\
    \ = i;\n   |                                      ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 largest_even_value\
    \ = *i;\n   |                                      +\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp4og8h1c6.rs:37:49\n\
    \   |\n37 |             if i as isize < smallest_even_value.0 {\n   |        \
    \                                         ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4og8h1c6.rs:38:39\n   |\n29 |     let mut smallest_even_value =\
    \ arr[0];\n   |                           "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_values = vec![];\n    let mut odd_values = vec![];\n    for\
    \ i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        } else {\n            odd_values.push(i);\n        }\n    }\n    if even_values.is_empty()\
    \ && odd_values.is_empty() {\n        return vec![];\n    }\n    if even_values.is_empty()\
    \ {\n        return even_values;\n    }\n    if odd_values.is_empty() {\n    \
    \    return odd_values;\n    }\n    if even_values.len() > odd_values.len() {\n\
    \        let mut min_even = even_values[even_values.len()-1];\n        let mut\
    \ min_odd = odd_values[odd_values.len()-1];\n        for i in even_values.iter()\
    \ {\n            if i % 2 == 0 {\n                if min_even > i {\n        \
    \            min_even = i;\n                }\n            } else {\n        \
    \        if min_odd > i {\n                    min_odd = i;\n                }\n\
    \            }\n        }\n        return vec![min_even, min_odd];\n    }\n  \
    \  let mut min_even = even_values[even_values.len()-1];\n    let mut min_odd =\
    \ odd_values[odd_values.len()-1];\n    for i in even_values.iter() {\n       \
    \ if i % 2 == 0 {\n            if min_even > i {\n                min_even = i;\n\
    \            }\n        } else {\n            if min_odd > i {\n             \
    \   min_odd = i;\n            }\n        }\n    }\n    let mut min_even_index\
    \ = even_values.iter().position(|&x| *x == min_even).unwrap();\n    if min_even_index\
    \ == even_values.len() {\n        return vec![];\n    }\n    let mut min_odd_index\
    \ = odd_values.iter().position(|&x| *x == min_odd).unwrap();\n    if min_odd_index\
    \ == odd_values.len() {\n        return vec![];\n    }\n    let mut min_value\
    \ = even_values[min_even_index];\n    if min_value == odd_values[min_odd_index]\
    \ {\n        return vec![];\n    }\n    return vec![min_value, min_even_index,\
    \ min_odd_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_mi55dw0.rs:40:16\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n40 |     \
    \    return even_values;\n   |                ^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmp_mi55dw0.rs:49:18\n   |\n49 |             if i % 2 == 0 {\n   |\
    \                - ^ - {integer}\n   |                |\n   |                &&isize\n\
    \   |\nhelp: `%` can be used on `isize`, you can dereference `i`\n   |\n49 | \
    \            if *i % 2 == 0 {\n   |                +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_mi55dw0.rs:59:21\n   |\n59 |         return vec![min_even,\
    \ min_odd];\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n59 |         return vec![*min_even,\
    \ min_odd];\n   |                     +\n\nerror[E0369]: cannot mod `&&isize`\
    \ by `{integer}`\n  --> /tmp/tmp_mi55dw0.rs:64:14\n   |\n64 |         if i % 2\
    \ == 0 {\n   |            - ^ - {integer}\n   |            |\n   |           \
    \ &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference `i`\n \
    \  |\n64 |         if *i % 2 == 0 {\n   |            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_mi55dw0.rs:74:69\n   |\n74 |     let mut min_even_index\
    \ = even_values.iter().position(|&x| *x == min_even).unwrap();\n   |         \
    \                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    74 |     let mut min_even_index = even_values.iter().position(|&x| *x == *min_even).unwrap();\n\
    \   |                                                                     +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_mi55dw0.rs:78:67\n   |\n78 |  \
    \   let mut min_odd_index = odd_values.iter().position(|&x| *x == min_odd).unwrap();\n\
    \   |                                                      "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut pivot_idx = arr.len() - 1;\n    let mut smallest_val: isize = 0;\n\
    \    let mut smallest_idx: usize = 0;\n    while pivot_idx >= 0 {\n        if\
    \ arr[pivot_idx] % 2 == 0 {\n            if smallest_val == 0 {\n            \
    \    smallest_val = arr[pivot_idx];\n                smallest_idx = pivot_idx;\n\
    \            }\n            pivot_idx -= 1;\n        } else {\n            pivot_idx\
    \ -= 1;\n        }\n    }\n    if smallest_val == 0 {\n        vec![]\n    } else\
    \ {\n        vec![smallest_val, smallest_idx]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2jxra9uk.rs:44:28\n   |\n\
    44 |         vec![smallest_val, smallest_idx]\n   |                          \
    \  ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n44\
    \ |         vec![smallest_val, smallest_idx.try_into().unwrap()]\n   |       \
    \                                 ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_value: Option<isize> = None;\n    let mut smaller_value: Option<isize>\
    \ = None;\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n       \
    \     if even_value.is_none() {\n                even_value = Some(i);\n     \
    \       } else {\n                smaller_value = Some(i);\n            }\n  \
    \      }\n    }\n    if even_value.is_none() {\n        return vec![];\n    }\n\
    \    if smaller_value.is_none() {\n        return vec![];\n    }\n    let mut\
    \ smallest_index: Option<usize> = None;\n    for i in 0..arr.len() {\n       \
    \ if arr[i] % 2 == 0 {\n            if smallest_index.is_none() {\n          \
    \      smallest_index = Some(i);\n                smallest_value = Some(arr[i]);\n\
    \            } else {\n                if arr[i] < smallest_value.unwrap() {\n\
    \                    smallest_value = Some(arr[i]);\n                    smallest_index\
    \ = Some(i);\n                }\n            }\n        }\n    }\n    let mut\
    \ result: Vec<isize> = vec![];\n    if smallest_index.is_none() {\n        return\
    \ vec![];\n    }\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n\
    \            if i == smallest_index.unwrap() {\n                result.push(smallest_value.unwrap());\n\
    \            }\n        }\n    }\n    result;\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `smallest_value` in this scope\n  --> /tmp/tmpip062516.rs:49:17\n\
    \   |\n49 |                 smallest_value = Some(arr[i]);\n   |             \
    \    ^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `smaller_value`\n\
    \nerror[E0425]: cannot find value `smallest_value` in this scope\n  --> /tmp/tmpip062516.rs:51:29\n\
    \   |\n51 |                 if arr[i] < smallest_value.unwrap() {\n   |      \
    \                       ^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `smaller_value`\n\nerror[E0425]: cannot find value `smallest_value`\
    \ in this scope\n  --> /tmp/tmpip062516.rs:52:21\n   |\n52 |                 \
    \    smallest_value = Some(arr[i]);\n   |                     ^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `smaller_value`\n\nerror[E0425]:\
    \ cannot find value `smallest_value` in this scope\n  --> /tmp/tmpip062516.rs:65:29\n\
    \   |\n65 |                 result.push(smallest_value.unwrap());\n   |      \
    \                       ^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `smaller_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip062516.rs:32:35\n\
    \   |\n32 |                 even_value = Some(i);\n   |                      \
    \             ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n32\
    \ |                 even_value = Some(i.try_into().unwrap());\n   |          \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpip062516.rs:34:38\n   |\n34 |                 smaller_value = Some(i);\n\
    \   |                                      ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n34 |                 smaller_value = Some(i.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpip062516.rs:26:30\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----                  "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for (i, elt) in\
    \ arr.iter().enumerate() {\n        if min_value == elt {\n            min_idx\
    \ = i;\n            continue;\n        }\n        if elt < min_value {\n     \
    \       min_value = elt;\n            min_idx = i;\n        }\n    }\n    let\
    \ mut even_idxs = vec![];\n    let mut even_values = vec![];\n    for (i, elt)\
    \ in arr.iter().enumerate() {\n        if i % 2 == 0 {\n            even_idxs.push(i\
    \ as isize);\n            even_values.push(elt as isize);\n        }\n    }\n\
    \    if even_idxs.len() == 0 || even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_idxs.len() == 1 {\n        let (mut smallest_value, smallest_idx)\
    \ = even_values.iter().min();\n        if smallest_idx == 0 {\n            return\
    \ vec![];\n        }\n        return vec![smallest_value, smallest_idx];\n   \
    \ }\n    let (mut smallest_value, smallest_idx) = even_values.iter().min();\n\
    \    if min_value == smallest_value {\n        return vec![];\n    }\n    even_idxs.remove(smallest_idx);\n\
    \    even_values.remove(smallest_idx);\n    for i in even_idxs.iter() {\n    \
    \    even_values.remove(i);\n    }\n    for i in even_values.iter() {\n      \
    \  even_idxs.remove(i);\n    }\n    even_idxs.sort_unstable();\n    even_values.sort_unstable();\n\
    \    let mut smallest = vec![];\n    for i in even_idxs {\n        if i.0 > min_idx\
    \ {\n            break;\n        }\n        smallest.push((i, even_values[i]));\n\
    \    }\n    smallest.sort_unstable();\n    let mut result = vec![];\n    for ((i,\
    \ elt) in smallest) {\n        let mut j = 0;\n        for j in i..(arr.len()\
    \ - 1) {\n            if arr[j] != elt {\n                break;\n           \
    \ }\n            j = j + 1;\n        }\n        result.push(elt);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, or `|`, found keyword `in`\n  --> /tmp/tmpwpv1xq3c.rs:80:19\n\
    \   |\n80 |     for ((i, elt) in smallest) {\n   |                   ^^ expected\
    \ one of `)`, `,`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop\
    \ head\n  --> /tmp/tmpwpv1xq3c.rs:80:9\n   |\n80 |     for ((i, elt) in smallest)\
    \ {\n   |         ^                    ^\n   |\nhelp: remove parentheses in `for`\
    \ loop\n   |\n80 -     for ((i, elt) in smallest) {\n80 +     for (i, elt) in\
    \ smallest {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwpv1xq3c.rs:30:25\n\
    \   |\n30 |         if min_value == elt {\n   |                         ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    30 |         if min_value == *elt {\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwpv1xq3c.rs:34:18\n   |\n34 |         if elt\
    \ < min_value {\n   |                  ^^^^^^^^^\n   |                  |\n  \
    \ |                  expected `&isize`, found `isize`\n   |                  help:\
    \ consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwpv1xq3c.rs:35:25\n   |\n27 |     let mut min_value = arr[0];\n   |\
    \                         ------ expected due to this value\n...\n35 |       \
    \      min_value = elt;\n   |                         ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |        \
    \     min_value = *elt;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwpv1xq3c.rs:51:13\n   |\n51 |         let (mut smallest_value,\
    \ smallest_idx) = even_values.iter().min();\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \   ------------------------ this expression has type `Option<&isize>`\n   | \
    \            |\n   |             expected enum `Option`, found tuple\n   |\n \
    \  = note: expected enum `Option<&isize>`\n             found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwpv1xq3c.rs:57:9\n   |\n57 | \
    \    let (mut smallest_value, smallest_idx) = even_values.iter().min();\n   |\
    \         ^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_unstable_by(|x, y| if y % 2 == 0 {x} else y);\n    let mut cur =\
    \ 0;\n    for x in arr.iter() {\n        if x % 2 == 0 {\n            return vec![cur,\
    \ x - 1];\n        }\n        cur = x;\n    }\n    return vec![];\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `y`\n  --> /tmp/tmp37zevk8e.rs:27:56\n   |\n\
    27 |     arr.sort_unstable_by(|x, y| if y % 2 == 0 {x} else y);\n   |        \
    \                                                ^ expected `{`\n   |\nhelp: try\
    \ placing this code inside a block\n   |\n27 |     arr.sort_unstable_by(|x, y|\
    \ if y % 2 == 0 {x} else { y });\n   |                                       \
    \                 +   +\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
